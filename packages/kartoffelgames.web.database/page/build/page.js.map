{"version":3,"file":".././page/build/page.js","mappings":"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AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uDAAuD,kBAAkB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,oBAAoB,OAAO,mBAAmB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,oBAAoB,OAAO,mBAAmB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yBAAyB;AAC3E;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gDAAgD,yBAAyB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;;;;;;;;;AChIa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB,+BAA+B,mBAAO,CAAC,sIAAkC;AACzE,yCAAyC,mBAAO,CAAC,0JAA4C;AAC7F,iCAAiC,mBAAO,CAAC,0IAAoC;AAC7E,8BAA8B,mBAAO,CAAC,gIAA+B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;;;;AC1Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,eAAe,mBAAO,CAAC,4EAAsB;AAC7C,mBAAmB,mBAAO,CAAC,mGAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;;;;;;;;;ACpFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,eAAe,mBAAO,CAAC,4EAAsB;AAC7C,4BAA4B,mBAAO,CAAC,qHAAqB;AACzD,wBAAwB,mBAAO,CAAC,6GAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;;;;;;;;;ACzCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB,eAAe,mBAAO,CAAC,4EAAsB;AAC7C,6BAA6B,mBAAO,CAAC,qJAA0C;AAC/E,+BAA+B,mBAAO,CAAC,2HAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;;;;ACjDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,wBAAwB,mBAAO,CAAC,6GAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;;;;;;;;;ACtCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,eAAe,mBAAO,CAAC,4EAAsB;AAC7C,6BAA6B,mBAAO,CAAC,qJAA0C;AAC/E,mBAAmB,mBAAO,CAAC,6GAAsB;AACjD;AACA;AACA,SAAS,wBAAwB,KAAK,wBAAwB,wBAAwB,eAAe;AACrG;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,qBAAM;AAClE;AACA;AACA,+CAA+C,mDAAmD;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;;;;;;;;;ACjLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8BAA8B;AACvD,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kEAAkE;AAC1G;AACA;AACA,wCAAwC,kEAAkE;AAC1G;AACA;AACA;AACA;AACA;AACA,wCAAwC,gEAAgE;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB,mBAAmB,mBAAmB;AACzD;;;;;;;;;;AC9Ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,eAAe,mBAAO,CAAC,4EAAQ;AAC/B,oBAAoB,mBAAO,CAAC,4FAAwB;AACpD;AACA,gBAAgB,UAAU;AAC1B,gBAAgB,qBAAqB,GAAG,mCAAmC,GAAG,+BAA+B,KAAK,qBAAqB;AACvI;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;;;;;;;;;AC9Ia;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY;AACZ;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,uDAAuD;AACvD;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA,YAAY;AACZ;;;;;;;;;;ACnLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,wCAAwC;AACxC,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;ACpKa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA,YAAY,aAAa,MAAM,wBAAwB;AACvD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;;;;;;;;;AChCa;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,mBAAmB,GAAG,gBAAgB,GAAG,gBAAgB,GAAG,aAAa,GAAG,iBAAiB,GAAG,YAAY,GAAG,kBAAkB;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,uGAA6B;AACxD,8CAA6C,EAAE,qCAAqC,mCAAmC,EAAC;AACxH,aAAa,mBAAO,CAAC,2FAAuB;AAC5C,wCAAuC,EAAE,qCAAqC,uBAAuB,EAAC;AACtG,kBAAkB,mBAAO,CAAC,2FAAuB;AACjD,6CAA4C,EAAE,qCAAqC,iCAAiC,EAAC;AACrH,cAAc,mBAAO,CAAC,6FAAwB;AAC9C,yCAAwC,EAAE,qCAAqC,yBAAyB,EAAC;AACzG;AACA,kBAAkB,mBAAO,CAAC,iFAAkB;AAC5C,4CAA2C,EAAE,qCAAqC,gCAAgC,EAAC;AACnH,kBAAkB,mBAAO,CAAC,iFAAkB;AAC5C,4CAA2C,EAAE,qCAAqC,gCAAgC,EAAC;AACnH;AACA,mBAAmB,mBAAO,CAAC,6FAAwB;AACnD,+CAA8C,EAAE,qCAAqC,oCAAoC,EAAC;AAC1H,6CAA4C,EAAE,qCAAqC,kCAAkC,EAAC;AACtH;;;;;;;;;;AC9Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;;;;ACrHa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;UCpCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;UEPD;UACA;UACA;UACA","sources":["webpack:///./page/source/index.ts","webpack:///./source/web_database/layout/web-database-identity.decorator.ts","webpack:///./source/web_database/layout/web-database-index.decorator.ts","webpack:///./source/web_database/layout/web-database-table-layout.ts","webpack:///./source/web_database/query/web-database-query-action.ts","webpack:///./source/web_database/query/web-database-query.ts","webpack:///./source/web_database/web-database-table.ts","webpack:///./source/web_database/web-database-transaction.ts","webpack:///./source/web_database/web-database.ts","webpack:///../kartoffelgames.core.dependency_injection/library/source/decoration-history/decoration-history.js","webpack:///../kartoffelgames.core.dependency_injection/library/source/decorator/add-metadata.decorator.js","webpack:///../kartoffelgames.core.dependency_injection/library/source/decorator/injectable-singleton.decorator.js","webpack:///../kartoffelgames.core.dependency_injection/library/source/decorator/injectable.decorator.js","webpack:///../kartoffelgames.core.dependency_injection/library/source/enum/inject-mode.js","webpack:///../kartoffelgames.core.dependency_injection/library/source/index.js","webpack:///../kartoffelgames.core.dependency_injection/library/source/injection/injection.js","webpack:///../kartoffelgames.core.dependency_injection/library/source/injector.js","webpack:///../kartoffelgames.core.dependency_injection/library/source/metadata/base-metadata.js","webpack:///../kartoffelgames.core.dependency_injection/library/source/metadata/constructor-metadata.js","webpack:///../kartoffelgames.core.dependency_injection/library/source/metadata/metadata.js","webpack:///../kartoffelgames.core.dependency_injection/library/source/metadata/property-metadata.js","webpack:///../kartoffelgames.core.dependency_injection/library/source/reflect/reflect-initializer.js","webpack:///../kartoffelgames.core/library/source/algorithm/myers-diff.js","webpack:///../kartoffelgames.core/library/source/data_container/dictionary.js","webpack:///../kartoffelgames.core/library/source/data_container/list.js","webpack:///../kartoffelgames.core/library/source/data_container/stack.js","webpack:///../kartoffelgames.core/library/source/exception/exception.js","webpack:///../kartoffelgames.core/library/source/index.js","webpack:///../kartoffelgames.core/library/source/util/enum-util.js","webpack:///../kartoffelgames.core/library/source/util/type-util.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/global","webpack:///webpack/before-startup","webpack:///webpack/startup","webpack:///webpack/after-startup"],"sourcesContent":["/* eslint-disable no-console */\nimport { WebDatabaseIdentity } from '../../source/web_database/layout/web-database-identity.decorator';\nimport { WebDatabaseIndex } from '../../source/web_database/layout/web-database-index.decorator';\nimport { WebDatabase } from '../../source/web_database/web-database';\nimport { WebDatabaseTable } from '../../source/web_database/web-database-table';\n\nclass TestTableOne {\n    @WebDatabaseIdentity(true)\n    public id?: number;\n\n    @WebDatabaseIndex(true)\n    public name?: string;\n\n    @WebDatabaseIndex()\n    public price?: number;\n\n    @WebDatabaseIndex()\n    public types?: Array<number>;\n\n    public notIndexed?: string;\n\n    public whatMyId(): number {\n        return this.id!;\n    }\n}\n\nclass TestTableTwo {\n    @WebDatabaseIndex(true)\n    public nameThing?: string;\n}\n\n(() => {\n    const lDatabase: WebDatabase = new WebDatabase('MainDB', [TestTableOne, TestTableTwo]);\n    lDatabase.transaction([TestTableOne, TestTableTwo], 'readwrite', async (pTransaction) => {\n        const lTestTableOne: WebDatabaseTable<typeof TestTableOne> = pTransaction.table(TestTableOne);\n        const lTestTableTwo: WebDatabaseTable<typeof TestTableTwo> = pTransaction.table(TestTableTwo);\n\n        await lTestTableOne.clear();\n        await lTestTableTwo.clear();\n\n        // Create random data.\n        for (let lCounter = 0; lCounter < 100; lCounter++) {\n            const lData: TestTableOne = new TestTableOne();\n            lData.name = Math.random().toString(16);\n            lData.price = Math.random();\n            lData.types = [1, 2, 3].slice(Math.floor(Math.random() * 4), Math.floor(Math.random() * 4));\n            lData.notIndexed = Math.random().toString(16);\n\n            await lTestTableOne.put(lData);\n        }\n\n        console.log(await lTestTableOne.count(), await lTestTableOne.getAll());\n        console.log(await lTestTableOne.where('types').is(2).and('price').between(0, 0.5).execute());\n\n        // Create random data.\n        for (let lCounter = 0; lCounter < 100; lCounter++) {\n            const lData: TestTableTwo = new TestTableTwo();\n            lData.nameThing = Math.random().toString(16);\n\n            await lTestTableTwo.put(lData);\n        }\n    });\n})();\n\n","import { Exception } from '@kartoffelgames/core';\nimport { Injector } from '@kartoffelgames/core.dependency-injection';\nimport { WebDatabaseTableLayout, TableType } from './web-database-table-layout';\n\n// Needed for type metadata.\nInjector.Initialize();\n\n/**\n * AtScript.\n * Add identity to table type.\n */\nexport function WebDatabaseIdentity(pAutoIncrement: boolean) {\n    return function (pTarget: object, pPropertyKey: string): void {\n        // Usually Class Prototype. Globaly.\n        const lPrototype: object = pTarget;\n        const lTableType: TableType = <any>lPrototype.constructor;\n\n        // Decorator can not be used on static propertys.\n        if (typeof pTarget === 'function') {\n            throw new Exception('Identity property can not be a static property.', WebDatabaseIdentity);\n        }\n\n        const lTableLayout: WebDatabaseTableLayout = new WebDatabaseTableLayout();\n\n        // Add table type identity to layout.\n        lTableLayout.setTableIdentity(lTableType, pPropertyKey, pAutoIncrement);\n    };\n}\n","import { Exception } from '@kartoffelgames/core';\nimport { WebDatabaseTableLayout, TableType } from './web-database-table-layout';\n\n/**\n * AtScript.\n * Add index to table type.\n * Indices with the same names are grouped.\n */\nexport function WebDatabaseIndex(pUnique: boolean = false, pName?: string) {\n    return function (pTarget: object, pPropertyKey: string): void {\n        // Usually Class Prototype. Globaly.\n        const lPrototype: object = pTarget;\n        const lTableType: TableType = <any>lPrototype.constructor;\n\n        // Decorator can not be used on static propertys.\n        if (typeof pTarget === 'function') {\n            throw new Exception('Identity property can not be a static property.', WebDatabaseIndex);\n        }\n\n        const lTableLayout: WebDatabaseTableLayout = new WebDatabaseTableLayout();\n\n        // Default the index name to the property key.\n        const lIndexName: string = pName ?? pPropertyKey;\n\n        // Add table type index to layout.\n        lTableLayout.setTableIndex(lTableType, pPropertyKey, lIndexName, pUnique);\n    };\n}\n","import { Dictionary, Exception, IVoidParameterConstructor } from '@kartoffelgames/core';\nimport { InjectionConstructor, Metadata } from '@kartoffelgames/core.dependency-injection';\n\n/**\n * Singleton. Table layout and settings.\n */\nexport class WebDatabaseTableLayout {\n    private static mInstance: WebDatabaseTableLayout;\n\n    private readonly mTableConfigs!: Dictionary<TableType, TableLayoutConfig>;\n\n    /**\n     * Constructor.\n     */\n    public constructor() {\n        if (WebDatabaseTableLayout.mInstance) {\n            return WebDatabaseTableLayout.mInstance;\n        }\n\n        WebDatabaseTableLayout.mInstance = this;\n\n        // Init lists.\n        this.mTableConfigs = new Dictionary<TableType, TableLayoutConfig>();\n    }\n\n    /**\n     * Get table configuration of type.\n     * \n     * @param pType - Table type.\n     * \n     * @returns table type config. \n     */\n    public configOf(pType: TableType): TableLayoutConfig {\n        // Table type is not initialized.\n        if (!this.mTableConfigs.has(pType)) {\n            throw new Exception('Table type not defined.', this);\n        }\n\n        const lTableConfiguration: TableLayoutConfig = this.mTableConfigs.get(pType)!;\n\n        // Validate idenitiy. Must happend after decoration so all metadata of the table has been loaded.\n        // Validate only when identity was user configurated.\n        if (lTableConfiguration.identity.configurated) {\n            // Type must be string or number.\n            const lPropertyType: InjectionConstructor | null = Metadata.get(pType).getProperty(lTableConfiguration.identity.key).type;\n            if (lPropertyType === null || lPropertyType !== String && lPropertyType !== Number) {\n                throw new Exception('Identity property must be a number or string type', this);\n            }\n\n            // Auto incrementing identity must be a number.\n            if (lTableConfiguration.identity.key && lPropertyType !== Number) {\n                throw new Exception('Identity property with auto increment must be a number type', this);\n            }\n        }\n\n        // Validate all indices.\n        for (const lIndex of lTableConfiguration.indices.values()) {\n            for (const lIndexKey of lIndex.keys) {\n                // Type must be string or number.\n                const lPropertyType: InjectionConstructor | null = Metadata.get(pType).getProperty(lIndexKey).type;\n                if (lPropertyType === null) {\n                    throw new Exception('Index property must have a type', this);\n                }\n\n                // Disable multientry when any key is not a array.\n                if (lPropertyType !== Array) {\n                    lIndex.options.multiEntity = false;\n                }\n            }\n        }\n\n        return lTableConfiguration;\n    }\n\n    /**\n     * Set table type identity.\n     * \n     * @param pType - Table type.\n     * @param pKey - Key of identity.\n     * @param pAutoIncrement - Autoincrement identity.\n     * \n     * @throws {@link Exception} - When a identitfier for this type is already set.\n     */\n    public setTableIdentity(pType: TableType, pKey: string, pAutoIncrement: boolean): void {\n        // Initialize table type.\n        this.initializeTableType(pType);\n\n        // Read table config and restrict to one identity.\n        const lTableConfig: TableLayoutConfig = this.mTableConfigs.get(pType)!;\n        if (lTableConfig.identity.configurated) {\n            throw new Exception(`A table type can only have one identifier.`, this);\n        }\n\n        // Set table type identity.\n        lTableConfig.identity = {\n            key: pKey,\n            autoIncrement: pAutoIncrement,\n            configurated: true\n        };\n    }\n\n    /**\n     * Set table type identity.\n     * \n     * @param pType - Table type.\n     * @param pKey - Key of identity.\n     * @param pName - Index name.\n     * @param pIsArray - Property is key.\n     * @param pIsUnique - Index should be unique.\n     */\n    public setTableIndex(pType: TableType, pKey: string, pName: string, pIsUnique: boolean): void {\n        // Initialize table type.\n        this.initializeTableType(pType);\n\n        // Read table config.\n        const lTableConfig: TableLayoutConfig = this.mTableConfigs.get(pType)!;\n\n        // Initialize index.\n        let lIndexConfig: TableLayoutConfigIndex | undefined = lTableConfig.indices.get(pName);\n        if (!lIndexConfig) {\n            // Set default configuration where anything is enabled.\n            lIndexConfig = {\n                name: pName,\n                keys: new Array<string>(),\n                options: {\n                    unique: true,\n                    multiEntity: true\n                }\n            };\n\n            // Link index to table config.\n            lTableConfig.indices.set(pName, lIndexConfig);\n        }\n\n        // Add key to index.\n        lIndexConfig.keys.push(pKey);\n\n        // Disable multientiy when key is not a array or more than one key is set for the same index.\n        if (lIndexConfig.keys.length > 1) {\n            lIndexConfig.options.multiEntity = false;\n        }\n\n        // Index is not unique when one index is not unique.\n        if (!pIsUnique) {\n            lIndexConfig.options.unique = false;\n        }\n    }\n\n    /**\n     * Initialize table type.\n     * Does nothing when the type is allready initialized.\n     * \n     * @param pType - Table type.\n     */\n    private initializeTableType(pType: TableType): void {\n        // Table type is allready initialized.\n        if (this.mTableConfigs.has(pType)) {\n            return;\n        }\n\n        // Add type reference.\n        this.mTableConfigs.set(pType, {\n            // Set default identity key.\n            identity: {\n                key: '__ID__',\n                autoIncrement: true,\n                configurated: false\n            },\n            indices: new Dictionary<string, TableLayoutConfigIndex>()\n        });\n    }\n}\n\nexport type TableLayoutConfigIndex = {\n    name: string;\n    keys: Array<string>;\n    options: {\n        unique: boolean;\n        multiEntity: boolean; // Set when single key is an array.\n    };\n};\n\nexport type TableLayoutConfig = {\n    identity: {\n        key: string;\n        autoIncrement: boolean;\n        configurated: boolean;\n    },\n    indices: Dictionary<string, TableLayoutConfigIndex>;\n};\n\nexport type TableType = IVoidParameterConstructor<object>;","import { TableType } from '../layout/web-database-table-layout';\nimport { WebDatabaseQuery } from './web-database-query';\n\nexport class WebDatabaseQueryAction<TTableType extends TableType> {\n    private readonly mActionCallback: WebDatabaseQueryActionCallback;\n    private readonly mDatabaseQuery: WebDatabaseQuery<TTableType>;\n\n    /**\n     * Constructor.\n     * \n     * @param pActionCallback - Callback to send back action of query.\n     * @param pQuery - Parent query.\n     */\n    public constructor(pQuery: WebDatabaseQuery<TTableType>, pActionCallback: WebDatabaseQueryActionCallback) {\n        this.mActionCallback = pActionCallback;\n        this.mDatabaseQuery = pQuery;\n    }\n\n    /**\n     * Request rows with the value between lower and upper value.\n     * \n     * @param pLowerValue - Lower value.\n     * @param pUpperValue - Upper value.\n     * \n     * @returns query. \n     */\n    public between(pLowerValue: WebDatabaseQueryActionValue, pUpperValue: WebDatabaseQueryActionValue): WebDatabaseQuery<TTableType> {\n        // Create database range action.\n        const lAction: IDBKeyRange = IDBKeyRange.bound(pLowerValue, pUpperValue, false, false);\n\n        // Send action to parent query.\n        this.mActionCallback(lAction);\n\n        // Return parent query to chain another.\n        return this.mDatabaseQuery;\n    }\n\n    /**\n     * Request rows with the value greather than {@link pValue}.\n     * \n     * @param pValue - Value.\n     * \n     * @returns query. \n     */\n    public greaterThan(pValue: WebDatabaseQueryActionValue): WebDatabaseQuery<TTableType> {\n        // Create database range action.\n        const lAction: IDBKeyRange = IDBKeyRange.lowerBound(pValue, false);\n\n        // Send action to parent query.\n        this.mActionCallback(lAction);\n\n        // Return parent query to chain another.\n        return this.mDatabaseQuery;\n    }\n\n    /**\n     * Request rows with the exact value.\n     * \n     * @param pValue - Value.\n     * \n     * @returns query. \n     */\n    public is(pValue: WebDatabaseQueryActionValue): WebDatabaseQuery<TTableType> {\n        // Create database range action.\n        const lAction: IDBKeyRange = IDBKeyRange.only(pValue);\n\n        // Send action to parent query.\n        this.mActionCallback(lAction);\n\n        // Return parent query to chain another.\n        return this.mDatabaseQuery;\n    }\n\n    /**\n     * Request rows with the value lower than {@link pValue}.\n     * \n     * @param pValue - Value.\n     * \n     * @returns query. \n     */\n    public lowerThan(pValue: WebDatabaseQueryActionValue): WebDatabaseQuery<TTableType> {\n        // Create database range action.\n        const lAction: IDBKeyRange = IDBKeyRange.upperBound(pValue, false);\n\n        // Send action to parent query.\n        this.mActionCallback(lAction);\n\n        // Return parent query to chain another.\n        return this.mDatabaseQuery;\n    }\n}\n\ntype WebDatabaseQueryActionValue = number | string | Array<number | string>;\ntype WebDatabaseQueryActionCallback = (pAction: IDBKeyRange) => void;","import { Dictionary, Exception } from '@kartoffelgames/core';\nimport { TableType } from '../layout/web-database-table-layout';\nimport { WebDatabaseTable } from '../web-database-table';\nimport { WebDatabaseQueryAction } from './web-database-query-action';\n\nexport class WebDatabaseQuery<TTableType extends TableType> {\n    private readonly mQueryList: Array<WebDatabaseQueryPart>;\n    private readonly mTable: WebDatabaseTable<TTableType>;\n\n    /**\n     * Constructor.\n     * \n     * @param pTable - Table of query.\n     */\n    public constructor(pTable: WebDatabaseTable<TTableType>) {\n        this.mTable = pTable;\n        this.mQueryList = new Array<WebDatabaseQueryPart>();\n    }\n\n    /**\n     * Chain database query with \"AND\".\n     * \n     * @param pIndexOrPropertyName - A index or a property name.\n     *  \n     * @returns query action. \n     */\n    public and(pIndexOrPropertyName: string): WebDatabaseQueryAction<TTableType> {\n        // Create query part.\n        const lPart: WebDatabaseQueryPart = {\n            indexKey: pIndexOrPropertyName,\n            action: null,\n            link: 'AND'\n        };\n\n        // Add part to query list.\n        this.mQueryList.push(lPart);\n\n        // Create query action that sets the action on a chained call.\n        return new WebDatabaseQueryAction(this, (pAction) => {\n            lPart.action = pAction;\n        });\n    }\n\n    /**\n     * Execute query and get all values.\n     * \n     * @returns filtered query result. \n     */\n    public async execute(): Promise<Array<InstanceType<TTableType>>> {\n        // Must have queries.\n        if (this.mQueryList.length === 0) {\n            throw new Exception('No queries specified.', this);\n        }\n\n        // Devide queries into \"AND\" blocks.\n        const lQueryBlockList: Array<Array<WebDatabaseQueryPart>> = new Array<Array<WebDatabaseQueryPart>>();\n\n        // Add first block.\n        lQueryBlockList.push(new Array<WebDatabaseQueryPart>());\n\n        // Assign every query into a block.\n        for (const lQuery of this.mQueryList) {\n            // Create new block on any or chain.\n            if (lQuery.link === 'OR') {\n                lQueryBlockList.push(new Array<WebDatabaseQueryPart>());\n            }\n\n            // Add query to latest block.\n            lQueryBlockList.at(-1)!.push(lQuery);\n        }\n\n        // Special solution for single query single block queries.\n        // Not neet to filter or merge.\n        if (lQueryBlockList.length === 1 && lQueryBlockList[0].length === 1) {\n            // Read and convert single block.\n            return this.convertDataToTableType(await this.readQuery(lQueryBlockList[0][0]));\n        }\n\n        // Special solution for single block queries.\n        // No need to merge.\n        if (lQueryBlockList.length === 1) {\n            const lQueryResult: Dictionary<string | number, any> = await this.readQueryBlock(lQueryBlockList[0]);\n\n            // Read and convert single block.\n            return this.convertDataToTableType(lQueryResult.values());\n        }\n\n        // Read all query blocks.\n        const lQueryBlockResultList: Set<Dictionary<string | number, any>> = new Set<Dictionary<string | number, any>>();\n        for (const lQueryBlock of lQueryBlockList) {\n            lQueryBlockResultList.add(await this.readQueryBlock(lQueryBlock));\n        }\n\n        // Find the greatest result set and use it as starting point.\n        // Greater performance when you only need to merge 1 entry in a set of 100 instead.\n        let lGreatestResultSet: Dictionary<string | number, any> = <any>null; // Will be set after the loop.\n        for (const lQueryBlockResult of lQueryBlockResultList) {\n            if (!lGreatestResultSet) {\n                lGreatestResultSet = lQueryBlockResult;\n                continue;\n            }\n\n            if (lGreatestResultSet.size < lQueryBlockResult.size) {\n                lGreatestResultSet = lQueryBlockResult;\n            }\n        }\n\n        // Remove the found set from iterator list.\n        lQueryBlockResultList.delete(lGreatestResultSet!);\n\n        // Merge remaining block result into.\n        for (const lQueryBlockResult of lQueryBlockResultList) {\n            for (const lQueryResultItem of lQueryBlockResult) {\n                lGreatestResultSet.set(...lQueryResultItem);\n            }\n        }\n\n        // Convert merged block.\n        return this.convertDataToTableType(lGreatestResultSet.values());\n    }\n\n    /**\n     * Chain database query with \"OR\".\n     * \n     * @param pIndexOrPropertyName - A index or a property name.\n     *  \n     * @returns query action. \n     */\n    public or(pIndexOrPropertyName: string): WebDatabaseQueryAction<TTableType> {\n        // Create query part.\n        const lPart: WebDatabaseQueryPart = {\n            indexKey: pIndexOrPropertyName,\n            action: null,\n            link: 'OR'\n        };\n\n        // Add part to query list.\n        this.mQueryList.push(lPart);\n\n        // Create query action that sets the action on a chained call.\n        return new WebDatabaseQueryAction(this, (pAction) => {\n            lPart.action = pAction;\n        });\n    }\n\n    /**\n     * Convert all data items into table type objects.\n     * \n     * @param pData - Data objects.\n     * \n     * @returns converted data list. \n     */\n    private convertDataToTableType(pData: Iterable<any>): Array<InstanceType<TTableType>> {\n        const lResultList: Array<InstanceType<TTableType>> = new Array<InstanceType<TTableType>>();\n\n        // Convert each item into type.\n        for (const lSourceObject of pData) {\n            const lTargetObject: InstanceType<TTableType> = new this.mTable.tableType() as InstanceType<TTableType>;\n\n            for (const lKey of Object.keys(lSourceObject)) {\n                (<any>lTargetObject)[lKey] = lSourceObject[lKey];\n            }\n\n            lResultList.push(lTargetObject);\n        }\n\n        return lResultList;\n    }\n\n    /**\n     * Read data from table filtered by query.\n     * When query index does not exists, it uses a expensive cursor filter.\n     * \n     * @param pQuery - Query.\n     * \n     * @returns Filtered item list. \n     */\n    private async readQuery(pQuery: WebDatabaseQueryPart): Promise<Array<any>> {\n        // Query must have a action.\n        if (!pQuery.action) {\n            throw new Exception('Query has no assigned action.', this);\n        }\n\n        // Get table connection.\n        const lTableConnection: IDBObjectStore = this.mTable.transaction.transaction.objectStore(this.mTable.tableType.name);\n\n        // Try to find index key.\n        const lIndexName: string | null = (() => {\n            const lIndexNameList: DOMStringList = lTableConnection.indexNames;\n            for (let lIndexNameListIndex: number = 0; lIndexNameListIndex < lIndexNameList.length; lIndexNameListIndex++) {\n                const lIndexName: string = lIndexNameList[lIndexNameListIndex];\n                if (lIndexName === pQuery.indexKey) {\n                    return lIndexName;\n                }\n            }\n\n            return null;\n        })();\n\n        // When index was found, use index.\n        if (lIndexName) {\n            const lIndex: IDBIndex = lTableConnection.index(lIndexName);\n\n            // Execute read request with the set query action.\n            const lRequest: IDBRequest<Array<any>> = lIndex.getAll(pQuery.action);\n            return new Promise<Array<any>>((pResolve, pReject) => {\n                // Reject on error.\n                lRequest.addEventListener('error', (pEvent) => {\n                    const lTarget: IDBRequest<Array<any>> = (<IDBRequest<Array<any>>>pEvent.target);\n                    pReject(new Exception(`Error fetching table.` + lTarget.error, this));\n                });\n\n                // Resolve on success.\n                lRequest.addEventListener('success', (pEvent) => {\n                    // Read event target like a shithead.\n                    const lTarget: IDBRequest<Array<any>> = pEvent.target as IDBRequest<Array<any>>;\n\n                    pResolve(lTarget.result);\n                });\n            });\n        }\n\n        // When no index was found you fucked up.\n        // Read anything and filter.\n        const lCursorRequest: IDBRequest<IDBCursorWithValue | null> = lTableConnection.openCursor();\n        const lFiteredList: Array<any> = new Array<any>();\n        return new Promise<Array<any>>((pResolve, pReject) => {\n            // Reject on error.\n            lCursorRequest.addEventListener('error', (pEvent) => {\n                const lTarget: IDBRequest<IDBCursorWithValue | null> = (<IDBRequest<IDBCursorWithValue | null>>pEvent.target);\n                pReject(new Exception(`Error fetching table.` + lTarget.error, this));\n            });\n\n            // Resolve on success.\n            lCursorRequest.addEventListener('success', (pEvent) => {\n                // Read event target like a shithead and resolve when cursor is eof.\n                const lTarget: IDBRequest<IDBCursorWithValue | null> = pEvent.target as IDBRequest<IDBCursorWithValue | null>;\n                const lCursorResult: IDBCursorWithValue | null = lTarget.result;\n                if (!lCursorResult) {\n                    pResolve(lFiteredList);\n                    return;\n                }\n\n                // Get value of filtered propery.\n                const lFiltedValue: any = lCursorResult.value[pQuery.indexKey];\n\n                // Append row when value is included in assigned action.\n                if (pQuery.action!.includes(lFiltedValue)) {\n                    lFiteredList.push(lCursorResult.value);\n                }\n\n                // Continue next value.\n                lCursorResult.continue();\n            });\n        });\n    }\n\n    /**\n     * Read the result of a query block.\n     * \n     * @param pBlock - Query block. Queries that are linked with an \"AND\"-Connection.\n     * \n     * return filtered query result.\n     */\n    private async readQueryBlock(pBlock: Array<WebDatabaseQueryPart>): Promise<Dictionary<string | number, any>> {\n        const lTableConnection: IDBObjectStore = this.mTable.transaction.transaction.objectStore(this.mTable.tableType.name);\n\n        // Read all queries in parallel.\n        const lQueryResultRequestList: Array<Promise<Array<any>>> = new Array<Promise<Array<any>>>();\n        for (const lQuery of pBlock) {\n            lQueryResultRequestList.push(this.readQuery(lQuery));\n        }\n\n        // Wait for all queries to finish.\n        const lQueryResultList: Array<Array<any>> = await Promise.all(lQueryResultRequestList);\n\n        // Get key of identity, identity is allways set and a single key.\n        const lIdentityKey: string = lTableConnection.keyPath as string;\n\n        // Conver all result list into an identity map.\n        const lIdentityMapList: Array<Dictionary<string | number, any>> = new Array<Dictionary<string | number, any>>();\n        for (const lQueryResult of lQueryResultList) {\n            // Map each item with its identity.\n            const lItemMap: Dictionary<string | number, any> = new Dictionary<string | number, any>();\n            for (const lItem of lQueryResult) {\n                lItemMap.set(lItem[lIdentityKey], lItem);\n            }\n\n            lIdentityMapList.push(lItemMap);\n        }\n\n        // Find the smallest identity set.\n        let lSmallestItemSet: Dictionary<string | number, any> = lIdentityMapList[0];\n        for (const lIdentityMap of lIdentityMapList) {\n            if (lIdentityMap.size < lSmallestItemSet.size) {\n                lSmallestItemSet = lIdentityMap;\n            }\n        }\n\n        // Remove smallest identity set from map list.\n        lIdentityMapList.splice(lIdentityMapList.indexOf(lSmallestItemSet), 1);\n\n        // Filter the smallest set for each remaining query.\n        for (const lFilteringQuery of lIdentityMapList) {\n            // Remove item from result list, when it does not exists in any other query result.\n            for (const lResultItemKey of lSmallestItemSet.keys()) {\n                if (!lFilteringQuery.has(lResultItemKey)) {\n                    lSmallestItemSet.delete(lResultItemKey);\n                }\n            }\n        }\n\n        return lSmallestItemSet;\n    }\n}\n\ntype WebDatabaseQueryPart = {\n    indexKey: string;\n    action: IDBKeyRange | null;\n    link: WebDatabaseQueryLink;\n};\n\ntype WebDatabaseQueryLink = 'AND' | 'OR';","\nimport { Exception } from '@kartoffelgames/core';\nimport { TableLayoutConfig, TableType, WebDatabaseTableLayout } from './layout/web-database-table-layout';\nimport { WebDatabaseQuery } from './query/web-database-query';\nimport { WebDatabaseQueryAction } from './query/web-database-query-action';\nimport { WebDatabaseTransaction } from './web-database-transaction';\n\nexport class WebDatabaseTable<TTableType extends TableType> {\n    private readonly mTableLayout: WebDatabaseTableLayout;\n    private readonly mTableType: TTableType;\n    private readonly mTransaction: WebDatabaseTransaction<TableType>;\n\n    /**\n     * Get table type.\n     */\n    public get tableType(): TTableType {\n        return this.mTableType;\n    }\n\n    /**\n     * Get transaction.\n     */\n    public get transaction(): WebDatabaseTransaction<TableType> {\n        return this.mTransaction;\n    }\n\n    /**\n     * Constructor.\n     * \n     * @param pType - Table type.\n     * @param pDatabase - Database.\n     */\n    public constructor(pType: TTableType, pTransaction: WebDatabaseTransaction<TableType>) {\n        this.mTableType = pType;\n        this.mTransaction = pTransaction;\n        this.mTableLayout = new WebDatabaseTableLayout();\n    }\n\n    /**\n     * Clear table data.\n     */\n    public async clear(): Promise<void> {\n        // Get table connection.\n        const lTable: IDBObjectStore = this.mTransaction.transaction.objectStore(this.mTableType.name);\n\n        // Clear data data.\n        const lRequest: IDBRequest<undefined> = lTable.clear();\n\n        // Wait for completion.\n        return new Promise<void>((pResolve, pReject) => {\n            // Reject on error.\n            lRequest.addEventListener('error', (pEvent) => {\n                const lTarget: IDBRequest<IDBValidKey> = pEvent.target as IDBRequest<IDBValidKey>;\n                pReject(new Exception(`Error clearing table data.` + lTarget.error, this));\n            });\n\n            lRequest.addEventListener('success', () => {\n                pResolve();\n            });\n        });\n    }\n\n    /**\n     * Get row count of table.\n     */\n    public async count(): Promise<number> {\n        // Get table connection.\n        const lTable: IDBObjectStore = this.mTransaction.transaction.objectStore(this.mTableType.name);\n\n        // Clear data data.\n        const lRequest: IDBRequest<number> = lTable.count();\n\n        // Wait for completion.\n        return new Promise<number>((pResolve, pReject) => {\n            // Reject on error.\n            lRequest.addEventListener('error', (pEvent) => {\n                const lTarget: IDBRequest<number> = (<IDBRequest<number>>pEvent.target);\n                pReject(new Exception(`Error counting table rows.` + lTarget.error, this));\n            });\n\n            // Resolve on success.\n            lRequest.addEventListener('success', (pEvent) => {\n                // Read event target like a shithead.\n                const lTarget: IDBRequest<number> = pEvent.target as IDBRequest<number>;\n\n                pResolve(lTarget.result);\n            });\n        });\n    }\n\n    /**\n     * Delete data.\n     * \n     * @param pData - Data. Must be an instance of the table type.\n     */\n    public async delete(pData: InstanceType<TTableType>): Promise<void> {\n        // Validate data type.\n        if (!(pData instanceof this.mTableType)) {\n            throw new Exception(`Invalid data type.`, this);\n        }\n\n        // Get identity value from data.\n        const lTableLayout: TableLayoutConfig = this.mTableLayout.configOf(this.mTableType);\n        const lIdentityProperty: string = lTableLayout.identity.key;\n        const lIdentityValue: string | number = (<any>pData)[lIdentityProperty];\n\n        // Get table connection.\n        const lTable: IDBObjectStore = this.mTransaction.transaction.objectStore(this.mTableType.name);\n\n        // Delete data.\n        const lRequest: IDBRequest<undefined> = lTable.delete(lIdentityValue);\n\n        // Wait for completion.\n        return new Promise<void>((pResolve, pReject) => {\n            // Reject on error.\n            lRequest.addEventListener('error', (pEvent) => {\n                const lTarget: IDBRequest<undefined> = pEvent.target as IDBRequest<undefined>;\n                pReject(new Exception(`Error deleting data.` + lTarget.error, this));\n            });\n\n            // Resolve on success.\n            lRequest.addEventListener('success', () => {\n                pResolve();\n            });\n        });\n    }\n\n    /**\n     * Get all table data. Can be limited by count.\n     */\n    public async getAll(pCount?: number): Promise<Array<InstanceType<TTableType>>> {\n        // Get table connection.\n        const lTable: IDBObjectStore = this.mTransaction.transaction.objectStore(this.mTableType.name);\n\n        // Clear data data.\n        const lRequest: IDBRequest<Array<any>> = lTable.getAll(null, pCount);\n\n        // Wait for completion.\n        return new Promise<Array<InstanceType<TTableType>>>((pResolve, pReject) => {\n            // Reject on error.\n            lRequest.addEventListener('error', (pEvent) => {\n                const lTarget: IDBRequest<number> = (<IDBRequest<number>>pEvent.target);\n                pReject(new Exception(`Error fetching table.` + lTarget.error, this));\n            });\n\n            // Resolve on success.\n            lRequest.addEventListener('success', (pEvent) => {\n                // Read event target like a shithead.\n                const lTarget: IDBRequest<Array<any>> = pEvent.target as IDBRequest<Array<any>>;\n\n                // Convert each item into type.\n                const lResult: Array<InstanceType<TTableType>> = lTarget.result.map((pSourceObject: any) => {\n                    const lTargetObject: InstanceType<TTableType> = new this.mTableType() as InstanceType<TTableType>;\n\n                    for (const lKey of Object.keys(pSourceObject)) {\n                        (<any>lTargetObject)[lKey] = pSourceObject[lKey];\n                    }\n\n                    return lTargetObject;\n                });\n\n                // Resolve converted data.\n                pResolve(lResult);\n            });\n        });\n    }\n\n\n    /**\n     * Put data.\n     * \n     * @param pData - Data. Must be an instance of the table type.\n     */\n    public async put(pData: InstanceType<TTableType>): Promise<void> {\n        // Validate data type.\n        if (!(pData instanceof this.mTableType)) {\n            throw new Exception(`Invalid data type.`, this);\n        }\n\n        // Get table connection.\n        const lTable: IDBObjectStore = this.mTransaction.transaction.objectStore(this.mTableType.name);\n\n        // Put data.\n        const lRequest: IDBRequest<IDBValidKey> = lTable.put(pData);\n\n        // Wait for completion.\n        return new Promise<void>((pResolve, pReject) => {\n            // Reject on error.\n            lRequest.addEventListener('error', (pEvent) => {\n                const lTarget: IDBRequest<IDBValidKey> = pEvent.target as IDBRequest<IDBValidKey>;\n                pReject(new Exception(`Error put data.` + lTarget.error, this));\n            });\n\n            // Resolve on success.\n            lRequest.addEventListener('success', (pEvent) => {\n                // Get table layout.\n                const lTableLayout: TableLayoutConfig = this.mTableLayout.configOf(this.mTableType);\n\n                // Read event target like a shithead.\n                const lTarget: IDBRequest<IDBValidKey> = pEvent.target as IDBRequest<IDBValidKey>;\n\n                // Update object with the new identity when any identity is specified.\n                const lIdentityProperty: string = lTableLayout.identity.key;\n                (<any>pData)[lIdentityProperty] = lTarget.result;\n\n                pResolve();\n            });\n        });\n    }\n\n    /**\n     * Create a new table query.\n     * \n     * @param pIndexOrPropertyName - A index or a property name.\n     * \n     * @returns a new chainable table query.\n     */\n    public where(pIndexOrPropertyName: string): WebDatabaseQueryAction<TTableType> {\n        return new WebDatabaseQuery<TTableType>(this).and(pIndexOrPropertyName);\n    }\n}","import { Exception } from '@kartoffelgames/core';\nimport { TableType } from './layout/web-database-table-layout';\nimport { WebDatabase } from './web-database';\nimport { WebDatabaseTable } from './web-database-table';\n\nexport class WebDatabaseTransaction<TTables extends TableType> {\n    private readonly mDatabase: WebDatabase;\n    private readonly mMode: WebDbTransactionMode;\n    private mState: IDBTransaction | null;\n    private readonly mTableTypes: Set<TTables>;\n\n    /**\n     * Underlying transaction.\n     */\n    public get transaction(): IDBTransaction {\n        if (!this.mState) {\n            throw new Exception(`Transaction is closed. Transactions can't be used with asynchronous calls.`, this);\n        }\n\n        return this.mState;\n    }\n\n    /**\n     * Constructor.\n     * \n     * @param pDatabase - Database-\n     * @param pTables - Tables of transaction.\n     * @param pMode - Transaction mode.\n     */\n    public constructor(pDatabase: WebDatabase, pTables: Array<TTables>, pMode: WebDbTransactionMode) {\n        this.mDatabase = pDatabase;\n        this.mTableTypes = new Set<TTables>(pTables);\n        this.mMode = pMode;\n        this.mState = null;\n    }\n\n    /**\n     * Force commit transaction.\n     */\n    public commit(): void {\n        if (!this.mState) {\n            return;\n        }\n\n        this.mState.commit();\n    }\n\n    /**\n     * Open the transaction.\n     */\n    public async open(): Promise<void> {\n        if (this.mState) {\n            return;\n        }\n\n        const lDatabaseConnection: IDBDatabase = await this.mDatabase.open();\n\n        // Convert types into names.\n        const lTableNames: Array<string> = Array.from(this.mTableTypes).map((pTableType: TTables) => {\n            return pTableType.name;\n        });\n\n        this.mState = lDatabaseConnection.transaction(lTableNames, this.mMode);\n        this.mState.addEventListener('complete', () => {\n            // Clear state on complete.\n            this.mState = null;\n        });\n    }\n\n    /**\n     * Get table of database.\n     * \n     * @param pType - Table type.\n     * \n     * @returns Table connection. \n     */\n    public table<T extends TTables>(pType: T): WebDatabaseTable<T> {\n        // Table type must exists in table.\n        if (!this.mTableTypes.has(pType)) {\n            throw new Exception('Table type not set for database.', this);\n        }\n\n        // Create table object with attached opened db.\n        return new WebDatabaseTable<T>(pType, this);\n    }\n\n}\n\nexport type WebDbTransactionMode = 'readwrite' | 'readonly';","import { Dictionary, Exception } from '@kartoffelgames/core';\nimport { TableLayoutConfig, TableLayoutConfigIndex, TableType, WebDatabaseTableLayout } from './layout/web-database-table-layout';\nimport { WebDatabaseTransaction, WebDbTransactionMode } from './web-database-transaction';\n\nexport class WebDatabase {\n    private static readonly ANONYMOUS_IDENTITIY_KEY: string = '__id__';\n\n    private mDatabaseConnection: IDBDatabase | null;\n    private readonly mDatabaseName: string;\n    private readonly mTableLayouts: WebDatabaseTableLayout;\n    private readonly mTableTypes: Dictionary<string, TableType>;\n\n    /**\n     * Constructor.\n     * \n     * @param pName - Database name.\n     * @param pTables - Database tables.\n     */\n    public constructor(pName: string, pTables: Array<TableType>) {\n        this.mDatabaseName = pName;\n        this.mDatabaseConnection = null;\n        this.mTableLayouts = new WebDatabaseTableLayout();\n\n        this.mTableTypes = new Dictionary<string, TableType>();\n        for (const lTableType of pTables) {\n            this.mTableTypes.set(lTableType.name, lTableType);\n        }\n    }\n\n    /**\n     * Close current database connections.\n     */\n    public close(): void {\n        // Skip when it is already closed.\n        if (this.mDatabaseConnection === null) {\n            return;\n        }\n\n        // Close and clear database connection.\n        this.mDatabaseConnection.close();\n        this.mDatabaseConnection = null;\n    }\n\n    /**\n     * Delete database and resolve on success.\n     */\n    public async delete(): Promise<void> {\n        const lDeleteRequest: IDBOpenDBRequest = window.indexedDB.deleteDatabase(this.mDatabaseName);\n        return new Promise<void>((pResolve, pReject) => {\n            // Reject on error.\n            lDeleteRequest.addEventListener('error', (pEvent) => {\n                const lTarget: IDBOpenDBRequest = pEvent.target as IDBOpenDBRequest;\n\n                pReject(new Exception('Error deleting database. ' + lTarget.error, this));\n            });\n\n            // Databse delete success.\n            lDeleteRequest.onsuccess = () => {\n                pResolve();\n            };\n        });\n\n    }\n\n    /**\n     * Open database connection.\n     * Resolve once the connection is set.\n     */\n    public async open(): Promise<IDBDatabase> {\n        // Dont open another connection when one is open.\n        if (this.mDatabaseConnection) {\n            return this.mDatabaseConnection;\n        }\n\n        // Open db with current version. Read all object stores and all indices and compare.\n        const lDatabaseUpdate: DatabaseUpdate = await new Promise((pResolve, pReject) => {\n            const lDatabaseUpdate: DatabaseUpdate = {\n                version: 0,\n                updateNeeded: false,\n                tableUpdates: new Array<TableUpdate>()\n            };\n\n            // Open database with current version.\n            const lOpenRequest: IDBOpenDBRequest = window.indexedDB.open(this.mDatabaseName);\n\n            // Set defaults when no database exists.\n            lOpenRequest.addEventListener('upgradeneeded', () => {\n                // Empty update.\n            });\n\n            // Reject on block or error. \n            lOpenRequest.addEventListener('blocked', (pEvent) => {\n                pReject(new Exception(`Database locked from another tab. Unable to update from \"${pEvent.oldVersion}\" to \"${pEvent.newVersion}\"`, this));\n            });\n            lOpenRequest.addEventListener('error', (pEvent) => {\n                const lTarget: IDBOpenDBRequest = pEvent.target as IDBOpenDBRequest;\n                pReject(new Exception('Error opening database. ' + lTarget.error, this));\n            });\n\n            // Save open state.\n            lOpenRequest.addEventListener('success', (pEvent) => {\n                const lDatabaseConnection: IDBDatabase = (<IDBOpenDBRequest>pEvent.target).result;\n\n                // Set current loaded database version.\n                lDatabaseUpdate.version = lDatabaseConnection.version;\n\n                // Read current tables names and tables names that should be created.\n                const lCurrentTableNames: Set<string> = new Set<string>(Array.from(lDatabaseConnection.objectStoreNames));\n                const lUncreatedTableNames: Set<string> = new Set<string>(Array.from(this.mTableTypes.keys()));\n\n                // Check current tables. When no tables exists, skip it, so no \"Empty Transaction\"-Error is thrown.\n                if (lCurrentTableNames.size > 0) {\n                    // Open a read transaction to read current table configurations.\n                    const lReadTransaction: IDBTransaction = lDatabaseConnection.transaction([...lCurrentTableNames], 'readonly');\n\n                    // Read all existing databases. \n                    for (const lTableName of lCurrentTableNames) {\n                        // Mark table as deleteable when it does not exists anymore.\n                        if (!lUncreatedTableNames.has(lTableName)) {\n                            lDatabaseUpdate.tableUpdates.push({\n                                name: lTableName,\n                                action: 'delete',\n                                indices: []\n                            });\n                            continue;\n                        }\n\n                        // Read table configuration.\n                        const lTableConfiguration: TableLayoutConfig = this.mTableLayouts.configOf(this.mTableTypes.get(lTableName)!);\n\n                        // Open database table.\n                        const lTable: IDBObjectStore = lReadTransaction.objectStore(lTableName);\n\n                        // Validate correct identity, update table when it differs.\n                        const lConfiguratedKeyPath: string = lTableConfiguration.identity.key;\n                        const lConfiguratedAutoIncrement: boolean = lTableConfiguration.identity.autoIncrement;\n                        if (lTable.keyPath !== lConfiguratedKeyPath || lTable.autoIncrement !== lConfiguratedAutoIncrement) {\n                            lDatabaseUpdate.tableUpdates.push({\n                                name: lTableName,\n                                action: 'delete',\n                                indices: []\n                            });\n                            continue;\n                        }\n\n                        // Remove table from uncreated table list, so it doesnt get created again.\n                        lUncreatedTableNames.delete(lTableName);\n\n                        // Read current tables indeces and tables indecies that should be created.\n                        const lCurrentTableIndices: Set<string> = new Set<string>(Array.from(lTable.indexNames));\n                        const lUncreatedTableIndices: Set<string> = new Set<string>(Array.from(lTableConfiguration.indices.keys()));\n\n                        const lIndexUpdates: Array<IndexUpdate> = new Array<IndexUpdate>();\n                        for (const lIndexName of lCurrentTableIndices) {\n                            // Mark index as deleteable when it does not exists anymore.\n                            if (!lUncreatedTableIndices.has(lIndexName)) {\n                                lIndexUpdates.push({\n                                    name: lIndexName,\n                                    action: 'delete',\n                                });\n                                continue;\n                            }\n\n                            // Read current index\n                            const lCurrentIndex: IDBIndex = lTable.index(lIndexName);\n                            const lIndexConfiguration: TableLayoutConfigIndex = lTableConfiguration.indices.get(lIndexName)!;\n\n                            // Read index keys.\n                            const lCurrentIndexKey: string = Array.isArray(lCurrentIndex.keyPath) ? lCurrentIndex.keyPath.join(',') : lCurrentIndex.keyPath;\n                            const lConfiguratedIndexKey: string = lIndexConfiguration.keys.join(',');\n\n                            // Validate same index configuration. Delete the current index when it differs.\n                            if (lCurrentIndexKey !== lConfiguratedIndexKey || lCurrentIndex.multiEntry !== lIndexConfiguration.options.multiEntity || lCurrentIndex.unique !== lIndexConfiguration.options.unique) {\n                                lIndexUpdates.push({\n                                    name: lIndexName,\n                                    action: 'delete',\n                                });\n                                continue;\n                            }\n\n                            // Remove index from uncreated index list, so it doesnt get created again.\n                            lUncreatedTableIndices.delete(lIndexName);\n                        }\n\n                        // Create all remaing missing indices.\n                        for (const lIndexName of lUncreatedTableIndices) {\n                            lIndexUpdates.push({\n                                name: lIndexName,\n                                action: 'create',\n                            });\n                        }\n\n                        // Add index update table update when any index is not created or must be deleted.\n                        if (lIndexUpdates.length > 0) {\n                            lDatabaseUpdate.tableUpdates.push({\n                                name: lTableName,\n                                action: 'none',\n                                indices: lIndexUpdates\n                            });\n                            continue;\n                        }\n                    }\n                }\n\n                // Create all remaining tables.\n                for (const lTableName of lUncreatedTableNames) {\n                    // Read table and index configuration.\n                    const lTableConfiguration: TableLayoutConfig = this.mTableLayouts.configOf(this.mTableTypes.get(lTableName)!);\n\n                    // Add all indices to the index update list.\n                    const lIndexUpdates: Array<IndexUpdate> = new Array<IndexUpdate>();\n                    for (const lIndexName of lTableConfiguration.indices.keys()) {\n                        lIndexUpdates.push({\n                            name: lIndexName,\n                            action: 'create',\n                        });\n                    }\n\n                    // Add create table update to database update.\n                    lDatabaseUpdate.tableUpdates.push({\n                        name: lTableName,\n                        action: 'create',\n                        indices: lIndexUpdates\n                    });\n                }\n\n                // Check for any update.\n                for (const lTableUpdate of lDatabaseUpdate.tableUpdates) {\n                    // Set database to need a update when any update should be made.\n                    if (lTableUpdate.action !== 'none' || lTableUpdate.indices.length > 0) {\n                        lDatabaseUpdate.updateNeeded = true;\n                        break;\n                    }\n                }\n\n                // Close connection before resolving.\n                lDatabaseConnection.close();\n\n                pResolve(lDatabaseUpdate);\n            });\n        });\n\n        // Get current or next version when a update must be made.\n        const lDatabaseVersion: number = (lDatabaseUpdate.updateNeeded) ? lDatabaseUpdate.version + 1 : lDatabaseUpdate.version;\n\n        // Open database request.\n        const lOpenRequest: IDBOpenDBRequest = window.indexedDB.open(this.mDatabaseName, lDatabaseVersion);\n        return new Promise<IDBDatabase>((pResolve, pReject) => {\n            // Init tables on upgradeneeded.\n            lOpenRequest.addEventListener('upgradeneeded', (pEvent) => {\n                const lTarget: IDBOpenDBRequest = pEvent.target as IDBOpenDBRequest;\n                const lDatabaseConnection: IDBDatabase = lTarget.result;\n                const lDatabaseTransaction: IDBTransaction = lTarget.transaction!;\n\n                for (const lTableUpdate of lDatabaseUpdate.tableUpdates) {\n                    // Delete action.\n                    if (lTableUpdate.action === 'delete') {\n                        lDatabaseConnection.deleteObjectStore(lTableUpdate.name);\n                        continue;\n                    }\n\n                    // Read table configuration.\n                    const lTableType: TableType = this.mTableTypes.get(lTableUpdate.name)!;\n                    const lTableConfiguration = this.mTableLayouts.configOf(lTableType);\n\n                    // Create table with correct identity.\n                    if (lTableUpdate.action === 'create') {\n                        if (lTableConfiguration.identity) {\n                            lDatabaseConnection.createObjectStore(lTableUpdate.name, {\n                                keyPath: lTableConfiguration.identity.key,\n                                autoIncrement: lTableConfiguration.identity.autoIncrement\n                            });\n                        } else {\n                            // Create object store without an identity.\n                            lDatabaseConnection.createObjectStore(lTableUpdate.name);\n                        }\n                    }\n\n                    // Update indices.\n                    if (lTableUpdate.indices.length > 0) {\n                        const lTable: IDBObjectStore = lDatabaseTransaction.objectStore(lTableUpdate.name);\n\n                        // Create indices.\n                        for (const lIndexUpdate of lTableUpdate.indices) {\n                            // Index delete action.\n                            if (lIndexUpdate.action === 'delete') {\n                                lTable.deleteIndex(lIndexUpdate.name);\n                                continue;\n                            }\n\n                            // Read index configuration.\n                            const lIndexConfiguration: TableLayoutConfigIndex = lTableConfiguration.indices.get(lIndexUpdate.name)!;\n\n                            // Read single keys as string, so multientries are recognized as single key.\n                            const lIndexKeys: string | Array<string> = lIndexConfiguration.keys.length > 1 ? lIndexConfiguration.keys : lIndexConfiguration.keys[0];\n\n                            // Index create action.\n                            if (lIndexUpdate.action === 'create') {\n                                lTable.createIndex(lIndexUpdate.name, lIndexKeys, {\n                                    unique: lIndexConfiguration.options.unique,\n                                    multiEntry: lIndexConfiguration.options.multiEntity\n                                });\n                                continue;\n                            }\n                        }\n                    }\n                }\n            });\n\n            // Reject when update is blocked.\n            lOpenRequest.addEventListener('blocked', (pEvent) => {\n                pReject(new Exception(`Database locked from another tab. Unable to update from \"${pEvent.oldVersion}\" to \"${pEvent.newVersion}\"`, this));\n            });\n\n            // Reject on error.\n            lOpenRequest.addEventListener('error', (pEvent) => {\n                const lTarget: IDBOpenDBRequest = pEvent.target as IDBOpenDBRequest;\n\n                pReject(new Exception('Error opening database. ' + lTarget.error, this));\n            });\n\n            // Save open state.\n            lOpenRequest.addEventListener('success', (pEvent) => {\n                // Save and resolve\n                this.mDatabaseConnection = (<IDBOpenDBRequest>pEvent.target).result;\n                pResolve(this.mDatabaseConnection);\n            });\n        });\n\n    }\n\n    /**\n     * Create a synchron action where data can be read or written.\n     * \n     * @param pTables - Tabes for this transaction.\n     * @param pAction - Action withing this transaction.\n     */\n    public async transaction<TTables extends TableType>(pTables: Array<TTables>, pMode: WebDbTransactionMode, pAction: (pTransaction: WebDatabaseTransaction<TTables>) => void): Promise<void> {\n        // Tables should exists.\n        for (const lTableType of pTables) {\n            if (!this.mTableTypes.has(lTableType.name)) {\n                throw new Exception(`Table \"${lTableType.name}\" does not exists in this database.`, this);\n            }\n        }\n\n        // Create and open transaction.\n        const lTransaction: WebDatabaseTransaction<TTables> = new WebDatabaseTransaction(this, pTables, pMode);\n        await lTransaction.open();\n\n        // Call action within the transaction.\n        // eslint-disable-next-line @typescript-eslint/await-thenable\n        await pAction(lTransaction);\n\n        // Commit transaction.\n        lTransaction.commit();\n    }\n}\n\ntype IndexUpdate = {\n    name: string;\n    action: 'delete' | 'create';\n};\n\ntype TableUpdate = {\n    name: string;\n    action: 'delete' | 'create' | 'none';\n    indices: Array<IndexUpdate>;\n};\n\ntype DatabaseUpdate = {\n    version: number;\n    updateNeeded: boolean;\n    tableUpdates: Array<TableUpdate>;\n};","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DecorationReplacementHistory = void 0;\nconst core_1 = require(\"@kartoffelgames/core\");\n/**\n * Decoration history keeps track of any class that was replaces through a decorator.\n *\n * @internal\n */\nclass DecorationReplacementHistory {\n    static { this.mBackwardHistory = new core_1.Dictionary(); }\n    /**\n     * Add an decoration parent.\n     *\n     * @param pFromConstructor - Previous constructor.\n     * @param pToConstructor - Changed / next construtor.\n     */\n    static add(pFromConstructor, pToConstructor) {\n        DecorationReplacementHistory.mBackwardHistory.add(pToConstructor, pFromConstructor);\n    }\n    /**\n     * Get the original constructor from a decorator replaced constructor.\n     * Iterates through decoration history until it cant find any parent.\n     *\n     * @param pConstructor - Constructor with decorations.\n     */\n    static getOriginalOf(pConstructor) {\n        let lCurrentConstructor;\n        // Iterate over history as long as history can't go back.\n        for (let lNextEntry = pConstructor; lNextEntry; lNextEntry = DecorationReplacementHistory.mBackwardHistory.get(lNextEntry)) {\n            lCurrentConstructor = lNextEntry;\n        }\n        return lCurrentConstructor;\n    }\n}\nexports.DecorationReplacementHistory = DecorationReplacementHistory;\n//# sourceMappingURL=decoration-history.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AddMetadata = AddMetadata;\nconst reflect_initializer_1 = require(\"../reflect/reflect-initializer\");\nreflect_initializer_1.ReflectInitializer.initialize();\n/**\n * AtScript.\n * Add metadata to class, method, accessor or property\n *\n * @param pMetadataKey - Key of metadata.\n * @param pMetadataValue - Value of metadata.\n */\nfunction AddMetadata(pMetadataKey, pMetadataValue) {\n    return (pTarget, pProperty) => {\n        Reflect.metadata(pMetadataKey, pMetadataValue)(pTarget, pProperty);\n    };\n}\n//# sourceMappingURL=add-metadata.decorator.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InjectableSingleton = InjectableSingleton;\nconst inject_mode_1 = require(\"../enum/inject-mode\");\nconst injection_1 = require(\"../injection/injection\");\nconst reflect_initializer_1 = require(\"../reflect/reflect-initializer\");\nreflect_initializer_1.ReflectInitializer.initialize();\n/**\n * AtScript.\n * Mark class to be injectable as an singleton object.\n *\n * @param pConstructor - Constructor.\n */\nfunction InjectableSingleton(pConstructor) {\n    injection_1.Injection.registerInjectable(pConstructor, inject_mode_1.InjectMode.Singleton);\n}\n//# sourceMappingURL=injectable-singleton.decorator.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Injectable = Injectable;\nconst inject_mode_1 = require(\"../enum/inject-mode\");\nconst reflect_initializer_1 = require(\"../reflect/reflect-initializer\");\nconst injection_1 = require(\"../injection/injection\");\nreflect_initializer_1.ReflectInitializer.initialize();\n/**\n * AtScript.\n * Mark class to be injectable as an instanced object.\n *\n * @param pConstructor - Constructor.\n */\nfunction Injectable(pConstructor) {\n    injection_1.Injection.registerInjectable(pConstructor, inject_mode_1.InjectMode.Instanced);\n}\n//# sourceMappingURL=injectable.decorator.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InjectMode = void 0;\n/**\n * Injection modes.\n * Used to create new or reuse old instances of a object.\n */\nvar InjectMode;\n(function (InjectMode) {\n    /**\n     * Only one instance of a class is constructed.\n     * Any other object created from this class has the same reference.\n     */\n    InjectMode[InjectMode[\"Singleton\"] = 1] = \"Singleton\";\n    /**\n     * Any new creation initializes a new instance.\n     */\n    InjectMode[InjectMode[\"Instanced\"] = 2] = \"Instanced\";\n})(InjectMode || (exports.InjectMode = InjectMode = {}));\n//# sourceMappingURL=inject-mode.js.map","\"use strict\";\n/* istanbul ignore file */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DecorationHistory = exports.Metadata = exports.Injection = exports.Injector = void 0;\n// Injection\nvar injector_1 = require(\"./injector\");\nObject.defineProperty(exports, \"Injector\", { enumerable: true, get: function () { return injector_1.Injector; } });\nvar injection_1 = require(\"./injection/injection\");\nObject.defineProperty(exports, \"Injection\", { enumerable: true, get: function () { return injection_1.Injection; } });\n// Metadata\nvar metadata_1 = require(\"./metadata/metadata\");\nObject.defineProperty(exports, \"Metadata\", { enumerable: true, get: function () { return metadata_1.Metadata; } });\n// Decoration\nvar decoration_history_1 = require(\"./decoration-history/decoration-history\");\nObject.defineProperty(exports, \"DecorationHistory\", { enumerable: true, get: function () { return decoration_history_1.DecorationReplacementHistory; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Injection = void 0;\nconst core_1 = require(\"@kartoffelgames/core\");\nconst inject_mode_1 = require(\"../enum/inject-mode\");\nconst decoration_history_1 = require(\"../decoration-history/decoration-history\");\nconst metadata_1 = require(\"../metadata/metadata\");\n/**\n * Injection configuration and creator.\n * Handes global injection configuration for replaced injections and creates new instances from injectable classes.\n *\n * @public\n */\nclass Injection {\n    static { this.mInjectMode = new core_1.Dictionary(); }\n    static { this.mInjectableConstructor = new core_1.Dictionary(); }\n    static { this.mInjectableReplacement = new core_1.Dictionary(); }\n    static { this.mSingletonMapping = new core_1.Dictionary(); }\n    static createObject(pConstructor, pForceCreateOrLocalInjections, pLocalInjections) {\n        // Decide between local injection or force creation parameter.\n        const [lForceCreate, lLocalInjections] = (() => {\n            if (typeof pForceCreateOrLocalInjections === 'object' && pForceCreateOrLocalInjections !== null) {\n                return [false, pForceCreateOrLocalInjections];\n            }\n            return [!!pForceCreateOrLocalInjections, pLocalInjections ?? new core_1.Dictionary()];\n        })();\n        // Find constructor in decoration replacement history that was used for registering. Only root can be registered.\n        const lRegisteredConstructor = decoration_history_1.DecorationReplacementHistory.getOriginalOf(pConstructor);\n        if (!Injection.mInjectableConstructor.has(lRegisteredConstructor)) {\n            throw new core_1.Exception(`Constructor \"${pConstructor.name}\" is not registered for injection and can not be build`, Injection);\n        }\n        // Get injection mode. Allways defaultsa to instanced, when force created.\n        const lInjectionMode = !lForceCreate ? Injection.mInjectMode.get(lRegisteredConstructor) : inject_mode_1.InjectMode.Instanced;\n        // Return cached singleton object if not forced to create a new one.\n        if (!lForceCreate && lInjectionMode === inject_mode_1.InjectMode.Singleton && Injection.mSingletonMapping.has(lRegisteredConstructor)) {\n            return Injection.mSingletonMapping.get(lRegisteredConstructor);\n        }\n        // Get constructor parameter type information and default to empty parameter list.\n        let lParameterTypeList = metadata_1.Metadata.get(pConstructor).parameterTypes;\n        if (lParameterTypeList === null) {\n            lParameterTypeList = new Array();\n        }\n        // Create parameter.\n        const lConstructorParameter = new Array();\n        for (const lParameterType of lParameterTypeList) {\n            let lParameterObject;\n            // Check if parameter can be replaced with an local injection\n            if (lInjectionMode !== inject_mode_1.InjectMode.Singleton && lLocalInjections.has(lParameterType)) {\n                lParameterObject = lLocalInjections.get(lParameterType);\n            }\n            else {\n                // Read original parameter type used as replacement key.\n                const lOriginalParameterType = decoration_history_1.DecorationReplacementHistory.getOriginalOf(lParameterType);\n                if (!Injection.mInjectableConstructor.has(lOriginalParameterType)) {\n                    throw new core_1.Exception(`Parameter \"${lParameterType.name}\" of ${pConstructor.name} is not registered to be injectable.`, Injection);\n                }\n                // Try to find global replacement.\n                let lParameterConstructor;\n                if (Injection.mInjectableReplacement.has(lOriginalParameterType)) {\n                    lParameterConstructor = Injection.mInjectableReplacement.get(lOriginalParameterType);\n                }\n                else {\n                    lParameterConstructor = lParameterType;\n                }\n                // Proxy exception.\n                try {\n                    // Get injectable parameter.\n                    lParameterObject = Injection.createObject(lParameterConstructor, lLocalInjections);\n                }\n                catch (pException) {\n                    // Error is always an Exception.\n                    const lException = pException;\n                    throw new core_1.Exception(`Parameter \"${lParameterType.name}\" of ${pConstructor.name} is not injectable.\\n` + lException.message, Injection);\n                }\n            }\n            // Add parameter to construction parameter list.\n            lConstructorParameter.push(lParameterObject);\n        }\n        // Create object.\n        const lCreatedObject = new pConstructor(...lConstructorParameter);\n        // Cache singleton objects but only if not forced to create.\n        if (lInjectionMode === inject_mode_1.InjectMode.Singleton && !Injection.mSingletonMapping.has(lRegisteredConstructor)) {\n            Injection.mSingletonMapping.add(lRegisteredConstructor, lCreatedObject);\n        }\n        return lCreatedObject;\n    }\n    /**\n     * Register an constructor for injection.\n     *\n     * @remarks\n     * Any constructor can be registred but only constructors that have a attached decorator of any kind are able to be injected.\n     *\n     * @param pConstructor - Constructor that can be injected.\n     * @param pMode - Mode of injection.\n     */\n    static registerInjectable(pConstructor, pMode) {\n        // Find root constructor of decorated constructor to habe registered constructor allways available top down.\n        const lBaseConstructor = decoration_history_1.DecorationReplacementHistory.getOriginalOf(pConstructor);\n        // Map constructor.\n        Injection.mInjectableConstructor.add(lBaseConstructor, pConstructor);\n        Injection.mInjectMode.add(lBaseConstructor, pMode);\n    }\n    /**\n     * Replaces an constructor so instead of the original, the replacement gets injected.\n     * Both constructors must be registered with {@link registerInjectable}.\n     *\n     * @param pOriginalConstructor - Original constructor that should be replaced.\n     * @param pReplacementConstructor - Replacement constructor that gets injected instead of original constructor.\n     *\n     * @throws {@link Exception}\n     * When a constructor is not registed with {@link registerInjectable}.\n     */\n    static replaceInjectable(pOriginalConstructor, pReplacementConstructor) {\n        // Find original registered original. Only root can be registerd.\n        const lRegisteredOriginal = decoration_history_1.DecorationReplacementHistory.getOriginalOf(pOriginalConstructor);\n        if (!Injection.mInjectableConstructor.has(lRegisteredOriginal)) {\n            throw new core_1.Exception('Original constructor is not registered.', Injection);\n        }\n        // Find replacement registered original. Only root can be registered.\n        const lRegisteredReplacement = decoration_history_1.DecorationReplacementHistory.getOriginalOf(pReplacementConstructor);\n        if (!Injection.mInjectableConstructor.has(lRegisteredReplacement)) {\n            throw new core_1.Exception('Replacement constructor is not registered.', Injection);\n        }\n        // Register replacement.\n        Injection.mInjectableReplacement.set(lRegisteredOriginal, pReplacementConstructor);\n    }\n}\nexports.Injection = Injection;\n//# sourceMappingURL=injection.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Injector = void 0;\nconst injectable_decorator_1 = require(\"./decorator/injectable.decorator\");\nconst injectable_singleton_decorator_1 = require(\"./decorator/injectable-singleton.decorator\");\nconst add_metadata_decorator_1 = require(\"./decorator/add-metadata.decorator\");\nconst reflect_initializer_1 = require(\"./reflect/reflect-initializer\");\nclass Injector {\n    /**\n     * AtScript.\n     * Mark class to be injectable as an instanced object.\n     *\n     * @param pConstructor - Constructor.\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static { this.Injectable = injectable_decorator_1.Injectable; }\n    /**\n     * AtScript.\n     * Mark class to be injectable as an singleton object.\n     *\n     * @param pConstructor - Constructor.\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static { this.InjectableSingleton = injectable_singleton_decorator_1.InjectableSingleton; }\n    /**\n     * AtScript.\n     * Add metadata to class, method, accessor or property\n     *\n     * @param pMetadataKey - Key of metadata.\n     * @param pMetadataValue - Value of metadata.\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static { this.Metadata = add_metadata_decorator_1.AddMetadata; }\n    /**\n     * Initialize reflection.\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static { this.Initialize = () => {\n        reflect_initializer_1.ReflectInitializer.initialize();\n    }; }\n}\nexports.Injector = Injector;\n//# sourceMappingURL=injector.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseMetadata = void 0;\nconst core_1 = require(\"@kartoffelgames/core\");\nconst metadata_1 = require(\"./metadata\");\n/**\n * Base metadata information for classes and properties.\n */\nclass BaseMetadata {\n    /**\n     * Constructor where all metadata should be attached.\n     */\n    get injectionConstructor() {\n        return this.mConstructor;\n    }\n    /**\n     * Constructor.\n     * Initialize lists.\n     *\n     * @param pConstructor - Constructor where all metadata should be attached.\n     * @param pPropertyKey - Key of property where all metadata should be attached.\n     */\n    constructor(pConstructor, pPropertyKey) {\n        this.mConstructor = pConstructor;\n        this.mProperty = pPropertyKey;\n        this.mCustomMetadata = new core_1.Dictionary();\n    }\n    /**\n     * Get metadata of constructor or property from this and any parent inheritance.\n     * List is empty if current and inherited items have no metadata.\n     *\n     * @param pMetadataKey - Metadata key.\n     *\n     * @typeParam T - Type of metadata value.\n     *\n     * @returns a array with all metadata set on all inherited parents.\n     */\n    getInheritedMetadata(pMetadataKey) {\n        // Try to get parent metadata.\n        const lParentClass = Object.getPrototypeOf(this.mConstructor);\n        // Read parent metadata or create new metadata list when no inheritance was found.\n        let lMetadataValueList;\n        if (lParentClass) {\n            let lMetadata = metadata_1.Metadata.get(lParentClass);\n            if (this.mProperty !== null) {\n                lMetadata = lMetadata.getProperty(this.mProperty);\n            }\n            lMetadataValueList = lMetadata.getInheritedMetadata(pMetadataKey);\n        }\n        else {\n            lMetadataValueList = new Array();\n        }\n        // Read current metadata and add it to inherited metadata list.\n        const lCurrentMetadata = this.getMetadata(pMetadataKey);\n        if (lCurrentMetadata !== null) {\n            lMetadataValueList.push(lCurrentMetadata);\n        }\n        return lMetadataValueList;\n    }\n    /**\n     * Get metadata of constructor or property.\n     *\n     * @param pMetadataKey - Metadata key.\n     *\n     * @typeParam T - Expected type of metadata value.\n     *\n     * @returns set metadata or null when no metadata was attached.\n     */\n    getMetadata(pMetadataKey) {\n        return this.mCustomMetadata.get(pMetadataKey) ?? null;\n    }\n    /**\n     * Set metadata of constructor or property.\n     *\n     * @param pMetadataKey - Metadata key.\n     * @param pMetadataValue - Metadata value.\n     *\n     * @typeParam T - Type of metadata value.\n     */\n    setMetadata(pMetadataKey, pMetadataValue) {\n        this.mCustomMetadata.set(pMetadataKey, pMetadataValue);\n    }\n}\nexports.BaseMetadata = BaseMetadata;\n//# sourceMappingURL=base-metadata.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConstructorMetadata = void 0;\nconst core_1 = require(\"@kartoffelgames/core\");\nconst property_metadata_1 = require(\"./property-metadata\");\nconst base_metadata_1 = require(\"./base-metadata\");\n/**\n * Constructor metadata.\n */\nclass ConstructorMetadata extends base_metadata_1.BaseMetadata {\n    /**\n     * Get parameter type information.\n     */\n    get parameterTypes() {\n        return this.getMetadata('design:paramtypes');\n    }\n    /**\n     * Constructor.\n     * Initialize lists.\n     *\n     * @param pConstructor - Constructor where all metadata should be attached.\n     */\n    constructor(pConstructor) {\n        super(pConstructor, null);\n        this.mPropertyMetadata = new core_1.Dictionary();\n    }\n    /**\n     * Get property by key.\n     * Creates new property metadata if it not already exists.\n     *\n     * @param pPropertyKey - Key of property.\n     */\n    getProperty(pPropertyKey) {\n        // Create new property mapping when no mapping is found.\n        if (!this.mPropertyMetadata.has(pPropertyKey)) {\n            this.mPropertyMetadata.add(pPropertyKey, new property_metadata_1.PropertyMetadata(this.injectionConstructor, pPropertyKey));\n        }\n        return this.mPropertyMetadata.get(pPropertyKey);\n    }\n}\nexports.ConstructorMetadata = ConstructorMetadata;\n//# sourceMappingURL=constructor-metadata.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Metadata = void 0;\nconst core_1 = require(\"@kartoffelgames/core\");\nconst decoration_history_1 = require(\"../decoration-history/decoration-history\");\nconst constructor_metadata_1 = require(\"./constructor-metadata\");\n/**\n * Static.\n * Metadata storage.\n *\n * @public\n */\nclass Metadata {\n    static { this.mConstructorMetadata = new core_1.Dictionary(); }\n    /**\n     * Get metadata of constructor.\n     *\n     * @param pConstructor - Constructor.\n     *\n     * @returns constructor metadata object of constructor.\n     *\n     * @example Adding a new and existing key.\n     * ```TypeScript\n     * @Injector.Metadata('key', 'value')\n     * class Foo {\n     *     @Injector.Metadata('key', 'value')\n     *     public prop: number;\n     * }\n     *\n     * const constructorMeta = Metadata.get(Foo).getMetadata('key');\n     * const propertyMeta = Metadata.get(Foo).getProperty('prop').getMetadata('key');\n     * ```\n     */\n    static get(pConstructor) {\n        // Use root constructor to register metadata information.\n        const lRegisteredConstructor = decoration_history_1.DecorationReplacementHistory.getOriginalOf(pConstructor);\n        // Create new or read existing metadata.\n        let lMetadata;\n        if (this.mConstructorMetadata.has(lRegisteredConstructor)) {\n            lMetadata = Metadata.mConstructorMetadata.get(lRegisteredConstructor);\n        }\n        else {\n            lMetadata = new constructor_metadata_1.ConstructorMetadata(lRegisteredConstructor);\n            Metadata.mConstructorMetadata.add(lRegisteredConstructor, lMetadata);\n        }\n        return lMetadata;\n    }\n}\nexports.Metadata = Metadata;\n//# sourceMappingURL=metadata.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PropertyMetadata = void 0;\nconst base_metadata_1 = require(\"./base-metadata\");\n/**\n * Property metadata.\n */\nclass PropertyMetadata extends base_metadata_1.BaseMetadata {\n    /**\n     * Get parameter type information.\n     */\n    get parameterTypes() {\n        return this.getMetadata('design:paramtypes');\n    }\n    /**\n     * Get return type information.\n     */\n    get returnType() {\n        return this.getMetadata('design:returntype');\n    }\n    /**\n     * Get property type information.\n     */\n    get type() {\n        return this.getMetadata('design:type');\n    }\n    /**\n     * Constructor.\n     * Initialize lists.\n     *\n     * @param pConstructor - Constructor where all metadata should be attached.\n     * @param pPropertyKey - Key of property where all metadata should be attached.\n     */\n    constructor(pConstructor, pPropertyKey) {\n        super(pConstructor, pPropertyKey);\n    }\n}\nexports.PropertyMetadata = PropertyMetadata;\n//# sourceMappingURL=property-metadata.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReflectInitializer = void 0;\nconst core_1 = require(\"@kartoffelgames/core\");\nconst decoration_history_1 = require(\"../decoration-history/decoration-history\");\nconst metadata_1 = require(\"../metadata/metadata\");\n/**\n * Initializes global metadata reflection functionality of typescript.\n * Adds {@link Reflect.metadata} and {@link Reflect.decorate} function to the global {@link Reflect} object.\n * These functions are used by Typescript to inject type information on compile time.\n *\n * @internal\n */\nclass ReflectInitializer {\n    static { this.mExported = false; }\n    /**\n     * Initializes global defintions for decorate and metadata into the Reflect object.\n     */\n    static initialize() {\n        if (!ReflectInitializer.mExported) {\n            ReflectInitializer.mExported = true;\n            ReflectInitializer.export('decorate', ReflectInitializer.decorate);\n            ReflectInitializer.export('metadata', ReflectInitializer.metadata);\n        }\n    }\n    /**\n     * Decorate class, method, parameter or property.\n     *\n     * @param pDecoratorList - List of decorators.\n     * @param pTarget - Target for decorator.\n     * @param pPropertyKey - Key of property on member decorator.\n     * @param pDescriptor - Descriptor of member on member decorator.\n     */\n    static decorate(pDecoratorList, pTarget, pPropertyKey, pDescriptor) {\n        let lDecoratorResult;\n        if (pPropertyKey && pDescriptor) {\n            // Decorate accessor, function. Returns new descriptor.\n            lDecoratorResult = ReflectInitializer.decorateMethod(pDecoratorList, pTarget, pPropertyKey, pDescriptor);\n        }\n        else if (pPropertyKey && !pDescriptor) {\n            // Decorate property or parameter. Has no return value.\n            ReflectInitializer.decorateProperty(pDecoratorList, pTarget, pPropertyKey);\n            lDecoratorResult = null; // Is ignored.\n        }\n        else { // Only target set.\n            // Decorate class. Returns replacement class.\n            lDecoratorResult = ReflectInitializer.decorateClass(pDecoratorList, pTarget);\n        }\n        return lDecoratorResult;\n    }\n    /**\n     * Decorate class.\n     *\n     * @param pDecoratorList - Decorators.\n     * @param pConstructor - Target constructor.\n     */\n    static decorateClass(pDecoratorList, pConstructor) {\n        let lCurrentConstrutor = pConstructor;\n        // Run all metadata decorator first.\n        for (const lDecorator of pDecoratorList) {\n            if (lDecorator.isMetadata) {\n                // Metadata decorator doesn't return values.\n                lDecorator(pConstructor);\n            }\n        }\n        // For each decorator included metadata decorator.\n        for (const lDecorator of pDecoratorList) {\n            // If the decorator was a metadata decorator use the original class as target.\n            if (!lDecorator.isMetadata) {\n                // Execute decorator.\n                const lNewConstructor = lDecorator(pConstructor);\n                // Check if decorator does return different class.\n                if (!!lNewConstructor && lNewConstructor !== lCurrentConstrutor) {\n                    if (typeof lNewConstructor === 'function') {\n                        // Add changed construtor to the decoration history.\n                        decoration_history_1.DecorationReplacementHistory.add(lCurrentConstrutor, lNewConstructor);\n                        lCurrentConstrutor = lNewConstructor;\n                    }\n                    else {\n                        throw new core_1.Exception('Constructor decorator does not return supported value.', lDecorator);\n                    }\n                }\n            }\n        }\n        return lCurrentConstrutor;\n    }\n    /**\n     * Decorate method or accessor.\n     *\n     * @param pDecoratorList - Decorators.\n     * @param pTarget - Is on instanced target the prototype and on static the constructor.s\n     * @param pPropertyKey - Key of property decorator.\n     * @param pDescriptor - Descriptor of property\n     */\n    static decorateMethod(pDecoratorList, pTarget, pPropertyKey, pDescriptor) {\n        let lCurrentDescriptor = pDescriptor;\n        // For each decorator.\n        for (const lDecorator of pDecoratorList) {\n            // Execute decorator.\n            const lDecoratedMember = lDecorator(pTarget, pPropertyKey, lCurrentDescriptor);\n            // Check if decorator does return different PropertyDescriptor.\n            if (lDecoratedMember) {\n                if (typeof lDecoratedMember === 'object') {\n                    lCurrentDescriptor = lDecoratedMember;\n                }\n                else {\n                    throw new core_1.Exception('Member decorator does not return supported value.', lDecorator);\n                }\n            }\n        }\n        return lCurrentDescriptor;\n    }\n    /**\n     * Decorate property or parameter.\n     *\n     * @param pDecoratorList - Decorators.\n     * @param pTarget - Is on instanced target the prototype and on static the constructor.s\n     * @param pPropertyKey - Key of property decorator.\n     */\n    static decorateProperty(pDecoratorList, pTarget, pPropertyKey) {\n        // For each decorator.\n        for (const lDecorator of pDecoratorList) {\n            // Execute decorator. Doesn't return any value.\n            lDecorator(pTarget, pPropertyKey, undefined); // Index number gets overriden for parameter decorator.\n        }\n    }\n    /**\n     * Export property into Reflect object.\n     *\n     * @param pKey - Key of property.\n     * @param pValue - Value of property.\n     */\n    static export(pKey, pValue) {\n        // Find root for accessing Reflect.\n        /* istanbul ignore next */\n        const lRoot = typeof window === 'object' ? window : global;\n        // Set target as Reflect of root. (window or global).\n        const lTarget = lRoot.Reflect;\n        Object.defineProperty(lTarget, pKey, { configurable: true, writable: true, value: pValue });\n    }\n    /**\n     * Entry point for Typescripts emitDecoratorMetadata data.\n     *\n     * @param pMetadataKey - Key of metadata.\n     * @param pMetadataValue - Value of metadata. Usually only \"design:paramtypes\" data.\n     */\n    static metadata(pMetadataKey, pMetadataValue) {\n        /*\n            Typescript injected metadata. __metadata is called as decorator and calls this metadata function.\n            \n           __metadata(\"design:type\", Function), // Parameter Value\n           __metadata(\"design:paramtypes\", [Number, String]), // Function or Constructor Parameter\n           __metadata(\"design:returntype\", void 0) // Function return type.\n        */\n        const lResultDecorator = (pTarget, pProperty) => {\n            // Get constructor from prototype if is an instanced member.\n            let lConstructor;\n            if (typeof pTarget !== 'function') {\n                lConstructor = pTarget.constructor;\n            }\n            else {\n                lConstructor = pTarget;\n            }\n            // Set metadata for property or class.\n            if (pProperty) {\n                metadata_1.Metadata.get(lConstructor).getProperty(pProperty).setMetadata(pMetadataKey, pMetadataValue);\n            }\n            else {\n                metadata_1.Metadata.get(lConstructor).setMetadata(pMetadataKey, pMetadataValue);\n            }\n        };\n        // Set as metadata constructor and return.\n        lResultDecorator.isMetadata = true;\n        return lResultDecorator;\n    }\n}\nexports.ReflectInitializer = ReflectInitializer;\n//# sourceMappingURL=reflect-initializer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ChangeState = exports.MyersDiff = void 0;\nclass MyersDiff {\n    /**\n     * Constructor.\n     * @param pCompareFunction - Compare function to compare two items.\n     */\n    constructor(pCompareFunction) {\n        this.mCompareFunction = pCompareFunction;\n    }\n    /**\n     * Get differences of the two item lists.\n     * @param pItemListA - Item list A.\n     * @param pItemListB - Item list B.\n     */\n    differencesOf(pItemListA, pItemListB) {\n        // Save farthest-right points with it histories.\n        const lFrontierList = { 1: { x: 0, history: [] } };\n        // \"Convert\" Zero index to One index.\n        const lOneIndex = (pId) => pId - 1;\n        const lLengthA = pItemListA.length;\n        const lLengthB = pItemListB.length;\n        let lHistoryList;\n        let lX;\n        for (let lD = 0; lD < lLengthA + lLengthB + 1; lD++) {\n            for (let lK = -lD; lK < lD + 1; lK += 2) {\n                // Check if next move goes down or right.\n                const lGoesDown = (lK === -lD || (lK !== lD && lFrontierList[lK - 1].x < lFrontierList[lK + 1].x));\n                // Get starting diagonal point.\n                if (lGoesDown) {\n                    const lNextFrontier = lFrontierList[lK + 1];\n                    lX = lNextFrontier.x;\n                    lHistoryList = lNextFrontier.history;\n                }\n                else {\n                    const lNextFrontier = lFrontierList[lK - 1];\n                    lX = lNextFrontier.x + 1;\n                    lHistoryList = lNextFrontier.history;\n                }\n                // Copy history list.\n                lHistoryList = lHistoryList.slice();\n                let lY = lX - lK;\n                // Only start tracking history on valid track. Staring point (0,0) should not be tracked.\n                if (1 <= lY && lY <= lLengthB && lGoesDown) {\n                    lHistoryList.push({ changeState: ChangeState.Insert, item: pItemListB[lOneIndex(lY)] });\n                }\n                else if (1 <= lX && lX <= lLengthA) {\n                    lHistoryList.push({ changeState: ChangeState.Remove, item: pItemListA[lOneIndex(lX)] });\n                }\n                // Move diagonal as long as possible.\n                while (lX < lLengthA && lY < lLengthB && this.mCompareFunction(pItemListA[lOneIndex(lX + 1)], pItemListB[lOneIndex(lY + 1)])) {\n                    lX += 1;\n                    lY += 1;\n                    lHistoryList.push({ changeState: ChangeState.Keep, item: pItemListA[lOneIndex(lX)] });\n                }\n                // Check if in the bottom right. If not save frontier.\n                if (lX >= lLengthA && lY >= lLengthB) {\n                    // Return found history.\n                    return lHistoryList;\n                }\n                else {\n                    lFrontierList[lK] = { x: lX, history: lHistoryList };\n                }\n            }\n        }\n        // Empty array for typescript. This area is never reached.\n        /* istanbul ignore next */\n        return new Array();\n    }\n}\nexports.MyersDiff = MyersDiff;\nvar ChangeState;\n(function (ChangeState) {\n    ChangeState[ChangeState[\"Remove\"] = 1] = \"Remove\";\n    ChangeState[ChangeState[\"Insert\"] = 2] = \"Insert\";\n    ChangeState[ChangeState[\"Keep\"] = 3] = \"Keep\";\n})(ChangeState || (exports.ChangeState = ChangeState = {}));\n//# sourceMappingURL=myers-diff.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Dictionary = void 0;\nconst list_1 = require(\"./list\");\nconst exception_1 = require(\"../exception/exception\");\n/**\n * Wrapper for {@link Map}.\n * Extended by {@link Dictionary.add}, {@link Dictionary.getAllKeysOfValue}, {@link Dictionary.getOrDefault} and {@link Dictionary.map}.\n *\n * @typeParam TKey - Type of objects defined for keys.\n * @typeParam TValue - Type of objects defined for values.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map}\n *\n * @public\n */\nclass Dictionary extends Map {\n    /**\n     * Add value and key to dictionary.\n     * Throws {@link Exception}  for any added dublicate key.\n     *\n     * @param pKey - Key of item.\n     * @param pValue - value of item.\n     *\n     * @throws\n     * On any dublicate key set,\n     *\n     * @example Adding a new and existing key.\n     * ```TypeScript\n     * const dictionary = new Dictionary<string, number>();\n     * dictionary.add('a', 4); // => OK\n     * dictionary.add('a', 4); // => Fail: Dublicate key.\n     * ```\n     */\n    add(pKey, pValue) {\n        // Add value and key to containers.\n        if (!this.has(pKey)) {\n            this.set(pKey, pValue);\n        }\n        else {\n            throw new exception_1.Exception(\"Can't add dublicate key to dictionary.\", this);\n        }\n    }\n    /**\n     * Create new dicionary and add same keys and values.\n     * @see {@link ICloneable.clone}\n     *\n     * @returns cloned dictionary with shallow copied key and value refernces.\n     *\n     * @example Clone and compare dictionary and dictionary items.\n     * ```TypeScript\n     * const dictionary = new Dictionary<string, object>();\n     * dictionary.set('a', new Object());\n     *\n     * const clone = dictionary.clone();\n     *\n     * const areSame = dictionary === clone; // => False\n     * const itemSame = dictionary.get('a') === clone.get('a'); // => True\n     * ```\n     */\n    clone() {\n        return new Dictionary(this);\n    }\n    /**\n     * Get all keys that have the set value.\n     *\n     * @param pValue - Value.\n     *\n     * @returns all keys that hold the specified value.\n     *\n     * @example Get keys of a value.\n     * ```TypeScript\n     * const dictionary = new Dictionary<string, number>();\n     * dictionary.set('a', 1);\n     * dictionary.set('b', 2);\n     * dictionary.set('c', 1);\n     *\n     * const keys = dictionary.getAllKeysOfValue(1); // => ['a', 'c']\n     * ```\n     */\n    getAllKeysOfValue(pValue) {\n        // Add entries iterator to list and filter for pValue = Value\n        const lKeyValuesWithValue = [...this.entries()].filter((pItem) => {\n            return pItem[1] === pValue;\n        });\n        // Get only keys of key values.\n        const lKeysOfKeyValue = lKeyValuesWithValue.map((pItem) => {\n            return pItem[0];\n        });\n        return lKeysOfKeyValue;\n    }\n    /**\n     * Get item. If the key does not exists the default value gets returned.\n     * @param pKey - Key of item.\n     * @param pDefault - Default value if key was not found.\n     *\n     * @returns value of the key. If the key does not exists the default value gets returned.\n     *\n     * @example Get value or default from a existing and none existing key.\n     * ```TypeScript\n     * const dictionary = new Dictionary<string, number>();\n     * dictionary.set('a', 1);\n     *\n     * const keyA = dictionary.getOrDefault('a', 22); // => 1\n     * const keyZ = dictionary.getOrDefault('z', 22); // => 22\n     * ```\n     */\n    getOrDefault(pKey, pDefault) {\n        const lValue = this.get(pKey);\n        if (typeof lValue !== 'undefined') {\n            return lValue;\n        }\n        return pDefault;\n    }\n    /**\n     * Maps information into new list.\n     * @param pFunction - Mapping funktion.\n     *\n     * @typeParam T - Result type of mapping resolver function.\n     *\n     * @returns mapped data for each item.\n     *\n     * @example Remap all dictionary values by adding a number to all values.\n     * ```TypeScript\n     * const dictionary = new Dictionary<string, number>();\n     * dictionary.set('a', 1);\n     * dictionary.set('b', 2);\n     *\n     * const list = dictionary.map((key, value) => value + 1); //  => [2, 3]\n     * ```\n     */\n    map(pFunction) {\n        const lResultList = new list_1.List();\n        for (const lKeyValuePair of this) {\n            // Execute callback and add result to list.\n            const lMappingResult = pFunction(lKeyValuePair[0], lKeyValuePair[1]);\n            lResultList.push(lMappingResult);\n        }\n        return lResultList;\n    }\n}\nexports.Dictionary = Dictionary;\n//# sourceMappingURL=dictionary.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.List = void 0;\n/**\n * Wrapper for {@link Array}.\n *\n * @typeParam T - Type of items of list.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array}\n *\n * @public\n */\nclass List extends Array {\n    /**\n     * Create list and add items.\n     * Prevents spread operator with number arrays to initialize array with length instead of item.\n     *\n     * @param pItemList - Items.\n     *\n     * @example Create new list with `newListWith` and failing creation with the native `Array` constructor.\n     * ```TypeScript\n     * const newList = List.newListWith<number>(...[3]); // => [3]\n     * const newListWrong = new List<number>(...[3]);    // => [undefined, undefined, undefined]\n     * ```\n     */\n    static newListWith(...pItemList) {\n        const lNewList = new List();\n        lNewList.push(...pItemList);\n        return lNewList;\n    }\n    /**\n     * Remove every item.\n     *\n     * @example Clear a list.\n     * ```TypeScript\n     * const list = List.newListWith<number>(1, 2, 3);\n     * list.clear();\n     *\n     * console.log(list.length); // => 0\n     * ```\n     */\n    clear() {\n        this.splice(0, this.length);\n    }\n    /**\n     * Create new list and add same items.\n     * @see {@link ICloneable.clone}\n     *\n     * @returns cloned list with shallow copied item refernces.\n     *\n     * @example Clone and compare list and list items.\n     * ```TypeScript\n     * const list = List.newListWith<object>(new Object());\n     *\n     * const clone = list.clone();\n     *\n     * const areSame = list === clone; // => False\n     * const itemSame = list[0] === list[0]; // => True\n     * ```\n     */\n    clone() {\n        return List.newListWith(...this);\n    }\n    /**\n     * Copy distinct values into new list.\n     *\n     * @returns new list instance with only distinct values.\n     *\n     * @example Create a new list with dublicates and create a new distinct list out of it.\n     * ```TypeScript\n     * const listWithDublicates = List.newListWith<number>(1, 1, 2, 3, 3);\n     * const distinctList = listWithDublicates.distinct(); // => [1, 2, 3]\n     * ```\n     */\n    distinct() {\n        return List.newListWith(...new Set(this));\n    }\n    /**\n     * Compares this array with the specified one.\n     * Compares length and every item by reference and order.\n     * Does only shallow compare item references.\n     *\n     * @param pArray - Array to compare.\n     *\n     * @returns true for equality.\n     *\n     * @example Compare two arrays with a list.\n     * ```TypeScript\n     * const list = List.newListWith<number>(1, 3, 2);\n     *\n     * const isEqual = list.equals([1, 3, 2]) // => True\n     * const isUnequal = list.equals([1, 2, 3]) // => False\n     * ```\n     */\n    equals(pArray) {\n        // Check if array are same, dont null and have same length.\n        if (this === pArray) {\n            return true;\n        }\n        else if (!pArray || this.length !== pArray.length) {\n            return false;\n        }\n        // Check each item.\n        for (let lIndex = 0; lIndex < this.length; ++lIndex) {\n            if (this[lIndex] !== pArray[lIndex]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Removes the first appearence of a value.\n     *\n     * @param pValue - Target value to remove.\n     *\n     * @returns removed element. When no element was removed, undefined is returned instead.\n     *\n     * @example Remove a existing and a none existing item of a list.\n     * ```TypeScript\n     * const list = List.newListWith<number>(1, 3, 2);\n     *\n     * const removedElement = list.remove(1); // => 1\n     * const noneExistingElement = list.remove(4); // => undefined\n     * ```\n     */\n    remove(pValue) {\n        const lFoundIndex = this.indexOf(pValue);\n        // Only remove if found.\n        if (lFoundIndex !== -1) {\n            return this.splice(lFoundIndex, 1)[0];\n        }\n        return undefined;\n    }\n    /**\n     * Replace first appearence of value.\n     *\n     * @param pOldValue - Target value to replace.\n     * @param pNewValue - Replacement value.\n     *\n     * @returns replaced element. When no element was replaced, undefined is returned instead.\n     *\n     * @example Replace a existing and a none existing item of a list.\n     * ```TypeScript\n     * const list = List.newListWith<number>(1, 5, 3);\n     *\n     * const removedElement = list.replace(5, 2); // => 5\n     * const noneExistingElement = list.replace(4, 3); // => undefined\n     *\n     * console.log(list); // => [1, 2, 3]\n     * ```\n     */\n    replace(pOldValue, pNewValue) {\n        const lFoundIndex = this.indexOf(pOldValue);\n        // Only replace if found.\n        if (lFoundIndex !== -1) {\n            // Save old value and replace it with new value.\n            const lOldValue = this[lFoundIndex];\n            this[lFoundIndex] = pNewValue;\n            return lOldValue;\n        }\n        return undefined;\n    }\n    /**\n     * Returns a string representation of this list.\n     * @override base objects {@link Array.toString}\n     *\n     * @returns string representation for this list.\n     *\n     * @example Output a string representation of a list.\n     * ```TypeScript\n     * const list = List.newListWith<number>(1, 2, 3);\n     * console.log(list.toString()); // => [1, 2, 3]\n     * ```\n     */\n    toString() {\n        return `[${super.join(', ')}]`;\n    }\n}\nexports.List = List;\n//# sourceMappingURL=list.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Stack = void 0;\n/**\n * Simple and fast stack implementation based on references.\n *\n * @public\n */\nclass Stack {\n    /**\n     * Get current stack size.\n     */\n    get size() {\n        return this.mSize;\n    }\n    /**\n     * Current top item of stack.\n     * Returns undefined when no item is stacked.\n     */\n    get top() {\n        // Undefined when no item is stacked.\n        if (!this.mTopItem) {\n            return undefined;\n        }\n        return this.mTopItem.value;\n    }\n    /**\n     * Constructor.\n     */\n    constructor() {\n        this.mTopItem = null;\n        this.mSize = 0;\n    }\n    /**\n     * Clones the references of all stack items into a new one.\n     * Does only shallow copy.\n     *\n     * @returns The cloned stack.\n     */\n    clone() {\n        const lClonedStack = new Stack();\n        // Only thing that needs to be cloned is the current reference.\n        lClonedStack.mTopItem = this.mTopItem;\n        lClonedStack.mSize = this.mSize;\n        return lClonedStack;\n    }\n    /**\n     * Iterates over each stack entry in reversed (newest...oldest) order.\n     *\n     * @returns Generator.\n     */\n    *entries() {\n        let lCurrentItem = this.mTopItem;\n        while (lCurrentItem !== null) {\n            yield lCurrentItem.value;\n            lCurrentItem = lCurrentItem.previous;\n        }\n    }\n    /**\n     * Clear stack and get all stacked items in stack order.\n     *\n     * @returns All stacked values in top to down order.\n     *\n     * @example Flush Stack\n     * ``` Typescript\n     * const stack = new Stack<number>();\n     * stack.push(1);\n     * stack.push(2);\n     * stack.push(3);\n     *\n     * // Flush all items. Clears stack.\n     * const stackValues = stack.flush(); // => [3, 2, 1];\n     * console.log(stack.top); // => undefined\n     * ```\n     */\n    flush() {\n        const lValueList = new Array();\n        // Pop items as long as there are stack items.\n        // Don't check poped value as next indicator as it can contain undefined.\n        while (this.mTopItem) {\n            lValueList.push(this.pop());\n        }\n        return lValueList;\n    }\n    /**\n     * Removes the current top item of stack.\n     * When no item is stacked nothing happends and undefined is returned.\n     *\n     * @returns Current top item. When no item was stacked, undefined is returned instead.\n     *\n     * @example Pop current top item.\n     * ``` Typescript\n     * const stack = new Stack<number>();\n     * stack.push(1);\n     * stack.push(2);\n     * stack.push(3);\n     *\n     * // Check current stacked top item before and after poping.\n     * console.log(stack.top); // => 3\n     * const stackValues = stack.pop(); // => 3;\n     * console.log(stack.top); // => 2\n     * ```\n     */\n    pop() {\n        // Undefined when no item is stacked.\n        if (!this.mTopItem) {\n            return undefined;\n        }\n        // Buffer current top value.\n        const lCurrentTopValue = this.mTopItem.value;\n        // Replace current top item with previous stacked.\n        this.mTopItem = this.mTopItem.previous;\n        this.mSize--;\n        return lCurrentTopValue;\n    }\n    /**\n     * Push new value as top item of stack. Replaces the current top item.\n     * @param pValue - Next value placed on top.\n     *\n     * @example Push next top item.\n     * ``` Typescript\n     * const stack = new Stack<number>();\n     * stack.push(1);\n\n     *\n     * // Check current stacked top item before and after pushing.\n     * console.log(stack.top); // => 1\n     * stack.push(2);\n     * console.log(stack.top); // => 2\n     * ```\n     */\n    push(pValue) {\n        // Create new stack item with the current top item as reference. \n        const lNextItem = {\n            previous: this.mTopItem,\n            value: pValue\n        };\n        // Replace current top item with next.\n        this.mTopItem = lNextItem;\n        this.mSize++;\n    }\n    /**\n     * Converts this stack into an array.\n     * The first item in the array is the last item pushed into the stack.\n     *\n     * @returns The current stack as array.\n     *\n     * @example Stack into array.\n     * ``` Typescript\n     * const stack = new Stack<number>();\n     * stack.push(1);\n     * stack.push(2);\n     * stack.push(3);\n     *\n     * // Stack to array.\n     * console.log(stack.toArray()); // => [3, 2, 1]\n     * ```\n     */\n    toArray() {\n        // Convert genertor into array.\n        return [...this.entries()];\n    }\n}\nexports.Stack = Stack;\n//# sourceMappingURL=stack.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Exception = void 0;\n/**\n * Extends {@link Error} by a {@link Exception.target} reference.\n *\n * @typeParam T - Exception target type.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}\n *\n * @public\n */\nclass Exception extends Error {\n    /**\n     * Target of exception.\n     *\n     * @readonly\n     */\n    get target() {\n        return this.mTarget;\n    }\n    /**\n     * Constructor.\n     * @param pMessage - Messsage of exception.\n     * @param pTarget - Target of exception.\n     */\n    constructor(pMessage, pTarget) {\n        super(pMessage);\n        this.mTarget = pTarget;\n    }\n}\nexports.Exception = Exception;\n//# sourceMappingURL=exception.js.map","\"use strict\";\n/* istanbul ignore file */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MyersDiff = exports.ChangeState = exports.TypeUtil = exports.EnumUtil = exports.Stack = exports.Exception = exports.List = exports.Dictionary = void 0;\n/**\n * Library for data container and easier data access.\n *\n * @remarks\n * This package consists mostly of helper classes and storage types, aimed at reducing code redundance and improving clarity.\n *\n * @packageDocumentation\n */\n// Container.\nvar dictionary_1 = require(\"./data_container/dictionary\");\nObject.defineProperty(exports, \"Dictionary\", { enumerable: true, get: function () { return dictionary_1.Dictionary; } });\nvar list_1 = require(\"./data_container/list\");\nObject.defineProperty(exports, \"List\", { enumerable: true, get: function () { return list_1.List; } });\nvar exception_1 = require(\"./exception/exception\");\nObject.defineProperty(exports, \"Exception\", { enumerable: true, get: function () { return exception_1.Exception; } });\nvar stack_1 = require(\"./data_container/stack\");\nObject.defineProperty(exports, \"Stack\", { enumerable: true, get: function () { return stack_1.Stack; } });\n// Handler.\nvar enum_util_1 = require(\"./util/enum-util\");\nObject.defineProperty(exports, \"EnumUtil\", { enumerable: true, get: function () { return enum_util_1.EnumUtil; } });\nvar type_util_1 = require(\"./util/type-util\");\nObject.defineProperty(exports, \"TypeUtil\", { enumerable: true, get: function () { return type_util_1.TypeUtil; } });\n// Algorythms\nvar myers_diff_1 = require(\"./algorithm/myers-diff\");\nObject.defineProperty(exports, \"ChangeState\", { enumerable: true, get: function () { return myers_diff_1.ChangeState; } });\nObject.defineProperty(exports, \"MyersDiff\", { enumerable: true, get: function () { return myers_diff_1.MyersDiff; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EnumUtil = void 0;\n/**\n * Static helper type to read data from enum objects.\n *\n * @public\n */\nclass EnumUtil {\n    /**\n     * Infers value into enum type.\n     * When the values can not be infered into the specified enum, undefined is returned.\n     *\n     * @param pEnum - typeof Enum object.\n     * @param pValue - Value of enum.\n     *\n     * @typeParam T - Enum type the value should be infered into.\n     *\n     * @returns Infered `pValue` parameter or undefined when the value does not exists as the enums value.\n     *\n     * @example Try to cast two possible enum values.\n     * ``` Typescript\n     * enum MyEnum {\n     *     Entry1 = 1,\n     *     Entry2 = 2\n     * }\n     *\n     * const existingValue = EnumUtil.cast<MyEnum>(MyEnum, 1); // => MyEnum.Entry1\n     * const noneExistingValue = EnumUtil.cast<MyEnum>(MyEnum, 5); // => undefined\n     * ```\n     */\n    static cast(pEnum, pValue) {\n        // Thats it... :)\n        if (EnumUtil.exists(pEnum, pValue)) {\n            return pValue;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Check value existence on a enum object.\n     * Infers `pValue` parameter as enum type.\n     * @param pEnum - typeof Enum object.\n     * @param pValue - Value of enum.\n     *\n     * @typeParam T - Enum type the value should be infered into.\n     *\n     * @returns True when the value can be casted into enum.\n     *\n     * @example Check existence of one two possible enum values.\n     * ``` Typescript\n     * enum MyEnum {\n     *     Entry1 = 1,\n     *     Entry2 = 2\n     * }\n     *\n     * const existingValue = EnumUtil.exists(MyEnum, 1); // => True\n     * const noneExistingValue = EnumUtil.exists(MyEnum, 5); // => False\n     * ```\n     */\n    static exists(pEnum, pValue) {\n        return EnumUtil.valuesOf(pEnum).includes(pValue);\n    }\n    /**\n     * Return all keys of an enum as array.\n     *\n     * @param pEnum - typeof Enum object.\n     *\n     * @returns All enum key as array in defined order.\n     *\n     * @remarks\n     * Does only work for number enums and should fail for mixed or string enums.\n     *\n     * @example Read enum names from custom enum object.\n     * ``` Typescript\n     * enum MyEnum {\n     *     Entry1 = 1,\n     *     Entry2 = 2\n     * }\n     *\n     * const enumNames = EnumUtil.namesOf(MyEnum); // => ['Entry1', 'Entry2']\n     * ```\n     */\n    static namesOf(pEnum) {\n        // Convert enum to key array.\n        return Object.keys(pEnum).filter((pKey) => isNaN(Number(pKey)));\n    }\n    /**\n     * Return all values of an enum as array.\n     *\n     * @param pEnum - typeof Enum object.\n     *\n     * @typeParam T - Enum value type.\n     *\n     * @returns All enum values as array in defined order.\n     *\n     * @example Read enum values from custom enum object.\n     * ``` Typescript\n     * enum MyEnum {\n     *     Entry1 = 1,\n     *     Entry2 = 2\n     * }\n     *\n     * const enumValues = EnumUtil.valuesOf(MyEnum); // => [1, 2]\n     * ```\n     */\n    static valuesOf(pEnum) {\n        const lEnumValues = new Array();\n        // Convert enum to vaue array by iterating over all keys.\n        for (const lKey of EnumUtil.namesOf(pEnum)) {\n            lEnumValues.push(pEnum[lKey]);\n        }\n        return lEnumValues;\n    }\n}\nexports.EnumUtil = EnumUtil;\n//# sourceMappingURL=enum-util.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeUtil = void 0;\n/**\n * Static helper type to read data from objects.\n *\n * @public\n */\nclass TypeUtil {\n    /**\n     * Get name of objects property.\n     * @param pName - Property name.\n     *\n     * @typeParam T - Object with any string key property.\n     *\n     * @returns the name of property.\n     *\n     * @remarks\n     * Acts more as a type safe way of accessing property names of a type.\n     *\n     * @example Read enum names from custom enum object.\n     * ``` Typescript\n     * class MyClass {\n     *    public myProperty: number = 1;\n     * }\n     *\n     * const propertyName = TypeUtil.nameOf<MyClass>('myProperty'); // => 'myProperty'\n     * ```\n     *\n     * @experimental @alpha\n     */\n    static nameOf(pName) {\n        return pName;\n    }\n}\nexports.TypeUtil = TypeUtil;\n//# sourceMappingURL=type-util.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./page/source/index.ts\");\n",""],"names":["web_database_identity_decorator_1","require","web_database_index_decorator_1","web_database_1","TestTableOne","whatMyId","id","__decorate","WebDatabaseIdentity","WebDatabaseIndex","Array","TestTableTwo","lDatabase","WebDatabase","transaction","_ref","_asyncToGenerator","pTransaction","lTestTableOne","table","lTestTableTwo","clear","lCounter","lData","name","Math","random","toString","price","types","slice","floor","notIndexed","put","console","log","count","getAll","where","is","and","between","execute","nameThing","_x","apply","arguments","exports","core_1","core_dependency_injection_1","web_database_table_layout_1","Injector","Initialize","pAutoIncrement","pTarget","pPropertyKey","lPrototype","lTableType","constructor","Exception","lTableLayout","WebDatabaseTableLayout","setTableIdentity","pUnique","pName","lIndexName","setTableIndex","mInstance","mTableConfigs","Dictionary","configOf","pType","has","lTableConfiguration","get","identity","configurated","lPropertyType","Metadata","getProperty","key","type","String","Number","lIndex","indices","values","lIndexKey","keys","options","multiEntity","pKey","initializeTableType","lTableConfig","autoIncrement","pIsUnique","lIndexConfig","unique","set","push","length","WebDatabaseQueryAction","pQuery","pActionCallback","mActionCallback","mDatabaseQuery","pLowerValue","pUpperValue","lAction","IDBKeyRange","bound","greaterThan","pValue","lowerBound","only","lowerThan","upperBound","web_database_query_action_1","WebDatabaseQuery","pTable","mTable","mQueryList","pIndexOrPropertyName","lPart","indexKey","action","link","pAction","_this","lQueryBlockList","lQuery","at","convertDataToTableType","readQuery","lQueryResult","readQueryBlock","lQueryBlockResultList","Set","lQueryBlock","add","lGreatestResultSet","lQueryBlockResult","size","delete","lQueryResultItem","or","pData","lResultList","lSourceObject","lTargetObject","tableType","lKey","Object","_this2","lTableConnection","objectStore","lIndexNameList","indexNames","lIndexNameListIndex","index","lRequest","Promise","pResolve","pReject","addEventListener","pEvent","lTarget","target","error","result","lCursorRequest","openCursor","lFiteredList","lCursorResult","lFiltedValue","value","includes","continue","pBlock","_this3","lQueryResultRequestList","lQueryResultList","all","lIdentityKey","keyPath","lIdentityMapList","lItemMap","lItem","lSmallestItemSet","lIdentityMap","splice","indexOf","lFilteringQuery","lResultItemKey","web_database_query_1","WebDatabaseTable","mTableType","mTransaction","mTableLayout","lTable","lIdentityProperty","lIdentityValue","pCount","_this4","lResult","map","pSourceObject","_this5","web_database_table_1","WebDatabaseTransaction","mState","pDatabase","pTables","pMode","mDatabase","mTableTypes","mMode","commit","open","lDatabaseConnection","lTableNames","from","pTableType","web_database_transaction_1","ANONYMOUS_IDENTITIY_KEY","mDatabaseName","mDatabaseConnection","mTableLayouts","close","lDeleteRequest","window","indexedDB","deleteDatabase","onsuccess","lDatabaseUpdate","version","updateNeeded","tableUpdates","lOpenRequest","oldVersion","newVersion","lCurrentTableNames","objectStoreNames","lUncreatedTableNames","lReadTransaction","lTableName","lConfiguratedKeyPath","lConfiguratedAutoIncrement","lCurrentTableIndices","lUncreatedTableIndices","lIndexUpdates","lCurrentIndex","lIndexConfiguration","lCurrentIndexKey","isArray","join","lConfiguratedIndexKey","multiEntry","lTableUpdate","lDatabaseVersion","lDatabaseTransaction","deleteObjectStore","createObjectStore","lIndexUpdate","deleteIndex","lIndexKeys","createIndex","lTransaction"],"sourceRoot":""}