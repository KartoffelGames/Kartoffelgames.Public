{
  "version": 3,
  "sources": ["../packages/kartoffelgames.core/source/data_container/list.ts", "../packages/kartoffelgames.core/source/exception/exception.ts", "../packages/kartoffelgames.core/source/data_container/dictionary.ts", "../packages/kartoffelgames.core.dependency_injection/source/metadata/base-metadata.ts", "../packages/kartoffelgames.core.dependency_injection/source/metadata/property-metadata.ts", "../packages/kartoffelgames.core.dependency_injection/source/metadata/constructor-metadata.ts", "../packages/kartoffelgames.core.dependency_injection/source/metadata/metadata.ts", "../packages/kartoffelgames.core.dependency_injection/source/injection/injection.ts", "../packages/kartoffelgames.web.database/source/web_database/web-database-table-layout.ts", "../packages/kartoffelgames.web.database/source/web_database/query/web-database-query-action.ts", "../packages/kartoffelgames.web.database/source/web_database/query/web-database-query.ts", "../packages/kartoffelgames.web.database/source/web_database/web-database-table.ts", "../packages/kartoffelgames.web.database/source/web_database/web-database-transaction.ts", "../packages/kartoffelgames.web.database/source/web_database/web-database.ts", "../packages/kartoffelgames.web.database/page/source/index.ts", "../packages/kartoffelgames.web.database/page/source/standard-input-file.js"],
  "sourcesContent": ["import type { ICloneable } from '../interface/i-cloneable.ts';\r\n\r\n/**\r\n * Wrapper for {@link Array}.\r\n * \r\n * @typeParam T - Type of items of list. \r\n * \r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array}\r\n * \r\n * @public\r\n */\r\nexport class List<T> extends Array<T> implements ICloneable<List<T>> {\r\n    /**\r\n     * Create list and add items.\r\n     * Prevents spread operator with number arrays to initialize array with length instead of item.\r\n     * \r\n     * @param pItemList - Items.\r\n     * \r\n     * @example Create new list with `newListWith` and failing creation with the native `Array` constructor.\r\n     * ```TypeScript\r\n     * const newList = List.newListWith<number>(...[3]); // => [3] \r\n     * const newListWrong = new List<number>(...[3]);    // => [undefined, undefined, undefined] \r\n     * ```\r\n     */\r\n    public static newListWith<T>(...pItemList: Array<T>): List<T> {\r\n        const lNewList: List<T> = new List<T>();\r\n        lNewList.push(...pItemList);\r\n\r\n        return lNewList;\r\n    }\r\n\r\n    /**\r\n     * Remove every item.\r\n     * \r\n     * @example Clear a list.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<number>(1, 2, 3);\r\n     * list.clear(); \r\n     * \r\n     * console.log(list.length); // => 0\r\n     * ```\r\n     */\r\n    public clear(): void {\r\n        this.splice(0, this.length);\r\n    }\r\n\r\n    /**\r\n     * Create new list and add same items.\r\n     * @see {@link ICloneable.clone}\r\n     * \r\n     * @returns cloned list with shallow copied item refernces.\r\n     * \r\n     * @example Clone and compare list and list items.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<object>(new Object());\r\n     * \r\n     * const clone = list.clone();\r\n     * \r\n     * const areSame = list === clone; // => False\r\n     * const itemSame = list[0] === list[0]; // => True\r\n     * ```\r\n     */\r\n    public clone(): List<T> {\r\n        return List.newListWith(...this);\r\n    }\r\n\r\n    /**\r\n     * Copy distinct values into new list.\r\n     * \r\n     * @returns new list instance with only distinct values.\r\n     * \r\n     * @example Create a new list with dublicates and create a new distinct list out of it.\r\n     * ```TypeScript\r\n     * const listWithDublicates = List.newListWith<number>(1, 1, 2, 3, 3);\r\n     * const distinctList = listWithDublicates.distinct(); // => [1, 2, 3]\r\n     * ```\r\n     */\r\n    public distinct(): List<T> {\r\n        return List.newListWith(...new Set(this));\r\n    }\r\n\r\n    /**\r\n     * Compares this array with the specified one.\r\n     * Compares length and every item by reference and order.\r\n     * Does only shallow compare item references.\r\n     * \r\n     * @param pArray - Array to compare.\r\n     * \r\n     * @returns true for equality.\r\n     * \r\n     * @example Compare two arrays with a list.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<number>(1, 3, 2);\r\n     * \r\n     * const isEqual = list.equals([1, 3, 2]) // => True\r\n     * const isUnequal = list.equals([1, 2, 3]) // => False\r\n     * ```\r\n     */\r\n    public equals(pArray: Array<unknown>): boolean {\r\n        // Check if array are same, dont null and have same length.\r\n        if (this === pArray) {\r\n            return true;\r\n        } else if (!pArray || this.length !== pArray.length) {\r\n            return false;\r\n        }\r\n\r\n        // Check each item.\r\n        for (let lIndex = 0; lIndex < this.length; ++lIndex) {\r\n            if (this[lIndex] !== pArray[lIndex]) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Removes the first appearence of a value.\r\n     * \r\n     * @param pValue - Target value to remove.\r\n     * \r\n     * @returns removed element. When no element was removed, undefined is returned instead.\r\n     * \r\n     * @example Remove a existing and a none existing item of a list.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<number>(1, 3, 2);\r\n     * \r\n     * const removedElement = list.remove(1); // => 1\r\n     * const noneExistingElement = list.remove(4); // => undefined\r\n     * ```\r\n     */\r\n    public remove(pValue: T): T | undefined {\r\n        const lFoundIndex: number = this.indexOf(pValue);\r\n\r\n        // Only remove if found.\r\n        if (lFoundIndex !== -1) {\r\n            return this.splice(lFoundIndex, 1)[0];\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Replace first appearence of value.\r\n     * \r\n     * @param pOldValue - Target value to replace.\r\n     * @param pNewValue - Replacement value.\r\n     * \r\n     * @returns replaced element. When no element was replaced, undefined is returned instead.\r\n     * \r\n     * @example Replace a existing and a none existing item of a list.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<number>(1, 5, 3);\r\n     * \r\n     * const removedElement = list.replace(5, 2); // => 5\r\n     * const noneExistingElement = list.replace(4, 3); // => undefined\r\n     * \r\n     * console.log(list); // => [1, 2, 3]\r\n     * ```\r\n     */\r\n    public replace(pOldValue: T, pNewValue: T): T | undefined {\r\n        const lFoundIndex: number = this.indexOf(pOldValue);\r\n\r\n        // Only replace if found.\r\n        if (lFoundIndex !== -1) {\r\n            // Save old value and replace it with new value.\r\n            const lOldValue: T = this[lFoundIndex];\r\n            this[lFoundIndex] = pNewValue;\r\n\r\n            return lOldValue;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of this list.\r\n     * @override base objects {@link Array.toString}\r\n     * \r\n     * @returns string representation for this list.\r\n     * \r\n     * @example Output a string representation of a list.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<number>(1, 2, 3);\r\n     * console.log(list.toString()); // => [1, 2, 3]\r\n     * ```\r\n     */\r\n    public override toString(): string {\r\n        return `[${super.join(', ')}]`;\r\n    }\r\n}", "\uFEFF/**\r\n * Extends {@link Error} by a {@link Exception.target} reference.\r\n * \r\n * @typeParam T - Exception target type.\r\n * \r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}\r\n * \r\n * @public\r\n */\r\nexport class Exception<T> extends Error {\r\n    private readonly mTarget: T;\r\n\r\n    /**\r\n     * Target of exception.\r\n     * \r\n     * @readonly\r\n     */\r\n    public get target(): T {\r\n        return this.mTarget;\r\n    }\r\n\r\n    /**\r\n     * Constructor. \r\n     * @param pMessage - Messsage of exception.\r\n     * @param pTarget - Target of exception.\r\n     * @param pErrorOptions - Optional error options.\r\n     */\r\n    public constructor(pMessage: string, pTarget: T, pErrorOptions?: ErrorOptions) {\r\n        super(pMessage, pErrorOptions);\r\n        this.mTarget = pTarget;\r\n    }\r\n}", "import { List } from './list.ts';\r\nimport { Exception } from '../exception/exception.ts';\r\nimport type { ICloneable } from '../interface/i-cloneable.ts';\r\n\r\n/**\r\n * Wrapper for {@link Map}.\r\n * Extended by {@link Dictionary.add}, {@link Dictionary.getAllKeysOfValue}, {@link Dictionary.getOrDefault} and {@link Dictionary.map}.\r\n * \r\n * @typeParam TKey - Type of objects defined for keys. \r\n * @typeParam TValue - Type of objects defined for values. \r\n * \r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map}\r\n * \r\n * @public\r\n */\r\nexport class Dictionary<TKey, TValue> extends Map<TKey, TValue> implements ICloneable<Dictionary<TKey, TValue>>{\r\n    /**\r\n     * Add value and key to dictionary. \r\n     * Throws {@link Exception}  for any added dublicate key. \r\n     * \r\n     * @param pKey - Key of item.\r\n     * @param pValue - value of item.\r\n     * \r\n     * @throws\r\n     * On any dublicate key set,\r\n     * \r\n     * @example Adding a new and existing key.\r\n     * ```TypeScript\r\n     * const dictionary = new Dictionary<string, number>();\r\n     * dictionary.add('a', 4); // => OK\r\n     * dictionary.add('a', 4); // => Fail: Dublicate key.\r\n     * ```\r\n     */\r\n    public add(pKey: TKey, pValue: TValue): void {\r\n        // Add value and key to containers.\r\n        if (!this.has(pKey)) {\r\n            this.set(pKey, pValue);\r\n        } else {\r\n            throw new Exception(\"Can't add dublicate key to dictionary.\", this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create new dicionary and add same keys and values.\r\n     * @see {@link ICloneable.clone}\r\n     * \r\n     * @returns cloned dictionary with shallow copied key and value refernces.\r\n     * \r\n     * @example Clone and compare dictionary and dictionary items.\r\n     * ```TypeScript\r\n     * const dictionary = new Dictionary<string, object>();\r\n     * dictionary.set('a', new Object());\r\n     * \r\n     * const clone = dictionary.clone();\r\n     * \r\n     * const areSame = dictionary === clone; // => False\r\n     * const itemSame = dictionary.get('a') === clone.get('a'); // => True\r\n     * ```\r\n     */\r\n    public clone(): Dictionary<TKey, TValue> {\r\n        return new Dictionary<TKey, TValue>(this);\r\n    }\r\n\r\n    /**\r\n     * Get all keys that have the set value.\r\n     * \r\n     * @param pValue - Value.\r\n     * \r\n     * @returns all keys that hold the specified value.\r\n     * \r\n     * @example Get keys of a value.\r\n     * ```TypeScript\r\n     * const dictionary = new Dictionary<string, number>();\r\n     * dictionary.set('a', 1);\r\n     * dictionary.set('b', 2);\r\n     * dictionary.set('c', 1);\r\n     * \r\n     * const keys = dictionary.getAllKeysOfValue(1); // => ['a', 'c']\r\n     * ```\r\n     */\r\n    public getAllKeysOfValue(pValue: TValue): Array<TKey> {\r\n        // Add entries iterator to list and filter for pValue = Value\r\n        const lKeyValuesWithValue: Array<[TKey, TValue]> = [...this.entries()].filter((pItem: [TKey, TValue]) => {\r\n            return pItem[1] === pValue;\r\n        });\r\n\r\n        // Get only keys of key values.\r\n        const lKeysOfKeyValue: Array<TKey> = lKeyValuesWithValue.map<TKey>((pItem: [TKey, TValue]): TKey => {\r\n            return pItem[0];\r\n        });\r\n\r\n        return lKeysOfKeyValue;\r\n    }\r\n\r\n    /**\r\n     * Get item. If the key does not exists the default value gets returned.\r\n     * @param pKey - Key of item.\r\n     * @param pDefault - Default value if key was not found.\r\n     * \r\n     * @returns value of the key. If the key does not exists the default value gets returned.\r\n     * \r\n     * @example Get value or default from a existing and none existing key. \r\n     * ```TypeScript\r\n     * const dictionary = new Dictionary<string, number>();\r\n     * dictionary.set('a', 1);\r\n     * \r\n     * const keyA = dictionary.getOrDefault('a', 22); // => 1\r\n     * const keyZ = dictionary.getOrDefault('z', 22); // => 22\r\n     * ```\r\n     */\r\n    public getOrDefault(pKey: TKey, pDefault: TValue): TValue {\r\n        const lValue: TValue | undefined = this.get(pKey);\r\n        if (typeof lValue !== 'undefined') {\r\n            return lValue;\r\n        }\r\n\r\n        return pDefault;\r\n    }\r\n\r\n    /**\r\n     * Maps information into new list.\r\n     * @param pFunction - Mapping funktion.\r\n     * \r\n     * @typeParam T - Result type of mapping resolver function.\r\n     * \r\n     * @returns mapped data for each item.\r\n     * \r\n     * @example Remap all dictionary values by adding a number to all values. \r\n     * ```TypeScript\r\n     * const dictionary = new Dictionary<string, number>();\r\n     * dictionary.set('a', 1);\r\n     * dictionary.set('b', 2);\r\n     * \r\n     * const list = dictionary.map((key, value) => value + 1); //  => [2, 3]\r\n     * ```\r\n     */\r\n    public map<T>(pFunction: (pKey: TKey, pValue: TValue) => T): Array<T> {\r\n        const lResultList: List<T> = new List<T>();\r\n\r\n        for (const lKeyValuePair of this) {\r\n            // Execute callback and add result to list.\r\n            const lMappingResult: T = pFunction(lKeyValuePair[0], lKeyValuePair[1]);\r\n            lResultList.push(lMappingResult);\r\n        }\r\n\r\n        return lResultList;\r\n    }\r\n}", "import { Dictionary } from '@kartoffelgames/core';\r\n\r\n/**\r\n * Base metadata information for classes and properties.\r\n */\r\nexport class BaseMetadata {\r\n    private readonly mCustomMetadata: Dictionary<MetadataKey, any>;\r\n\r\n    /**\r\n     * Constructor.\r\n     * Initialize lists.\r\n     * \r\n     * @param pConstructor - Constructor where all metadata should be attached.\r\n     * @param pPropertyKey - Key of property where all metadata should be attached.\r\n     */\r\n    public constructor() {\r\n        this.mCustomMetadata = new Dictionary<MetadataKey, any>();\r\n    }\r\n\r\n    /**\r\n     * Get metadata of constructor or property.\r\n     * \r\n     * @param pMetadataKey - Metadata key.\r\n     * \r\n     * @typeParam T - Expected type of metadata value. \r\n     * \r\n     * @returns set metadata or null when no metadata was attached.\r\n     */\r\n    public getMetadata<T>(pMetadataKey: MetadataKey): T | null {\r\n        return this.mCustomMetadata.get(pMetadataKey) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Set metadata of constructor or property.\r\n     * \r\n     * @param pMetadataKey - Metadata key.\r\n     * @param pMetadataValue - Metadata value.\r\n     * \r\n     * @typeParam T - Type of metadata value. \r\n     */\r\n    public setMetadata<T>(pMetadataKey: MetadataKey, pMetadataValue: T): void {\r\n        this.mCustomMetadata.set(pMetadataKey, pMetadataValue);\r\n    }\r\n}\r\n\r\nexport type MetadataKey = string | symbol | number;", "import { BaseMetadata } from './base-metadata.ts';\r\n\r\n/**\r\n * Property metadata.\r\n */\r\nexport class PropertyMetadata extends BaseMetadata{\r\n    \r\n}", "import { Dictionary } from '@kartoffelgames/core';\r\nimport { BaseMetadata, type MetadataKey } from './base-metadata.ts';\r\nimport { PropertyMetadata } from './property-metadata.ts';\r\n\r\n/**\r\n * Constructor metadata.\r\n */\r\nexport class ConstructorMetadata extends BaseMetadata {\r\n    private static readonly mPrivateMetadataKey: symbol = Symbol('Metadata');\r\n\r\n    private readonly mDecoratorMetadataObject: DecoratorMetadataObject;\r\n    private readonly mPropertyMetadata: Dictionary<PropertyKey, PropertyMetadata>;\r\n\r\n    /**\r\n     * Constructor.\r\n     * Initialize lists.\r\n     * \r\n     * @param pDecoratorMetadataObject - Constructor where all metadata should be attached.\r\n     */\r\n    public constructor(pDecoratorMetadataObject: DecoratorMetadataObject) {\r\n        super();\r\n\r\n        this.mDecoratorMetadataObject = pDecoratorMetadataObject;\r\n        this.mPropertyMetadata = new Dictionary<PropertyKey, PropertyMetadata>();\r\n\r\n        // Attach constructor metadata to decorator metadata object.\r\n        pDecoratorMetadataObject[ConstructorMetadata.mPrivateMetadataKey] = this;\r\n    }\r\n\r\n    /**\r\n     * Get metadata of constructor.\r\n     * Searches for metadata in inheritance chain.\r\n     * \r\n     * @param pMetadataKey - Metadata key.\r\n     * \r\n     * @typeParam T - Expected type of metadata value. \r\n     * \r\n     * @returns set metadata or null when no metadata was attached.\r\n     */\r\n    public getInheritedMetadata<T>(pMetadataKey: MetadataKey): Array<T> {\r\n        const lInheritedMetadata: Array<T> = new Array<T>();\r\n\r\n        // Read starting decorator metadata. At this point it should have a metadata object.\r\n        let lDecoratorMetadataObject: DecoratorMetadataObject | null = this.mDecoratorMetadataObject;\r\n        do {\r\n            // Check if metadata is set on this constructor.\r\n            if (Object.hasOwn(lDecoratorMetadataObject, ConstructorMetadata.mPrivateMetadataKey)) {\r\n                // Get metadata from constructor.\r\n                const lConstructorMetadata: ConstructorMetadata = lDecoratorMetadataObject[ConstructorMetadata.mPrivateMetadataKey] as ConstructorMetadata;\r\n\r\n                // Check if metadata is set.\r\n                const lMetadataValue: T | null = lConstructorMetadata.getMetadata(pMetadataKey);\r\n                if (lMetadataValue !== null) {\r\n                    lInheritedMetadata.push(lMetadataValue);\r\n                }\r\n            }\r\n\r\n            // Read next metadata object.\r\n            lDecoratorMetadataObject = Object.getPrototypeOf(lDecoratorMetadataObject);\r\n        } while (lDecoratorMetadataObject !== null);\r\n\r\n        // Reverse array to send data order from Parent to Child.\r\n        return lInheritedMetadata.reverse();\r\n    }\r\n\r\n    /**\r\n     * Get property by key.\r\n     * Creates new property metadata if it not already exists.\r\n     * \r\n     * @param pPropertyKey - Key of property.\r\n     */\r\n    public getProperty(pPropertyKey: PropertyKey): PropertyMetadata {\r\n        // Create new property mapping when no mapping is found.\r\n        if (!this.mPropertyMetadata.has(pPropertyKey)) {\r\n            this.mPropertyMetadata.add(pPropertyKey, new PropertyMetadata());\r\n        }\r\n\r\n        return <PropertyMetadata>this.mPropertyMetadata.get(pPropertyKey);\r\n    }\r\n}\r\n", "import { Dictionary } from '@kartoffelgames/core';\r\nimport type { InjectionConstructor, InjectionInstance } from '../type.ts';\r\nimport { ConstructorMetadata } from './constructor-metadata.ts';\r\n\r\n// Polyfill for Symbol.metadata for environments that do not support it.\r\n(<any>Symbol).metadata ??= Symbol('Symbol.metadata');\r\n\r\n/**\r\n * Static.\r\n * Metadata storage.\r\n * \r\n * @public\r\n */\r\nexport class Metadata {\r\n    private static readonly mMetadataMapping: Dictionary<DecoratorMetadataObject, ConstructorMetadata> = new Dictionary<DecoratorMetadataObject, ConstructorMetadata>();\r\n\r\n    /**\r\n     * AtScript.\r\n     * Add metadata to class, method, accessor or property\r\n     * \r\n     * @param pMetadataKey - Key of metadata.\r\n     * @param pMetadataValue - Value of metadata.\r\n     */\r\n    public static add<TThis extends object, TValue = any>(pMetadataKey: string, pMetadataValue: TValue) {\r\n        return (_pOriginalTarget: any, pContext: AllClassDecoratorContext<InjectionConstructor<TThis>>): void => {\r\n            // Get metadata object for constructor.\r\n            const lConstructorMetadata: ConstructorMetadata = Metadata.forInternalDecorator(pContext.metadata);\r\n\r\n            // Set for any kind.\r\n            switch (pContext.kind) {\r\n                case 'class':\r\n                    lConstructorMetadata.setMetadata(pMetadataKey, pMetadataValue);\r\n                    return;\r\n                case 'method':\r\n                case 'field':\r\n                case 'getter':\r\n                case 'setter':\r\n                case 'accessor':\r\n                    // Metadata is not allowed for statics.\r\n                    if (pContext.static) {\r\n                        throw new Error(`@Metadata.add not supported for statics.`);\r\n                    }\r\n\r\n                    lConstructorMetadata.getProperty(pContext.name).setMetadata(pMetadataKey, pMetadataValue);\r\n                    return;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Initialize metadata.\r\n     * \r\n     * @param pMetadataObject - Metadata object.\r\n     */\r\n    public static forInternalDecorator(pMetadataObject: DecoratorMetadataObject): ConstructorMetadata {\r\n        return Metadata.mapMetadata(pMetadataObject);\r\n    }\r\n\r\n    /**\r\n     * Get metadata of constructor.\r\n     * \r\n     * @param pTarget - Constructor or decorator metadata object.\r\n     * \r\n     * @returns constructor metadata object of constructor.\r\n     * \r\n     * @example Adding a new and existing key.\r\n     * ```TypeScript\r\n     * @Injector.Metadata('key', 'value')\r\n     * class Foo {\r\n     *     @Injector.Metadata('key', 'value')\r\n     *     public prop: number;\r\n     * }\r\n     * \r\n     * const constructorMeta = Metadata.get(Foo).getMetadata('key');\r\n     * const propertyMeta = Metadata.get(Foo).getProperty('prop').getMetadata('key');\r\n     * ```\r\n     */\r\n    public static get(pTarget: InjectionConstructor): ConstructorMetadata {\r\n        // Check if constructor has a decorator metadata.\r\n        if (!Object.hasOwn(pTarget, Symbol.metadata)) {\r\n            Metadata.polyfillMissingMetadata(pTarget);\r\n        }\r\n\r\n        // Read metadata object for constructor.\r\n        const lDecoratorMetadataObject: DecoratorMetadataObject = pTarget[Symbol.metadata]!;\r\n\r\n        // Get or create constructor metadata instance.\r\n        return Metadata.mapMetadata(lDecoratorMetadataObject);\r\n    }\r\n\r\n    /**\r\n     * AtScript.\r\n     * Init metadata to class, method, accessor or property\r\n     * \r\n     * @param _pOriginalTarget - Unused. original decorator target.\r\n     * @param pContext - Decorator context\r\n     */\r\n    public static init() {\r\n        return (_pOriginalTarget: any, pContext: ClassDecoratorContext): void => {\r\n            Metadata.forInternalDecorator(pContext.metadata);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Maps a given decorator metadata object to a constructor metadata object.\r\n     * If the metadata object is already mapped, the existing constructor metadata is returned.\r\n     * Otherwise, a new constructor metadata object is created, mapped, and returned.\r\n     *\r\n     * @param pMetadataObject - The decorator metadata object to be mapped.\r\n     * @returns The corresponding constructor metadata object.\r\n     */\r\n    private static mapMetadata(pMetadataObject: DecoratorMetadataObject): ConstructorMetadata {\r\n        // Check if metadata object is already mapped.\r\n        if (Metadata.mMetadataMapping.has(pMetadataObject)) {\r\n            return Metadata.mMetadataMapping.get(pMetadataObject)!;\r\n        }\r\n\r\n        // Create new constructor metadata object from decorator metadata.\r\n        const lConstructorMetadata: ConstructorMetadata = new ConstructorMetadata(pMetadataObject);\r\n\r\n        // Map metadata object to constructor metadata.\r\n        Metadata.mMetadataMapping.set(pMetadataObject, lConstructorMetadata);\r\n\r\n        return lConstructorMetadata;\r\n    }\r\n\r\n    /**\r\n     * Ensures that all constructors in the inheritance chain have a metadata object.\r\n     * If a constructor does not have a metadata object, it creates one and sets its prototype\r\n     * to the metadata object of its parent constructor.\r\n     *\r\n     * @param pConstructor - The constructor to start the inheritance chain from.\r\n     */\r\n    private static polyfillMissingMetadata(pConstructor: InjectionConstructor): void {\r\n        const lInheritanceChain: Array<InjectionConstructor> = new Array<InjectionConstructor>();\r\n\r\n        // Read all constructors in inheritance chain.\r\n        let lCurrentConstructor: InjectionConstructor = pConstructor;\r\n        do {\r\n            // Save constructor in inheritance chain.\r\n            lInheritanceChain.push(lCurrentConstructor);\r\n\r\n            // Read next metadata object.\r\n            lCurrentConstructor = Object.getPrototypeOf(lCurrentConstructor);\r\n        } while (lCurrentConstructor !== null);\r\n\r\n        // Move inheritance chain backwards and chain metadata objects with prototypes.\r\n        for (let lIndex = lInheritanceChain.length - 1; lIndex >= 0; lIndex--) {\r\n            const lConstructor = lInheritanceChain[lIndex];\r\n\r\n            // When not metadata object is set, create one.\r\n            if (!Object.hasOwn(lConstructor, Symbol.metadata)) {\r\n                // When constructor has a parent set it as prototype.\r\n                let lPrototype: object | null = null;\r\n                if (lIndex < lInheritanceChain.length - 2) {\r\n                    const lParentConstructor: InjectionConstructor = lInheritanceChain[lIndex + 1];\r\n\r\n                    // It must have an own metadata.\r\n                    lPrototype = lParentConstructor[Symbol.metadata];\r\n                }\r\n\r\n                // Create new metadata object with the potential parent metadata as prototype.\r\n                lConstructor[Symbol.metadata] = Object.create(lPrototype, {});\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\ntype AllClassDecoratorContext<TThis extends InjectionConstructor = InjectionConstructor> =\r\n    | ClassDecoratorContext<TThis>\r\n    | ClassMethodDecoratorContext<InjectionInstance<TThis>>\r\n    | ClassGetterDecoratorContext<InjectionInstance<TThis>>\r\n    | ClassSetterDecoratorContext<InjectionInstance<TThis>>\r\n    | ClassFieldDecoratorContext<InjectionInstance<TThis>>\r\n    | ClassAccessorDecoratorContext<InjectionInstance<TThis>>;\r\n\r\n", "import { Dictionary, Exception } from '@kartoffelgames/core';\r\nimport type { ConstructorMetadata } from '../metadata/constructor-metadata.ts';\r\nimport { Metadata } from '../metadata/metadata.ts';\r\nimport type { InjectionConstructor } from '../type.ts';\r\n\r\n/**\r\n * Injection configuration and creator.\r\n * Handes global injection configuration for replaced injections and creates new instances from injectable classes.\r\n * \r\n * @public \r\n */\r\nexport class Injection {\r\n    private static mCurrentInjectionContext: InjectionContext | null = null;\r\n    private static readonly mInjectMode: Dictionary<InjectionIdentification, InjectMode> = new Dictionary<InjectionIdentification, InjectMode>();\r\n    private static readonly mInjectableConstructor: Dictionary<InjectionIdentification, InjectionConstructor> = new Dictionary<InjectionIdentification, InjectionConstructor>();\r\n    private static readonly mInjectableReplacement: Dictionary<InjectionIdentification, InjectionConstructor> = new Dictionary<InjectionIdentification, InjectionConstructor>();\r\n    private static readonly mInjectionConstructorIdentificationMetadataKey: symbol = Symbol('InjectionConstructorIdentification');\r\n    private static readonly mSingletonMapping: Dictionary<InjectionIdentification, object> = new Dictionary<InjectionIdentification, object>();\r\n\r\n    /**\r\n     * Create object and auto inject parameter. Replaces parameter set by {@link replaceInjectable}.\r\n     * \r\n     * @remarks\r\n     * Instancing configuration is set on {@link Injector.Injectable} or {@link Injector.InjectableSingleton} decorators.\r\n     * \r\n     * @param pConstructor - Constructor that should be created.\r\n     * @param pLocalInjections - [Optional] Type objects pairs that replaces parameter with given type.\r\n     *                           Does not inject those types any further into create object of parameters.\r\n     * @param pForceCreate - [Optional] Force create new objects. Ignores the singleton injection restriction and creates a new object.\r\n     *                       Has no effect on none singleton injections.\r\n     * \r\n     * @throws {@link Exception}\r\n     * When either the {@link pConstructor} is not injectable or any of its parameter fails to construct.\r\n     * Construction of parameters fail when they are not registered or an error occurred on construction. \r\n     * \r\n     * @example Adding a new and existing key.\r\n     * ```TypeScript\r\n     * @Injector.Injectable\r\n     * class Foo {}\r\n     * \r\n     * @Injector.InjectableSingleton\r\n     * class Bar {}\r\n     * \r\n     * const instance = Injection.createObject(Foo);\r\n     * const singleton = Injection.createObject(Bar);\r\n     * ```\r\n     * \r\n     * @returns a singleton or new instance of {@link pConstructor} based on it set injection configuration.\r\n     */\r\n    public static createObject<T extends object>(pConstructor: InjectionConstructor<T>, pForceCreate?: boolean): T;\r\n    public static createObject<T extends object>(pConstructor: InjectionConstructor<T>, pLocalInjections?: Dictionary<InjectionConstructor, any>): T;\r\n    public static createObject<T extends object>(pConstructor: InjectionConstructor<T>, pForceCreate?: boolean, pLocalInjections?: Dictionary<InjectionConstructor, any>): T;\r\n    public static createObject<T extends object>(pConstructor: InjectionConstructor<T>, pForceCreateOrLocalInjections?: boolean | Dictionary<InjectionConstructor, any>, pLocalInjections?: Dictionary<InjectionConstructor, any>): T {\r\n        // Decide between local injection or force creation parameter.\r\n        const [lForceCreate, lLocalInjectionConstructors] = (() => {\r\n            if (typeof pForceCreateOrLocalInjections === 'object' && pForceCreateOrLocalInjections !== null) {\r\n                return [false, pForceCreateOrLocalInjections];\r\n            }\r\n\r\n            return [!!pForceCreateOrLocalInjections, pLocalInjections ?? new Dictionary<InjectionConstructor, any>()];\r\n        })();\r\n\r\n        // Find identifier for constructor and check if it is registered.\r\n        const lConstructorIdentification: InjectionIdentification = Injection.getInjectionIdentification(pConstructor);\r\n        if (!Injection.mInjectableConstructor.has(lConstructorIdentification)) {\r\n            throw new Exception(`Constructor \"${pConstructor.name}\" is not registered for injection and can not be built`, Injection);\r\n        }\r\n\r\n        // Get injection mode. Allways defaultsa to instanced, when force created.\r\n        const lInjectionMode: InjectMode = !lForceCreate ? Injection.mInjectMode.get(lConstructorIdentification)! : 'instanced';\r\n\r\n        // Convert local injections from constructor to identification.\r\n        const lLocalInjections: Dictionary<InjectionIdentification, any> = new Dictionary<InjectionIdentification, any>(\r\n            // Convert [constructor, object] pair to an [identification, object] pair.\r\n            lLocalInjectionConstructors.map((pKey, pValue) => [Injection.getInjectionIdentification(pKey), pValue])\r\n        );\r\n\r\n        // Save old injection context.\r\n        const lOldInjectionContext: InjectionContext | null = Injection.mCurrentInjectionContext;\r\n\r\n        // Merge new local injection context with old one.\r\n        const lNewLocalInjection: Dictionary<InjectionIdentification, any> = new Dictionary<InjectionIdentification, any>([\r\n            ...(lOldInjectionContext?.localInjections.entries() ?? []),\r\n            ...lLocalInjections.entries()\r\n        ]);\r\n\r\n        // Set new injection context.\r\n        Injection.mCurrentInjectionContext = {\r\n            injectionMode: lInjectionMode,\r\n            localInjections: lNewLocalInjection\r\n        };\r\n\r\n        try {\r\n            // Return cached singleton object if not forced to create a new one.\r\n            if (!lForceCreate && lInjectionMode === 'singleton' && Injection.mSingletonMapping.has(lConstructorIdentification)) {\r\n                return <T>Injection.mSingletonMapping.get(lConstructorIdentification);\r\n            }\r\n\r\n            // Create object. The usage of Injection.use() handles the actual type injection.\r\n            const lCreatedObject: T = <T>new pConstructor();\r\n\r\n            // Cache singleton objects but only if not forced to create.\r\n            if (lInjectionMode === 'singleton' && !Injection.mSingletonMapping.has(lConstructorIdentification)) {\r\n                Injection.mSingletonMapping.add(lConstructorIdentification, lCreatedObject);\r\n            }\r\n\r\n            // Return created object.\r\n            return lCreatedObject;\r\n        } finally {\r\n            // Reset old injection context.\r\n            Injection.mCurrentInjectionContext = lOldInjectionContext;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * AtScript.\r\n     * Mark class to be injectable\r\n     * \r\n     * @param pMode - Injection mode.\r\n     */\r\n    public static injectable(pMode: InjectMode = 'instanced') {\r\n        return (pOriginalClass: InjectionConstructor, pContext: ClassDecoratorContext): void => {\r\n            Injection.registerInjectable(pOriginalClass, pContext.metadata, pMode);\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Register an constructor for injection.\r\n     * Must be used inside an decorator, otherway an metadata missmatch could occur. \r\n     * \r\n     * @remarks\r\n     * Any constructor can be registred but only constructors that have a attached decorator of any kind are able to be injected.\r\n     * \r\n     * @param pConstructor - Constructor that can be injected.\r\n     * @param pMode - Mode of injection.\r\n     */\r\n    public static registerInjectable(pConstructor: InjectionConstructor, pMetaDataObject: DecoratorMetadataObject, pMode: InjectMode): void {\r\n        // Get unique identification for constructor.\r\n        const lConstructorIdentification: InjectionIdentification = Injection.getInjectionIdentification(pConstructor, pMetaDataObject);\r\n\r\n        // Map constructor.\r\n        Injection.mInjectableConstructor.add(lConstructorIdentification, pConstructor);\r\n        Injection.mInjectMode.add(lConstructorIdentification, pMode);\r\n    }\r\n\r\n    /**\r\n     * Replaces an constructor so instead of the original, the replacement gets injected.\r\n     * Both constructors must be registered with {@link registerInjectable}.\r\n     * \r\n     * @param pOriginalConstructor - Original constructor that should be replaced.\r\n     * @param pReplacementConstructor - Replacement constructor that gets injected instead of original constructor.\r\n     * \r\n     * @throws {@link Exception}\r\n     * When a constructor is not registed with {@link registerInjectable}.\r\n     */\r\n    public static replaceInjectable(pOriginalConstructor: InjectionConstructor, pReplacementConstructor: InjectionConstructor): void {\r\n        // Find original registered original.\r\n        const lOriginalIdentification: InjectionIdentification = Injection.getInjectionIdentification(pOriginalConstructor);\r\n        if (!Injection.mInjectableConstructor.has(lOriginalIdentification)) {\r\n            throw new Exception('Original constructor is not registered.', Injection);\r\n        }\r\n\r\n        // Find replacement registered original.\r\n        const lReplacementIdentification: InjectionIdentification = Injection.getInjectionIdentification(pReplacementConstructor);\r\n        if (!Injection.mInjectableConstructor.has(lReplacementIdentification)) {\r\n            throw new Exception('Replacement constructor is not registered.', Injection);\r\n        }\r\n\r\n        // Register replacement.\r\n        Injection.mInjectableReplacement.set(lOriginalIdentification, pReplacementConstructor);\r\n    }\r\n\r\n    /**\r\n     * Use a type as injection target.\r\n     * \r\n     * @param pConstructor - Constructor that should be injected.\r\n     * \r\n     * @returns new instance of {@link pConstructor}. \r\n     * \r\n     * @example Adding a new and existing key.\r\n     * ```TypeScript\r\n     * @Injector.Injectable\r\n     * class Foo {}\r\n     * \r\n     * @Injector.Injectable\r\n     * class Bar { public constructor(pFoo = Injection.use(Foo)) {} }\r\n     * ```\r\n     */\r\n    public static use<T extends object>(pConstructor: InjectionConstructor<T>): T {\r\n        // Restrict usage to an active injection context.\r\n        if (Injection.mCurrentInjectionContext === null) {\r\n            throw new Exception(`Can't create object outside of an injection context.`, Injection);\r\n        }\r\n\r\n        // Get unique identification for constructor.\r\n        const lConstructorIdentification: InjectionIdentification = Injection.getInjectionIdentification(pConstructor);\r\n\r\n        // If a replacement in the current injection context is found, use it.\r\n        if (Injection.mCurrentInjectionContext.injectionMode !== 'singleton' && Injection.mCurrentInjectionContext.localInjections.has(lConstructorIdentification)) {\r\n            return Injection.mCurrentInjectionContext.localInjections.get(lConstructorIdentification);\r\n        }\r\n\r\n        // Read injection from replacement context.\r\n        let lConstructor: InjectionConstructor<T> | null = Injection.mInjectableReplacement.get(lConstructorIdentification) as InjectionConstructor<T>;\r\n\r\n        // When no constructor was found, try to find it in global context.\r\n        if (!lConstructor) {\r\n            lConstructor = Injection.mInjectableConstructor.get(lConstructorIdentification) as InjectionConstructor<T>;\r\n        }\r\n\r\n        // Throw exception when constructor is not registered.\r\n        if (!lConstructor) {\r\n            throw new Exception(`Constructor \"${pConstructor.name}\" is not registered for injection and can not be built`, Injection);\r\n        }\r\n\r\n        // Create object.\r\n        return Injection.createObject<T>(lConstructor);\r\n    }\r\n\r\n    /**\r\n     * Get a unique identification for a constructor.\r\n     * When a constructor is replaced by a decorator, all constructors should have the same identification.\r\n     * \r\n     * @param pConstructor - Constructor.\r\n     * \r\n     * @returns unique identification for constructor. \r\n     */\r\n    private static getInjectionIdentification(pConstructor: InjectionConstructor, pMetadata?: DecoratorMetadataObject): InjectionIdentification {\r\n        // Read the constructor metadata.\r\n        const lConstructorMetadata: ConstructorMetadata = !!pMetadata ? Metadata.forInternalDecorator(pMetadata) : Metadata.get(pConstructor);\r\n\r\n        // Read metadata from constructor.\r\n        let lIdentification: InjectionIdentification | null = lConstructorMetadata.getMetadata(Injection.mInjectionConstructorIdentificationMetadataKey);\r\n\r\n        // Create new metadata object and assign it to decorator metadata.\r\n        if (!lIdentification) {\r\n            lIdentification = Symbol(pConstructor.name);\r\n            lConstructorMetadata.setMetadata(Injection.mInjectionConstructorIdentificationMetadataKey, lIdentification);\r\n        }\r\n\r\n        return lIdentification;\r\n    }\r\n}\r\n\r\ntype InjectionIdentification = symbol;\r\n\r\ntype InjectionContext = {\r\n    injectionMode: InjectMode,\r\n    localInjections: Dictionary<InjectionIdentification, any>,\r\n};\r\n\r\nexport type InjectMode = 'singleton' | 'instanced';", "import { Exception, type IVoidParameterConstructor } from '@kartoffelgames/core';\r\nimport { Metadata } from '@kartoffelgames/core-dependency-injection';\r\n\r\n/**\r\n * Singleton. Table layout and settings.\r\n */\r\nexport class WebDatabaseTableLayout {\r\n    public static readonly METADATA_KEY: symbol = Symbol('WebDatabaseTableLayoutMetadataKey');\r\n\r\n    /**\r\n     * Get table configuration of type.\r\n     * \r\n     * @param pType - Table type.\r\n     * \r\n     * @returns table type config. \r\n     */\r\n    public static configOf(pType: TableType): WebDatabaseTableLayout {\r\n        // Read table config from metadata.\r\n        const lTableLayout: WebDatabaseTableLayout | null = Metadata.get(pType).getMetadata(WebDatabaseTableLayout.METADATA_KEY);\r\n\r\n        // Table type is not initialized.\r\n        if (!lTableLayout) {\r\n            throw new Exception('Table type not defined.', this);\r\n        }\r\n\r\n        return lTableLayout;\r\n    }\r\n\r\n    private mTableName: string | null;\r\n    private readonly mFields: Set<string>;\r\n    private mIdentity: TableLayoutIdentity | null;\r\n    private readonly mIndices: Map<string, TableLayoutIndex>;\r\n\r\n    /**\r\n     * Get table field names.\r\n     */\r\n    public get fields(): Array<string> {\r\n        // Restrict access when no table name is set.\r\n        if (!this.mTableName) {\r\n            throw new Exception('Webdatabase field defined but the Table was not initialized with a name.', this);\r\n        }\r\n\r\n        return Array.from(this.mFields.values());\r\n    }\r\n\r\n    /**\r\n     * Get all indices of the table type.\r\n     */\r\n    public get identity(): TableLayoutIdentity {\r\n        // Restrict access when no table name is set.\r\n        if (!this.mTableName) {\r\n            throw new Exception('Webdatabase field defined but the Table was not initialized with a name.', this);\r\n        }\r\n\r\n        // Return a default identity when no identity is set.\r\n        if (!this.mIdentity) {\r\n            return {\r\n                key: '__ID__',\r\n                autoIncrement: true\r\n            };\r\n        }\r\n\r\n        return this.mIdentity;\r\n    }\r\n\r\n    /**\r\n     * Get all indices of the table type.\r\n     */\r\n    public get indices(): Array<string> {\r\n        // Restrict access when no table name is set.\r\n        if (!this.mTableName) {\r\n            throw new Exception('Webdatabase field defined but the Table was not initialized with a name.', this);\r\n        }\r\n\r\n        return Array.from(this.mIndices.keys());\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mTableName = null;\r\n        this.mIdentity = null;\r\n        this.mIndices = new Map<string, TableLayoutIndex>();\r\n        this.mFields = new Set<string>();\r\n    }\r\n\r\n    /**\r\n     * Get table type index by name.\r\n     * \r\n     * @param pName - Index name.\r\n     * \r\n     * @returns Table type index or undefined when not found.\r\n     */\r\n    public index(pName: string): TableLayoutIndex | undefined {\r\n        // Restrict access when no table name is set.\r\n        if (!this.mTableName) {\r\n            throw new Exception('Webdatabase field defined but the Table was not initialized with a name.', this);\r\n        }\r\n\r\n        return this.mIndices.get(pName);\r\n    }\r\n\r\n    /**\r\n     * Set table type identity.\r\n     * \r\n     * @param pType - Table type.\r\n     * @param pKey - Key of identity.\r\n     * @param pAutoIncrement - Autoincrement identity.\r\n     * \r\n     * @throws {@link Exception} - When a identitfier for this type is already set.\r\n     */\r\n    public setTableIdentity(pKey: string, pAutoIncrement: boolean): void {\r\n        // Read table config and restrict to one identity.\r\n        if (this.mIdentity) {\r\n            throw new Exception(`A table type can only have one identifier.`, this);\r\n        }\r\n\r\n        // Set table type identity.\r\n        this.mIdentity = {\r\n            key: pKey,\r\n            autoIncrement: pAutoIncrement,\r\n        };\r\n\r\n        // Add property key to field list.\r\n        this.mFields.add(pKey);\r\n    }\r\n\r\n    /**\r\n     * Set table type identity.\r\n     * \r\n     * @param pType - Table type.\r\n     * @param pPropertyKey - Property key of identity.\r\n     * @param pIndexName - Index name.\r\n     * @param pIsArray - Property is key.\r\n     * @param pIsUnique - Index should be unique.\r\n     */\r\n    public setTableField(pPropertyKey: string, pIndexName?: string, pIsUnique: boolean = false, pMultiEnty: boolean = false): void {\r\n        // add property key to field list.\r\n        this.mFields.add(pPropertyKey);\r\n\r\n        // Skip index creation when no index name is set.\r\n        if (!pIndexName) {\r\n            return;\r\n        }\r\n\r\n        // Initialize index.\r\n        let lIndexConfig: TableLayoutIndex | undefined = this.mIndices.get(pIndexName);\r\n        if (!lIndexConfig) {\r\n            // Set default configuration where anything is enabled.\r\n            lIndexConfig = {\r\n                name: pIndexName,\r\n                keys: new Array<string>() as [string],\r\n                unique: true,\r\n                type: pMultiEnty ? 'multiEntryIndex' : 'index',\r\n            };\r\n\r\n            // Link index to table config.\r\n            this.mIndices.set(pIndexName, lIndexConfig);\r\n        }\r\n\r\n        // Add key to index.\r\n        lIndexConfig.keys.push(pPropertyKey);\r\n\r\n        // Disable multientity when key is not a array or more than one key is set for the same index.\r\n        if (lIndexConfig.keys.length > 1 && lIndexConfig.type === 'multiEntryIndex') {\r\n            throw new Exception(`Multientity index can only have one key.`, this);\r\n        }\r\n\r\n        // Upgrade index type when more than one key is set.\r\n        if (lIndexConfig.keys.length > 1) {\r\n            lIndexConfig.type = 'compoundIndex';\r\n        }\r\n\r\n        // Index is not unique when one index is not unique.\r\n        if (!pIsUnique) {\r\n            lIndexConfig.unique = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set table name.\r\n     */\r\n    public setTableName(pName: string): void {\r\n        if (this.mTableName) {\r\n            throw new Exception('Table name can only be set once.', this);\r\n        }\r\n        this.mTableName = pName;\r\n    }\r\n}\r\n\r\nexport type TableLayoutIndex = {\r\n    name: string;\r\n    keys: [string];\r\n    unique: boolean;\r\n    type: 'index' | 'multiEntryIndex';\r\n} | {\r\n    name: string;\r\n    keys: Array<string>;\r\n    unique: boolean;\r\n    type: 'compoundIndex';\r\n};\r\n\r\nexport type TableLayoutIdentity = {\r\n    key: string;\r\n    autoIncrement: boolean;\r\n};\r\n\r\nexport type TableType = IVoidParameterConstructor<object>;", "import type { TableType } from '../web-database-table-layout.ts';\r\nimport type { WebDatabaseQuery } from './web-database-query.ts';\r\n\r\nexport class WebDatabaseQueryAction<TTableType extends TableType> {\r\n    private readonly mActionCallback: WebDatabaseQueryActionCallback;\r\n    private readonly mDatabaseQuery: WebDatabaseQuery<TTableType>;\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pActionCallback - Callback to send back action of query.\r\n     * @param pQuery - Parent query.\r\n     */\r\n    public constructor(pQuery: WebDatabaseQuery<TTableType>, pActionCallback: WebDatabaseQueryActionCallback) {\r\n        this.mActionCallback = pActionCallback;\r\n        this.mDatabaseQuery = pQuery;\r\n    }\r\n\r\n    /**\r\n     * Request rows with the value between lower and upper value.\r\n     * \r\n     * @param pLowerValue - Lower value.\r\n     * @param pUpperValue - Upper value.\r\n     * \r\n     * @returns query. \r\n     */\r\n    public between(pLowerValue: WebDatabaseQueryActionValue, pUpperValue: WebDatabaseQueryActionValue): WebDatabaseQuery<TTableType> {\r\n        // Create database range action.\r\n        const lAction: IDBKeyRange = IDBKeyRange.bound(pLowerValue, pUpperValue, false, false);\r\n\r\n        // Send action to parent query.\r\n        this.mActionCallback(lAction);\r\n\r\n        // Return parent query to chain another.\r\n        return this.mDatabaseQuery;\r\n    }\r\n\r\n    /**\r\n     * Request rows with the value greather than {@link pValue}.\r\n     * \r\n     * @param pValue - Value.\r\n     * \r\n     * @returns query. \r\n     */\r\n    public greaterThan(pValue: WebDatabaseQueryActionValue): WebDatabaseQuery<TTableType> {\r\n        // Create database range action.\r\n        const lAction: IDBKeyRange = IDBKeyRange.lowerBound(pValue, false);\r\n\r\n        // Send action to parent query.\r\n        this.mActionCallback(lAction);\r\n\r\n        // Return parent query to chain another.\r\n        return this.mDatabaseQuery;\r\n    }\r\n\r\n    /**\r\n     * Request rows with the exact value.\r\n     * \r\n     * @param pValue - Value.\r\n     * \r\n     * @returns query. \r\n     */\r\n    public is(pValue: WebDatabaseQueryActionValue): WebDatabaseQuery<TTableType> {\r\n        // Create database range action.\r\n        const lAction: IDBKeyRange = IDBKeyRange.only(pValue);\r\n\r\n        // Send action to parent query.\r\n        this.mActionCallback(lAction);\r\n\r\n        // Return parent query to chain another.\r\n        return this.mDatabaseQuery;\r\n    }\r\n\r\n    /**\r\n     * Request rows with the value lower than {@link pValue}.\r\n     * \r\n     * @param pValue - Value.\r\n     * \r\n     * @returns query. \r\n     */\r\n    public lowerThan(pValue: WebDatabaseQueryActionValue): WebDatabaseQuery<TTableType> {\r\n        // Create database range action.\r\n        const lAction: IDBKeyRange = IDBKeyRange.upperBound(pValue, false);\r\n\r\n        // Send action to parent query.\r\n        this.mActionCallback(lAction);\r\n\r\n        // Return parent query to chain another.\r\n        return this.mDatabaseQuery;\r\n    }\r\n}\r\n\r\ntype WebDatabaseQueryActionValue = number | string | Array<number | string>;\r\ntype WebDatabaseQueryActionCallback = (pAction: IDBKeyRange) => void;", "import { Dictionary, Exception } from '@kartoffelgames/core';\r\nimport type { TableType } from '../web-database-table-layout.ts';\r\nimport type { WebDatabaseTable } from '../web-database-table.ts';\r\nimport { WebDatabaseQueryAction } from './web-database-query-action.ts';\r\n\r\nexport class WebDatabaseQuery<TTableType extends TableType> {\r\n    private readonly mQueryList: Array<WebDatabaseQueryPart>;\r\n    private readonly mTable: WebDatabaseTable<TTableType>;\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pTable - Table of query.\r\n     */\r\n    public constructor(pTable: WebDatabaseTable<TTableType>) {\r\n        this.mTable = pTable;\r\n        this.mQueryList = new Array<WebDatabaseQueryPart>();\r\n    }\r\n\r\n    /**\r\n     * Chain database query with \"AND\".\r\n     * \r\n     * @param pIndexOrPropertyName - A index or a property name.\r\n     *  \r\n     * @returns query action. \r\n     */\r\n    public and(pIndexOrPropertyName: string): WebDatabaseQueryAction<TTableType> {\r\n        // Create query part.\r\n        const lPart: WebDatabaseQueryPart = {\r\n            indexKey: pIndexOrPropertyName,\r\n            action: null,\r\n            link: 'AND'\r\n        };\r\n\r\n        // Add part to query list.\r\n        this.mQueryList.push(lPart);\r\n\r\n        // Create query action that sets the action on a chained call.\r\n        return new WebDatabaseQueryAction(this, (pAction) => {\r\n            lPart.action = pAction;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Execute query and get all values.\r\n     * \r\n     * @returns filtered query result. \r\n     */\r\n    public async execute(): Promise<Array<InstanceType<TTableType>>> {\r\n        // Must have queries.\r\n        if (this.mQueryList.length === 0) {\r\n            throw new Exception('No queries specified.', this);\r\n        }\r\n\r\n        // Devide queries into \"AND\" blocks.\r\n        const lQueryBlockList: Array<Array<WebDatabaseQueryPart>> = new Array<Array<WebDatabaseQueryPart>>();\r\n\r\n        // Add first block.\r\n        lQueryBlockList.push(new Array<WebDatabaseQueryPart>());\r\n\r\n        // Assign every query into a block.\r\n        for (const lQuery of this.mQueryList) {\r\n            // Create new block on any or chain.\r\n            if (lQuery.link === 'OR') {\r\n                lQueryBlockList.push(new Array<WebDatabaseQueryPart>());\r\n            }\r\n\r\n            // Add query to latest block.\r\n            lQueryBlockList.at(-1)!.push(lQuery);\r\n        }\r\n\r\n        // Special solution for single query single block queries.\r\n        // Not neet to filter or merge.\r\n        if (lQueryBlockList.length === 1 && lQueryBlockList[0].length === 1) {\r\n            // Read and convert single block.\r\n            return this.mTable.parseToType(await this.readQuery(lQueryBlockList[0][0]));\r\n        }\r\n\r\n        // Special solution for single block queries.\r\n        // No need to merge.\r\n        if (lQueryBlockList.length === 1) {\r\n            const lQueryResult: Dictionary<string | number, any> = await this.readQueryBlock(lQueryBlockList[0]);\r\n\r\n            // Read and convert single block.\r\n            return this.mTable.parseToType(lQueryResult.values());\r\n        }\r\n\r\n        // Read all query blocks.\r\n        const lQueryBlockResultList: Set<Dictionary<string | number, any>> = new Set<Dictionary<string | number, any>>();\r\n        for (const lQueryBlock of lQueryBlockList) {\r\n            lQueryBlockResultList.add(await this.readQueryBlock(lQueryBlock));\r\n        }\r\n\r\n        // Find the greatest result set and use it as starting point.\r\n        // Greater performance when you only need to merge 1 entry in a set of 100 instead.\r\n        let lGreatestResultSet: Dictionary<string | number, any> = <any>null; // Will be set after the loop.\r\n        for (const lQueryBlockResult of lQueryBlockResultList) {\r\n            if (!lGreatestResultSet) {\r\n                lGreatestResultSet = lQueryBlockResult;\r\n                continue;\r\n            }\r\n\r\n            if (lGreatestResultSet.size < lQueryBlockResult.size) {\r\n                lGreatestResultSet = lQueryBlockResult;\r\n            }\r\n        }\r\n\r\n        // Remove the found set from iterator list.\r\n        lQueryBlockResultList.delete(lGreatestResultSet!);\r\n\r\n        // Merge remaining block result into.\r\n        for (const lQueryBlockResult of lQueryBlockResultList) {\r\n            for (const lQueryResultItem of lQueryBlockResult) {\r\n                lGreatestResultSet.set(...lQueryResultItem);\r\n            }\r\n        }\r\n\r\n        // Convert merged block.\r\n        return this.mTable.parseToType(lGreatestResultSet.values());\r\n    }\r\n\r\n    /**\r\n     * Chain database query with \"OR\".\r\n     * \r\n     * @param pIndexOrPropertyName - A index or a property name.\r\n     *  \r\n     * @returns query action. \r\n     */\r\n    public or(pIndexOrPropertyName: string): WebDatabaseQueryAction<TTableType> {\r\n        // Create query part.\r\n        const lPart: WebDatabaseQueryPart = {\r\n            indexKey: pIndexOrPropertyName,\r\n            action: null,\r\n            link: 'OR'\r\n        };\r\n\r\n        // Add part to query list.\r\n        this.mQueryList.push(lPart);\r\n\r\n        // Create query action that sets the action on a chained call.\r\n        return new WebDatabaseQueryAction(this, (pAction) => {\r\n            lPart.action = pAction;\r\n        });\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Read data from table filtered by query.\r\n     * When query index does not exists, it uses a expensive cursor filter.\r\n     * \r\n     * @param pQuery - Query.\r\n     * \r\n     * @returns Filtered item list. \r\n     */\r\n    private async readQuery(pQuery: WebDatabaseQueryPart): Promise<Array<any>> {\r\n        // Query must have a action.\r\n        if (!pQuery.action) {\r\n            throw new Exception('Query has no assigned action.', this);\r\n        }\r\n\r\n        // Get table connection.\r\n        const lTableConnection: IDBObjectStore = this.mTable.transaction.transaction.objectStore(this.mTable.tableType.name);\r\n\r\n        // Try to find index key.\r\n        const lIndexName: string | null = (() => {\r\n            const lIndexNameList: DOMStringList = lTableConnection.indexNames;\r\n            // eslint-disable-next-line @typescript-eslint/prefer-for-of\r\n            for (let lIndexNameListIndex: number = 0; lIndexNameListIndex < lIndexNameList.length; lIndexNameListIndex++) {\r\n                const lIndexName: string = lIndexNameList[lIndexNameListIndex];\r\n                if (lIndexName === pQuery.indexKey) {\r\n                    return lIndexName;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        })();\r\n\r\n        // When index was found, use index.\r\n        if (lIndexName) {\r\n            const lIndex: IDBIndex = lTableConnection.index(lIndexName);\r\n\r\n            // Execute read request with the set query action.\r\n            const lRequest: IDBRequest<Array<any>> = lIndex.getAll(pQuery.action);\r\n            return new Promise<Array<any>>((pResolve, pReject) => {\r\n                // Reject on error.\r\n                lRequest.addEventListener('error', (pEvent) => {\r\n                    const lTarget: IDBRequest<Array<any>> = (<IDBRequest<Array<any>>>pEvent.target);\r\n                    pReject(new Exception(`Error fetching table.` + lTarget.error, this));\r\n                });\r\n\r\n                // Resolve on success.\r\n                lRequest.addEventListener('success', (pEvent) => {\r\n                    // Read event target like a shithead.\r\n                    const lTarget: IDBRequest<Array<any>> = pEvent.target as IDBRequest<Array<any>>;\r\n\r\n                    pResolve(lTarget.result);\r\n                });\r\n            });\r\n        }\r\n\r\n        // When no index was found you fucked up.\r\n        // Read anything and filter.\r\n        const lCursorRequest: IDBRequest<IDBCursorWithValue | null> = lTableConnection.openCursor();\r\n        const lFiteredList: Array<any> = new Array<any>();\r\n        return new Promise<Array<any>>((pResolve, pReject) => {\r\n            // Reject on error.\r\n            lCursorRequest.addEventListener('error', (pEvent) => {\r\n                const lTarget: IDBRequest<IDBCursorWithValue | null> = (<IDBRequest<IDBCursorWithValue | null>>pEvent.target);\r\n                pReject(new Exception(`Error fetching table.` + lTarget.error, this));\r\n            });\r\n\r\n            // Resolve on success.\r\n            lCursorRequest.addEventListener('success', (pEvent) => {\r\n                // Read event target like a shithead and resolve when cursor is eof.\r\n                const lTarget: IDBRequest<IDBCursorWithValue | null> = pEvent.target as IDBRequest<IDBCursorWithValue | null>;\r\n                const lCursorResult: IDBCursorWithValue | null = lTarget.result;\r\n                if (!lCursorResult) {\r\n                    pResolve(lFiteredList);\r\n                    return;\r\n                }\r\n\r\n                // Get value of filtered propery.\r\n                const lFiltedValue: any = lCursorResult.value[pQuery.indexKey];\r\n\r\n                // Append row when value is included in assigned action.\r\n                if (pQuery.action!.includes(lFiltedValue)) {\r\n                    lFiteredList.push(lCursorResult.value);\r\n                }\r\n\r\n                // Continue next value.\r\n                lCursorResult.continue();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Read the result of a query block.\r\n     * \r\n     * @param pBlock - Query block. Queries that are linked with an \"AND\"-Connection.\r\n     * \r\n     * return filtered query result.\r\n     */\r\n    private async readQueryBlock(pBlock: Array<WebDatabaseQueryPart>): Promise<Dictionary<string | number, any>> {\r\n        const lTableConnection: IDBObjectStore = this.mTable.transaction.transaction.objectStore(this.mTable.tableType.name);\r\n\r\n        // Read all queries in parallel.\r\n        const lQueryResultRequestList: Array<Promise<Array<any>>> = new Array<Promise<Array<any>>>();\r\n        for (const lQuery of pBlock) {\r\n            lQueryResultRequestList.push(this.readQuery(lQuery));\r\n        }\r\n\r\n        // Wait for all queries to finish.\r\n        const lQueryResultList: Array<Array<any>> = await Promise.all(lQueryResultRequestList);\r\n\r\n        // Get key of identity, identity is allways set and a single key.\r\n        const lIdentityKey: string = lTableConnection.keyPath as string;\r\n\r\n        // Conver all result list into an identity map.\r\n        const lIdentityMapList: Array<Dictionary<string | number, any>> = new Array<Dictionary<string | number, any>>();\r\n        for (const lQueryResult of lQueryResultList) {\r\n            // Map each item with its identity.\r\n            const lItemMap: Dictionary<string | number, any> = new Dictionary<string | number, any>();\r\n            for (const lItem of lQueryResult) {\r\n                lItemMap.set(lItem[lIdentityKey], lItem);\r\n            }\r\n\r\n            lIdentityMapList.push(lItemMap);\r\n        }\r\n\r\n        // Find the smallest identity set.\r\n        let lSmallestItemSet: Dictionary<string | number, any> = lIdentityMapList[0];\r\n        for (const lIdentityMap of lIdentityMapList) {\r\n            if (lIdentityMap.size < lSmallestItemSet.size) {\r\n                lSmallestItemSet = lIdentityMap;\r\n            }\r\n        }\r\n\r\n        // Remove smallest identity set from map list.\r\n        lIdentityMapList.splice(lIdentityMapList.indexOf(lSmallestItemSet), 1);\r\n\r\n        // Filter the smallest set for each remaining query.\r\n        for (const lFilteringQuery of lIdentityMapList) {\r\n            // Remove item from result list, when it does not exists in any other query result.\r\n            for (const lResultItemKey of lSmallestItemSet.keys()) {\r\n                if (!lFilteringQuery.has(lResultItemKey)) {\r\n                    lSmallestItemSet.delete(lResultItemKey);\r\n                }\r\n            }\r\n        }\r\n\r\n        return lSmallestItemSet;\r\n    }\r\n}\r\n\r\ntype WebDatabaseQueryPart = {\r\n    indexKey: string;\r\n    action: IDBKeyRange | null;\r\n    link: WebDatabaseQueryLink;\r\n};\r\n\r\ntype WebDatabaseQueryLink = 'AND' | 'OR';", "\r\nimport { Exception } from '@kartoffelgames/core';\r\nimport { type TableType, WebDatabaseTableLayout } from './web-database-table-layout.ts';\r\nimport type { WebDatabaseQueryAction } from './query/web-database-query-action.ts';\r\nimport { WebDatabaseQuery } from './query/web-database-query.ts';\r\nimport type { WebDatabaseTransaction } from './web-database-transaction.ts';\r\n\r\nexport class WebDatabaseTable<TTableType extends TableType> {\r\n    private readonly mTableType: TTableType;\r\n    private readonly mTransaction: WebDatabaseTransaction<TableType>;\r\n    private readonly mTableLayout: WebDatabaseTableLayout;\r\n\r\n    /**\r\n     * Get table type.\r\n     */\r\n    public get tableType(): TTableType {\r\n        return this.mTableType;\r\n    }\r\n\r\n    /**\r\n     * Get transaction.\r\n     */\r\n    public get transaction(): WebDatabaseTransaction<TableType> {\r\n        return this.mTransaction;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pType - Table type.\r\n     * @param pDatabase - Database.\r\n     */\r\n    public constructor(pType: TTableType, pTransaction: WebDatabaseTransaction<TableType>) {\r\n        this.mTableType = pType;\r\n        this.mTransaction = pTransaction;\r\n\r\n        // Get table layout.\r\n        this.mTableLayout = WebDatabaseTableLayout.configOf(this.mTableType);\r\n    }\r\n\r\n    /**\r\n     * Clear table data.\r\n     */\r\n    public async clear(): Promise<void> {\r\n        // Get table connection.\r\n        const lTable: IDBObjectStore = this.mTransaction.transaction.objectStore(this.mTableType.name);\r\n\r\n        // Clear data.\r\n        const lRequest: IDBRequest<undefined> = lTable.clear();\r\n\r\n        // Wait for completion.\r\n        return new Promise<void>((pResolve, pReject) => {\r\n            // Reject on error.\r\n            lRequest.addEventListener('error', (pEvent) => {\r\n                const lTarget: IDBRequest<IDBValidKey> = pEvent.target as IDBRequest<IDBValidKey>;\r\n                pReject(new Exception(`Error clearing table data.` + lTarget.error, this));\r\n            });\r\n\r\n            lRequest.addEventListener('success', () => {\r\n                pResolve();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get row count of table.\r\n     */\r\n    public async count(): Promise<number> {\r\n        // Get table connection.\r\n        const lTable: IDBObjectStore = this.mTransaction.transaction.objectStore(this.mTableType.name);\r\n\r\n        // Clear data data.\r\n        const lRequest: IDBRequest<number> = lTable.count();\r\n\r\n        // Wait for completion.\r\n        return new Promise<number>((pResolve, pReject) => {\r\n            // Reject on error.\r\n            lRequest.addEventListener('error', (pEvent) => {\r\n                const lTarget: IDBRequest<number> = (<IDBRequest<number>>pEvent.target);\r\n                pReject(new Exception(`Error counting table rows.` + lTarget.error, this));\r\n            });\r\n\r\n            // Resolve on success.\r\n            lRequest.addEventListener('success', (pEvent) => {\r\n                // Read event target like a shithead.\r\n                const lTarget: IDBRequest<number> = pEvent.target as IDBRequest<number>;\r\n\r\n                pResolve(lTarget.result);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Delete data.\r\n     * \r\n     * @param pData - Data. Must be an instance of the table type.\r\n     */\r\n    public async delete(pData: InstanceType<TTableType>): Promise<void> {\r\n        // Validate data type.\r\n        if (!(pData instanceof this.mTableType)) {\r\n            throw new Exception(`Invalid data type.`, this);\r\n        }\r\n\r\n        // Get identity value from data.\r\n        const lIdentityProperty: string = this.mTableLayout.identity.key;\r\n        const lIdentityValue: string | number = (<any>pData)[lIdentityProperty];\r\n\r\n        // Get table connection.\r\n        const lTable: IDBObjectStore = this.mTransaction.transaction.objectStore(this.mTableType.name);\r\n\r\n        // Delete data.\r\n        const lRequest: IDBRequest<undefined> = lTable.delete(lIdentityValue);\r\n\r\n        // Wait for completion.\r\n        return new Promise<void>((pResolve, pReject) => {\r\n            // Reject on error.\r\n            lRequest.addEventListener('error', (pEvent) => {\r\n                const lTarget: IDBRequest<undefined> = pEvent.target as IDBRequest<undefined>;\r\n                pReject(new Exception(`Error deleting data.` + lTarget.error, this));\r\n            });\r\n\r\n            // Resolve on success.\r\n            lRequest.addEventListener('success', () => {\r\n                pResolve();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get all table data. Can be limited by count.\r\n     */\r\n    public async getAll(pCount?: number): Promise<Array<InstanceType<TTableType>>> {\r\n        // Get table connection.\r\n        const lTable: IDBObjectStore = this.mTransaction.transaction.objectStore(this.mTableType.name);\r\n\r\n        // Clear data data.\r\n        const lRequest: IDBRequest<Array<any>> = lTable.getAll(null, pCount);\r\n\r\n        // Wait for completion.\r\n        return new Promise<Array<InstanceType<TTableType>>>((pResolve, pReject) => {\r\n            // Reject on error.\r\n            lRequest.addEventListener('error', (pEvent) => {\r\n                const lTarget: IDBRequest<number> = (<IDBRequest<number>>pEvent.target);\r\n                pReject(new Exception(`Error fetching table.` + lTarget.error, this));\r\n            });\r\n\r\n            // Resolve on success.\r\n            lRequest.addEventListener('success', (pEvent) => {\r\n                // Read event target like a shithead.\r\n                const lTarget: IDBRequest<Array<any>> = pEvent.target as IDBRequest<Array<any>>;\r\n\r\n                // Convert each item into type.\r\n                const lResult: Array<InstanceType<TTableType>> = this.parseToType(lTarget.result);\r\n\r\n                // Resolve converted data.\r\n                pResolve(lResult);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Put data.\r\n     * \r\n     * @param pData - Data. Must be an instance of the table type.\r\n     */\r\n    public async put(pData: InstanceType<TTableType>): Promise<void> {\r\n        // Validate data type.\r\n        if (!(pData instanceof this.mTableType)) {\r\n            throw new Exception(`Invalid data type.`, this);\r\n        }\r\n\r\n        // Get table connection.\r\n        const lTable: IDBObjectStore = this.mTransaction.transaction.objectStore(this.mTableType.name);\r\n\r\n        // Put data.\r\n        const lRequest: IDBRequest<IDBValidKey> = lTable.put(JSON.parse(JSON.stringify(pData, this.mTableLayout.fields)));\r\n\r\n        // Wait for completion.\r\n        return new Promise<void>((pResolve, pReject) => {\r\n            // Reject on error.\r\n            lRequest.addEventListener('error', (pEvent) => {\r\n                const lTarget: IDBRequest<IDBValidKey> = pEvent.target as IDBRequest<IDBValidKey>;\r\n                pReject(new Exception(`Error put data.` + lTarget.error, this));\r\n\r\n                \r\n            });\r\n\r\n            // Resolve on success.\r\n            lRequest.addEventListener('success', (pEvent) => {\r\n                // Read event target like a shithead.\r\n                const lTarget: IDBRequest<IDBValidKey> = pEvent.target as IDBRequest<IDBValidKey>;\r\n\r\n                // Update object with the new identity when any identity is specified.\r\n                const lIdentityProperty: string = this.mTableLayout.identity.key;\r\n                (<any>pData)[lIdentityProperty] = lTarget.result;\r\n\r\n                pResolve();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a new table query.\r\n     * \r\n     * @param pIndexOrPropertyName - A index or a property name.\r\n     * \r\n     * @returns a new chainable table query.\r\n     */\r\n    public where(pIndexOrPropertyName: string): WebDatabaseQueryAction<TTableType> {\r\n        return new WebDatabaseQuery<TTableType>(this).and(pIndexOrPropertyName);\r\n    }\r\n\r\n    /**\r\n     * Convert all data items into table type objects.\r\n     * \r\n     * @param pData - Data objects.\r\n     * \r\n     * @returns converted data list. \r\n     */\r\n    public parseToType(pData: Iterable<Record<string, any>>): Array<InstanceType<TTableType>> {\r\n        const lResultList: Array<InstanceType<TTableType>> = new Array<InstanceType<TTableType>>();\r\n\r\n        // Convert each item into type.\r\n        for (const lSourceObject of pData) {\r\n            const lTargetObject: InstanceType<TTableType> = new this.mTableType() as InstanceType<TTableType>;\r\n\r\n            for (const lKey of this.mTableLayout.fields) {\r\n                (<any>lTargetObject)[lKey] = lSourceObject[lKey];\r\n            }\r\n\r\n            lResultList.push(lTargetObject);\r\n        }\r\n\r\n        return lResultList;\r\n    }\r\n}", "import { Exception } from '@kartoffelgames/core';\r\nimport type { TableType } from './web-database-table-layout.ts';\r\nimport type { WebDatabase } from './web-database.ts';\r\nimport { WebDatabaseTable } from './web-database-table.ts';\r\n\r\nexport class WebDatabaseTransaction<TTables extends TableType> {\r\n    private readonly mDatabase: WebDatabase;\r\n    private readonly mMode: WebDbTransactionMode;\r\n    private mState: IDBTransaction | null;\r\n    private readonly mTableTypes: Set<TTables>;\r\n\r\n    /**\r\n     * Underlying transaction.\r\n     */\r\n    public get transaction(): IDBTransaction {\r\n        if (!this.mState) {\r\n            throw new Exception(`Transaction is closed. Transactions can't be used with asynchronous calls.`, this);\r\n        }\r\n\r\n        return this.mState;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pDatabase - Database-\r\n     * @param pTables - Tables of transaction.\r\n     * @param pMode - Transaction mode.\r\n     */\r\n    public constructor(pDatabase: WebDatabase, pTables: Array<TTables>, pMode: WebDbTransactionMode) {\r\n        this.mDatabase = pDatabase;\r\n        this.mTableTypes = new Set<TTables>(pTables);\r\n        this.mMode = pMode;\r\n        this.mState = null;\r\n    }\r\n\r\n    /**\r\n     * Force commit transaction.\r\n     */\r\n    public commit(): void {\r\n        if (!this.mState) {\r\n            return;\r\n        }\r\n\r\n        this.mState.commit();\r\n    }\r\n\r\n    /**\r\n     * Open the transaction.\r\n     */\r\n    public async open(): Promise<void> {\r\n        if (this.mState) {\r\n            return;\r\n        }\r\n\r\n        const lDatabaseConnection: IDBDatabase = await this.mDatabase.open();\r\n\r\n        // Convert types into names.\r\n        const lTableNames: Array<string> = Array.from(this.mTableTypes).map((pTableType: TTables) => {\r\n            return pTableType.name;\r\n        });\r\n\r\n        this.mState = lDatabaseConnection.transaction(lTableNames, this.mMode);\r\n        this.mState.addEventListener('complete', () => {\r\n            // Clear state on complete.\r\n            this.mState = null;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get table of database.\r\n     * \r\n     * @param pType - Table type.\r\n     * \r\n     * @returns Table connection. \r\n     */\r\n    public table<T extends TTables>(pType: T): WebDatabaseTable<T> {\r\n        // Table type must exists in table.\r\n        if (!this.mTableTypes.has(pType)) {\r\n            throw new Exception('Table type not set for database.', this);\r\n        }\r\n\r\n        // Create table object with attached opened db.\r\n        return new WebDatabaseTable<T>(pType, this);\r\n    }\r\n\r\n}\r\n\r\nexport type WebDbTransactionMode = 'readwrite' | 'readonly';", "import { Dictionary, Exception } from '@kartoffelgames/core';\r\nimport { WebDatabaseTableLayout, type TableLayoutIndex, type TableType } from './web-database-table-layout.ts';\r\nimport { WebDatabaseTransaction, type WebDbTransactionMode } from './web-database-transaction.ts';\r\nimport { Metadata } from \"../../../kartoffelgames.core.dependency_injection/source/metadata/metadata.ts\";\r\n\r\nexport class WebDatabase {\r\n    /**\r\n     * Set propery as table field.\r\n     * \r\n     * @param pIndexName - Index name.\r\n     * @param pUnique - Index should be unique.\r\n     * @param pMultiEntry - Index is a multi entry index. Only supported for arrays.\r\n     */\r\n    public static field(pIndexName?: string, pUnique: boolean = false, pMultiEntry: boolean = false) {\r\n        return function (_: any, pContext: WebDatabaseFieldDecoratorContext<any, any>): void {\r\n            // Decorator can not be used on static propertys.\r\n            if (pContext.static) {\r\n                throw new Exception('Index property can not be a static property.', WebDatabase);\r\n            }\r\n\r\n            // Decorator can only be attached to string named properties.\r\n            if (typeof pContext.name !== 'string') {\r\n                throw new Exception('Index name must be a string.', WebDatabase);\r\n            }\r\n\r\n            // Read metadata from metadata...\r\n            const lConstructorMetadata = Metadata.forInternalDecorator(pContext.metadata);\r\n\r\n            // Try to read table layout from metadata.\r\n            let lTableLayout: WebDatabaseTableLayout | null = lConstructorMetadata.getMetadata(WebDatabaseTableLayout.METADATA_KEY);\r\n            if (!lTableLayout) {\r\n                lTableLayout = new WebDatabaseTableLayout();\r\n            }\r\n\r\n            // Add table type index to layout.\r\n            lTableLayout.setTableField(pContext.name, pIndexName, pUnique, pMultiEntry);\r\n\r\n            // Set the table layout to the metadata.\r\n            lConstructorMetadata.setMetadata(WebDatabaseTableLayout.METADATA_KEY, lTableLayout);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Add identity to table type.\r\n     * Auto incremented identity is only supported for number types.\r\n     * \r\n     * @param pAutoIncrement - Auto incremented identity.\r\n     */\r\n    public static identity<TAutoIncrement extends true | false>(pAutoIncrement: TAutoIncrement) {\r\n        return (_pTarget: any, pContext: WebDatabaseFieldDecoratorContext<any, TAutoIncrement extends true ? number : any>): void => {\r\n            // Decorator can not be used on static propertys.\r\n            if (pContext.static) {\r\n                throw new Exception('Identity property can not be a static property.', WebDatabase);\r\n            }\r\n\r\n            // Decorator can only be attached to string named properties.\r\n            if (typeof pContext.name !== 'string') {\r\n                throw new Exception('Identity name must be a string.', WebDatabase);\r\n            }\r\n\r\n            // Read metadata from metadata...\r\n            const lConstructorMetadata = Metadata.forInternalDecorator(pContext.metadata);\r\n\r\n            // Try to read table layout from metadata.\r\n            let lTableLayout: WebDatabaseTableLayout | null = lConstructorMetadata.getMetadata(WebDatabaseTableLayout.METADATA_KEY);\r\n            if (!lTableLayout) {\r\n                lTableLayout = new WebDatabaseTableLayout();\r\n            }\r\n\r\n            // Add table type index to layout.\r\n            lTableLayout.setTableIdentity(pContext.name, pAutoIncrement);\r\n\r\n            // Set the table layout to the metadata.\r\n            lConstructorMetadata.setMetadata(WebDatabaseTableLayout.METADATA_KEY, lTableLayout);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Decorator for the database table.\r\n     * \r\n     * @param pTableName - Table name.\r\n     */\r\n    public static table(pTableName: string) {\r\n        return function (_pClassTarget: any, pContext: ClassDecoratorContext): void {\r\n            // Read metadata from metadata...\r\n            const lConstructorMetadata = Metadata.forInternalDecorator(pContext.metadata);\r\n\r\n            // Try to read table layout from metadata.\r\n            let lTableLayout: WebDatabaseTableLayout | null = lConstructorMetadata.getMetadata(WebDatabaseTableLayout.METADATA_KEY);\r\n            if (!lTableLayout) {\r\n                lTableLayout = new WebDatabaseTableLayout();\r\n            }\r\n\r\n            // Set table name.\r\n            lTableLayout.setTableName(pTableName);\r\n\r\n            // Set the table layout to the metadata.\r\n            lConstructorMetadata.setMetadata(WebDatabaseTableLayout.METADATA_KEY, lTableLayout);\r\n        };\r\n    }\r\n\r\n    private mDatabaseConnection: IDBDatabase | null;\r\n    private readonly mDatabaseName: string;\r\n    private readonly mTableTypes: Dictionary<string, TableType>;\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pName - Database name.\r\n     * @param pTables - Database tables.\r\n     */\r\n    public constructor(pName: string, pTables: Array<TableType>) {\r\n        this.mDatabaseName = pName;\r\n        this.mDatabaseConnection = null;\r\n\r\n        this.mTableTypes = new Dictionary<string, TableType>();\r\n        for (const lTableType of pTables) {\r\n            this.mTableTypes.set(lTableType.name, lTableType);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Close current database connections.\r\n     */\r\n    public close(): void {\r\n        // Skip when it is already closed.\r\n        if (this.mDatabaseConnection === null) {\r\n            return;\r\n        }\r\n\r\n        // Close and clear database connection.\r\n        this.mDatabaseConnection.close();\r\n        this.mDatabaseConnection = null;\r\n    }\r\n\r\n    /**\r\n     * Delete database and resolve on success.\r\n     */\r\n    public async delete(): Promise<void> {\r\n        const lDeleteRequest: IDBOpenDBRequest = globalThis.indexedDB.deleteDatabase(this.mDatabaseName);\r\n        return new Promise<void>((pResolve, pReject) => {\r\n            // Reject on error.\r\n            lDeleteRequest.addEventListener('error', (pEvent) => {\r\n                const lTarget: IDBOpenDBRequest = pEvent.target as IDBOpenDBRequest;\r\n\r\n                pReject(new Exception('Error deleting database. ' + lTarget.error, this));\r\n            });\r\n\r\n            // Databse delete success.\r\n            lDeleteRequest.onsuccess = () => {\r\n                pResolve();\r\n            };\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Open database connection.\r\n     * Resolve once the connection is set.\r\n     */\r\n    public async open(): Promise<IDBDatabase> {\r\n        // Dont open another connection when one is open.\r\n        if (this.mDatabaseConnection) {\r\n            return this.mDatabaseConnection;\r\n        }\r\n\r\n        // Open db with current version. Read all object stores and all indices and compare.\r\n        const lDatabaseUpdate: DatabaseUpdate = await new Promise((pResolve, pReject) => {\r\n            const lDatabaseUpdate: DatabaseUpdate = {\r\n                version: 0,\r\n                updateNeeded: false,\r\n                tableUpdates: new Array<TableUpdate>()\r\n            };\r\n\r\n            // Open database with current version.\r\n            const lOpenRequest: IDBOpenDBRequest = globalThis.indexedDB.open(this.mDatabaseName);\r\n\r\n            // Set defaults when no database exists.\r\n            lOpenRequest.addEventListener('upgradeneeded', () => {\r\n                // Empty update.\r\n            });\r\n\r\n            // Reject on block or error. \r\n            lOpenRequest.addEventListener('blocked', (pEvent) => {\r\n                pReject(new Exception(`Database locked from another tab. Unable to update from \"${pEvent.oldVersion}\" to \"${pEvent.newVersion}\"`, this));\r\n            });\r\n            lOpenRequest.addEventListener('error', (pEvent) => {\r\n                const lTarget: IDBOpenDBRequest = pEvent.target as IDBOpenDBRequest;\r\n                pReject(new Exception('Error opening database. ' + lTarget.error, this));\r\n            });\r\n\r\n            // Save open state.\r\n            lOpenRequest.addEventListener('success', (pEvent) => {\r\n                const lDatabaseConnection: IDBDatabase = (<IDBOpenDBRequest>pEvent.target).result;\r\n\r\n                // Set current loaded database version.\r\n                lDatabaseUpdate.version = lDatabaseConnection.version;\r\n\r\n                // Read current tables names and tables names that should be created.\r\n                const lCurrentTableNames: Set<string> = new Set<string>(Array.from(lDatabaseConnection.objectStoreNames));\r\n                const lUncreatedTableNames: Set<string> = new Set<string>(Array.from(this.mTableTypes.keys()));\r\n\r\n                // Check current tables. When no tables exists, skip it, so no \"Empty Transaction\"-Error is thrown.\r\n                if (lCurrentTableNames.size > 0) {\r\n                    // Open a read transaction to read current table configurations.\r\n                    const lReadTransaction: IDBTransaction = lDatabaseConnection.transaction([...lCurrentTableNames], 'readonly');\r\n\r\n                    // Read all existing databases. \r\n                    for (const lTableName of lCurrentTableNames) {\r\n                        // Mark table as deleteable when it does not exists anymore.\r\n                        if (!lUncreatedTableNames.has(lTableName)) {\r\n                            lDatabaseUpdate.tableUpdates.push({\r\n                                name: lTableName,\r\n                                action: 'delete',\r\n                                indices: []\r\n                            });\r\n                            continue;\r\n                        }\r\n\r\n                        // Read table configuration.\r\n                        const lTableLayout: WebDatabaseTableLayout = WebDatabaseTableLayout.configOf(this.mTableTypes.get(lTableName)!);\r\n\r\n                        // Open database table.\r\n                        const lTable: IDBObjectStore = lReadTransaction.objectStore(lTableName);\r\n\r\n                        // Validate correct identity, update table when it differs.\r\n                        const lConfiguratedKeyPath: string = lTableLayout.identity.key;\r\n                        const lConfiguratedAutoIncrement: boolean = lTableLayout.identity.autoIncrement;\r\n                        if (lTable.keyPath !== lConfiguratedKeyPath || lTable.autoIncrement !== lConfiguratedAutoIncrement) {\r\n                            lDatabaseUpdate.tableUpdates.push({\r\n                                name: lTableName,\r\n                                action: 'delete',\r\n                                indices: []\r\n                            });\r\n\r\n                            // Continue without deleting it from the uncreated table list, so it can be created again with the correct identity.\r\n                            continue;\r\n                        }\r\n\r\n                        // Remove table from uncreated table list, so it doesnt get created again.\r\n                        lUncreatedTableNames.delete(lTableName);\r\n\r\n                        // Read current tables indeces and tables indecies that should be created.\r\n                        const lCurrentTableIndices: Set<string> = new Set<string>(Array.from(lTable.indexNames));\r\n                        const lUncreatedTableIndices: Set<string> = new Set<string>(lTableLayout.indices);\r\n\r\n                        const lIndexUpdates: Array<IndexUpdate> = new Array<IndexUpdate>();\r\n                        for (const lIndexName of lCurrentTableIndices) {\r\n                            // Mark index as deleteable when it does not exists anymore.\r\n                            if (!lUncreatedTableIndices.has(lIndexName)) {\r\n                                lIndexUpdates.push({\r\n                                    name: lIndexName,\r\n                                    action: 'delete',\r\n                                });\r\n                                continue;\r\n                            }\r\n\r\n                            // Read current index\r\n                            const lCurrentIndex: IDBIndex = lTable.index(lIndexName);\r\n                            const lIndexConfiguration: TableLayoutIndex = lTableLayout.index(lIndexName)!;\r\n\r\n                            // Read index keys. A Compound index is already checked by creating index key.\r\n                            const lCurrentIndexKey: string = Array.isArray(lCurrentIndex.keyPath) ? lCurrentIndex.keyPath.join(',') : lCurrentIndex.keyPath;\r\n                            const lConfiguratedIndexKey: string = lIndexConfiguration.keys.join(',');\r\n\r\n                            // Configurated entry is a multi entry index.\r\n                            const lConfiguratedIsMultiEntry: boolean = lIndexConfiguration.type === 'multiEntryIndex';\r\n\r\n                            // Validate same index configuration. Delete the current index when it differs.\r\n                            if (lCurrentIndexKey !== lConfiguratedIndexKey || lCurrentIndex.multiEntry !== lConfiguratedIsMultiEntry || lCurrentIndex.unique !== lIndexConfiguration.unique) {\r\n                                lIndexUpdates.push({\r\n                                    name: lIndexName,\r\n                                    action: 'delete',\r\n                                });\r\n\r\n                                // Continue without deleting it from the uncreated index list, so it can be created again with the correct configuration.\r\n                                continue;\r\n                            }\r\n\r\n                            // Remove index from uncreated index list, so it doesnt get created again.\r\n                            lUncreatedTableIndices.delete(lIndexName);\r\n                        }\r\n\r\n                        // Create all remaing missing indices.\r\n                        for (const lIndexName of lUncreatedTableIndices) {\r\n                            lIndexUpdates.push({\r\n                                name: lIndexName,\r\n                                action: 'create',\r\n                            });\r\n                        }\r\n\r\n                        // Add index update table update when any index is not created or must be deleted.\r\n                        if (lIndexUpdates.length > 0) {\r\n                            lDatabaseUpdate.tableUpdates.push({\r\n                                name: lTableName,\r\n                                action: 'none',\r\n                                indices: lIndexUpdates\r\n                            });\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Create all remaining tables.\r\n                for (const lTableName of lUncreatedTableNames) {\r\n                    // Read table and index configuration.\r\n                    const lTableLayout: WebDatabaseTableLayout = WebDatabaseTableLayout.configOf(this.mTableTypes.get(lTableName)!);\r\n\r\n                    // Add all indices to the index update list.\r\n                    const lIndexUpdates: Array<IndexUpdate> = new Array<IndexUpdate>();\r\n                    for (const lIndexName of lTableLayout.indices) {\r\n                        lIndexUpdates.push({\r\n                            name: lIndexName,\r\n                            action: 'create',\r\n                        });\r\n                    }\r\n\r\n                    // Add create table update to database update.\r\n                    lDatabaseUpdate.tableUpdates.push({\r\n                        name: lTableName,\r\n                        action: 'create',\r\n                        indices: lIndexUpdates\r\n                    });\r\n                }\r\n\r\n                // Check for any update.\r\n                for (const lTableUpdate of lDatabaseUpdate.tableUpdates) {\r\n                    // Set database to need a update when any update should be made.\r\n                    if (lTableUpdate.action !== 'none' || lTableUpdate.indices.length > 0) {\r\n                        lDatabaseUpdate.updateNeeded = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // Close connection before resolving.\r\n                lDatabaseConnection.close();\r\n\r\n                pResolve(lDatabaseUpdate);\r\n            });\r\n        });\r\n\r\n        // Get current or next version when a update must be made.\r\n        const lDatabaseVersion: number = (lDatabaseUpdate.updateNeeded) ? lDatabaseUpdate.version + 1 : lDatabaseUpdate.version;\r\n\r\n        // Open database request.\r\n        const lOpenRequest: IDBOpenDBRequest = globalThis.indexedDB.open(this.mDatabaseName, lDatabaseVersion);\r\n        return new Promise<IDBDatabase>((pResolve, pReject) => {\r\n            // Init tables on upgradeneeded.\r\n            lOpenRequest.addEventListener('upgradeneeded', (pEvent) => {\r\n                const lTarget: IDBOpenDBRequest = pEvent.target as IDBOpenDBRequest;\r\n                const lDatabaseConnection: IDBDatabase = lTarget.result;\r\n                const lDatabaseTransaction: IDBTransaction = lTarget.transaction!;\r\n\r\n                for (const lTableUpdate of lDatabaseUpdate.tableUpdates) {\r\n                    // Delete action.\r\n                    if (lTableUpdate.action === 'delete') {\r\n                        lDatabaseConnection.deleteObjectStore(lTableUpdate.name);\r\n                        continue;\r\n                    }\r\n\r\n                    // Read table configuration.\r\n                    const lTableType: TableType = this.mTableTypes.get(lTableUpdate.name)!;\r\n                    const lTableConfiguration = WebDatabaseTableLayout.configOf(lTableType);\r\n\r\n                    // Create table with correct identity.\r\n                    if (lTableUpdate.action === 'create') {\r\n                        if (lTableConfiguration.identity) {\r\n                            lDatabaseConnection.createObjectStore(lTableUpdate.name, {\r\n                                keyPath: lTableConfiguration.identity.key,\r\n                                autoIncrement: lTableConfiguration.identity.autoIncrement\r\n                            });\r\n                        } else {\r\n                            // Create object store without an identity.\r\n                            lDatabaseConnection.createObjectStore(lTableUpdate.name);\r\n                        }\r\n                    }\r\n\r\n                    // Update indices.\r\n                    if (lTableUpdate.indices.length > 0) {\r\n                        const lTable: IDBObjectStore = lDatabaseTransaction.objectStore(lTableUpdate.name);\r\n\r\n                        // Create indices.\r\n                        for (const lIndexUpdate of lTableUpdate.indices) {\r\n                            // Index delete action.\r\n                            if (lIndexUpdate.action === 'delete') {\r\n                                lTable.deleteIndex(lIndexUpdate.name);\r\n                                continue;\r\n                            }\r\n\r\n                            // Read index configuration.\r\n                            const lIndexConfiguration: TableLayoutIndex = lTableConfiguration.index(lIndexUpdate.name)!;\r\n\r\n                            // Read single keys as string, so multientries are recognized as single key.\r\n                            const lIndexKeys: string | Array<string> = lIndexConfiguration.keys.length > 1 ? lIndexConfiguration.keys : lIndexConfiguration.keys[0];\r\n\r\n                            // Index create action.\r\n                            if (lIndexUpdate.action === 'create') {\r\n                                lTable.createIndex(lIndexUpdate.name, lIndexKeys, {\r\n                                    unique: lIndexConfiguration.unique,\r\n                                    multiEntry: lIndexConfiguration.type === 'multiEntryIndex'\r\n                                });\r\n                                continue;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            // Reject when update is blocked.\r\n            lOpenRequest.addEventListener('blocked', (pEvent) => {\r\n                pReject(new Exception(`Database locked from another tab. Unable to update from \"${pEvent.oldVersion}\" to \"${pEvent.newVersion}\"`, this));\r\n            });\r\n\r\n            // Reject on error.\r\n            lOpenRequest.addEventListener('error', (pEvent) => {\r\n                const lTarget: IDBOpenDBRequest = pEvent.target as IDBOpenDBRequest;\r\n\r\n                pReject(new Exception('Error opening database. ' + lTarget.error, this));\r\n            });\r\n\r\n            // Save open state.\r\n            lOpenRequest.addEventListener('success', (pEvent) => {\r\n                // Save and resolve\r\n                this.mDatabaseConnection = (<IDBOpenDBRequest>pEvent.target).result;\r\n                pResolve(this.mDatabaseConnection);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a synchron action where data can be read or written.\r\n     * \r\n     * @param pTables - Tabes for this transaction.\r\n     * @param pAction - Action withing this transaction.\r\n     */\r\n    public async transaction<TTables extends TableType>(pTables: Array<TTables>, pMode: WebDbTransactionMode, pAction: (pTransaction: WebDatabaseTransaction<TTables>) => void): Promise<void> {\r\n        // Tables should exists.\r\n        for (const lTableType of pTables) {\r\n            if (!this.mTableTypes.has(lTableType.name)) {\r\n                throw new Exception(`Table \"${lTableType.name}\" does not exists in this database.`, this);\r\n            }\r\n        }\r\n\r\n        // Create and open transaction.\r\n        const lTransaction: WebDatabaseTransaction<TTables> = new WebDatabaseTransaction(this, pTables, pMode);\r\n        await lTransaction.open();\r\n\r\n        // Call action within the transaction.\r\n        // eslint-disable-next-line @typescript-eslint/await-thenable\r\n        await pAction(lTransaction);\r\n\r\n        // Commit transaction.\r\n        lTransaction.commit();\r\n    }\r\n}\r\n\r\ntype IndexUpdate = {\r\n    name: string;\r\n    action: 'delete' | 'create';\r\n};\r\n\r\ntype TableUpdate = {\r\n    name: string;\r\n    action: 'delete' | 'create' | 'none';\r\n    indices: Array<IndexUpdate>;\r\n};\r\n\r\ntype DatabaseUpdate = {\r\n    version: number;\r\n    updateNeeded: boolean;\r\n    tableUpdates: Array<TableUpdate>;\r\n};\r\n\r\ntype WebDatabaseFieldDecoratorContext<TThis, TValue> = ClassGetterDecoratorContext<TThis, TValue> | ClassSetterDecoratorContext<TThis, TValue> | ClassFieldDecoratorContext<TThis, TValue> | ClassAccessorDecoratorContext<TThis, TValue>;", "/* eslint-disable no-console */\r\n\r\nimport type { WebDatabaseTable } from '../../source/web_database/web-database-table.ts';\r\nimport { WebDatabase } from '../../source/web_database/web-database.ts';\r\n\r\n@WebDatabase.table('TestTableOne')\r\nclass TestTableOne {\r\n    @WebDatabase.identity(true)\r\n    public id!: number;\r\n\r\n    @WebDatabase.field('name', true)\r\n    public name?: string;\r\n\r\n    @WebDatabase.field('price')\r\n    public price?: number;\r\n\r\n    @WebDatabase.field('type', false, true)\r\n    public types?: Array<number>;\r\n\r\n    @WebDatabase.field()\r\n    public notIndexed?: string;\r\n\r\n    public whatMyId(): number {\r\n        return this.id!;\r\n    }\r\n}\r\n\r\n@WebDatabase.table('TestTableTwo')\r\nclass TestTableTwo {\r\n    @WebDatabase.field('nameThing', true)\r\n    public nameThing?: string;\r\n}\r\n\r\n(() => {\r\n    const lDatabase: WebDatabase = new WebDatabase('MainDB', [TestTableOne, TestTableTwo]);\r\n    lDatabase.transaction([TestTableOne, TestTableTwo], 'readwrite', async (pTransaction) => {\r\n        const lTestTableOne: WebDatabaseTable<typeof TestTableOne> = pTransaction.table(TestTableOne);\r\n        const lTestTableTwo: WebDatabaseTable<typeof TestTableTwo> = pTransaction.table(TestTableTwo);\r\n\r\n        await lTestTableOne.clear();\r\n        await lTestTableTwo.clear();\r\n\r\n        // Create random data.\r\n        for (let lCounter = 0; lCounter < 100; lCounter++) {\r\n            const lData: TestTableOne = new TestTableOne();\r\n            lData.name = Math.random().toString(16);\r\n            lData.price = Math.random();\r\n            lData.types = [1, 2, 3].slice(Math.floor(Math.random() * 4), Math.floor(Math.random() * 4));\r\n            lData.notIndexed = Math.random().toString(16);\r\n\r\n            await lTestTableOne.put(lData);\r\n        }\r\n\r\n        console.log(await lTestTableOne.count(), await lTestTableOne.getAll());\r\n        console.log(await lTestTableOne.where('types').is(2).and('price').between(0, 0.5).execute());\r\n\r\n        // Create random data.\r\n        for (let lCounter = 0; lCounter < 100; lCounter++) {\r\n            const lData: TestTableTwo = new TestTableTwo();\r\n            lData.nameThing = Math.random().toString(16);\r\n\r\n            await lTestTableTwo.put(lData);\r\n        }\r\n    });\r\n})();\r\n\r\n", "(() => {\n    const socket = new WebSocket('ws://127.0.0.1:8088');\n    socket.addEventListener('open', () => {\n        console.log('Refresh connection established');\n    });\n    socket.addEventListener('message', (event) => {\n        console.log('Bundle finished. Start refresh');\n        if (event.data === 'REFRESH') {\n            window.location.reload();\n        }\n    });\n})();\nimport './index.ts';\n"],
  "mappings": "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",
  "names": ["List", "_List", "pItemList", "lNewList", "pArray", "lIndex", "pValue", "lFoundIndex", "pOldValue", "pNewValue", "lOldValue", "Exception", "pMessage", "pTarget", "pErrorOptions", "Dictionary", "_Dictionary", "pKey", "pValue", "Exception", "pItem", "pDefault", "lValue", "pFunction", "lResultList", "List", "lKeyValuePair", "lMappingResult", "BaseMetadata", "Dictionary", "pMetadataKey", "pMetadataValue", "PropertyMetadata", "BaseMetadata", "ConstructorMetadata", "_ConstructorMetadata", "BaseMetadata", "pDecoratorMetadataObject", "Dictionary", "pMetadataKey", "lInheritedMetadata", "lDecoratorMetadataObject", "lMetadataValue", "pPropertyKey", "PropertyMetadata", "Metadata", "_Metadata", "Dictionary", "pMetadataKey", "pMetadataValue", "_pOriginalTarget", "pContext", "lConstructorMetadata", "pMetadataObject", "pTarget", "lDecoratorMetadataObject", "ConstructorMetadata", "pConstructor", "lInheritanceChain", "lCurrentConstructor", "lIndex", "lConstructor", "lPrototype", "Injection", "_Injection", "Dictionary", "pConstructor", "pForceCreateOrLocalInjections", "pLocalInjections", "lForceCreate", "lLocalInjectionConstructors", "lConstructorIdentification", "Exception", "lInjectionMode", "lLocalInjections", "pKey", "pValue", "lOldInjectionContext", "lNewLocalInjection", "lCreatedObject", "pMode", "pOriginalClass", "pContext", "pMetaDataObject", "pOriginalConstructor", "pReplacementConstructor", "lOriginalIdentification", "lReplacementIdentification", "lConstructor", "pMetadata", "lConstructorMetadata", "Metadata", "lIdentification", "WebDatabaseTableLayout", "_WebDatabaseTableLayout", "pType", "lTableLayout", "Metadata", "Exception", "pName", "pKey", "pAutoIncrement", "pPropertyKey", "pIndexName", "pIsUnique", "pMultiEnty", "lIndexConfig", "WebDatabaseQueryAction", "pQuery", "pActionCallback", "pLowerValue", "pUpperValue", "lAction", "pValue", "WebDatabaseQuery", "pTable", "pIndexOrPropertyName", "lPart", "WebDatabaseQueryAction", "pAction", "Exception", "lQueryBlockList", "lQuery", "lQueryResult", "lQueryBlockResultList", "lQueryBlock", "lGreatestResultSet", "lQueryBlockResult", "lQueryResultItem", "pQuery", "lTableConnection", "lIndexName", "lIndexNameList", "lIndexNameListIndex", "lRequest", "pResolve", "pReject", "pEvent", "lTarget", "lCursorRequest", "lFiteredList", "lCursorResult", "lFiltedValue", "pBlock", "lQueryResultRequestList", "lQueryResultList", "lIdentityKey", "lIdentityMapList", "lItemMap", "Dictionary", "lItem", "lSmallestItemSet", "lIdentityMap", "lFilteringQuery", "lResultItemKey", "WebDatabaseTable", "pType", "pTransaction", "WebDatabaseTableLayout", "lRequest", "pResolve", "pReject", "pEvent", "lTarget", "Exception", "pData", "lIdentityProperty", "lIdentityValue", "pCount", "lResult", "pIndexOrPropertyName", "WebDatabaseQuery", "lResultList", "lSourceObject", "lTargetObject", "lKey", "WebDatabaseTransaction", "Exception", "pDatabase", "pTables", "pMode", "lDatabaseConnection", "lTableNames", "pTableType", "pType", "WebDatabaseTable", "WebDatabase", "_WebDatabase", "pIndexName", "pUnique", "pMultiEntry", "_", "pContext", "Exception", "lConstructorMetadata", "Metadata", "lTableLayout", "WebDatabaseTableLayout", "pAutoIncrement", "_pTarget", "pTableName", "_pClassTarget", "pName", "pTables", "Dictionary", "lTableType", "lDeleteRequest", "pResolve", "pReject", "pEvent", "lTarget", "lDatabaseUpdate", "lOpenRequest", "lDatabaseConnection", "lCurrentTableNames", "lUncreatedTableNames", "lReadTransaction", "lTableName", "lTable", "lConfiguratedKeyPath", "lConfiguratedAutoIncrement", "lCurrentTableIndices", "lUncreatedTableIndices", "lIndexUpdates", "lIndexName", "lCurrentIndex", "lIndexConfiguration", "lCurrentIndexKey", "lConfiguratedIndexKey", "lConfiguratedIsMultiEntry", "lTableUpdate", "lDatabaseVersion", "lDatabaseTransaction", "lTableConfiguration", "lIndexUpdate", "lIndexKeys", "pMode", "pAction", "lTransaction", "WebDatabaseTransaction", "_notIndexed_dec", "_types_dec", "_price_dec", "_name_dec", "_id_dec", "_TestTableOne_decorators", "_init", "WebDatabase", "TestTableOne", "__publicField", "__runInitializers", "__decoratorStart", "__decorateElement", "_nameThing_dec", "_TestTableTwo_decorators", "TestTableTwo", "pTransaction", "lTestTableOne", "lTestTableTwo", "lCounter", "lData", "socket", "event"]
}
