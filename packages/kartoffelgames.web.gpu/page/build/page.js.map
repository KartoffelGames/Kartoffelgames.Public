{
  "version": 3,
  "sources": ["../packages/kartoffelgames.core/source/data_container/list.ts", "../packages/kartoffelgames.core/source/exception/exception.ts", "../packages/kartoffelgames.core/source/data_container/dictionary.ts", "../packages/kartoffelgames.core/source/data_container/stack.ts", "../packages/kartoffelgames.core/source/data_container/linked-list.ts", "../packages/kartoffelgames.core/source/util/enum-util.ts", "../packages/kartoffelgames.core/source/util/type-util.ts", "../packages/kartoffelgames.core/source/algorithm/myers-diff.ts", "../packages/kartoffelgames.core/source/index.ts", "../packages/kartoffelgames.web.gpu/source/constant/buffer-usage.enum.ts", "../packages/kartoffelgames.web.gpu/source/gpu_object/gpu-object-invalidation-reasons.ts", "../packages/kartoffelgames.web.gpu/source/gpu_object/gpu-object.ts", "../packages/kartoffelgames.web.gpu/source/gpu_object/gpu-resource-object.ts", "../packages/kartoffelgames.web.gpu/source/constant/gpu-limit.enum.ts", "../packages/kartoffelgames.web.gpu/source/constant/storage-binding-type.enum.ts", "../packages/kartoffelgames.web.gpu/source/buffer/gpu-buffer-view.ts", "../packages/kartoffelgames.web.gpu/source/buffer/gpu-buffer.ts", "../packages/kartoffelgames.web.gpu/source/constant/buffer-item-format.enum.ts", "../packages/kartoffelgames.web.gpu/source/constant/buffer-item-multiplier.enum.ts", "../packages/kartoffelgames.web.gpu/source/constant/compare-function.enum.ts", "../packages/kartoffelgames.web.gpu/source/constant/compute-stage.enum.ts", "../packages/kartoffelgames.web.gpu/source/constant/gpu-feature.enum.ts", "../packages/kartoffelgames.web.gpu/source/constant/primitive-cullmode.enum.ts", "../packages/kartoffelgames.web.gpu/source/constant/sampler-type.enum.ts", "../packages/kartoffelgames.web.gpu/source/constant/texture-blend-factor.enum.ts", "../packages/kartoffelgames.web.gpu/source/constant/texture-blend-operation.enum.ts", "../packages/kartoffelgames.web.gpu/source/constant/texture-format.enum.ts", "../packages/kartoffelgames.web.gpu/source/constant/texture-view-dimension.enum.ts", "../packages/kartoffelgames.web.gpu/source/constant/vertex-parameter-step-mode.enum.ts", "../packages/kartoffelgames.web.gpu/source/execution/gpu-execution.ts", "../packages/kartoffelgames.web.gpu/source/execution/pass/compute-pass-context.ts", "../packages/kartoffelgames.web.gpu/source/execution/pass/compute-pass.ts", "../packages/kartoffelgames.web.gpu/source/constant/texture-usage.enum.ts", "../packages/kartoffelgames.web.gpu/source/constant/filter-mode.enum.ts", "../packages/kartoffelgames.web.gpu/source/constant/wrapping-mode.enum.ts", "../packages/kartoffelgames.web.gpu/source/texture/texture-sampler.ts", "../packages/kartoffelgames.web.gpu/source/constant/buffer-alignment-type.enum.ts", "../packages/kartoffelgames.web.gpu/source/base-memory-layout.ts", "../packages/kartoffelgames.web.gpu/source/buffer/memory_layout/base-buffer-memory-layout.ts", "../packages/kartoffelgames.web.gpu/source/buffer/memory_layout/array-buffer-memory-layout.ts", "../packages/kartoffelgames.web.gpu/source/buffer/memory_layout/primitive-buffer-memory-layout.ts", "../packages/kartoffelgames.web.gpu/source/gpu_object/gpu-object-setup.ts", "../packages/kartoffelgames.web.gpu/source/gpu_object/gpu-object-child-setup.ts", "../packages/kartoffelgames.web.gpu/source/buffer/memory_layout/struct-buffer-memory-layout-property-setup.ts", "../packages/kartoffelgames.web.gpu/source/buffer/memory_layout/struct-buffer-memory-layout-setup.ts", "../packages/kartoffelgames.web.gpu/source/buffer/memory_layout/struct-buffer-memory-layout.ts", "../packages/kartoffelgames.web.gpu/source/constant/texture-dimension.enum.ts", "../packages/kartoffelgames.web.gpu/source/texture/gpu-texture-view.ts", "../packages/kartoffelgames.web.gpu/source/texture/memory_layout/texture-view-memory-layout.ts", "../packages/kartoffelgames.web.gpu/source/texture/gpu-texture.ts", "../packages/kartoffelgames.web.gpu/source/texture/memory_layout/sampler-memory-layout.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/bind_group/bind-group-data-setup.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/bind_group/bind-group.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/pipeline_data/pipeline-data-group-setup.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/pipeline_data/pipeline-data-setup.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/pipeline_data/pipeline-data.ts", "../packages/kartoffelgames.web.gpu/source/constant/primitive-front-face.enum.ts", "../packages/kartoffelgames.web.gpu/source/constant/primitive-topology.enum.ts", "../packages/kartoffelgames.web.gpu/source/constant/stencil-operation.enum.ts", "../packages/kartoffelgames.web.gpu/source/constant/texture-aspect.enum.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/vertex_fragment_pipeline/vertex-fragment-pipeline-depth-configuration.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/vertex_fragment_pipeline/vertex-fragment-pipeline-stencil-configuration.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/vertex_fragment_pipeline/vertex-fragment-pipeline-target-configuration.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/vertex_fragment_pipeline/vertex-fragment-pipeline.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/vertex_parameter/vertex-parameter.ts", "../packages/kartoffelgames.web.gpu/source/execution/pass/render-pass-context.ts", "../packages/kartoffelgames.web.gpu/source/execution/pass/render-pass.ts", "../packages/kartoffelgames.web.gpu/source/constant/texture-operation.enum.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/render_targets/render-targets-texture-setup.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/render_targets/render-targets-setup.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/render_targets/render-targets.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/pipeline-layout.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/bind_group_layout/bind-group-layout-buffer-memory-layout-setup.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/bind_group_layout/bind-group-layout-memory-layout-setup.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/bind_group_layout/bind-group-layout-setup.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/bind_group_layout/bind-group-layout.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/vertex_parameter/vertex-parameter-buffer-layout-setup.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/vertex_parameter/vertex-parameter-layout-setup.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/vertex_parameter/vertex-parameter-layout.ts", "../packages/kartoffelgames.web.gpu/source/shader/setup/shader-compute-entry-point-setup.ts", "../packages/kartoffelgames.web.gpu/source/shader/setup/shader-fragment-entry-point-setup.ts", "../packages/kartoffelgames.web.gpu/source/shader/setup/shader-setup.ts", "../packages/kartoffelgames.web.gpu/source/pipeline/compute-pipeline.ts", "../packages/kartoffelgames.web.gpu/source/shader/shader-compute-module.ts", "../packages/kartoffelgames.web.gpu/source/shader/shader-render-module.ts", "../packages/kartoffelgames.web.gpu/source/shader/shader.ts", "../packages/kartoffelgames.web.gpu/source/texture/canvas-texture.ts", "../packages/kartoffelgames.web.gpu/source/device/capabilities/gpu-device-capabilities.ts", "../packages/kartoffelgames.web.gpu/source/constant/texture-sample-type.enum.ts", "../packages/kartoffelgames.web.gpu/source/device/capabilities/gpu-texture-format-capabilities.ts", "../packages/kartoffelgames.web.gpu/source/device/gpu-device.ts", "../packages/kartoffelgames.web.gpu/page/source/camera/math/vector.ts", "../packages/kartoffelgames.web.gpu/page/source/camera/light/ambient-light.ts", "../packages/kartoffelgames.web.gpu/page/source/camera/math/matrix.ts", "../packages/kartoffelgames.web.gpu/page/source/camera/math/euler.ts", "../packages/kartoffelgames.web.gpu/page/source/camera/math/quaternion.ts", "../packages/kartoffelgames.web.gpu/page/source/camera/transform.ts", "../packages/kartoffelgames.web.gpu/page/source/camera/view_projection/projection/perspective-projection.ts", "../packages/kartoffelgames.web.gpu/page/source/camera/view_projection/view-projection.ts", "../packages/kartoffelgames.web.gpu/page/source/game_objects/color_cube/color-cube-shader.wgsl", "../packages/kartoffelgames.web.gpu/page/source/game_objects/cube/cube-shader.wgsl", "../packages/kartoffelgames.web.gpu/page/source/game_objects/leaf_particle/particle-compute-shader.wgsl", "../packages/kartoffelgames.web.gpu/page/source/game_objects/leaf_particle/particle-shader.wgsl", "../packages/kartoffelgames.web.gpu/page/source/game_objects/light/light-box-shader.wgsl", "../packages/kartoffelgames.web.gpu/page/source/game_objects/skybox/sky-box-shader.wgsl", "../packages/kartoffelgames.web.gpu/page/source/game_objects/video_canvas/video-canvas-shader.wgsl", "../packages/kartoffelgames.web.gpu/page/source/meshes/canvas-mesh.ts", "../packages/kartoffelgames.web.gpu/page/source/meshes/cube-mesh.ts", "../packages/kartoffelgames.web.gpu/page/source/meshes/particle-mesh.ts", "../packages/kartoffelgames.web.gpu/page/source/util.ts", "../packages/kartoffelgames.web.gpu/page/source/index.ts", "../packages/kartoffelgames.web.gpu/page/source/standard-input-file.ts"],
  "sourcesContent": ["import type { ICloneable } from '../interface/i-cloneable.ts';\r\n\r\n/**\r\n * Wrapper for {@link Array}.\r\n * \r\n * @typeParam T - Type of items of list. \r\n * \r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array}\r\n * \r\n * @public\r\n */\r\nexport class List<T> extends Array<T> implements ICloneable<List<T>> {\r\n    /**\r\n     * Create list and add items.\r\n     * Prevents spread operator with number arrays to initialize array with length instead of item.\r\n     * \r\n     * @param pItemList - Items.\r\n     * \r\n     * @example Create new list with `newListWith` and failing creation with the native `Array` constructor.\r\n     * ```TypeScript\r\n     * const newList = List.newListWith<number>(...[3]); // => [3] \r\n     * const newListWrong = new List<number>(...[3]);    // => [undefined, undefined, undefined] \r\n     * ```\r\n     */\r\n    public static newListWith<T>(...pItemList: Array<T>): List<T> {\r\n        const lNewList: List<T> = new List<T>();\r\n        lNewList.push(...pItemList);\r\n\r\n        return lNewList;\r\n    }\r\n\r\n    /**\r\n     * Remove every item.\r\n     * \r\n     * @example Clear a list.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<number>(1, 2, 3);\r\n     * list.clear(); \r\n     * \r\n     * console.log(list.length); // => 0\r\n     * ```\r\n     */\r\n    public clear(): void {\r\n        this.splice(0, this.length);\r\n    }\r\n\r\n    /**\r\n     * Create new list and add same items.\r\n     * @see {@link ICloneable.clone}\r\n     * \r\n     * @returns cloned list with shallow copied item refernces.\r\n     * \r\n     * @example Clone and compare list and list items.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<object>(new Object());\r\n     * \r\n     * const clone = list.clone();\r\n     * \r\n     * const areSame = list === clone; // => False\r\n     * const itemSame = list[0] === list[0]; // => True\r\n     * ```\r\n     */\r\n    public clone(): List<T> {\r\n        return List.newListWith(...this);\r\n    }\r\n\r\n    /**\r\n     * Copy distinct values into new list.\r\n     * \r\n     * @returns new list instance with only distinct values.\r\n     * \r\n     * @example Create a new list with dublicates and create a new distinct list out of it.\r\n     * ```TypeScript\r\n     * const listWithDublicates = List.newListWith<number>(1, 1, 2, 3, 3);\r\n     * const distinctList = listWithDublicates.distinct(); // => [1, 2, 3]\r\n     * ```\r\n     */\r\n    public distinct(): List<T> {\r\n        return List.newListWith(...new Set(this));\r\n    }\r\n\r\n    /**\r\n     * Compares this array with the specified one.\r\n     * Compares length and every item by reference and order.\r\n     * Does only shallow compare item references.\r\n     * \r\n     * @param pArray - Array to compare.\r\n     * \r\n     * @returns true for equality.\r\n     * \r\n     * @example Compare two arrays with a list.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<number>(1, 3, 2);\r\n     * \r\n     * const isEqual = list.equals([1, 3, 2]) // => True\r\n     * const isUnequal = list.equals([1, 2, 3]) // => False\r\n     * ```\r\n     */\r\n    public equals(pArray: Array<unknown>): boolean {\r\n        // Check if array are same, dont null and have same length.\r\n        if (this === pArray) {\r\n            return true;\r\n        } else if (!pArray || this.length !== pArray.length) {\r\n            return false;\r\n        }\r\n\r\n        // Check each item.\r\n        for (let lIndex = 0; lIndex < this.length; ++lIndex) {\r\n            if (this[lIndex] !== pArray[lIndex]) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Removes the first appearence of a value.\r\n     * \r\n     * @param pValue - Target value to remove.\r\n     * \r\n     * @returns removed element. When no element was removed, undefined is returned instead.\r\n     * \r\n     * @example Remove a existing and a none existing item of a list.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<number>(1, 3, 2);\r\n     * \r\n     * const removedElement = list.remove(1); // => 1\r\n     * const noneExistingElement = list.remove(4); // => undefined\r\n     * ```\r\n     */\r\n    public remove(pValue: T): T | undefined {\r\n        const lFoundIndex: number = this.indexOf(pValue);\r\n\r\n        // Only remove if found.\r\n        if (lFoundIndex !== -1) {\r\n            return this.splice(lFoundIndex, 1)[0];\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Replace first appearence of value.\r\n     * \r\n     * @param pOldValue - Target value to replace.\r\n     * @param pNewValue - Replacement value.\r\n     * \r\n     * @returns replaced element. When no element was replaced, undefined is returned instead.\r\n     * \r\n     * @example Replace a existing and a none existing item of a list.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<number>(1, 5, 3);\r\n     * \r\n     * const removedElement = list.replace(5, 2); // => 5\r\n     * const noneExistingElement = list.replace(4, 3); // => undefined\r\n     * \r\n     * console.log(list); // => [1, 2, 3]\r\n     * ```\r\n     */\r\n    public replace(pOldValue: T, pNewValue: T): T | undefined {\r\n        const lFoundIndex: number = this.indexOf(pOldValue);\r\n\r\n        // Only replace if found.\r\n        if (lFoundIndex !== -1) {\r\n            // Save old value and replace it with new value.\r\n            const lOldValue: T = this[lFoundIndex];\r\n            this[lFoundIndex] = pNewValue;\r\n\r\n            return lOldValue;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of this list.\r\n     * @override base objects {@link Array.toString}\r\n     * \r\n     * @returns string representation for this list.\r\n     * \r\n     * @example Output a string representation of a list.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<number>(1, 2, 3);\r\n     * console.log(list.toString()); // => [1, 2, 3]\r\n     * ```\r\n     */\r\n    public override toString(): string {\r\n        return `[${super.join(', ')}]`;\r\n    }\r\n}", "\uFEFF/**\r\n * Extends {@link Error} by a {@link Exception.target} reference.\r\n * \r\n * @typeParam T - Exception target type.\r\n * \r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}\r\n * \r\n * @public\r\n */\r\nexport class Exception<T> extends Error {\r\n    private readonly mTarget: T;\r\n\r\n    /**\r\n     * Target of exception.\r\n     * \r\n     * @readonly\r\n     */\r\n    public get target(): T {\r\n        return this.mTarget;\r\n    }\r\n\r\n    /**\r\n     * Constructor. \r\n     * @param pMessage - Messsage of exception.\r\n     * @param pTarget - Target of exception.\r\n     * @param pErrorOptions - Optional error options.\r\n     */\r\n    public constructor(pMessage: string, pTarget: T, pErrorOptions?: ErrorOptions) {\r\n        super(pMessage, pErrorOptions);\r\n        this.mTarget = pTarget;\r\n    }\r\n}", "import { List } from './list.ts';\r\nimport { Exception } from '../exception/exception.ts';\r\nimport type { ICloneable } from '../interface/i-cloneable.ts';\r\n\r\n/**\r\n * Wrapper for {@link Map}.\r\n * Extended by {@link Dictionary.add}, {@link Dictionary.getAllKeysOfValue}, {@link Dictionary.getOrDefault} and {@link Dictionary.map}.\r\n * \r\n * @typeParam TKey - Type of objects defined for keys. \r\n * @typeParam TValue - Type of objects defined for values. \r\n * \r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map}\r\n * \r\n * @public\r\n */\r\nexport class Dictionary<TKey, TValue> extends Map<TKey, TValue> implements ICloneable<Dictionary<TKey, TValue>>{\r\n    /**\r\n     * Add value and key to dictionary. \r\n     * Throws {@link Exception}  for any added dublicate key. \r\n     * \r\n     * @param pKey - Key of item.\r\n     * @param pValue - value of item.\r\n     * \r\n     * @throws\r\n     * On any dublicate key set,\r\n     * \r\n     * @example Adding a new and existing key.\r\n     * ```TypeScript\r\n     * const dictionary = new Dictionary<string, number>();\r\n     * dictionary.add('a', 4); // => OK\r\n     * dictionary.add('a', 4); // => Fail: Dublicate key.\r\n     * ```\r\n     */\r\n    public add(pKey: TKey, pValue: TValue): void {\r\n        // Add value and key to containers.\r\n        if (!this.has(pKey)) {\r\n            this.set(pKey, pValue);\r\n        } else {\r\n            throw new Exception(\"Can't add dublicate key to dictionary.\", this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create new dicionary and add same keys and values.\r\n     * @see {@link ICloneable.clone}\r\n     * \r\n     * @returns cloned dictionary with shallow copied key and value refernces.\r\n     * \r\n     * @example Clone and compare dictionary and dictionary items.\r\n     * ```TypeScript\r\n     * const dictionary = new Dictionary<string, object>();\r\n     * dictionary.set('a', new Object());\r\n     * \r\n     * const clone = dictionary.clone();\r\n     * \r\n     * const areSame = dictionary === clone; // => False\r\n     * const itemSame = dictionary.get('a') === clone.get('a'); // => True\r\n     * ```\r\n     */\r\n    public clone(): Dictionary<TKey, TValue> {\r\n        return new Dictionary<TKey, TValue>(this);\r\n    }\r\n\r\n    /**\r\n     * Get all keys that have the set value.\r\n     * \r\n     * @param pValue - Value.\r\n     * \r\n     * @returns all keys that hold the specified value.\r\n     * \r\n     * @example Get keys of a value.\r\n     * ```TypeScript\r\n     * const dictionary = new Dictionary<string, number>();\r\n     * dictionary.set('a', 1);\r\n     * dictionary.set('b', 2);\r\n     * dictionary.set('c', 1);\r\n     * \r\n     * const keys = dictionary.getAllKeysOfValue(1); // => ['a', 'c']\r\n     * ```\r\n     */\r\n    public getAllKeysOfValue(pValue: TValue): Array<TKey> {\r\n        // Add entries iterator to list and filter for pValue = Value\r\n        const lKeyValuesWithValue: Array<[TKey, TValue]> = [...this.entries()].filter((pItem: [TKey, TValue]) => {\r\n            return pItem[1] === pValue;\r\n        });\r\n\r\n        // Get only keys of key values.\r\n        const lKeysOfKeyValue: Array<TKey> = lKeyValuesWithValue.map<TKey>((pItem: [TKey, TValue]): TKey => {\r\n            return pItem[0];\r\n        });\r\n\r\n        return lKeysOfKeyValue;\r\n    }\r\n\r\n    /**\r\n     * Get item. If the key does not exists the default value gets returned.\r\n     * @param pKey - Key of item.\r\n     * @param pDefault - Default value if key was not found.\r\n     * \r\n     * @returns value of the key. If the key does not exists the default value gets returned.\r\n     * \r\n     * @example Get value or default from a existing and none existing key. \r\n     * ```TypeScript\r\n     * const dictionary = new Dictionary<string, number>();\r\n     * dictionary.set('a', 1);\r\n     * \r\n     * const keyA = dictionary.getOrDefault('a', 22); // => 1\r\n     * const keyZ = dictionary.getOrDefault('z', 22); // => 22\r\n     * ```\r\n     */\r\n    public getOrDefault(pKey: TKey, pDefault: TValue): TValue {\r\n        const lValue: TValue | undefined = this.get(pKey);\r\n        if (typeof lValue !== 'undefined') {\r\n            return lValue;\r\n        }\r\n\r\n        return pDefault;\r\n    }\r\n\r\n    /**\r\n     * Maps information into new list.\r\n     * @param pFunction - Mapping funktion.\r\n     * \r\n     * @typeParam T - Result type of mapping resolver function.\r\n     * \r\n     * @returns mapped data for each item.\r\n     * \r\n     * @example Remap all dictionary values by adding a number to all values. \r\n     * ```TypeScript\r\n     * const dictionary = new Dictionary<string, number>();\r\n     * dictionary.set('a', 1);\r\n     * dictionary.set('b', 2);\r\n     * \r\n     * const list = dictionary.map((key, value) => value + 1); //  => [2, 3]\r\n     * ```\r\n     */\r\n    public map<T>(pFunction: (pKey: TKey, pValue: TValue) => T): Array<T> {\r\n        const lResultList: List<T> = new List<T>();\r\n\r\n        for (const lKeyValuePair of this) {\r\n            // Execute callback and add result to list.\r\n            const lMappingResult: T = pFunction(lKeyValuePair[0], lKeyValuePair[1]);\r\n            lResultList.push(lMappingResult);\r\n        }\r\n\r\n        return lResultList;\r\n    }\r\n}", "import type { ICloneable } from '../interface/i-cloneable.ts';\r\n\r\n/**\r\n * Simple and fast stack implementation based on references.\r\n * \r\n * @public\r\n */\r\nexport class Stack<T> implements ICloneable<Stack<T>> {\r\n    private mSize: number;\r\n    private mTopItem: StackItem<T> | null;\r\n\r\n    /**\r\n     * Get current stack size.\r\n     */\r\n    public get size(): number {\r\n        return this.mSize;\r\n    }\r\n\r\n    /**\r\n     * Current top item of stack.\r\n     * Returns undefined when no item is stacked.\r\n     */\r\n    public get top(): T | undefined {\r\n        // Undefined when no item is stacked.\r\n        if (!this.mTopItem) {\r\n            return undefined;\r\n        }\r\n\r\n        return this.mTopItem.value;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mTopItem = null;\r\n        this.mSize = 0;\r\n    }\r\n\r\n    /**\r\n     * Clones the references of all stack items into a new one.\r\n     * Does only shallow copy.\r\n     * \r\n     * @returns The cloned stack.\r\n     */\r\n    public clone(): Stack<T> {\r\n        const lClonedStack: Stack<T> = new Stack<T>();\r\n\r\n        // Only thing that needs to be cloned is the current reference.\r\n        lClonedStack.mTopItem = this.mTopItem;\r\n        lClonedStack.mSize = this.mSize;\r\n\r\n        return lClonedStack;\r\n    }\r\n\r\n    /**\r\n     * Iterates over each stack entry in reversed (newest...oldest) order.\r\n     * \r\n     * @returns Generator.\r\n     */\r\n    public *entries(): Generator<T> {\r\n        let lCurrentItem: StackItem<T> | null = this.mTopItem;\r\n\r\n        while (lCurrentItem !== null) {\r\n            yield lCurrentItem.value;\r\n\r\n            lCurrentItem = lCurrentItem.previous;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear stack and get all stacked items in stack order.\r\n     * \r\n     * @returns All stacked values in top to down order.\r\n     * \r\n     * @example Flush Stack\r\n     * ``` Typescript\r\n     * const stack = new Stack<number>();\r\n     * stack.push(1);\r\n     * stack.push(2);\r\n     * stack.push(3);\r\n     * \r\n     * // Flush all items. Clears stack.\r\n     * const stackValues = stack.flush(); // => [3, 2, 1];\r\n     * console.log(stack.top); // => undefined\r\n     * ``` \r\n     */\r\n    public flush(): Array<T> {\r\n        const lValueList: Array<T> = new Array<T>();\r\n\r\n        // Pop items as long as there are stack items.\r\n        // Don't check poped value as next indicator as it can contain undefined.\r\n        while (this.mTopItem) {\r\n            lValueList.push(this.pop()!);\r\n        }\r\n\r\n        return lValueList;\r\n    }\r\n\r\n    /**\r\n     * Removes the current top item of stack.\r\n     * When no item is stacked nothing happends and undefined is returned.\r\n     * \r\n     * @returns Current top item. When no item was stacked, undefined is returned instead.\r\n     * \r\n     * @example Pop current top item.\r\n     * ``` Typescript\r\n     * const stack = new Stack<number>();\r\n     * stack.push(1);\r\n     * stack.push(2);\r\n     * stack.push(3);\r\n     * \r\n     * // Check current stacked top item before and after poping.\r\n     * console.log(stack.top); // => 3\r\n     * const stackValues = stack.pop(); // => 3;\r\n     * console.log(stack.top); // => 2\r\n     * ``` \r\n     */\r\n    public pop(): T | undefined {\r\n        // Undefined when no item is stacked.\r\n        if (!this.mTopItem) {\r\n            return undefined;\r\n        }\r\n\r\n        // Buffer current top value.\r\n        const lCurrentTopValue: T = this.mTopItem.value;\r\n\r\n        // Replace current top item with previous stacked.\r\n        this.mTopItem = this.mTopItem.previous;\r\n        this.mSize--;\r\n\r\n        return lCurrentTopValue;\r\n    }\r\n\r\n    /**\r\n     * Push new value as top item of stack. Replaces the current top item.\r\n     * @param pValue - Next value placed on top.\r\n     * \r\n     * @example Push next top item.\r\n     * ``` Typescript\r\n     * const stack = new Stack<number>();\r\n     * stack.push(1);\r\n\r\n     * \r\n     * // Check current stacked top item before and after pushing.\r\n     * console.log(stack.top); // => 1\r\n     * stack.push(2);\r\n     * console.log(stack.top); // => 2\r\n     * ``` \r\n     */\r\n    public push(pValue: T): void {\r\n        // Create new stack item with the current top item as reference. \r\n        const lNextItem: StackItem<T> = {\r\n            previous: this.mTopItem,\r\n            value: pValue\r\n        };\r\n\r\n        // Replace current top item with next.\r\n        this.mTopItem = lNextItem;\r\n        this.mSize++;\r\n    }\r\n\r\n    /**\r\n     * Converts this stack into an array.\r\n     * The first item in the array is the last item pushed into the stack.\r\n     * \r\n     * @returns The current stack as array.\r\n     * \r\n     * @example Stack into array.\r\n     * ``` Typescript\r\n     * const stack = new Stack<number>();\r\n     * stack.push(1);\r\n     * stack.push(2);\r\n     * stack.push(3);\r\n     * \r\n     * // Stack to array.\r\n     * console.log(stack.toArray()); // => [3, 2, 1]\r\n     * ``` \r\n     */\r\n    public toArray(): Array<T> {\r\n        // Convert genertor into array.\r\n        return [...this.entries()];\r\n    }\r\n}\r\n\r\ntype StackItem<T> = {\r\n    previous: StackItem<T> | null;\r\n    value: T;\r\n};", "export class LinkedList<T> {\r\n    private mCurrent: LinkedListChain<T>;\r\n    private mHeadElement: LinkedListHeadElement<T>;\r\n    private mRoot: LinkedListChain<T>;\r\n\r\n\r\n    /**\r\n     * Get current item.\r\n     */\r\n    public get current(): T | null {\r\n        // If current is null revert to the last item.\r\n        if (!this.mCurrent.item) {\r\n            return null;\r\n        }\r\n\r\n        return this.mCurrent.item.value;\r\n    }\r\n\r\n    /**\r\n     * Get if the list is done\r\n     */\r\n    public get done(): boolean {\r\n        return !this.mCurrent.next;\r\n    }\r\n\r\n    /**\r\n     * Get the root item.\r\n     */\r\n    public get root(): T | null {\r\n        if (!this.mRoot.item) {\r\n            return null;\r\n        }\r\n\r\n        return this.mRoot.item.value;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        // Set root.\r\n        this.mRoot = {\r\n            next: null,\r\n            item: null,\r\n        };\r\n\r\n        // List is empty, so it is also the root.\r\n        this.mHeadElement = {\r\n            head: this.mRoot\r\n        };\r\n        this.mCurrent = this.mRoot;\r\n    }\r\n\r\n    /**\r\n     * Move to the last item in the linked list.\r\n     */\r\n    public moveEnd(): void {\r\n        this.mCurrent = this.mHeadElement.head;\r\n    }\r\n\r\n    /**\r\n     * Move to the previous item in the linked list.\r\n     */\r\n    public moveFirst(): void {\r\n        this.mCurrent = this.mRoot;\r\n    }\r\n\r\n    /**\r\n     * Move to the next item in the linked list.\r\n     * \r\n     * @returns false when the end of the list is reached.\r\n     */\r\n    public next(): boolean {\r\n        // If current is null revert to the last item.\r\n        if (!this.mCurrent.next) {\r\n            return false;\r\n        }\r\n\r\n        // Move to next item.\r\n        this.mCurrent = this.mCurrent.next;\r\n\r\n        // Return if there is an item.\r\n        return !!this.mCurrent.item;\r\n    }\r\n\r\n    /**\r\n     * Add a new item to the end.\r\n     * \r\n     * @param pValue The value to add.\r\n     */\r\n    public push(pValue: T): void {\r\n        const lNewChain: LinkedListChain<T> = {\r\n            next: null,\r\n            item: null,\r\n        };\r\n\r\n        // Set value to current head.\r\n        this.mHeadElement.head.item = {\r\n            value: pValue\r\n        };\r\n\r\n        // Chain the new item.\r\n        this.mHeadElement.head.next = lNewChain;\r\n\r\n        // Set the new head.\r\n        this.mHeadElement.head = lNewChain;\r\n    }\r\n\r\n    /**\r\n     * Creates a new linked list starting from the current node.\r\n     * The list is still linked to the original list.\r\n     * Appending to the original list will expand the new list and vice versa.\r\n     *\r\n     * @returns {LinkedList<T>} A new linked list instance starting from the current node.\r\n     */\r\n    public sliceReference(): LinkedList<T> {\r\n        const lNewList: LinkedList<T> = new LinkedList<T>();\r\n        lNewList.mRoot = lNewList.mCurrent = this.mCurrent;\r\n\r\n        // Both lists are linked to the same head element.\r\n        lNewList.mHeadElement = this.mHeadElement;\r\n\r\n        return lNewList;\r\n    }\r\n\r\n    /**\r\n     * Sync the list with another list by setting \r\n     * the current element to the current element of the other list.\r\n     * \r\n     * @param pList The list to sync with.\r\n     */\r\n    public sync(pList: LinkedList<T>): void {\r\n        this.mCurrent = pList.mCurrent;\r\n    }\r\n}\r\n\r\ntype LinkedListHeadElement<T> = {\r\n    head: LinkedListChain<T>;\r\n};\r\n\r\ntype LinkedListChain<T> = {\r\n    next: LinkedListChain<T> | null;\r\n    item: LinkedListItem<T> | null;\r\n};\r\n\r\ntype LinkedListItem<T> = {\r\n    value: T;\r\n};", "/**\r\n * Static helper type to read data from enum objects.\r\n * \r\n * @public\r\n */\r\nexport class EnumUtil {\r\n    /**\r\n     * Infers value into enum type.\r\n     * When the values can not be infered into the specified enum, undefined is returned.\r\n     * \r\n     * @param pEnum - typeof Enum object.\r\n     * @param pValue - Value of enum.\r\n     * \r\n     * @typeParam T - Enum type the value should be infered into.\r\n     * \r\n     * @returns Infered `pValue` parameter or undefined when the value does not exists as the enums value.\r\n     * \r\n     * @example Try to cast two possible enum values.\r\n     * ``` Typescript\r\n     * enum MyEnum {\r\n     *     Entry1 = 1,\r\n     *     Entry2 = 2\r\n     * }\r\n     * \r\n     * const existingValue = EnumUtil.cast<MyEnum>(MyEnum, 1); // => MyEnum.Entry1\r\n     * const noneExistingValue = EnumUtil.cast<MyEnum>(MyEnum, 5); // => undefined\r\n     * ```\r\n     */\r\n    public static cast<T>(pEnum: object, pValue: any): T | undefined {\r\n        // Thats it... :)\r\n        if (EnumUtil.exists<T>(pEnum, pValue)) {\r\n            return pValue;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check value existence on a enum object.\r\n     * Infers `pValue` parameter as enum type.\r\n     * @param pEnum - typeof Enum object.\r\n     * @param pValue - Value of enum.\r\n     * \r\n     * @typeParam T - Enum type the value should be infered into.\r\n     * \r\n     * @returns True when the value can be casted into enum.\r\n     * \r\n     * @example Check existence of one two possible enum values.\r\n     * ``` Typescript\r\n     * enum MyEnum {\r\n     *     Entry1 = 1,\r\n     *     Entry2 = 2\r\n     * }\r\n     * \r\n     * const existingValue = EnumUtil.exists(MyEnum, 1); // => True\r\n     * const noneExistingValue = EnumUtil.exists(MyEnum, 5); // => False\r\n     * ```\r\n     */\r\n    public static exists<T>(pEnum: object, pValue: any): pValue is T {\r\n        return EnumUtil.valuesOf(pEnum).includes(pValue);\r\n    }\r\n\r\n    /**\r\n     * Return all keys of an enum as array.\r\n     * \r\n     * @param pEnum - typeof Enum object.\r\n     * \r\n     * @returns All enum key as array in defined order.\r\n     * \r\n     * @remarks\r\n     * Does only work for number enums and should fail for mixed or string enums.\r\n     * \r\n     * @example Read enum names from custom enum object.\r\n     * ``` Typescript\r\n     * enum MyEnum {\r\n     *     Entry1 = 1,\r\n     *     Entry2 = 2\r\n     * }\r\n     * \r\n     * const enumNames = EnumUtil.namesOf(MyEnum); // => ['Entry1', 'Entry2']\r\n     * ```\r\n     */\r\n    public static namesOf<TEnum>(pEnum: TEnum): Array<keyof TEnum> {\r\n        // Convert enum to key array.\r\n        return Object.keys(pEnum as object).filter((pKey) => isNaN(Number(pKey))) as Array<keyof TEnum>;\r\n    }\r\n\r\n    /**\r\n     * Return all values of an enum as array.\r\n     * \r\n     * @param pEnum - typeof Enum object.\r\n     * \r\n     * @typeParam T - Enum value type.\r\n     * \r\n     * @returns All enum values as array in defined order.\r\n     * \r\n     * @example Read enum values from custom enum object.\r\n     * ``` Typescript\r\n     * enum MyEnum {\r\n     *     Entry1 = 1,\r\n     *     Entry2 = 2\r\n     * }\r\n     * \r\n     * const enumValues = EnumUtil.valuesOf(MyEnum); // => [1, 2]\r\n     * ```\r\n     */\r\n    public static valuesOf<T>(pEnum: object): Array<T> {\r\n        const lEnumValues: Array<T> = new Array<T>();\r\n\r\n        // Convert enum to vaue array by iterating over all keys.\r\n        for (const lKey of EnumUtil.namesOf(pEnum)) {\r\n            lEnumValues.push((<{ [key: string]: T; }>pEnum)[lKey]);\r\n        }\r\n\r\n        return lEnumValues;\r\n    }\r\n}", "/**\r\n * Static helper type to read data from objects.\r\n * \r\n * @public\r\n */\r\nexport class TypeUtil {\r\n    /**\r\n     * Get name of objects property.\r\n     * @param pName - Property name.\r\n     * \r\n     * @typeParam T - Object with any string key property. \r\n     * \r\n     * @returns the name of property.\r\n     * \r\n     * @remarks\r\n     * Acts more as a type safe way of accessing property names of a type.\r\n     * \r\n     * @example Read enum names from custom enum object.\r\n     * ``` Typescript\r\n     * class MyClass {\r\n     *    public myProperty: number = 1;\r\n     * }\r\n     * \r\n     * const propertyName = TypeUtil.nameOf<MyClass>('myProperty'); // => 'myProperty'\r\n     * ```\r\n     * \r\n     * @experimental @alpha\r\n     */\r\n    public static nameOf<T>(pName: Extract<keyof T, string>): string {\r\n        return pName;\r\n    }\r\n}", "/**\r\n * Optimized implementation of the myers diff algorithm.\r\n */\r\nexport class MyersDiff<TA, TB> {\r\n    private readonly mCompareFunction: (itemA: TA, itemB: TB) => boolean;\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pCompareFunction - Compare function to compare two items.\r\n     */\r\n    public constructor(pCompareFunction: (itemA: TA, itemB: TB) => boolean) {\r\n        this.mCompareFunction = pCompareFunction;\r\n    }\r\n\r\n    /**\r\n     * Get differences of the two item lists.\r\n     * @param pItemListA - Item list A.\r\n     * @param pItemListB - Item list B.\r\n     */\r\n    public differencesOf(pItemListA: Array<TA>, pItemListB: Array<TB>): Array<HistoryItem<TA, TB>> {\r\n        // Save farthest-right points with it histories.\r\n        const lFrontierList: { [index: number]: Frontier<TA, TB>; } = { 1: { x: 0, history: [] } };\r\n\r\n        // \"Convert\" Zero index to One index.\r\n        const lOneIndex: (pId: number) => number = (pId: number): number => pId - 1;\r\n\r\n        const lLengthA: number = pItemListA.length;\r\n        const lLengthB: number = pItemListB.length;\r\n\r\n        let lHistoryList: Array<HistoryItem<TA, TB>>;\r\n        let lX: number;\r\n\r\n        for (let lD = 0; lD < lLengthA + lLengthB + 1; lD++) {\r\n            for (let lK = -lD; lK < lD + 1; lK += 2) {\r\n                // Check if next move goes down or right.\r\n                const lGoesDown: boolean = (lK === -lD || (lK !== lD && lFrontierList[lK - 1].x < lFrontierList[lK + 1].x));\r\n\r\n                // Get starting diagonal point.\r\n                if (lGoesDown) {\r\n                    const lNextFrontier: Frontier<TA, TB> = lFrontierList[lK + 1];\r\n                    lX = lNextFrontier.x;\r\n                    lHistoryList = lNextFrontier.history;\r\n                } else {\r\n                    const lNextFrontier: Frontier<TA, TB> = lFrontierList[lK - 1];\r\n                    lX = lNextFrontier.x + 1;\r\n                    lHistoryList = lNextFrontier.history;\r\n                }\r\n\r\n                // Copy history list.\r\n                lHistoryList = lHistoryList.slice();\r\n                let lY: number = lX - lK;\r\n\r\n                // Only start tracking history on valid track. Staring point (0,0) should not be tracked.\r\n                if (1 <= lY && lY <= lLengthB && lGoesDown) {\r\n                    lHistoryList.push({ changeState: ChangeState.Insert, item: pItemListB[lOneIndex(lY)] });\r\n                } else if (1 <= lX && lX <= lLengthA) {\r\n                    lHistoryList.push({ changeState: ChangeState.Remove, item: pItemListA[lOneIndex(lX)] });\r\n                }\r\n\r\n                // Move diagonal as long as possible.\r\n                while (lX < lLengthA && lY < lLengthB && this.mCompareFunction(pItemListA[lOneIndex(lX + 1)], pItemListB[lOneIndex(lY + 1)])) {\r\n                    lX += 1;\r\n                    lY += 1;\r\n                    lHistoryList.push({ changeState: ChangeState.Keep, item: pItemListA[lOneIndex(lX)] });\r\n                }\r\n\r\n                // Check if in the bottom right. If not save frontier.\r\n                if (lX >= lLengthA && lY >= lLengthB) {\r\n                    // Return found history.\r\n                    return lHistoryList;\r\n                } else {\r\n                    lFrontierList[lK] = { x: lX, history: lHistoryList };\r\n                }\r\n            }\r\n        }\r\n\r\n        // Empty array for typescript. This area is never reached.\r\n        // deno-coverage-ignore-next\r\n        return new Array<HistoryItem<TA, TB>>();\r\n    }\r\n}\r\n\r\nexport type HistoryItemRemove<T> = { changeState: ChangeState.Remove, item: T; };\r\nexport type HistoryItemInsert<T> = { changeState: ChangeState.Insert, item: T; };\r\nexport type HistoryItemKeep<T> = { changeState: ChangeState.Keep, item: T; };\r\nexport type HistoryItem<TA, TB> = HistoryItemRemove<TA> | HistoryItemInsert<TB> | HistoryItemKeep<TA>;\r\n\r\nexport enum ChangeState {\r\n    Remove = 1,\r\n    Insert = 2,\r\n    Keep = 3\r\n}\r\n\r\ntype Frontier<TA, TB> = { x: number, history: Array<HistoryItem<TA, TB>>; };\r\n", "/**\r\n * Library for data container and easier data access.\r\n *\r\n * @remarks \r\n * This package consists mostly of helper classes and storage types, aimed at reducing code redundance and improving clarity.\r\n * \r\n * @packageDocumentation\r\n */\r\n\r\n// Container.\r\nexport { Dictionary } from './data_container/dictionary.ts';\r\nexport { List } from './data_container/list.ts';\r\nexport { Stack } from './data_container/stack.ts';\r\nexport { Exception } from './exception/exception.ts';\r\nexport { LinkedList } from './data_container/linked-list.ts';\r\n\r\n// Handler.\r\nexport { EnumUtil } from './util/enum-util.ts';\r\nexport { TypeUtil } from './util/type-util.ts';\r\n\r\n// Interfaces.\r\nexport { type ICloneable } from './interface/i-cloneable.ts';\r\nexport { type IVoidParameterConstructor } from './interface/i-constructor.ts';\r\nexport { type IDeconstructable } from './interface/i-deconstructable.ts';\r\n\r\n// Support types.\r\nexport { \r\n    type Readonly, type Writeable,\r\n\r\n    // Decorator types.\r\n    type ClassDecorator,\r\n    type ClassAccessorDecorator,\r\n    type ClassMethodDecorator,\r\n    type ClassFieldDecorator,\r\n\r\n    // Types that should be native\r\n    type TypedArray\r\n} from './types.ts';\r\n\r\n// Algorythms\r\nexport { ChangeState, MyersDiff, type HistoryItem } from './algorithm/myers-diff.ts';\r\n", "export enum BufferUsage {\r\n    None = 0,\r\n    Index = GPUBufferUsage.INDEX,\r\n    Vertex = GPUBufferUsage.VERTEX,\r\n    Uniform = GPUBufferUsage.UNIFORM,\r\n    Storage = GPUBufferUsage.STORAGE,\r\n    Indirect = GPUBufferUsage.INDIRECT,\r\n    CopySource = GPUBufferUsage.COPY_SRC,\r\n    CopyDestination = GPUBufferUsage.COPY_DST,\r\n\r\n    // No public available\r\n    // MapWrite = GPUBufferUsage.MAP_WRITE,\r\n    // MapRead = GPUBufferUsage.MAP_READ,\r\n    // QueryResolve = GPUBufferUsage.QUERY_RESOLVE\r\n}", "import { Exception } from '@kartoffelgames/core';\r\n\r\n/**\r\n * Reason list why a gpu object was invalidated.\r\n */\r\nexport class GpuObjectInvalidationReasons<TReasons extends string> {\r\n    private mDeconstruct: boolean;\r\n    private readonly mReasons: Set<TReasons>;\r\n\r\n    /**\r\n     * Life time was reached.\r\n     */\r\n    public get deconstruct(): boolean {\r\n        return this.mDeconstruct;\r\n    } set deconstruct(pDeconstruct: boolean) {\r\n        if (!pDeconstruct) {\r\n            throw new Exception(`Deconstruct reason can not be reverted. Sadly.`, this);\r\n        }\r\n\r\n        this.mDeconstruct = pDeconstruct;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mReasons = new Set<TReasons>();\r\n        this.mDeconstruct = false;\r\n    }\r\n\r\n    /**\r\n     * Add update reason.\r\n     * @param pReason - Update reason.\r\n     */\r\n    public add(pReason: TReasons): void {\r\n        this.mReasons.add(pReason);\r\n    }\r\n\r\n    /**\r\n     * If update reason has any existing reason.\r\n     */\r\n    public any(): boolean {\r\n        return this.mReasons.size > 0  || this.mDeconstruct;\r\n    }\r\n\r\n    /**\r\n     * Clear all reasons.\r\n     */\r\n    public clear(): void {\r\n        this.mReasons.clear();\r\n    }\r\n\r\n    /**\r\n     * Check for update reason.\r\n     * @param pReason - Update reason.\r\n     */\r\n    public has(pReason: TReasons): boolean {\r\n        return this.mReasons.has(pReason);\r\n    }\r\n}", "// @ts-types=\"npm:@webgpu/types\"\r\n\r\nimport { Dictionary, Exception, IDeconstructable, List, Writeable } from '@kartoffelgames/core';\r\nimport { GpuDevice } from '../device/gpu-device.ts';\r\nimport { GpuObjectInvalidationReasons } from './gpu-object-invalidation-reasons.ts';\r\nimport { GpuObjectSetup } from './gpu-object-setup.ts';\r\n\r\n/**\r\n * Object that handles gpu data, resources or configs.\r\n */\r\nexport abstract class GpuObject<TNativeObject = null, TInvalidationType extends string = '', TSetupObject extends GpuObjectSetup<any> | null = null> implements IDeconstructable {\r\n    private mDeconstructed: boolean;\r\n    private readonly mDevice: GpuDevice;\r\n    private readonly mInvalidationReasons: GpuObjectInvalidationReasons<TInvalidationType>;\r\n    private mIsSetup: boolean;\r\n    private mNativeObject: TNativeObject | null;\r\n    private readonly mUpdateListener: Dictionary<TInvalidationType, List<GpuObjectUpdateListener<TInvalidationType>>>;\r\n    private readonly mUpdateListenerAffectedTyped: WeakMap<GpuObjectUpdateListener<TInvalidationType>, Array<TInvalidationType>>;\r\n\r\n    /**\r\n     * Gpu Device.\r\n     */\r\n    public get device(): GpuDevice {\r\n        return this.mDevice;\r\n    }\r\n\r\n    /**\r\n     * Object was setup.\r\n     */\r\n    protected get isSetup(): boolean {\r\n        return this.mIsSetup;\r\n    }\r\n\r\n    /**\r\n     * Native gpu object.\r\n     */\r\n    protected get native(): TNativeObject {\r\n        return this.readNative();\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Gpu device.\r\n     * @param pNativeLifeTime - Lifetime of native object.\r\n     */\r\n    public constructor(pDevice: GpuDevice) {\r\n        // Save static settings.\r\n        this.mDevice = pDevice;\r\n        this.mIsSetup = false;\r\n\r\n        // Init default settings and config.\r\n        this.mDeconstructed = false;\r\n        this.mNativeObject = null;\r\n\r\n        // Init lists.\r\n        this.mUpdateListener = new Dictionary<TInvalidationType, List<GpuObjectUpdateListener<TInvalidationType>>>();\r\n        this.mUpdateListenerAffectedTyped = new WeakMap<GpuObjectUpdateListener<TInvalidationType>, Array<TInvalidationType>>();\r\n        this.mInvalidationReasons = new GpuObjectInvalidationReasons<TInvalidationType>();\r\n    }\r\n\r\n    /**\r\n     * Add invalidation listener.\r\n     * \r\n     * @param pListener - Listener.\r\n     * @param pAffected - Trigger listener only on those reasons.\r\n     * \r\n     * @returns this.\r\n     */\r\n    public addInvalidationListener(pListener: GpuObjectUpdateListener<TInvalidationType>, pFirstAffected: TInvalidationType, ...pAffected: Array<TInvalidationType>): this {\r\n        if (this.mUpdateListenerAffectedTyped.has(pListener)) {\r\n            throw new Exception(`Invalidation listener can't be applied twice.`, this);\r\n        }\r\n\r\n        // Concat first and optional types.\r\n        const lAffectedList: Array<TInvalidationType> = [pFirstAffected, ...pAffected];\r\n\r\n        // Listener to each affected\r\n        for (const lAffectedType of lAffectedList) {\r\n            // Init new affected bucket.\r\n            if (!this.mUpdateListener.has(lAffectedType)) {\r\n                this.mUpdateListener.set(lAffectedType, new List<GpuObjectUpdateListener<TInvalidationType>>());\r\n            }\r\n\r\n            // Assign listener to affected type.\r\n            this.mUpdateListener.get(lAffectedType)!.push(pListener);\r\n        }\r\n\r\n        // Map listener to affected types.\r\n        this.mUpdateListenerAffectedTyped.set(pListener, lAffectedList);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Deconstruct native object.\r\n     */\r\n    public deconstruct(): void {\r\n        this.mInvalidationReasons.deconstruct = true;\r\n\r\n        // Clear and destroy old native when any update reason exists.\r\n        if (this.mNativeObject !== null) {\r\n            this.destroyNative(this.mNativeObject, this.mInvalidationReasons);\r\n            this.mNativeObject = null;\r\n        }\r\n\r\n        this.mDeconstructed = true;\r\n    }\r\n\r\n    /**\r\n     * Invalidate native gpu object so it will be created again.\r\n     */\r\n    public invalidate(...pReasons: Array<TInvalidationType>): void {\r\n        // Single reason execution function.\r\n        const lExecuteReasonListener = (pReason: TInvalidationType) => {\r\n            // Skip reasons that already occurred or no native was created.\r\n            // This step ensures to execute invalidation listener for all gpu objects that doesn't create natives. \r\n            if (this.mNativeObject !== null && this.mInvalidationReasons.has(pReason)) {\r\n                return;\r\n            }\r\n\r\n            // Add invalidation reason.\r\n            this.mInvalidationReasons.add(pReason);\r\n\r\n            // Read listener list.\r\n            const lListenerList: List<GpuObjectUpdateListener<TInvalidationType>> | undefined = this.mUpdateListener.get(pReason);\r\n            if (!lListenerList || lListenerList.length === 0) {\r\n                return;\r\n            }\r\n\r\n            // Single execution of listener when only one exists.\r\n            if (lListenerList.length === 1) {\r\n                lListenerList[0](pReason);\r\n            } else {\r\n                for (const lListener of lListenerList) {\r\n                    lListener(pReason);\r\n                }\r\n            }\r\n        };\r\n\r\n        // Invalidate for each reason. Single reason execution when only one exists.\r\n        if (pReasons.length === 1) {\r\n            lExecuteReasonListener(pReasons[0]);\r\n        } else {\r\n            for (const lReason of pReasons) {\r\n                lExecuteReasonListener(lReason);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add invalidation listener.\r\n     * @param pListener - Listener.\r\n     */\r\n    public removeInvalidationListener(pListener: GpuObjectUpdateListener<TInvalidationType>): void {\r\n        // Get all affected types of listener.\r\n        const lAffectedList: Array<TInvalidationType> | undefined = this.mUpdateListenerAffectedTyped.get(pListener);\r\n        if (!lAffectedList) {\r\n            return;\r\n        }\r\n\r\n        // Remove all listener from each affected type.\r\n        for (const lAffectedType of lAffectedList) {\r\n            this.mUpdateListener.get(lAffectedType)!.remove(pListener);\r\n        }\r\n\r\n        // Remove listener from affected mapping.\r\n        this.mUpdateListenerAffectedTyped.delete(pListener);\r\n    }\r\n\r\n    /**\r\n     * Destroy native object.\r\n     * \r\n     * @param _pNative - Native object.\r\n     * @param _pReasons - Reason why it should be destroyed. \r\n     */\r\n    protected destroyNative(_pNative: TNativeObject, _pReasons: GpuObjectInvalidationReasons<TInvalidationType>): void {\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Throws when the gpu object not setup.\r\n     */\r\n    protected ensureSetup(): void {\r\n        if (!this.mIsSetup) {\r\n            throw new Exception('Gpu object must be setup to access properties.', this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate new native object.\r\n     * Return null when no native can be generated.\r\n     * \r\n     * @param _pCurrentNative - Current native element.\r\n     * @param _pReasons - Reason why it should be newly generated. \r\n     */\r\n    protected generateNative(_pCurrentNative: TNativeObject | null, _pReasons: GpuObjectInvalidationReasons<TInvalidationType>): TNativeObject | null {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Setup with setup object.\r\n     * \r\n     * @param _pReferences - Used references.\r\n     */\r\n    protected onSetup(_pReferences: GpuObjectSetupData<TSetupObject>): void {\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Create setup object.\r\n     * Return null to skip any setups.\r\n     * \r\n     * @param _pReferences - Unfilled setup references.\r\n     * \r\n     * @returns Setup object.\r\n     */\r\n    protected onSetupObjectCreate(_pReferences: GpuObjectSetupReferences<GpuObjectSetupData<TSetupObject>>): TSetupObject {\r\n        return null as TSetupObject;\r\n    }\r\n\r\n    /**\r\n     * Call setup.\r\n     * \r\n     * @param pSetupCallback - Setup callback. \r\n     * \r\n     * @returns this. \r\n     */\r\n    protected setup(pSetupCallback?: (pSetup: TSetupObject) => void): this {\r\n        // Dont call twice.\r\n        if (this.mIsSetup) {\r\n            throw new Exception(`Render targets setup can't be called twice.`, this);\r\n        }\r\n\r\n        // Create unfilled\r\n        const lSetupReferences: GpuObjectSetupReferences<GpuObjectSetupData<TSetupObject>> = {\r\n            inSetup: true,\r\n            device: this.mDevice,\r\n            data: {}\r\n        };\r\n\r\n        // Creates setup object.\r\n        const lSetupObject: TSetupObject | null = this.onSetupObjectCreate(lSetupReferences);\r\n        if (lSetupObject !== null) {\r\n            // Call optional user setup.\r\n            if (pSetupCallback) {\r\n                pSetupCallback(lSetupObject);\r\n            }\r\n\r\n            // Call gpu object setup. At this point all references should be filled.\r\n            this.onSetup(lSetupReferences.data as GpuObjectSetupData<TSetupObject>);\r\n        }\r\n\r\n        // Defuse setup references.\r\n        (<Writeable<GpuObjectSetupReferences<GpuObjectSetupData<TSetupObject>>>>lSetupReferences).inSetup = false;\r\n\r\n        // Set gpu object as setup.\r\n        this.mIsSetup = true;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update native object.\r\n     * \r\n     * @param _pNative - Native object.\r\n     * @param _pReasons - Reason why it should be updated. \r\n     * \r\n     * @returns true when native element was updated, false when it should be created anew.\r\n     */\r\n    protected updateNative(_pNative: TNativeObject, _pReasons: GpuObjectInvalidationReasons<TInvalidationType>): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Read up to date native object.\r\n     * Invalidates, destroys and generates the native object.\r\n     * \r\n     * @returns native object.\r\n     */\r\n    private readNative(): TNativeObject {\r\n        // Restrict deconstructed access.\r\n        if (this.mDeconstructed) {\r\n            throw new Exception(`Native GPU object was deconstructed and can't be used again.`, this);\r\n        }\r\n\r\n        // Ensure the setup was called.\r\n        if (!this.isSetup) {\r\n            // Call empty update.\r\n            this.setup();\r\n        }\r\n\r\n        // When native is generated and is invalid, try to update it.\r\n        if (this.mNativeObject !== null && this.mInvalidationReasons.any()) {\r\n            // Try to update native.\r\n            const lUpdateSuccessfull: boolean = this.updateNative(this.mNativeObject, this.mInvalidationReasons);\r\n            if (lUpdateSuccessfull) {\r\n                this.mInvalidationReasons.clear();\r\n            }\r\n        }\r\n\r\n        // When no native is generated or update was not successfull.\r\n        if (this.mNativeObject === null || this.mInvalidationReasons.any()) {\r\n            // Save current native.\r\n            const lCurrentNative: TNativeObject | null = this.mNativeObject;\r\n\r\n            // Generate new native.\r\n            this.mNativeObject = this.generateNative(lCurrentNative, this.mInvalidationReasons);\r\n\r\n            // Destroy old native when existing.\r\n            if (lCurrentNative !== null) {\r\n                this.destroyNative(lCurrentNative, this.mInvalidationReasons);\r\n            }\r\n\r\n            // Reset all update reasons.\r\n            this.mInvalidationReasons.clear();\r\n        }\r\n\r\n        return this.mNativeObject!;\r\n    }\r\n}\r\n\r\ntype GpuObjectSetupData<TGpuObjectSetup> = TGpuObjectSetup extends GpuObjectSetup<infer T> ? T : never;\r\n\r\nexport interface GpuObjectSetupReferences<TSetupReferenceData> {\r\n    readonly device: GpuDevice;\r\n    readonly inSetup: boolean;\r\n    readonly data: Partial<TSetupReferenceData>;\r\n}\r\n\r\nexport type GpuObjectUpdateListener<TInvalidationReason extends string> = (pReason: TInvalidationReason) => void;", "import { GpuDevice } from '../device/gpu-device.ts';\r\nimport { GpuObject } from './gpu-object.ts';\r\nimport { GpuObjectSetup } from './gpu-object-setup.ts';\r\n\r\n/**\r\n * Gpu resource object.\r\n * Takes actual memory space on gpu hardware.\r\n */\r\nexport class GpuResourceObject<TUsageType extends number = number, TNativeObject = null, TInvalidationType extends string = '', TSetupObject extends GpuObjectSetup<any> | null = null> extends GpuObject<TNativeObject, TInvalidationType | GpuResourceObjectInvalidationType, TSetupObject> {\r\n    private mResourceUsage: TUsageType;\r\n\r\n    /**\r\n     * Texture usage.\r\n     */\r\n    protected get usage(): TUsageType {\r\n        return this.mResourceUsage;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Device.\r\n     */\r\n    public constructor(pDevice: GpuDevice) {\r\n        super(pDevice);\r\n\r\n        // Set static config.\r\n        this.mResourceUsage = 0 as TUsageType;\r\n    }\r\n\r\n    /**\r\n     * Extend usage of resource.\r\n     * Might trigger a resource rebuild.\r\n     * \r\n     * @param pUsage - Usage. \r\n     */\r\n    public extendUsage(pUsage: TUsageType): this {\r\n        // Update onyl when not already set.\r\n        if ((this.mResourceUsage & pUsage) === 0) {\r\n            this.mResourceUsage = (this.mResourceUsage | pUsage) as TUsageType ;\r\n            this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nexport enum GpuResourceObjectInvalidationType {\r\n    ResourceRebuild = 'ResourceRebuild'\r\n}\r\n", "/**\r\n * Gpu limit names.\r\n */\r\nexport enum GpuLimit {\r\n    MaxTextureDimension1D = 'maxTextureDimension1D',\r\n    MaxTextureDimension2D = 'maxTextureDimension2D',\r\n    MaxTextureDimension3D = 'maxTextureDimension3D',\r\n    MaxTextureArrayLayers = 'maxTextureArrayLayers',\r\n    MaxBindGroups = 'maxBindGroups',\r\n    MaxBindGroupsPlusVertexBuffers = 'maxBindGroupsPlusVertexBuffers',\r\n    MaxBindingsPerBindGroup = 'maxBindingsPerBindGroup',\r\n    MaxDynamicUniformBuffersPerPipelineLayout = 'maxDynamicUniformBuffersPerPipelineLayout',\r\n    MaxDynamicStorageBuffersPerPipelineLayout = 'maxDynamicStorageBuffersPerPipelineLayout',\r\n    MaxSampledTexturesPerShaderStage = 'maxSampledTexturesPerShaderStage',\r\n    MaxSamplersPerShaderStage = 'maxSamplersPerShaderStage',\r\n    MaxStorageBuffersPerShaderStage = 'maxStorageBuffersPerShaderStage',\r\n    MaxStorageTexturesPerShaderStage = 'maxStorageTexturesPerShaderStage',\r\n    MaxUniformBuffersPerShaderStage = 'maxUniformBuffersPerShaderStage',\r\n    MaxUniformBufferBindingSize = 'maxUniformBufferBindingSize',\r\n    MaxStorageBufferBindingSize = 'maxStorageBufferBindingSize',\r\n    MinUniformBufferOffsetAlignment = 'minUniformBufferOffsetAlignment',\r\n    MinStorageBufferOffsetAlignment = 'minStorageBufferOffsetAlignment',\r\n    MaxVertexBuffers = 'maxVertexBuffers',\r\n    MaxBufferSize = 'maxBufferSize',\r\n    MaxVertexAttributes = 'maxVertexAttributes',\r\n    MaxVertexBufferArrayStride = 'maxVertexBufferArrayStride',\r\n    MaxInterStageShaderVariables = 'maxInterStageShaderVariables',\r\n    MaxColorAttachments = 'maxColorAttachments',\r\n    MaxColorAttachmentBytesPerSample = 'maxColorAttachmentBytesPerSample',\r\n    MaxComputeWorkgroupStorageSize = 'maxComputeWorkgroupStorageSize',\r\n    MaxComputeInvocationsPerWorkgroup = 'maxComputeInvocationsPerWorkgroup',\r\n    MaxComputeWorkgroupSizeX = 'maxComputeWorkgroupSizeX',\r\n    MaxComputeWorkgroupSizeY = 'maxComputeWorkgroupSizeY',\r\n    MaxComputeWorkgroupSizeZ = 'maxComputeWorkgroupSizeZ',\r\n    MaxComputeWorkgroupsPerDimension = 'maxComputeWorkgroupsPerDimension',\r\n}\r\n", "export enum StorageBindingType {\r\n    None = 0,\r\n    Read = 1,\r\n    Write = 2,\r\n    ReadWrite = 4\r\n}", "import { Exception, TypedArray } from '@kartoffelgames/core';\r\nimport { GpuLimit } from '../constant/gpu-limit.enum.ts';\r\nimport { StorageBindingType } from '../constant/storage-binding-type.enum.ts';\r\nimport { GpuBuffer } from './gpu-buffer.ts';\r\nimport { BaseBufferMemoryLayout } from './memory_layout/base-buffer-memory-layout.ts';\r\n\r\n/**\r\n * Create a view to look at a gpu buffer.\r\n */\r\nexport class GpuBufferView<T extends TypedArray> {\r\n    private readonly mBuffer: GpuBuffer;\r\n    private readonly mDynamicOffset: number;\r\n    private readonly mLayout: BaseBufferMemoryLayout;\r\n    private readonly mTypedArrayConstructor: GpuBufferViewFormat<T>;\r\n\r\n    /**\r\n     * Get underlying buffer of view.\r\n     */\r\n    public get buffer(): GpuBuffer {\r\n        return this.mBuffer;\r\n    }\r\n\r\n    /**\r\n     * Index of dynamic offset.\r\n     */\r\n    public get dynamicOffsetIndex(): number {\r\n        return this.mDynamicOffset / this.mLayout.fixedSize;\r\n    }\r\n\r\n    /**\r\n     * Buffer view format.\r\n     */\r\n    public get format(): GpuBufferViewFormat<T> {\r\n        return this.mTypedArrayConstructor;\r\n    }\r\n\r\n    /**\r\n     * Length of buffer view based on view type.\r\n     */\r\n    public get length(): number {\r\n        return this.mBuffer.size / this.mTypedArrayConstructor.BYTES_PER_ELEMENT;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pBuffer - Views buffer. \r\n     * @param pLayout - Layout of view.\r\n     * @param pDynamicOffsetIndex - Index of dynamic offset.\r\n     */\r\n    public constructor(pBuffer: GpuBuffer, pLayout: BaseBufferMemoryLayout, pType: GpuBufferViewFormat<T>, pDynamicOffsetIndex: number = 0, pStorageType: StorageBindingType = StorageBindingType.None) {\r\n        // Layout must fit into buffer.\r\n        if (pLayout.fixedSize > pBuffer.size) {\r\n            throw new Exception(`Buffer view fixed size (${pLayout.fixedSize}) exceedes buffer size (${pBuffer.size}). Buffer must at least be the layouts fixed size.`, this);\r\n        }\r\n\r\n        // Default dynamic offset.\r\n        this.mDynamicOffset = 0;\r\n\r\n        // Calculate and validate dynamic offset.\r\n        if (pDynamicOffsetIndex > 0) {\r\n            // Dynamic offsets can only be applied to fixed buffer layouts.\r\n            if (pLayout.variableSize > 0) {\r\n                throw new Exception('Dynamic offsets can only be applied to fixed buffer layouts.', this);\r\n            }\r\n\r\n            // Read correct alignment limitations for storage type.\r\n            const lOffsetAlignment: number = (() => {\r\n                if (pStorageType === StorageBindingType.None) {\r\n                    return pBuffer.device.capabilities.getLimit(GpuLimit.MinUniformBufferOffsetAlignment);\r\n                } else {\r\n                    return pBuffer.device.capabilities.getLimit(GpuLimit.MinStorageBufferOffsetAlignment);\r\n                }\r\n            })();\r\n\r\n            // Apply offset alignment to byte size.\r\n            const lMinBufferSize: number = (Math.ceil(pLayout.fixedSize / lOffsetAlignment) * lOffsetAlignment) * (pDynamicOffsetIndex + 1);\r\n            if (pBuffer.size < lMinBufferSize) {\r\n                throw new Exception(`Buffer view offset size (${lMinBufferSize}) exceedes buffer size ${pBuffer.size}.`, this);\r\n            }\r\n\r\n            this.mDynamicOffset = (Math.ceil(pLayout.fixedSize / lOffsetAlignment) * lOffsetAlignment) * pDynamicOffsetIndex;\r\n        }\r\n\r\n        this.mLayout = pLayout;\r\n        this.mBuffer = pBuffer;\r\n        this.mTypedArrayConstructor = pType;\r\n\r\n    }\r\n\r\n    /**\r\n     * Read buffer on layout location.\r\n     * \r\n     * @param pLayoutPath - Layout path. \r\n     */\r\n    public async read(pLayoutPath: Array<string> = []): Promise<TypedArray> {\r\n        const lLocation = this.mLayout.locationOf(pLayoutPath);\r\n\r\n        return new this.mTypedArrayConstructor(await this.mBuffer.read(this.mDynamicOffset + lLocation.offset, lLocation.size));\r\n    }\r\n\r\n    /**\r\n     * Write data on layout location.\r\n     * \r\n     * @param pData - Data.\r\n     * @param pLayoutPath - Layout path.\r\n     */\r\n    public async write(pData: ArrayLike<number>, pLayoutPath: Array<string> = []): Promise<void> {\r\n        const lLocation = this.mLayout.locationOf(pLayoutPath);\r\n\r\n        // Add data into a data buffer.\r\n        const lDataBuffer: TypedArray = new this.mTypedArrayConstructor(pData);\r\n\r\n        // Skip new promise creation by returning original promise.\r\n        return this.mBuffer.write(lDataBuffer.buffer, this.mDynamicOffset + lLocation.offset);\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport type GpuBufferViewFormat<T extends TypedArray> = (new (pArrayLike: ArrayLike<number> | ArrayBufferLike) => T) & { BYTES_PER_ELEMENT: number; };", "import { Exception, TypedArray } from '@kartoffelgames/core';\r\nimport { BufferUsage } from '../constant/buffer-usage.enum.ts';\r\nimport { GpuDevice } from '../device/gpu-device.ts';\r\nimport { GpuResourceObject, GpuResourceObjectInvalidationType } from '../gpu_object/gpu-resource-object.ts';\r\nimport { IGpuObjectNative } from '../gpu_object/interface/i-gpu-object-native.ts';\r\nimport { GpuBufferView, GpuBufferViewFormat } from './gpu-buffer-view.ts';\r\nimport { BaseBufferMemoryLayout } from './memory_layout/base-buffer-memory-layout.ts';\r\n\r\n/**\r\n * GpuBuffer. Uses local and native gpu buffers.\r\n */\r\nexport class GpuBuffer extends GpuResourceObject<BufferUsage, GPUBuffer> implements IGpuObjectNative<GPUBuffer> {\r\n    private mByteSize: number;\r\n    private mInitialData: ArrayBufferLike | null | undefined;\r\n    private mReadBuffer: GPUBuffer | null;\r\n    private readonly mWriteBuffer: GpuBufferWriteBuffer;\r\n\r\n    /**\r\n     * Native gpu object.\r\n     */\r\n    public override get native(): GPUBuffer {\r\n        return super.native;\r\n    }\r\n\r\n    /**\r\n     * Buffer size in bytes aligned to 4 bytes.\r\n     */\r\n    public get size(): number {\r\n        // Align data size by 4 byte.\r\n        return this.mByteSize;\r\n    } set size(pByteCount: number) {\r\n        // Calculate size. Align to 4 byte. Allways.\r\n        this.mByteSize = ((pByteCount) + 3) & ~3;\r\n\r\n        this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * Write buffer limitation.\r\n     * Limiting the amount of created staging buffer to perform reads.\r\n     */\r\n    public get writeBufferLimitation(): number {\r\n        return this.mWriteBuffer.limitation;\r\n    } set writeBufferLimitation(pLimit: number) {\r\n        this.mWriteBuffer.limitation = pLimit;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - GPU.\r\n     * @param pLayout - Buffer layout.\r\n     * @param pInitialData  - Inital data. Can be empty. Or Buffer size. \r\n     */\r\n    public constructor(pDevice: GpuDevice, pByteCount: number) {\r\n        super(pDevice);\r\n\r\n        // Calculate size. Align to 4 byte. Allways.\r\n        this.mByteSize = ((pByteCount) + 3) & ~3;\r\n\r\n        // Allways add copy source/destination to copy over information on rebuild.\r\n        this.extendUsage(BufferUsage.CopyDestination);\r\n        this.extendUsage(BufferUsage.CopySource);\r\n\r\n        // Read and write buffers.\r\n        this.mWriteBuffer = {\r\n            limitation: Number.MAX_SAFE_INTEGER,\r\n            ready: new Array<GPUBuffer>(),\r\n            buffer: new Set<GPUBuffer>()\r\n        };\r\n        this.mReadBuffer = null;\r\n\r\n        // No intial data.\r\n        this.mInitialData = null;\r\n    }\r\n\r\n    /**\r\n     * Set new initial data before the buffer is created.\r\n     * \r\n     * @param pDataCallback - Data callback. \r\n     */\r\n    public initialData(pInitialData: ArrayBufferLike): this {\r\n        // Initial is inital.\r\n        if (this.mInitialData !== null) {\r\n            throw new Exception('Initial callback can only be set once.', this);\r\n        }\r\n\r\n        // Set new initial data, set on creation.\r\n        this.mInitialData = pInitialData;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Read data raw without layout.\r\n     * \r\n     * @param pOffset - Data read offset in byte.\r\n     * @param pSize - Data read size in byte.\r\n     */\r\n    public async read(pOffset?: number | undefined, pSize?: number | undefined): Promise<ArrayBuffer> {\r\n        // Set buffer as writeable.\r\n        this.extendUsage(BufferUsage.CopySource);\r\n\r\n        const lOffset: number = pOffset ?? 0;\r\n        const lSize: number = pSize ?? this.size - lOffset;\r\n\r\n        // Create a new buffer when it is not already created.\r\n        if (this.mReadBuffer === null) {\r\n            this.mReadBuffer = this.device.gpu.createBuffer({\r\n                label: `ReadWaveBuffer`,\r\n                size: this.size,\r\n                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\r\n                mappedAtCreation: false,\r\n            });\r\n        }\r\n\r\n        // Copy buffer data from native into staging.\r\n        const lCommandDecoder: GPUCommandEncoder = this.device.gpu.createCommandEncoder();\r\n        lCommandDecoder.copyBufferToBuffer(this.native, lOffset, this.mReadBuffer, lOffset, lSize);\r\n        this.device.gpu.queue.submit([lCommandDecoder.finish()]);\r\n\r\n        // Get buffer and map data.\r\n        await this.mReadBuffer.mapAsync(GPUMapMode.READ, lOffset, lSize);\r\n\r\n        // Read result from mapped range and copy it with slice.\r\n        const lBufferReadResult: ArrayBuffer = this.mReadBuffer.getMappedRange().slice(0);\r\n\r\n        // Map read buffer again.\r\n        this.mReadBuffer.unmap();\r\n\r\n        // Get mapped data and force it into typed array.\r\n        return lBufferReadResult;\r\n    }\r\n\r\n    /**\r\n     * Create view of buffer.\r\n     * \r\n     * @param pLayout - View layout.\r\n     * @param pType - Type of view.\r\n     * @param pDynamicOffsetIndex - Index of dynamic offset.\r\n     * \r\n     * @returns view of buffer. \r\n     */\r\n    public view<T extends TypedArray>(pLayout: BaseBufferMemoryLayout, pType: GpuBufferViewFormat<T>, pDynamicOffsetIndex: number = 0): GpuBufferView<T> {\r\n        return new GpuBufferView(this, pLayout, pType, pDynamicOffsetIndex);\r\n    }\r\n\r\n    /**\r\n     * Write data raw without layout.\r\n     * \r\n     * @param pData - Data.\r\n     * @param pOffset - Data offset.\r\n     */\r\n    public async write(pData: ArrayBufferLike, pOffset?: number): Promise<void> {\r\n        // Set buffer as writeable.\r\n        this.extendUsage(BufferUsage.CopyDestination);\r\n\r\n        // Read native before reading staging buffers.\r\n        // On Native read, staging buffers can be destroyed.\r\n        const lNative: GPUBuffer = this.native;\r\n\r\n        // Try to read a mapped buffer from waving list.\r\n        let lStagingBuffer: GPUBuffer | null = null;\r\n        if (this.mWriteBuffer.ready.length === 0) {\r\n            // Create new buffer when limitation is not meet.\r\n            if (this.mWriteBuffer.buffer.size < this.mWriteBuffer.limitation) {\r\n                lStagingBuffer = this.device.gpu.createBuffer({\r\n                    label: `RingBuffer-WriteWaveBuffer-${this.mWriteBuffer.buffer.size}`,\r\n                    size: this.size,\r\n                    usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,\r\n                    mappedAtCreation: true,\r\n                });\r\n\r\n                // Add new buffer to complete list.\r\n                this.mWriteBuffer.buffer.add(lStagingBuffer);\r\n            }\r\n        } else {\r\n            // Pop as long as staging buffer is not destroyed or could not be found.\r\n            lStagingBuffer = this.mWriteBuffer.ready.pop()!;\r\n        }\r\n\r\n        // Convert views into array buffers.\r\n        let lDataArrayBuffer: ArrayBufferLike = pData;\r\n        if (ArrayBuffer.isView(lDataArrayBuffer)) {\r\n            lDataArrayBuffer = lDataArrayBuffer.buffer;\r\n        }\r\n\r\n        // Get byte length and offset of data to write.\r\n        const lDataByteLength: number = lDataArrayBuffer.byteLength;\r\n        const lOffset: number = pOffset ?? 0;\r\n\r\n        // When no staging buffer is available, use the slow native.\r\n        if (!lStagingBuffer) {\r\n            // Write data into mapped range.\r\n            this.device.gpu.queue.writeBuffer(lNative, lOffset, lDataArrayBuffer, 0, lDataByteLength);\r\n\r\n            return;\r\n        }\r\n\r\n        // Execute write operations on waving buffer.\r\n        const lMappedBuffer: ArrayBuffer = lStagingBuffer.getMappedRange(lOffset, lDataByteLength);\r\n\r\n        // Set data to mapped buffer. Use the smallest available byte view (1 byte).\r\n        new Int8Array(lMappedBuffer).set(new Int8Array(lDataArrayBuffer));\r\n\r\n        // Unmap for copying data.\r\n        lStagingBuffer.unmap();\r\n\r\n        // Copy buffer data from staging into wavig buffer.\r\n        const lCommandDecoder: GPUCommandEncoder = this.device.gpu.createCommandEncoder();\r\n        lCommandDecoder.copyBufferToBuffer(lStagingBuffer, lOffset, lNative, lOffset, lDataByteLength);\r\n        this.device.gpu.queue.submit([lCommandDecoder.finish()]);\r\n\r\n        // Shedule staging buffer remaping.\r\n        lStagingBuffer.mapAsync(GPUMapMode.WRITE).then(() => {\r\n            // Check for destroyed state, it is destroyed when not in write buffer list.\r\n            if (this.mWriteBuffer.buffer.has(lStagingBuffer)) {\r\n                this.mWriteBuffer.ready.push(lStagingBuffer);\r\n            }\r\n        }).catch(() => {\r\n            // Remove buffer when it could not be mapped.\r\n            this.mWriteBuffer.buffer.delete(lStagingBuffer);\r\n            lStagingBuffer.destroy();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Destroy wave and ready buffer.\r\n     */\r\n    protected override destroyNative(pNativeObject: GPUBuffer): void {\r\n        pNativeObject.destroy();\r\n\r\n        // Destroy all wave buffer and clear list.\r\n        for (const lWriteBuffer of this.mWriteBuffer.buffer) {\r\n            lWriteBuffer.destroy();\r\n        }\r\n        this.mWriteBuffer.buffer.clear();\r\n\r\n        // Clear ready buffer list.\r\n        while (this.mWriteBuffer.ready.length > 0) {\r\n            // No need to destroy. All buffers have already destroyed.\r\n            this.mWriteBuffer.ready.pop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate buffer. Write local gpu object data as initial native buffer data.\r\n     */\r\n    protected override generateNative(pLastNative: GPUBuffer | null): GPUBuffer {\r\n        // Create gpu buffer mapped\r\n        const lBuffer: GPUBuffer = this.device.gpu.createBuffer({\r\n            label: 'Ring-Buffer-Static-Buffer',\r\n            size: this.size,\r\n            usage: this.usage,\r\n            mappedAtCreation: !!this.mInitialData\r\n        });\r\n\r\n        // Write data. Is completly async.\r\n        if (this.mInitialData) {\r\n            // Convert views into array buffers.\r\n            let lDataArrayBuffer: ArrayBufferLike = this.mInitialData;\r\n            if (ArrayBuffer.isView(lDataArrayBuffer)) {\r\n                lDataArrayBuffer = lDataArrayBuffer.buffer;\r\n            }\r\n\r\n            // Write initial data.\r\n            const lMappedBuffer: ArrayBuffer = lBuffer.getMappedRange();\r\n\r\n            // Validate buffer and initial data length.\r\n            if (lMappedBuffer.byteLength !== lDataArrayBuffer.byteLength) {\r\n                throw new Exception(`Initial buffer data (byte-length: ${lDataArrayBuffer.byteLength}) does not fit into buffer (length: ${lMappedBuffer.byteLength}). `, this);\r\n            }\r\n\r\n            // Set data to buffer. Use the smallest available byte view (1 byte).\r\n            new Int8Array(lMappedBuffer).set(new Int8Array(lDataArrayBuffer));\r\n\r\n            // Unmap buffer.\r\n            lBuffer.unmap();\r\n\r\n            // Clear inital data.\r\n            this.mInitialData = undefined;\r\n        }\r\n\r\n        // Try to copy last data into new buffer.\r\n        if (pLastNative) {\r\n            const lCommandDecoder: GPUCommandEncoder = this.device.gpu.createCommandEncoder();\r\n            lCommandDecoder.copyBufferToBuffer(pLastNative, 0, lBuffer, 0, Math.min(pLastNative.size, lBuffer.size));\r\n            this.device.gpu.queue.submit([lCommandDecoder.finish()]);\r\n        }\r\n\r\n        return lBuffer;\r\n    }\r\n}\r\n\r\ntype GpuBufferWriteBuffer = {\r\n    buffer: Set<GPUBuffer>;\r\n    ready: Array<GPUBuffer>;\r\n    limitation: number;\r\n};", "export enum BufferItemFormat {\r\n    Float32 = 'float32',\r\n    Uint32 = 'uint32',\r\n    Sint32 = 'sint32',\r\n\r\n    // Extended vertex formats.\r\n    Float16 = 'float16',\r\n    Uint8 = 'uint8',\r\n    Sint8 = 'sint8',\r\n    Uint16 = 'uint16',\r\n    Sint16 = 'sint16',\r\n    Unorm16 = 'unorm16',\r\n    Snorm16 = 'snorm16',\r\n    Unorm8 = 'unorm8',\r\n    Snorm8 = 'snorm8'\r\n}", "export enum BufferItemMultiplier {\r\n    // Single\r\n    Single = 'x1',\r\n    \r\n    // Vector\r\n    Vector2 = 'v2',\r\n    Vector3 = 'v3',\r\n    Vector4 = 'v4',\r\n\r\n    // Matrix\r\n    Matrix22 = 'm22',\r\n    Matrix23 = 'm23',\r\n    Matrix24 = 'm24',\r\n    Matrix32 = 'm32',\r\n    Matrix33 = 'm33',\r\n    Matrix34 = 'm34',\r\n    Matrix42 = 'm42',\r\n    Matrix43 = 'm43',\r\n    Matrix44 = 'm44',\r\n}", "export enum CompareFunction {\r\n    Never = 'never',\r\n    Less = 'less',\r\n    Equal = 'equal',\r\n    LessEqual = 'less-equal',\r\n    Greater = 'greater',\r\n    NotEqual = 'not-equal',\r\n    GreaterEqual = 'greater-equal',\r\n    Allways = 'always'\r\n}", "export enum ComputeStage {\r\n    None = 0,\r\n    Fragment = GPUShaderStage.FRAGMENT,\r\n    Vertex = GPUShaderStage.VERTEX,\r\n    Compute = GPUShaderStage.COMPUTE\r\n}\r\n", "/**\r\n * Gpu feature names.\r\n */\r\nexport enum GpuFeature {\r\n    DepthClipControl = 'depth-clip-control',\r\n    Depth32floatStencil8 = 'depth32float-stencil8',\r\n    TextureCompressionBc = 'texture-compression-bc',\r\n    TextureCompressionBcSliced3d = 'texture-compression-bc-sliced-3d',\r\n    TextureCompressionEtc2 = 'texture-compression-etc2',\r\n    TextureCompressionAstc = 'texture-compression-astc',\r\n    TimestampQuery = 'timestamp-query',\r\n    IndirectFirstInstance = 'indirect-first-instance',\r\n    ShaderF16 = 'shader-f16',\r\n    Rg11b10ufloatRenderable = 'rg11b10ufloat-renderable',\r\n    Bgra8unormStorage = 'bgra8unorm-storage',\r\n    Float32Filterable = 'float32-filterable',\r\n    ClipDistances = 'clip-distances',\r\n    DualSourceBlendin = 'dual-source-blending'\r\n}", "export enum PrimitiveCullMode {\r\n    None = 'none',\r\n    Front = 'front',\r\n    Back = 'back'\r\n}", "export enum SamplerType {\r\n    Filter = 'filtering',\r\n    NoneFiltering = 'non-filtering',\r\n    Comparison = 'comparison'\r\n}", "export enum TextureBlendFactor {\r\n    Zero = 'zero',\r\n    One = 'one',\r\n    Src = 'src',\r\n    OneMinusSrc = 'one-minus-src',\r\n    SrcAlpha = 'src-alpha',\r\n    OneMinusSrcAlpha = 'one-minus-src-alpha',\r\n    Dst = 'dst',\r\n    OneMinusDst = 'one-minus-dst',\r\n    DstAlpha = 'dst-alpha',\r\n    OneMinusDstAlpha = 'one-minus-dst-alpha',\r\n    SrcAlphaSaturated = 'src-alpha-saturated',\r\n    Constant = 'constant',\r\n    OneMinusConstant = 'one-minus-constant',\r\n    Src1 = 'src1',\r\n    OneMinusSrc1 = 'one-minus-src1',\r\n    Src1Alpha = 'src1-alpha',\r\n    OneMinusSrc1Alpha = 'one-minus-src1-alpha'\r\n}", "export enum TextureBlendOperation {\r\n    Add = 'add',\r\n    Subtract = 'subtract',\r\n    ReverseSubtract = 'reverse-subtract',\r\n    Min = 'min',\r\n    Max = 'max'\r\n}\r\n", "export enum TextureFormat {\r\n    // 8-bit formats\r\n    R8unorm = 'r8unorm',\r\n    R8snorm = 'r8snorm',\r\n    R8uint = 'r8uint',\r\n    R8sint = 'r8sint',\r\n\r\n    // 16-bit formats\r\n    R16uint = 'r16uint',\r\n    R16sint = 'r16sint',\r\n    R16float = 'r16float',\r\n    Rg8unorm = 'rg8unorm',\r\n    Rg8snorm = 'rg8snorm',\r\n    Rg8uint = 'rg8uint',\r\n    Rg8sint = 'rg8sint',\r\n\r\n    // 32-bit formats\r\n    R32uint = 'r32uint',\r\n    R32sint = 'r32sint',\r\n    R32float = 'r32float',\r\n    Rg16uint = 'rg16uint',\r\n    Rg16sint = 'rg16sint',\r\n    Rg16float = 'rg16float',\r\n    Rgba8unorm = 'rgba8unorm',\r\n    Rgba8unormSrgb = 'rgba8unorm-srgb',\r\n    Rgba8snorm = 'rgba8snorm',\r\n    Rgba8uint = 'rgba8uint',\r\n    Rgba8sint = 'rgba8sint',\r\n    Bgra8unorm = 'bgra8unorm',\r\n    Bgra8unormSrgb = 'bgra8unorm-srgb',\r\n\r\n    // Packed 32-bit formats\r\n    Rgb9e5ufloat = 'rgb9e5ufloat',\r\n    Rgb10a2uint = 'rgb10a2uint',\r\n    Rgb10a2unorm = 'rgb10a2unorm',\r\n    Rg11b10ufloat = 'rg11b10ufloat',\r\n\r\n    // 64-bit formats\r\n    Rg32uint = 'rg32uint',\r\n    Rg32sint = 'rg32sint',\r\n    Rg32float = 'rg32float',\r\n    Rgba16uint = 'rgba16uint',\r\n    Rgba16sint = 'rgba16sint',\r\n    Rgba16float = 'rgba16float',\r\n\r\n    // 128-bit formats\r\n    Rgba32uint = 'rgba32uint',\r\n    Rgba32sint = 'rgba32sint',\r\n    Rgba32float = 'rgba32float',\r\n\r\n    // Depth/stencil formats\r\n    Stencil8 = 'stencil8',\r\n    Depth16unorm = 'depth16unorm',\r\n    Depth24plus = 'depth24plus',\r\n    Depth24plusStencil8 = 'depth24plusStencil8',\r\n    Depth32float = 'depth32float',\r\n\r\n    // \"depth32float-stencil8\" feature\r\n    Depth32floatStencil8 = 'depth32floatStencil8',\r\n\r\n    // BC compressed formats usable if \"texture-compression-bc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    Bc1RgbaUnorm = 'bc1-rgba-unorm',\r\n    Bc1RgbaUnormSrgb = 'bc1-rgba-unorm-srgb',\r\n    Bc2RgbaUnorm = 'bc2-rgba-unorm',\r\n    Bc2RgbaUnormSrgb = 'bc2-rgba-unorm-srgb',\r\n    Bc3RgbaUnorm = 'bc3-rgba-unorm',\r\n    Bc3RgbaUnormSrgb = 'bc3-rgba-unorm-srgb',\r\n    Bc4Runorm = 'bc4-r-unorm',\r\n    Bc4Rsnorm = 'bc4-r-snorm',\r\n    Bc5RgUnorm = 'bc5-rg-unorm',\r\n    Bc5RgSnorm = 'bc5-rg-snorm',\r\n    Bc6hRgbUfloat = 'bc6h-rgb-ufloat',\r\n    Bc6hRgbFloat = 'bc6h-rgb-float',\r\n    Bc7RgbaUnorm = 'bc7-rgba-unorm',\r\n    Bc7RgbaUnormSrgb = 'bc7-rgba-unorm-srgb',\r\n\r\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    Etc2Rgb8unorm = 'etc2-rgb8unorm',\r\n    Etc2Rgb8unormSrgb = 'etc2-rgb8unorm-srgb',\r\n    Etc2Rgb8a1unorm = 'etc2-rgb8a1unorm',\r\n    Etc2Rgb8a1unormSrgb = 'etc2-rgb8a1unorm-srgb',\r\n    Etc2Rgba8unorm = 'etc2-rgba8unorm',\r\n    Etc2Rgba8unormSrgb = 'etc2-rgba8unorm-srgb',\r\n    EacR11unorm = 'eac-r11unorm',\r\n    EacR11snorm = 'eac-r11snorm',\r\n    EacRg11unorm = 'eac-rg11unorm',\r\n    EacRg11snorm = 'eac-rg11snorm',\r\n\r\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    Astc4x4unorm = 'astc-4x4-unorm',\r\n    Astc4x4unormSrgb = 'astc-4x4-unorm-srgb',\r\n    Astc5x4unorm = 'astc-5x4-unorm',\r\n    Astc5x4unormSrgb = 'astc-5x4-unorm-srgb',\r\n    Astc5x5unorm = 'astc-5x5-unorm',\r\n    Astc5x5unormSrgb = 'astc-5x5-unorm-srgb',\r\n    Astc6x5unorm = 'astc-6x5-unorm',\r\n    Astc6x5unormSrgb = 'astc-6x5-unorm-srgb',\r\n    Astc6x6unorm = 'astc-6x6-unorm',\r\n    Astc6x6unormSrgb = 'astc-6x6-unorm-srgb',\r\n    Astc8x5unorm = 'astc-8x5-unorm',\r\n    Astc8x5unormSrgb = 'astc-8x5-unorm-srgb',\r\n    Astc8x6unorm = 'astc-8x6-unorm',\r\n    Astc8x6unormSrgb = 'astc-8x6-unorm-srgb',\r\n    Astc8x8unorm = 'astc-8x8-unorm',\r\n    Astc8x8unormSrgb = 'astc-8x8-unorm-srgb',\r\n    Astc10x5unorm = 'astc-10x5-unorm',\r\n    Astc10x5unormSrgb = 'astc-10x5-unorm-srgb',\r\n    Astc10x6unorm = 'astc-10x6-unorm',\r\n    Astc10x6unormSrgb = 'astc-10x6-unorm-srgb',\r\n    Astc10x8unorm = 'astc-10x8-unorm',\r\n    Astc10x8unormSrgb = 'astc-10x8-unorm-srgb',\r\n    Astc10x10unorm = 'astc-10x10-unorm',\r\n    Astc10x10unormSrgb = 'astc-10x10-unorm-srgb',\r\n    Astc12x10unorm = 'astc-12x10-unorm',\r\n    Astc12x10unormSrgb = 'astc-12x10-unorm-srgb',\r\n    Astc12x12unorm = 'astc-12x12-unorm',\r\n    Astc12x12unormSrgb = 'astc-12x12-unorm-srgb'\r\n}", "export enum TextureViewDimension {\r\n    OneDimension = '1d',\r\n    TwoDimension = '2d',\r\n    TwoDimensionArray = '2d-array',\r\n    Cube = 'cube',\r\n    CubeArray = 'cube-array',\r\n    ThreeDimension = '3d'\r\n}", "export enum VertexParameterStepMode {\r\n    Vertex = 'vertex-step',\r\n    Index = 'index-step',\r\n    Instance = 'instance-step',\r\n}", "import { GpuDevice } from '../device/gpu-device.ts';\r\nimport { GpuObject } from '../gpu_object/gpu-object.ts';\r\n\r\n/**\r\n * Bundles execute calls to execute them bunched.\r\n */\r\nexport class GpuExecution extends GpuObject {\r\n    private readonly mExecutionFunction: GpuExecutionFunction;\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pDevice - Device reference. \r\n     * @param pExecution - Main execution function.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pExecution: GpuExecutionFunction) {\r\n        super(pDevice);\r\n\r\n        this.mExecutionFunction = pExecution;\r\n    }\r\n\r\n    /**\r\n     * Execute with context.\r\n     */\r\n    public execute(): void {\r\n        // Create command encoder.\r\n        const lCommandEncoder: GPUCommandEncoder = this.device.gpu.createCommandEncoder({\r\n            label: 'Execution'\r\n        });\r\n\r\n        // Call execution with encoder context.\r\n        this.mExecutionFunction({\r\n            commandEncoder: lCommandEncoder\r\n        });\r\n\r\n        // Submit commands to queue and clear command encoder.\r\n        this.device.gpu.queue.submit([lCommandEncoder.finish()]);\r\n    }\r\n}\r\n\r\nexport type GpuExecutionFunction = (pContext: GpuExecutionContext) => void;\r\n\r\nexport type GpuExecutionContext = {\r\n    commandEncoder: GPUCommandEncoder;\r\n};", "import { Exception } from '@kartoffelgames/core';\r\nimport { GpuBuffer } from '../../buffer/gpu-buffer.ts';\r\nimport { BufferUsage } from '../../constant/buffer-usage.enum.ts';\r\nimport { ComputePipeline } from '../../pipeline/compute-pipeline.ts';\r\nimport { PipelineData, PipelineDataGroup } from '../../pipeline/pipeline_data/pipeline-data.ts';\r\n\r\n/**\r\n * Context for a compute pass.\r\n * Used to execute compute calles.\r\n */\r\nexport class ComputePassContext {\r\n    private readonly mComputeResourceBuffer: ComputePassPassContextRenderBuffer;\r\n    private readonly mEncoder: GPUComputePassEncoder;\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pEncoder - Encoder.\r\n     */\r\n    public constructor(pEncoder: GPUComputePassEncoder) {\r\n        this.mEncoder = pEncoder;\r\n\r\n        this.mComputeResourceBuffer = {\r\n            pipeline: null,\r\n            pipelineDataGroupList: new Array<PipelineDataGroup>(),\r\n            highestBindGroupListIndex: -1\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Compute direct with set parameter.\r\n     * \r\n     * @param pPipeline - Pipeline.\r\n     * @param pPipelineData - Pipline bind data groups.\r\n     * @param pX - Workgroup x dimension.\r\n     * @param pY - Workgroup y dimension.\r\n     * @param pZ - Workgroup z dimension.\r\n     */\r\n    public computeDirect(pPipeline: ComputePipeline, pPipelineData: PipelineData, pX: number = 1, pY: number = 1, pZ: number = 1): void {\r\n        // Validate pipeline data matches pipeline layout of pipeline.\r\n        if (pPipeline.layout !== pPipelineData.layout) {\r\n            throw new Exception('Pipline data not valid for set pipeline.', this);\r\n        }\r\n\r\n        // Execute compute.\r\n        if (this.setupEncoderData(pPipeline, pPipelineData)) {\r\n            this.mEncoder.dispatchWorkgroups(pX, pY, pZ);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compute indirect with parameters set in buffer.\r\n     * \r\n     * @param pPipeline - Pipeline.\r\n     * @param pPipelineData - Pipline bind data groups.\r\n     * @param pIndirectBuffer - Buffer with indirect parameter data.\r\n     */\r\n    public computeIndirect(pPipeline: ComputePipeline, pPipelineData: PipelineData, pIndirectBuffer: GpuBuffer): void {\r\n        // Validate pipeline data matches pipeline layout of pipeline.\r\n        if (pPipeline.layout !== pPipelineData.layout) {\r\n            throw new Exception('Pipline data not valid for set pipeline.', this);\r\n        }\r\n\r\n        // Extend usage.\r\n        pIndirectBuffer.extendUsage(BufferUsage.Indirect);\r\n\r\n        // Execute compute.\r\n        if (this.setupEncoderData(pPipeline, pPipelineData)) {\r\n            // Validate buffer length\r\n            // 4 Byte * 3 => 12 Byte => Indexed draw \r\n            if (pIndirectBuffer.size === 20) {\r\n                // Start indirect call.\r\n                this.mEncoder.dispatchWorkgroupsIndirect(pIndirectBuffer.native, 0);\r\n            } else {\r\n                throw new Exception('Indirect compute calls can only be done with 20 or 16 byte long buffers', this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set pipeline and any bind data.\r\n     * \r\n     * @param pPipeline - Pipeline.\r\n     * @param pPipelineData - Pipeline binding data.\r\n     * \r\n     * @returns true when everything has been successfully set. \r\n     */\r\n    public setupEncoderData(pPipeline: ComputePipeline, pPipelineData: PipelineData): boolean {\r\n        // Skip pipelines that are currently loading.\r\n        const lNativePipeline: GPUComputePipeline | null = pPipeline.native;\r\n        if (lNativePipeline === null) {\r\n            return false;\r\n        }\r\n\r\n        // Cache for bind group length of this instruction.\r\n        let lLocalHighestBindGroupListIndex: number = -1;\r\n\r\n        // Add bind groups.\r\n        const lPipelineDataGroupList: Array<PipelineDataGroup> = pPipelineData.data;\r\n        for (let lBindGroupIndex: number = 0; lBindGroupIndex < lPipelineDataGroupList.length; lBindGroupIndex++) {\r\n            const lPipelineDataGroup: PipelineDataGroup | undefined = lPipelineDataGroupList[lBindGroupIndex];\r\n            const lCurrentPipelineDataGroup: PipelineDataGroup | null = this.mComputeResourceBuffer.pipelineDataGroupList[lBindGroupIndex];\r\n\r\n            // Extend group list length.\r\n            if (lBindGroupIndex > lLocalHighestBindGroupListIndex) {\r\n                lLocalHighestBindGroupListIndex = lBindGroupIndex;\r\n            }\r\n\r\n            // Use cached bind group or use new. Catches null bindings.\r\n            if (!lCurrentPipelineDataGroup || lPipelineDataGroup.bindGroup !== lCurrentPipelineDataGroup.bindGroup || lPipelineDataGroup.offsetId !== lCurrentPipelineDataGroup.offsetId) {\r\n                // Set bind group buffer to cache current set bind groups.\r\n                this.mComputeResourceBuffer.pipelineDataGroupList[lBindGroupIndex] = lPipelineDataGroup;\r\n\r\n                // Set bind group to gpu.\r\n                if (lPipelineDataGroup.bindGroup.layout.hasDynamicOffset) {\r\n                    this.mEncoder.setBindGroup(lBindGroupIndex, lPipelineDataGroup.bindGroup.native, lPipelineDataGroup.offsets);\r\n                } else {\r\n                    this.mEncoder.setBindGroup(lBindGroupIndex, lPipelineDataGroup.bindGroup.native);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Use cached pipeline or use new.\r\n        if (pPipeline !== this.mComputeResourceBuffer.pipeline) {\r\n            this.mComputeResourceBuffer.pipeline = pPipeline;\r\n\r\n            // Generate and set new pipeline.\r\n            this.mEncoder.setPipeline(lNativePipeline);\r\n\r\n            // Only clear bind buffer when a new pipeline is set.\r\n            // Same pipelines must have set the same bind group layouts.\r\n            if (this.mComputeResourceBuffer.highestBindGroupListIndex > lLocalHighestBindGroupListIndex) {\r\n                for (let lBindGroupIndex: number = (lLocalHighestBindGroupListIndex + 1); lBindGroupIndex < (this.mComputeResourceBuffer.highestBindGroupListIndex + 1); lBindGroupIndex++) {\r\n                    this.mEncoder.setBindGroup(lBindGroupIndex, null);\r\n                }\r\n            }\r\n\r\n            // Update global bind group list length.\r\n            this.mComputeResourceBuffer.highestBindGroupListIndex = lLocalHighestBindGroupListIndex;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ntype ComputePassPassContextRenderBuffer = {\r\n    pipeline: ComputePipeline | null;\r\n\r\n    pipelineDataGroupList: Array<PipelineDataGroup>;\r\n    highestBindGroupListIndex: number;\r\n};", "import { GpuBuffer } from '../../buffer/gpu-buffer.ts';\r\nimport { BufferUsage } from '../../constant/buffer-usage.enum.ts';\r\nimport { GpuFeature } from '../../constant/gpu-feature.enum.ts';\r\nimport { GpuDevice } from '../../device/gpu-device.ts';\r\nimport { GpuObject } from '../../gpu_object/gpu-object.ts';\r\nimport { GpuExecutionContext } from '../gpu-execution.ts';\r\nimport { ComputePassContext } from './compute-pass-context.ts';\r\n\r\n/**\r\n * Gpu compute pass.\r\n */\r\nexport class ComputePass extends GpuObject {\r\n    private readonly mExecutionFunction: ComputePassExecutionFunction;\r\n    private readonly mQueries: ComputePassQuery;\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Device reference.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pExecution: ComputePassExecutionFunction) {\r\n        super(pDevice);\r\n\r\n        this.mExecutionFunction = pExecution;\r\n        this.mQueries = {};\r\n    }\r\n\r\n    /**\r\n     * Execute steps in a row.\r\n     * @param pExecutionContext - Executor context.\r\n     */\r\n    public execute(pExecutionContext: GpuExecutionContext): void {\r\n        // Read render pass descriptor and inject timestamp query when it is setup.\r\n        const lComputePassDescriptor: GPUComputePassDescriptor = {};\r\n        if (this.mQueries.timestamp) {\r\n            lComputePassDescriptor.timestampWrites = this.mQueries.timestamp.query;\r\n        }\r\n\r\n        // Pass descriptor is set, when the pipeline ist set.\r\n        const lComputePassEncoder: GPUComputePassEncoder = pExecutionContext.commandEncoder.beginComputePass(lComputePassDescriptor);\r\n\r\n        // Direct execute function.\r\n        this.mExecutionFunction(new ComputePassContext(lComputePassEncoder));\r\n\r\n        // End compute pass.\r\n        lComputePassEncoder.end();\r\n\r\n        // Resolve query.\r\n        if (this.mQueries.timestamp) {\r\n            pExecutionContext.commandEncoder.resolveQuerySet(this.mQueries.timestamp.query.querySet, 0, 2, this.mQueries.timestamp.buffer.native, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Probe timestamp data from render pass.\r\n     * Resolves into two big ints with start and end time in nanoseconds.\r\n     * \r\n     * @returns Promise that resolves with the latest timestamp data.\r\n     */\r\n    public async probeTimestamp(): Promise<[bigint, bigint]> {\r\n        // Skip when not enabled.\r\n        if (!this.device.capabilities.hasFeature(GpuFeature.TimestampQuery)) {\r\n            return [0n, 0n];\r\n        }\r\n\r\n        // Init timestamp query when not already set.\r\n        if (!this.mQueries.timestamp) {\r\n            // Create timestamp query.\r\n            const lTimestampQuerySet: GPUQuerySet = this.device.gpu.createQuerySet({\r\n                type: 'timestamp',\r\n                count: 2\r\n            });\r\n\r\n            // Create timestamp buffer.\r\n            const lTimestampBuffer: GpuBuffer = new GpuBuffer(this.device, 16);\r\n            lTimestampBuffer.extendUsage(GPUBufferUsage.QUERY_RESOLVE);\r\n            lTimestampBuffer.extendUsage(BufferUsage.CopySource);\r\n\r\n            // Create query.\r\n            this.mQueries.timestamp = {\r\n                query: {\r\n                    querySet: lTimestampQuerySet,\r\n                    beginningOfPassWriteIndex: 0,\r\n                    endOfPassWriteIndex: 1\r\n                },\r\n                buffer: lTimestampBuffer,\r\n                resolver: null\r\n            };\r\n        }\r\n\r\n        // Use existing resolver.\r\n        if (this.mQueries.timestamp.resolver) {\r\n            return this.mQueries.timestamp.resolver;\r\n        }\r\n\r\n        this.mQueries.timestamp.resolver = this.mQueries.timestamp.buffer.read(0, 16).then((pData: ArrayBuffer) => {\r\n            // Reset resolver.\r\n            this.mQueries.timestamp!.resolver = null;\r\n\r\n            // Read and resolve timestamp data.\r\n            const lTimedata: BigUint64Array = new BigUint64Array(pData);\r\n            return [lTimedata[0], lTimedata[1]];\r\n        });\r\n\r\n        return this.mQueries.timestamp.resolver;\r\n    }\r\n}\r\n\r\nexport type ComputePassExecutionFunction = (pContext: ComputePassContext) => void;\r\n\r\ntype ComputePassQuery = {\r\n    timestamp?: {\r\n        query: GPURenderPassTimestampWrites;\r\n        buffer: GpuBuffer;\r\n        resolver: null | Promise<[bigint, bigint]>;\r\n    };\r\n};", "export enum TextureUsage {\r\n    None = 0,\r\n    CopySource = GPUTextureUsage.COPY_SRC,\r\n    CopyDestination = GPUTextureUsage.COPY_DST,\r\n    TextureBinding = GPUTextureUsage.TEXTURE_BINDING,\r\n    Storage = GPUTextureUsage.STORAGE_BINDING,\r\n    RenderAttachment = GPUTextureUsage.RENDER_ATTACHMENT,\r\n}", "export enum FilterMode {\r\n    Nearest = 'nearest',\r\n    Linear = 'linear'\r\n}", "export enum WrappingMode {\r\n    ClampToEdge = 'clamp-to-edge',\r\n    Repeat = 'repeat',\r\n    MirrorRepeat = 'mirror-repeat'\r\n}", "import { Exception } from '@kartoffelgames/core';\r\nimport { CompareFunction } from '../constant/compare-function.enum.ts';\r\nimport { FilterMode } from '../constant/filter-mode.enum.ts';\r\nimport { SamplerType } from '../constant/sampler-type.enum.ts';\r\nimport { WrappingMode } from '../constant/wrapping-mode.enum.ts';\r\nimport { GpuDevice } from '../device/gpu-device.ts';\r\nimport { GpuResourceObject, GpuResourceObjectInvalidationType } from '../gpu_object/gpu-resource-object.ts';\r\nimport { IGpuObjectNative } from '../gpu_object/interface/i-gpu-object-native.ts';\r\nimport { SamplerMemoryLayout } from './memory_layout/sampler-memory-layout.ts';\r\n\r\n/**\r\n * Gpu texture sampler resource.\r\n */\r\nexport class TextureSampler extends GpuResourceObject<0, GPUSampler> implements IGpuObjectNative<GPUSampler> {\r\n    private mCompare: CompareFunction | null;\r\n    private mLodMaxClamp: number;\r\n    private mLodMinClamp: number;\r\n    private mMagFilter: FilterMode;\r\n    private mMaxAnisotropy: number;\r\n    private readonly mMemoryLayout: SamplerMemoryLayout;\r\n    private mMinFilter: FilterMode;\r\n    private mMipmapFilter: FilterMode;\r\n    private mWrapMode: WrappingMode;\r\n\r\n    /**\r\n     * When provided the sampler will be a comparison sampler with the specified compare function.\r\n     */\r\n    public get compare(): CompareFunction | null {\r\n        return this.mCompare;\r\n    } set compare(pValue: CompareFunction | null) {\r\n        this.mCompare = pValue;\r\n\r\n        // Invalidate native object.\r\n        this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * Specifies the maximum levels of detail, respectively, used internally when sampling a texture.\r\n     */\r\n    public get lodMaxClamp(): number {\r\n        return this.mLodMaxClamp;\r\n    } set lodMaxClamp(pValue: number) {\r\n        this.mLodMaxClamp = pValue;\r\n\r\n        // Invalidate native object.\r\n        this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * Specifies the minimum levels of detail, respectively, used internally when sampling a texture.\r\n     */\r\n    public get lodMinClamp(): number {\r\n        return this.mLodMinClamp;\r\n    } set lodMinClamp(pValue: number) {\r\n        this.mLodMinClamp = pValue;\r\n\r\n        // Invalidate native object.\r\n        this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * How the texture is sampled when a texel covers more than one pixel.\r\n     */\r\n    public get magFilter(): FilterMode {\r\n        return this.mMagFilter;\r\n    } set magFilter(pValue: FilterMode) {\r\n        this.mMagFilter = pValue;\r\n\r\n        // Invalidate native object.\r\n        this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * Specifies the maximum anisotropy value clamp used by the sampler.\r\n     */\r\n    public get maxAnisotropy(): number {\r\n        return this.mMaxAnisotropy;\r\n    } set maxAnisotropy(pValue: number) {\r\n        this.mMaxAnisotropy = pValue;\r\n\r\n        // Invalidate native object.\r\n        this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * Sampler memory layout.\r\n     */\r\n    public get memoryLayout(): SamplerMemoryLayout {\r\n        return this.mMemoryLayout;\r\n    }\r\n\r\n    /**\r\n     * How the texture is sampled when a texel covers less than one pixel.\r\n     */\r\n    public get minFilter(): FilterMode {\r\n        return this.mMinFilter;\r\n    } set minFilter(pValue: FilterMode) {\r\n        this.mMinFilter = pValue;\r\n\r\n        // Invalidate native object.\r\n        this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * Specifies behavior for sampling between mipmap levels.\r\n     */\r\n    public get mipmapFilter(): FilterMode {\r\n        return this.mMipmapFilter;\r\n    } set mipmapFilter(pValue: FilterMode) {\r\n        this.mMipmapFilter = pValue;\r\n\r\n        // Invalidate native object.\r\n        this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * Native gpu object.\r\n     */\r\n    public override get native(): GPUSampler {\r\n        return super.native;\r\n    }\r\n\r\n    /**\r\n     * Texture sampler edge wrap mode.\r\n     */\r\n    public get wrapMode(): WrappingMode {\r\n        return this.mWrapMode;\r\n    } set wrapMode(pValue: WrappingMode) {\r\n        this.mWrapMode = pValue;\r\n\r\n        // Invalidate native object.\r\n        this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Device.\r\n     * @param pLayout - Sampler memory layout.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pLayout: SamplerMemoryLayout) {\r\n        super(pDevice);\r\n\r\n        this.mMemoryLayout = pLayout;\r\n\r\n        // Set defaults.\r\n        this.mCompare = null;\r\n        this.mWrapMode = WrappingMode.ClampToEdge;\r\n        this.mMagFilter = FilterMode.Linear;\r\n        this.mMinFilter = FilterMode.Linear;\r\n        this.mMipmapFilter = FilterMode.Linear;\r\n        this.mLodMinClamp = 0;\r\n        this.mLodMaxClamp = 32;\r\n        this.mMaxAnisotropy = 16;\r\n    }\r\n\r\n    /**\r\n     * Generate native bind data group layout object.\r\n     */\r\n    protected override generateNative(): GPUSampler {\r\n        // Create sampler descriptor.\r\n        const lSamplerOptions: GPUSamplerDescriptor = {\r\n            label: 'Texture-Sampler',\r\n            addressModeU: this.wrapMode,\r\n            addressModeV: this.wrapMode,\r\n            addressModeW: this.wrapMode,\r\n            magFilter: this.magFilter,\r\n            minFilter: this.minFilter,\r\n            mipmapFilter: this.mipmapFilter,\r\n            lodMaxClamp: this.lodMaxClamp,\r\n            lodMinClamp: this.lodMinClamp,\r\n            maxAnisotropy: this.maxAnisotropy\r\n        };\r\n\r\n        // Add compare function when sampler is a compare sampler.\r\n        if (this.memoryLayout.samplerType === SamplerType.Comparison) {\r\n            if (!this.compare) {\r\n                throw new Exception(`No compare function is set for a comparison sampler.`, this);\r\n            }\r\n            lSamplerOptions.compare = this.compare;\r\n        }\r\n\r\n        return this.device.gpu.createSampler(lSamplerOptions);\r\n    }\r\n}", "export enum BufferAlignmentType {\r\n    Packed = 1,\r\n    Uniform = 2,\r\n    Storage = 3\r\n}", "import { GpuDevice } from './device/gpu-device.ts';\r\nimport { GpuObject } from './gpu_object/gpu-object.ts';\r\nimport { GpuObjectSetup } from './gpu_object/gpu-object-setup.ts';\r\n\r\n/**\r\n * Base memory layout. \r\n * Represents a memory slot used by a shader.\r\n */\r\nexport abstract class BaseMemoryLayout<TSetupObject extends GpuObjectSetup<any> | null = any> extends GpuObject<null, '', TSetupObject> {\r\n    /**\r\n     * Constuctor.\r\n     * @param pDevice - Device reference.\r\n     */\r\n    public constructor(pDevice: GpuDevice) {\r\n        super(pDevice);\r\n    }\r\n}", "import { BaseMemoryLayout } from '../../base-memory-layout.ts';\r\nimport { BufferAlignmentType } from '../../constant/buffer-alignment-type.enum.ts';\r\nimport { GpuDevice } from '../../device/gpu-device.ts';\r\nimport { GpuObjectSetup } from '../../gpu_object/gpu-object-setup.ts';\r\n\r\n/**\r\n * Basic memory layout for gpu buffers. \r\n */\r\nexport abstract class BaseBufferMemoryLayout<TSetupObject extends GpuObjectSetup<any> | null = any> extends BaseMemoryLayout<TSetupObject> {\r\n    private readonly mAlignmentType: BufferAlignmentType;\r\n\r\n    /**\r\n     * Type byte alignment.\r\n     */\r\n    public abstract readonly alignment: number;\r\n\r\n    /**\r\n     * Fixed buffer size in bytes.\r\n     */\r\n    public abstract readonly fixedSize: number;\r\n\r\n    /**\r\n     * Size of the variable part of layout in bytes.\r\n     */\r\n    public abstract readonly variableSize: number;\r\n\r\n    /**\r\n     * Buffer value alignment type.\r\n     */\r\n    public get alignmentType(): BufferAlignmentType {\r\n        return this.mAlignmentType;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pDevice - Device reference.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pAlignmentType: BufferAlignmentType) {\r\n        super(pDevice);\r\n        this.mAlignmentType = pAlignmentType;\r\n    }\r\n\r\n    /**\r\n     * Get location of path.\r\n     * @param pPathName - Path name. Divided by dots.\r\n     */\r\n    public abstract locationOf(pPathName: Array<string>): BufferLayoutLocation;\r\n}\r\n\r\nexport type BufferLayoutLocation = {\r\n    /**\r\n     * Offset in bytes.\r\n     */\r\n    offset: number;\r\n\r\n    /**\r\n     * Size in byte.\r\n     */\r\n    size: number;\r\n};", "import { Exception } from '@kartoffelgames/core';\r\nimport { BufferAlignmentType } from '../../constant/buffer-alignment-type.enum.ts';\r\nimport { GpuDevice } from '../../device/gpu-device.ts';\r\nimport { BaseBufferMemoryLayout, BufferLayoutLocation } from './base-buffer-memory-layout.ts';\r\n\r\n/**\r\n * Memory layout for a array buffer or part of a buffer.\r\n */\r\nexport class ArrayBufferMemoryLayout extends BaseBufferMemoryLayout {\r\n    private readonly mAlignment: number;\r\n    private readonly mArraySize: number;\r\n    private readonly mInnerType: BaseBufferMemoryLayout;\r\n\r\n    /**\r\n     * Type byte alignment.\r\n     */\r\n    public override get alignment(): number {\r\n        return this.mAlignment;\r\n    }\r\n\r\n    /**\r\n     * Array item count.\r\n     */\r\n    public get arraySize(): number {\r\n        return this.mArraySize;\r\n    }\r\n\r\n    /**\r\n     * Type size in byte.\r\n     */\r\n    public get fixedSize(): number {\r\n        if (this.arraySize < 1) {\r\n            return 0;\r\n        }\r\n\r\n        return this.arraySize * Math.ceil(this.innerType.fixedSize / this.innerType.alignment) * this.innerType.alignment;\r\n    }\r\n\r\n    /**\r\n     * Array type.\r\n     * Is negative when array is variable sized.\r\n     */\r\n    public get innerType(): BaseBufferMemoryLayout {\r\n        return this.mInnerType;\r\n    }\r\n\r\n    /**\r\n     * Size of the variable part of layout in bytes.\r\n     */\r\n    public get variableSize(): number {\r\n        if (this.arraySize > 0) {\r\n            return 0;\r\n        }\r\n\r\n        return Math.ceil(this.innerType.fixedSize / this.innerType.alignment) * this.innerType.alignment;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pDevice - Device reference.\r\n     * @param pParameter - Parameter.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pParameter: ArrayBufferMemoryLayoutParameter) {\r\n        super(pDevice, pParameter.innerType.alignmentType);\r\n\r\n        // Static properties.\r\n        this.mArraySize = pParameter.arraySize;\r\n        this.mInnerType = pParameter.innerType;\r\n\r\n        // Change alignment based on alignment type.\r\n        this.mAlignment = (() => {\r\n            switch (pParameter.innerType.alignmentType) {\r\n                case BufferAlignmentType.Packed: {\r\n                    return 1;\r\n                }\r\n                case BufferAlignmentType.Storage: {\r\n                    return pParameter.innerType.alignment;\r\n                }\r\n                case BufferAlignmentType.Uniform: {\r\n                    // For uniforms, arrays buffers are aligned by 16 byte\r\n                    return Math.ceil(pParameter.innerType.alignment / 16) * 16;\r\n                }\r\n            }\r\n        })();\r\n\r\n        if (this.mInnerType.variableSize > 0) {\r\n            throw new Exception(`Array memory layout must be of fixed size.`, this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get location of path.\r\n     * @param pPathName - Path name. Divided by dots.\r\n     */\r\n    public override locationOf(pPathName: Array<string>): BufferLayoutLocation {\r\n        const lPathName: Array<string> = [...pPathName];\r\n\r\n        // Complete array.\r\n        const lItemIndexString: string | undefined = lPathName.shift();\r\n        if (!lItemIndexString) {\r\n            // Only valid for static arrays.\r\n            if (this.variableSize > 0) {\r\n                throw new Exception('Getting the offset and size location for dynamic arrays is not supported.', this);\r\n            }\r\n\r\n            return { size: this.fixedSize, offset: 0 };\r\n        }\r\n\r\n        // Validate item index.\r\n        if (isNaN(<any>lItemIndexString)) {\r\n            throw new Exception('Array index must be a number.', this);\r\n        }\r\n\r\n        // Calculate size of single item.\r\n        const lArrayItemSize: number = Math.ceil(this.innerType.fixedSize / this.innerType.alignment) * this.innerType.alignment;\r\n        const lArrayItemOffset: number = parseInt(lItemIndexString) * lArrayItemSize;\r\n\r\n        // Single item.\r\n        if (lPathName.length === 0) {\r\n            return { size: lArrayItemSize, offset: lArrayItemOffset };\r\n        }\r\n\r\n        // Inner property.\r\n        const lInnerLocation = this.innerType.locationOf(lPathName);\r\n        return { size: lInnerLocation.size, offset: lArrayItemOffset + lInnerLocation.offset };\r\n    }\r\n}\r\n\r\nexport interface ArrayBufferMemoryLayoutParameter {\r\n    /**\r\n     * Array size. -1 when array is variable sized.\r\n     */\r\n    arraySize: number;\r\n    innerType: BaseBufferMemoryLayout;\r\n}", "import { Exception } from '@kartoffelgames/core';\r\nimport { BufferAlignmentType } from '../../constant/buffer-alignment-type.enum.ts';\r\nimport { BufferItemFormat } from '../../constant/buffer-item-format.enum.ts';\r\nimport { BufferItemMultiplier } from '../../constant/buffer-item-multiplier.enum.ts';\r\nimport { GpuDevice } from '../../device/gpu-device.ts';\r\nimport { BaseBufferMemoryLayout, BufferLayoutLocation } from './base-buffer-memory-layout.ts';\r\n\r\n/**\r\n * Memory layout for a primitive number buffer or part of a buffer.\r\n */\r\nexport class PrimitiveBufferMemoryLayout extends BaseBufferMemoryLayout {\r\n    /**\r\n     * Get item count for multiplier type.\r\n     * \r\n     * @param pMultiplier - Multiplier type.\r\n     * \r\n     * @returns item count of multiplier. \r\n     */\r\n    public static itemCountOfMultiplier(pMultiplier: BufferItemMultiplier): number {\r\n        switch (pMultiplier) {\r\n            case BufferItemMultiplier.Single: { return 1; }\r\n            case BufferItemMultiplier.Vector2: { return 2; }\r\n            case BufferItemMultiplier.Vector3: { return 3; }\r\n            case BufferItemMultiplier.Vector4: { return 4; }\r\n            case BufferItemMultiplier.Matrix22: { return 4; }\r\n            case BufferItemMultiplier.Matrix23: { return 6; }\r\n            case BufferItemMultiplier.Matrix24: { return 8; }\r\n            case BufferItemMultiplier.Matrix32: { return 6; }\r\n            case BufferItemMultiplier.Matrix33: { return 9; }\r\n            case BufferItemMultiplier.Matrix34: { return 12; }\r\n            case BufferItemMultiplier.Matrix42: { return 8; }\r\n            case BufferItemMultiplier.Matrix43: { return 0; }\r\n            case BufferItemMultiplier.Matrix44: { return 16; }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get byte count of item format.\r\n     * \r\n     * @param pItemFormat - Item format.\r\n     * \r\n     * @returns byte count of format. \r\n     */\r\n    public static itemFormatByteCount(pItemFormat: BufferItemFormat): number {\r\n        switch (pItemFormat) {\r\n            case BufferItemFormat.Float16: return 2;\r\n            case BufferItemFormat.Float32: return 4;\r\n            case BufferItemFormat.Uint32: return 4;\r\n            case BufferItemFormat.Sint32: return 4;\r\n            case BufferItemFormat.Uint8: return 1;\r\n            case BufferItemFormat.Sint8: return 1;\r\n            case BufferItemFormat.Uint16: return 2;\r\n            case BufferItemFormat.Sint16: return 2;\r\n            case BufferItemFormat.Unorm16: return 2;\r\n            case BufferItemFormat.Snorm16: return 2;\r\n            case BufferItemFormat.Unorm8: return 1;\r\n            case BufferItemFormat.Snorm8: return 1;\r\n        }\r\n    }\r\n\r\n    private readonly mAlignment: number;\r\n    private readonly mFormatByteCount: number;\r\n    private readonly mItemFormat: BufferItemFormat;\r\n    private readonly mItemMultiplier: BufferItemMultiplier;\r\n    private readonly mSize: number;\r\n\r\n    /**\r\n     * Type byte alignment.\r\n     */\r\n    public override get alignment(): number {\r\n        return this.mAlignment;\r\n    }\r\n\r\n    /**\r\n     * Fixed buffer size in bytes.\r\n     */\r\n    public get fixedSize(): number {\r\n        return this.mSize;\r\n    }\r\n\r\n    /**\r\n     * Byte count of underlying format.\r\n     */\r\n    public get formatByteCount(): number {\r\n        return this.mFormatByteCount;\r\n    }\r\n\r\n    /**\r\n     * Format of single value.\r\n     */\r\n    public get itemFormat(): BufferItemFormat {\r\n        return this.mItemFormat;\r\n    }\r\n\r\n    /**\r\n     * Format multiplication.\r\n     */\r\n    public get itemMultiplier(): BufferItemMultiplier {\r\n        return this.mItemMultiplier;\r\n    }\r\n\r\n    /**\r\n     * Buffer size in bytes.\r\n     */\r\n    public get variableSize(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pDevice - Device reference.\r\n     * @param pParameter - Parameter.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pParameter: LinearBufferMemoryLayoutParameter) {\r\n        super(pDevice, pParameter.alignmentType);\r\n\r\n        // Set default size by format.\r\n        this.mFormatByteCount = PrimitiveBufferMemoryLayout.itemFormatByteCount(pParameter.primitiveFormat);\r\n        this.mItemFormat = pParameter.primitiveFormat;\r\n        this.mItemMultiplier = pParameter.primitiveMultiplier;\r\n        this.mSize = this.mFormatByteCount * PrimitiveBufferMemoryLayout.itemCountOfMultiplier(pParameter.primitiveMultiplier);\r\n\r\n        // Calculate alignment and size.\r\n        this.mAlignment = ((): number => {\r\n            switch (pParameter.primitiveMultiplier) {\r\n                case BufferItemMultiplier.Single: return this.mFormatByteCount;\r\n                case BufferItemMultiplier.Vector2: return this.mFormatByteCount * 2;\r\n                case BufferItemMultiplier.Vector3: return this.mFormatByteCount * 4;\r\n                case BufferItemMultiplier.Vector4: return this.mFormatByteCount * 4;\r\n                case BufferItemMultiplier.Matrix22: return this.mFormatByteCount * 2;\r\n                case BufferItemMultiplier.Matrix23: return this.mFormatByteCount * 4;\r\n                case BufferItemMultiplier.Matrix24: return this.mFormatByteCount * 4;\r\n                case BufferItemMultiplier.Matrix32: return this.mFormatByteCount * 2;\r\n                case BufferItemMultiplier.Matrix33: return this.mFormatByteCount * 4;\r\n                case BufferItemMultiplier.Matrix34: return this.mFormatByteCount * 4;\r\n                case BufferItemMultiplier.Matrix42: return this.mFormatByteCount * 2;\r\n                case BufferItemMultiplier.Matrix43: return this.mFormatByteCount * 4;\r\n                case BufferItemMultiplier.Matrix44: return this.mFormatByteCount * 4;\r\n            }\r\n        })();\r\n\r\n        // Override size of primitive.\r\n        if (pParameter.overrideSize) {\r\n            if (this.mSize > pParameter.overrideSize) {\r\n                throw new Exception('Overriden buffer byte size can not be lower than the actual byte size.', this);\r\n            }\r\n\r\n            this.mAlignment = pParameter.overrideSize;\r\n        }\r\n\r\n        // Change alignment based on alignment type.\r\n        this.mAlignment = (() => {\r\n            switch (pParameter.alignmentType) {\r\n                case BufferAlignmentType.Packed: {\r\n                    return 1;\r\n                }\r\n                case BufferAlignmentType.Storage:\r\n                case BufferAlignmentType.Uniform: {\r\n                    return this.mAlignment;\r\n                }\r\n            }\r\n        })();\r\n\r\n        // Override alignment of primitive.\r\n        if (pParameter.overrideAlignment) {\r\n            if (pParameter.overrideAlignment % this.mAlignment !== 0) {\r\n                throw new Exception('Overriden alignment must be dividable by its actual alignment value.', this);\r\n            }\r\n\r\n            this.mAlignment = pParameter.overrideAlignment;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get location of path.\r\n     * @param pPathName - Path name. Divided by dots.\r\n     */\r\n    public locationOf(pPathName: Array<string>): BufferLayoutLocation {\r\n        // Only validate name.\r\n        if (pPathName.length !== 0) {\r\n            throw new Exception(`Simple buffer layout has no properties.`, this);\r\n        }\r\n\r\n        return { size: this.fixedSize, offset: 0 };\r\n    }\r\n}\r\n\r\nexport interface LinearBufferMemoryLayoutParameter {\r\n    alignmentType: BufferAlignmentType;\r\n    overrideAlignment?: number | null;\r\n    overrideSize?: number | null;\r\n    primitiveFormat: BufferItemFormat;\r\n    primitiveMultiplier: BufferItemMultiplier;\r\n}", "import { Exception } from '@kartoffelgames/core';\r\nimport { GpuDevice } from '../device/gpu-device.ts';\r\nimport { GpuObjectSetupReferences } from './gpu-object.ts';\r\n\r\n/**\r\n * Gpu setup object.\r\n */\r\nexport abstract class GpuObjectSetup<TSetupData> {\r\n    private readonly mSetupReference: GpuObjectSetupReferences<TSetupData>;\r\n\r\n    /**\r\n     * Gpu device reference.\r\n     */\r\n    protected get device(): GpuDevice {\r\n        return this.mSetupReference.device;\r\n    }\r\n\r\n    /**\r\n     * Setup data.\r\n     */\r\n    protected get setupData(): TSetupData {\r\n        // References should be setup at this point.\r\n        return this.mSetupReference.data as TSetupData;\r\n    }\r\n\r\n    /**\r\n     * Setup references.\r\n     */\r\n    protected get setupReferences(): GpuObjectSetupReferences<TSetupData> {\r\n        return this.mSetupReference;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pSetupReference - Setup references.\r\n     */\r\n    public constructor(pSetupReference: GpuObjectSetupReferences<TSetupData>) {\r\n        this.mSetupReference = pSetupReference;\r\n\r\n        // Fill default data to setup references.\r\n        this.fillDefaultData(pSetupReference.data);\r\n    }\r\n\r\n    /**\r\n     * Ensure that current call is used inside a setup call.\r\n     */\r\n    protected ensureThatInSetup(): void {\r\n        // Lock setup to a setup call.\r\n        if (!this.mSetupReference.inSetup) {\r\n            throw new Exception('Can only setup in a setup call.', this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fill in default data before the setup starts.\r\n     * \r\n     * @param pDataReference - Setup data reference.\r\n     */\r\n    protected abstract fillDefaultData(pDataReference: Partial<TSetupData>): void;\r\n}", "import { Exception } from '@kartoffelgames/core';\r\nimport { GpuDevice } from '../device/gpu-device.ts';\r\nimport { GpuObjectSetupReferences } from './gpu-object.ts';\r\n\r\n/**\r\n * Helper object for setup objects. Returns results with a callback.\r\n */\r\nexport abstract class GpuObjectChildSetup<TSetupReferenceData, TCallback extends GpuObjectChildSetupCallback> {\r\n    private readonly mSetupCallback: TCallback;\r\n    private readonly mSetupReference: GpuObjectSetupReferences<TSetupReferenceData>;\r\n\r\n    /**\r\n     * Gpu device reference.\r\n     */\r\n    protected get device(): GpuDevice {\r\n        return this.mSetupReference.device;\r\n    }\r\n\r\n    /**\r\n     * Setup data.\r\n     */\r\n    protected get setupData(): Readonly<TSetupReferenceData> {\r\n        // References should be setup at this point.\r\n        return this.mSetupReference.data as TSetupReferenceData;\r\n    }\r\n\r\n    /**\r\n     * Setup references.\r\n     */\r\n    protected get setupReferences(): GpuObjectSetupReferences<TSetupReferenceData> {\r\n        return this.mSetupReference;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pSetupReference - Setup references.\r\n     * @param pDataCallback - Setup data callback.\r\n     */\r\n    public constructor(pSetupReference: GpuObjectSetupReferences<TSetupReferenceData>, pDataCallback: TCallback) {\r\n        this.mSetupReference = pSetupReference;\r\n        this.mSetupCallback = pDataCallback;\r\n    }\r\n\r\n    /**\r\n     * Ensure that current call is used inside a setup call.\r\n     */\r\n    protected ensureThatInSetup(): void {\r\n        // Lock setup to a setup call.\r\n        if (!this.mSetupReference.inSetup) {\r\n            throw new Exception('Can only setup in a setup call.', this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send data back to parent setup.\r\n     * \r\n     * @param pData - Setup complete data.\r\n     */\r\n    protected sendData(...pData: Parameters<TCallback>): void {\r\n        this.mSetupCallback(...pData);\r\n    }\r\n}\r\n\r\ntype GpuObjectChildSetupCallback = (...args: any) => void;", "\r\nimport { BufferAlignmentType } from '../../constant/buffer-alignment-type.enum.ts';\r\nimport { BufferItemFormat } from '../../constant/buffer-item-format.enum.ts';\r\nimport { BufferItemMultiplier } from '../../constant/buffer-item-multiplier.enum.ts';\r\nimport { GpuObjectSetupReferences } from '../../gpu_object/gpu-object.ts';\r\nimport { GpuObjectChildSetup } from '../../gpu_object/gpu-object-child-setup.ts';\r\nimport { ArrayBufferMemoryLayout } from './array-buffer-memory-layout.ts';\r\nimport { BaseBufferMemoryLayout } from './base-buffer-memory-layout.ts';\r\nimport { PrimitiveBufferMemoryLayout } from './primitive-buffer-memory-layout.ts';\r\nimport { StructBufferMemoryLayout } from './struct-buffer-memory-layout.ts';\r\nimport { StructBufferMemoryLayoutSetup, StructBufferMemoryLayoutSetupData } from './struct-buffer-memory-layout-setup.ts';\r\n\r\n/**\r\n * Child setup to add types to struct properties.\r\n */\r\nexport class StructBufferMemoryLayoutPropertySetup extends GpuObjectChildSetup<StructBufferMemoryLayoutSetupData, MemoryLayoutCallback> {\r\n    private readonly mAlignmentType: BufferAlignmentType;\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pUsage - Buffer usage. \r\n     * @param pSetupReference - Setup references.\r\n     * @param pDataCallback - Data callback.\r\n     */\r\n    public constructor(pSetupReference: GpuObjectSetupReferences<StructBufferMemoryLayoutSetupData>, pAlignmentType: BufferAlignmentType, pDataCallback: MemoryLayoutCallback) {\r\n        super(pSetupReference, pDataCallback);\r\n\r\n        this.mAlignmentType = pAlignmentType;\r\n    }\r\n\r\n    /**\r\n     * Buffer as array.\r\n     * \r\n     * @param pSize - Optional. Set size fixed.\r\n     *  \r\n     * @returns array setup. \r\n     */\r\n    public asArray(pSize: number = -1): StructBufferMemoryLayoutPropertySetup {\r\n        return new StructBufferMemoryLayoutPropertySetup(this.setupReferences, this.mAlignmentType, (pMemoryLayout: BaseBufferMemoryLayout) => {\r\n            const lLayout: ArrayBufferMemoryLayout = new ArrayBufferMemoryLayout(this.device, {\r\n                arraySize: pSize,\r\n                innerType: pMemoryLayout\r\n            });\r\n\r\n            this.sendData(lLayout);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Memory layout as primitive.\r\n     * \r\n     * @param pPrimitiveFormat - Primitive format.\r\n     * @param pPrimitiveMultiplier - Value multiplier.\r\n     */\r\n    public asPrimitive(pPrimitiveFormat: BufferItemFormat, pPrimitiveMultiplier: BufferItemMultiplier, pAlignment: number | null = null): void {\r\n        const lLayout: PrimitiveBufferMemoryLayout = new PrimitiveBufferMemoryLayout(this.device, {\r\n            alignmentType: this.mAlignmentType,\r\n            primitiveFormat: pPrimitiveFormat,\r\n            primitiveMultiplier: pPrimitiveMultiplier,\r\n            overrideAlignment: pAlignment\r\n        });\r\n\r\n        // Send created data.\r\n        this.sendData(lLayout);\r\n    }\r\n\r\n    /**\r\n     * Memory layout as struct\r\n     * \r\n     * @param pSetupCall - Struct setup call.\r\n     */\r\n    public asStruct(pSetupCall: (pSetup: StructBufferMemoryLayoutSetup) => void): void {\r\n        // Create and setup struct buffer memory layout.\r\n        const lLayout: StructBufferMemoryLayout = new StructBufferMemoryLayout(this.device, this.mAlignmentType);\r\n        lLayout.setup(pSetupCall);\r\n\r\n        // Send created data.\r\n        this.sendData(lLayout);\r\n    }\r\n}\r\n\r\n\r\ntype MemoryLayoutCallback = (pMemoryLayout: BaseBufferMemoryLayout) => void;", "import { BufferAlignmentType } from '../../constant/buffer-alignment-type.enum.ts';\r\nimport { GpuObjectSetupReferences } from '../../gpu_object/gpu-object.ts';\r\nimport { GpuObjectSetup } from '../../gpu_object/gpu-object-setup.ts';\r\nimport { BaseBufferMemoryLayout } from './base-buffer-memory-layout.ts';\r\nimport { StructBufferMemoryLayoutPropertySetup } from './struct-buffer-memory-layout-property-setup.ts';\r\n\r\n/**\r\n * Setup object to add properties to a struct layout.\r\n */\r\nexport class StructBufferMemoryLayoutSetup extends GpuObjectSetup<StructBufferMemoryLayoutSetupData> {\r\n    private readonly mAlignmentType: BufferAlignmentType;\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pSetupReference - Setup references.\r\n     */\r\n    public constructor(pSetupReference: GpuObjectSetupReferences<StructBufferMemoryLayoutSetupData>, pAlignmentType: BufferAlignmentType) {\r\n        super(pSetupReference);\r\n\r\n        this.mAlignmentType = pAlignmentType;\r\n    }\r\n\r\n    /**\r\n     * Add propery.\r\n     * \r\n     * @param pName - Propery name.\r\n     * \r\n     * @returns property setup. \r\n     */\r\n    public property(pName: string): StructBufferMemoryLayoutPropertySetup {\r\n        // Create empty property.\r\n        const lProperty: StructBufferMemoryLayoutSetupPropertyData = {\r\n            name: pName,\r\n            orderIndex: this.setupData.properties.length,\r\n            layout: null\r\n        };\r\n\r\n        // Add empty property.\r\n        this.setupData.properties.push(lProperty);\r\n\r\n        // Create and return property setup.\r\n        return new StructBufferMemoryLayoutPropertySetup(this.setupReferences, this.mAlignmentType, (pMemoryLayout: BaseBufferMemoryLayout) => {\r\n            lProperty.layout = pMemoryLayout;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fill in default data before the setup starts.\r\n     *\r\n     * @param pDataReference - Setup data reference.\r\n     */\r\n    protected override fillDefaultData(pDataReference: StructBufferMemoryLayoutSetupData): void {\r\n        pDataReference.properties = new Array<{ orderIndex: number; name: string; layout: BaseBufferMemoryLayout; }>();\r\n    }\r\n}\r\n\r\ntype StructBufferMemoryLayoutSetupPropertyData = {\r\n    orderIndex: number;\r\n    name: string;\r\n    layout: BaseBufferMemoryLayout | null;\r\n};\r\n\r\nexport type StructBufferMemoryLayoutSetupData = {\r\n    properties: Array<StructBufferMemoryLayoutSetupPropertyData>;\r\n};", "import { Exception } from '@kartoffelgames/core';\r\nimport { BufferAlignmentType } from '../../constant/buffer-alignment-type.enum.ts';\r\nimport { GpuDevice } from '../../device/gpu-device.ts';\r\nimport { GpuObjectSetupReferences } from '../../gpu_object/gpu-object.ts';\r\nimport { IGpuObjectSetup } from '../../gpu_object/interface/i-gpu-object-setup.ts';\r\nimport { BaseBufferMemoryLayout, BufferLayoutLocation } from './base-buffer-memory-layout.ts';\r\nimport { StructBufferMemoryLayoutSetup, StructBufferMemoryLayoutSetupData } from './struct-buffer-memory-layout-setup.ts';\r\n\r\n/**\r\n * Memory layout for a struct buffer or part of a buffer.\r\n */\r\nexport class StructBufferMemoryLayout extends BaseBufferMemoryLayout<StructBufferMemoryLayoutSetup> implements IGpuObjectSetup<StructBufferMemoryLayoutSetup> {\r\n    private mAlignment: number;\r\n    private mFixedSize: number;\r\n    private mInnerProperties: Array<StructBufferMemoryLayoutProperty>;\r\n    private mVariableSize: number;\r\n\r\n    /**\r\n     * Alignment of type.\r\n     */\r\n    public get alignment(): number {\r\n        // Ensure setup was called.\r\n        this.ensureSetup();\r\n\r\n        return this.mAlignment;\r\n    }\r\n\r\n    /**\r\n     * Type size in byte.\r\n     */\r\n    public get fixedSize(): number {\r\n        // Ensure setup was called.\r\n        this.ensureSetup();\r\n\r\n        return this.mFixedSize;\r\n    }\r\n\r\n    /**\r\n     * Ordered inner property names.\r\n     */\r\n    public get properties(): Array<StructBufferMemoryLayoutProperty> {\r\n        // Ensure setup was called.\r\n        this.ensureSetup();\r\n\r\n        return [...this.mInnerProperties];\r\n    }\r\n\r\n    /**\r\n     * Size of variable part of struct.\r\n     */\r\n    public get variableSize(): number {\r\n        // Ensure setup was called.\r\n        this.ensureSetup();\r\n\r\n        return this.mVariableSize;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pDevice - Device reference.\r\n     * @param pParameter - Parameter.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pAlignmentType: BufferAlignmentType) {\r\n        super(pDevice, pAlignmentType);\r\n\r\n        // Calculated properties.\r\n        this.mAlignment = 0;\r\n        this.mFixedSize = 0;\r\n        this.mVariableSize = 0;\r\n\r\n        // Static properties.\r\n        this.mInnerProperties = new Array<StructBufferMemoryLayoutProperty>();\r\n    }\r\n\r\n    /**\r\n     * Get location of path.\r\n     * @param pPathName - Path name. Divided by dots.\r\n     */\r\n    public override locationOf(pPathName: Array<string>): BufferLayoutLocation {\r\n        // Ensure setup was called.\r\n        this.ensureSetup();\r\n\r\n        const lPathName: Array<string> = [...pPathName];\r\n\r\n        // Complete array.\r\n        const lPropertyName: string | undefined = lPathName.shift();\r\n        if (!lPropertyName) {\r\n            if (this.mVariableSize > 0) {\r\n                throw new Exception(`Can't read location of a memory layout with a variable size.`, this);\r\n            }\r\n\r\n            return { size: this.fixedSize, offset: 0 };\r\n        }\r\n\r\n        // Recalculate size.\r\n        let lPropertyOffset: number = 0;\r\n        let lFoundProperty: StructBufferMemoryLayoutProperty | null = null;\r\n        for (const lProperty of this.mInnerProperties) {\r\n            // Increase offset to needed alignment.\r\n            lPropertyOffset = Math.ceil(lPropertyOffset / lProperty.layout.alignment) * lProperty.layout.alignment;\r\n\r\n            // Inner property is found. Skip searching.\r\n            // Alignment just applied so it can be skipped later.\r\n            if (lProperty.name === lPropertyName) {\r\n                lFoundProperty = lProperty;\r\n                break;\r\n            }\r\n\r\n            // Increase offset for complete property. \r\n            // Only last property can have a variable size, so we can only save the fixed size.\r\n            lPropertyOffset += lProperty.layout.fixedSize;\r\n        }\r\n\r\n        // Validate property.\r\n        if (!lFoundProperty) {\r\n            throw new Exception(`Struct buffer layout property \"${lPropertyName}\" not found.`, this);\r\n        }\r\n\r\n        const lPropertyLocation = lFoundProperty.layout.locationOf(lPathName);\r\n        return {\r\n            size: lPropertyLocation.size,\r\n            offset: lPropertyOffset + lPropertyLocation.offset\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Call setup.\r\n     *\r\n     * @param pSetupCallback - Setup callback.\r\n     *\r\n     * @returns this.\r\n     */\r\n    public override setup(pSetupCallback?: ((pSetup: StructBufferMemoryLayoutSetup) => void)): this {\r\n        super.setup(pSetupCallback);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Setup struct layout.\r\n     * \r\n     * @param pReferences - Setup data references.\r\n     */\r\n    protected override onSetup(pReferences: StructBufferMemoryLayoutSetupData): void {\r\n        // Add each property\r\n        for (const lProperty of pReferences.properties) {\r\n            if (!lProperty.layout) {\r\n                throw new Exception(`Struct propery layout was not set.`, this);\r\n            }\r\n\r\n            this.mInnerProperties.push({\r\n                orderIndex: lProperty.orderIndex,\r\n                name: lProperty.name,\r\n                layout: lProperty.layout\r\n            });\r\n        }\r\n\r\n        // Order properties.\r\n        this.mInnerProperties = this.mInnerProperties.sort((pA, pB) => {\r\n            return pA.orderIndex - pB.orderIndex;\r\n        });\r\n\r\n        // Calculate size.\r\n        let lRawDataSize: number = 0;\r\n        for (let lIndex: number = 0; lIndex < this.mInnerProperties.length; lIndex++) {\r\n            const lPropertyLayout = this.mInnerProperties[lIndex].layout;\r\n\r\n            if (lPropertyLayout.variableSize > 0 && lIndex !== (this.mInnerProperties.length - 1)) {\r\n                throw new Exception(`Only the last property of a struct memory layout can have a variable size.`, this);\r\n            }\r\n\r\n            // Increase offset to needed alignment.\r\n            lRawDataSize = Math.ceil(lRawDataSize / lPropertyLayout.alignment) * lPropertyLayout.alignment;\r\n\r\n            // Increase offset for type.\r\n            lRawDataSize += lPropertyLayout.fixedSize;\r\n\r\n            // Alignment is the highest alignment of all properties.\r\n            if (lPropertyLayout.alignment > this.mAlignment) {\r\n                this.mAlignment = lPropertyLayout.alignment;\r\n            }\r\n\r\n            // Set variable size. Can only be the last property.\r\n            if (lPropertyLayout.variableSize > 0) {\r\n                this.mVariableSize = lPropertyLayout.variableSize;\r\n            }\r\n        }\r\n\r\n        // Apply struct alignment to raw data size.\r\n        this.mFixedSize = Math.ceil(lRawDataSize / this.mAlignment) * this.mAlignment;\r\n\r\n        // Change alignment based on alignment type.\r\n        this.mAlignment = (() => {\r\n            switch (this.alignmentType) {\r\n                case BufferAlignmentType.Packed: {\r\n                    return 1;\r\n                }\r\n                case BufferAlignmentType.Storage: {\r\n                    return this.mAlignment;\r\n                }\r\n                case BufferAlignmentType.Uniform: {\r\n                    // For uniforms, struct buffers are aligned by 16 byte\r\n                    return Math.ceil(this.mAlignment / 16) * 16;\r\n                }\r\n            }\r\n        })();\r\n    }\r\n\r\n    /**\r\n     * Create setup object.\r\n     * \r\n     * @param pReferences - Setup references.\r\n     * \r\n     * @returns setup object. \r\n     */\r\n    protected override onSetupObjectCreate(pReferences: GpuObjectSetupReferences<StructBufferMemoryLayoutSetupData>): StructBufferMemoryLayoutSetup {\r\n        return new StructBufferMemoryLayoutSetup(pReferences, this.alignmentType);\r\n    }\r\n}\r\n\r\nexport type StructBufferMemoryLayoutProperty = {\r\n    orderIndex: number,\r\n    name: string,\r\n    layout: BaseBufferMemoryLayout;\r\n};", "export enum TextureDimension {\r\n    OneDimension = '1d',\r\n    TwoDimension = '2d',\r\n    ThreeDimension = '3d'\r\n}", "import { TextureUsage } from '../constant/texture-usage.enum.ts';\r\nimport { TextureViewDimension } from '../constant/texture-view-dimension.enum.ts';\r\nimport { GpuDevice } from '../device/gpu-device.ts';\r\nimport { GpuResourceObject, GpuResourceObjectInvalidationType } from '../gpu_object/gpu-resource-object.ts';\r\nimport { IGpuObjectNative } from '../gpu_object/interface/i-gpu-object-native.ts';\r\nimport { GpuTexture } from './gpu-texture.ts';\r\nimport { TextureViewMemoryLayout } from './memory_layout/texture-view-memory-layout.ts';\r\n\r\n/**\r\n * View to a gpu texture.\r\n */\r\nexport class GpuTextureView extends GpuResourceObject<TextureUsage, GPUTextureView> implements IGpuObjectNative<GPUTextureView> {\r\n    private mArrayLayerEnd: number;\r\n    private mArrayLayerStart: number;\r\n    private readonly mLayout: TextureViewMemoryLayout;\r\n    private mMipLevelEnd: number;\r\n    private mMipLevelStart: number;\r\n    private readonly mTexture: GpuTexture;\r\n\r\n    /**\r\n     * End index of depth or array level.\r\n     */\r\n    public get arrayLayerEnd(): number {\r\n        return this.mArrayLayerEnd;\r\n    } set arrayLayerEnd(pArrayLayer: number) {\r\n        this.mArrayLayerEnd = pArrayLayer;\r\n\r\n        // Invalidate view.\r\n        this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * Staring index of depth or array level.\r\n     */\r\n    public get arrayLayerStart(): number {\r\n        return this.mArrayLayerStart;\r\n    } set arrayLayerStart(pArrayLayerIndex: number) {\r\n        this.mArrayLayerStart = pArrayLayerIndex;\r\n\r\n        // Invalidate view.\r\n        this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * Texture layout.\r\n     */\r\n    public get layout(): TextureViewMemoryLayout {\r\n        return this.mLayout;\r\n    }\r\n\r\n    /**\r\n     * End index of mip level.\r\n     */\r\n    public get mipLevelEnd(): number {\r\n        return this.mMipLevelEnd;\r\n    } set mipLevelEnd(pMipLevel: number) {\r\n        this.mMipLevelEnd = pMipLevel;\r\n\r\n        // Invalidate view.\r\n        this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * Staring index of mip level.\r\n     */\r\n    public get mipLevelStart(): number {\r\n        return this.mMipLevelStart;\r\n    } set mipLevelStart(pMipLevel: number) {\r\n        this.mMipLevelStart = pMipLevel;\r\n\r\n        // Invalidate view.\r\n        this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * Native gpu object.\r\n     */\r\n    public override get native(): GPUTextureView {\r\n        return super.native;\r\n    }\r\n\r\n    /**\r\n     * Views texture.\r\n     */\r\n    public get texture(): GpuTexture {\r\n        return this.mTexture;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Device.\r\n     * @param pTexture - Texture of view.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pTexture: GpuTexture, pLayout: TextureViewMemoryLayout) {\r\n        super(pDevice);\r\n\r\n        // Set statics.\r\n        this.mTexture = pTexture;\r\n        this.mLayout = pLayout;\r\n\r\n        // Set defaults.\r\n        this.mMipLevelStart = 0;\r\n        this.mMipLevelEnd = -1;\r\n        this.mArrayLayerStart = 0;\r\n        this.mArrayLayerEnd = -1;\r\n\r\n        // Trigger View rebuild on texture rebuilds.\r\n        pTexture.addInvalidationListener(() => {\r\n            this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n        }, GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * Generate native canvas texture view.\r\n     */\r\n    protected override generateNative(): GPUTextureView {\r\n        // Read native texture.\r\n        const lNativeTexture: GPUTexture = this.mTexture.native;\r\n\r\n        // When mip end level or array end layer is not set, use textures max. \r\n        const lMipLevelEnd: number = this.mMipLevelEnd < 0 ? (lNativeTexture.mipLevelCount - 1) : this.mMipLevelEnd;\r\n        const lArrayLayerEnd: number = this.mArrayLayerEnd < 0 ? (lNativeTexture.depthOrArrayLayers - 1) : this.mArrayLayerEnd;\r\n\r\n        // Validate dimension based on \r\n        const lDimensionViewDepthCount: number = (() => {\r\n            switch (this.mLayout.dimension) {\r\n                case TextureViewDimension.OneDimension:\r\n                case TextureViewDimension.TwoDimension: {\r\n                    return 1;\r\n                }\r\n                case TextureViewDimension.Cube: {\r\n                    return 6;\r\n                }\r\n                case TextureViewDimension.CubeArray: {\r\n                    return Math.floor(((lArrayLayerEnd - this.mArrayLayerStart) + 1) / 6) * 6;\r\n                }\r\n                case TextureViewDimension.TwoDimensionArray:\r\n                case TextureViewDimension.ThreeDimension: {\r\n                    return (lArrayLayerEnd - this.mArrayLayerStart) + 1;\r\n                }\r\n                default: {\r\n                    return 1;\r\n                }\r\n            }\r\n        })();\r\n\r\n        // Create and configure canvas context.\r\n        return lNativeTexture.createView({\r\n            aspect: 'all',\r\n            format: this.mLayout.format as GPUTextureFormat,\r\n            dimension: this.mLayout.dimension,\r\n\r\n            // Mip start and end.\r\n            baseMipLevel: this.mMipLevelStart,\r\n            mipLevelCount: (lMipLevelEnd - this.mMipLevelStart) + 1,\r\n\r\n            // Array layer start and end.\r\n            baseArrayLayer: this.mArrayLayerStart,\r\n            arrayLayerCount: lDimensionViewDepthCount\r\n        });\r\n    }\r\n}", "import { BaseMemoryLayout } from '../../base-memory-layout.ts';\r\nimport { TextureFormat } from '../../constant/texture-format.enum.ts';\r\nimport { TextureViewDimension } from '../../constant/texture-view-dimension.enum.ts';\r\nimport { GpuDevice } from '../../device/gpu-device.ts';\r\n\r\n/**\r\n * Memory layout for textures views.\r\n */\r\nexport class TextureViewMemoryLayout extends BaseMemoryLayout {\r\n    private readonly mDimension: TextureViewDimension;\r\n    private readonly mFormat: TextureFormat;\r\n    private readonly mMultisampled: boolean;\r\n\r\n    /**\r\n     * Texture dimension.\r\n     */\r\n    public get dimension(): TextureViewDimension {\r\n        return this.mDimension;\r\n    }\r\n\r\n    /**\r\n     * Texture format.\r\n     */\r\n    public get format(): TextureFormat {\r\n        return this.mFormat;\r\n    }\r\n\r\n    /**\r\n     * Texture uses multisample.\r\n     */\r\n    public get multisampled(): boolean {\r\n        return this.mMultisampled;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pDevice - Device reference.\r\n     * @param pParameter - Parameter.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pParameter: TextureViewMemoryLayoutParameter) {\r\n        super(pDevice);\r\n\r\n        // Set defauls.\r\n        this.mDimension = pParameter.dimension;\r\n        this.mFormat = pParameter.format;\r\n        this.mMultisampled = pParameter.multisampled;\r\n    }\r\n}\r\n\r\ntype TextureViewMemoryLayoutParameter = {\r\n    dimension: TextureViewDimension;\r\n    format: TextureFormat;\r\n    multisampled: boolean;\r\n};\r\n", "import { Exception } from '@kartoffelgames/core';\r\nimport { GpuLimit } from '../constant/gpu-limit.enum.ts';\r\nimport { TextureDimension } from '../constant/texture-dimension.enum.ts';\r\nimport { TextureFormat } from '../constant/texture-format.enum.ts';\r\nimport { TextureUsage } from '../constant/texture-usage.enum.ts';\r\nimport { TextureViewDimension } from '../constant/texture-view-dimension.enum.ts';\r\nimport { GpuDevice } from '../device/gpu-device.ts';\r\nimport { GpuResourceObject, GpuResourceObjectInvalidationType } from '../gpu_object/gpu-resource-object.ts';\r\nimport { IGpuObjectNative } from '../gpu_object/interface/i-gpu-object-native.ts';\r\nimport { GpuTextureView } from './gpu-texture-view.ts';\r\nimport { TextureViewMemoryLayout } from './memory_layout/texture-view-memory-layout.ts';\r\n\r\n/**\r\n * Gpu texture that is alocated on gpu memory.\r\n */\r\nexport class GpuTexture extends GpuResourceObject<TextureUsage, GPUTexture> implements IGpuObjectNative<GPUTexture> {\r\n    private mDepth: number;\r\n    private readonly mDimension: TextureDimension;\r\n    private readonly mFormat: TextureFormat;\r\n    private mHeight: number;\r\n    private mMipLevelCount: number;\r\n    private readonly mMultisampled: boolean;\r\n    private mWidth: number;\r\n\r\n    /**\r\n     * Texture depth.\r\n     */\r\n    public get depth(): number {\r\n        return this.mDepth;\r\n    } set depth(pDepth: number) {\r\n        this.mDepth = pDepth;\r\n\r\n        // Invalidate texture.\r\n        this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * Texture dimension.\r\n     */\r\n    public get dimension(): TextureDimension {\r\n        return this.mDimension;\r\n    }\r\n\r\n    /**\r\n     * Texture format.\r\n     */\r\n    public get format(): TextureFormat {\r\n        return this.mFormat;\r\n    }\r\n\r\n    /**\r\n     * Texture height.\r\n     */\r\n    public get height(): number {\r\n        return this.mHeight;\r\n    } set height(pHeight: number) {\r\n        this.mHeight = pHeight;\r\n\r\n        // Invalidate texture.\r\n        this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * Texture mip level count.\r\n     */\r\n    public get mipCount(): number {\r\n        return this.mMipLevelCount;\r\n    } set mipCount(pMipCount: number) {\r\n        this.mMipLevelCount = pMipCount;\r\n\r\n        // Invalidate texture.\r\n        this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * Texture multi sampled.\r\n     */\r\n    public get multiSampled(): boolean {\r\n        return this.mMultisampled;\r\n    }\r\n\r\n    /**\r\n     * Native gpu object.\r\n     */\r\n    public override get native(): GPUTexture {\r\n        return super.native;\r\n    }\r\n\r\n    /**\r\n     * Texture width.\r\n     */\r\n    public get width(): number {\r\n        return this.mWidth;\r\n    } set width(pWidth: number) {\r\n        this.mWidth = pWidth;\r\n\r\n        // Invalidate texture.\r\n        this.invalidate(GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Device.\r\n     * @param pLayout - Texture layout.\r\n     * @param pCanvas - Canvas of texture.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pParameter: GpuTextureParameter) {\r\n        super(pDevice);\r\n\r\n        // Allways add copy source/destination and copy over information on rebuild. \r\n        this.extendUsage(TextureUsage.CopyDestination);\r\n        this.extendUsage(TextureUsage.CopySource);\r\n\r\n        // Set static config.\r\n        this.mDimension = pParameter.dimension;\r\n        this.mFormat = pParameter.format;\r\n        this.mMultisampled = pParameter.multisampled;\r\n\r\n        // Set defaults.\r\n        this.mMipLevelCount = 1;\r\n        this.mDepth = 1;\r\n        this.mHeight = 1;\r\n        this.mWidth = 1;\r\n    }\r\n\r\n    public copyFrom(...pTextures: Array<GpuTextureCopyOptions | GpuTextureCopyData>): void {\r\n        // Convert into none optional config.\r\n        const lCopyConfig: Array<GpuTextureCopyDefinition> = new Array<GpuTextureCopyDefinition>();\r\n        for (let lTextureIndex: number = 0; lTextureIndex < pTextures.length; lTextureIndex++) {\r\n            const lCopyTexture: GpuTextureCopyOptions | GpuTextureCopyData = pTextures[lTextureIndex];\r\n\r\n            // Create new config from data.\r\n            if (!('data' in lCopyTexture)) {\r\n                // Wild instance checks.\r\n                switch (true) {\r\n                    case lCopyTexture instanceof GpuTexture: {\r\n                        lCopyConfig.push({\r\n                            data: lCopyTexture,\r\n                            mipLevel: 0,\r\n                            external: false,\r\n                            dimension: {\r\n                                width: lCopyTexture.width,\r\n                                height: lCopyTexture.height,\r\n                                depthOrArrayLayers: lCopyTexture.depth\r\n                            },\r\n                            sourceOrigin: { x: 0, y: 0, z: 0 },\r\n                            targetOrigin: { x: 0, y: 0, z: lTextureIndex }\r\n                        });\r\n\r\n                        continue;\r\n                    }\r\n                    case lCopyTexture instanceof ImageBitmap: {\r\n                        lCopyConfig.push({\r\n                            data: lCopyTexture,\r\n                            mipLevel: 0,\r\n                            external: true,\r\n                            dimension: {\r\n                                width: lCopyTexture.width,\r\n                                height: lCopyTexture.height,\r\n                                depthOrArrayLayers: 1\r\n                            },\r\n                            sourceOrigin: { x: 0, y: 0, z: 0 },\r\n                            targetOrigin: { x: 0, y: 0, z: lTextureIndex }\r\n                        });\r\n\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                // Not hit. But better to read.\r\n                continue;\r\n            }\r\n\r\n            // Get data type.\r\n            const lExternal: boolean = !(lCopyTexture instanceof GpuTexture);\r\n\r\n            // Fill in missing values with defaults.\r\n            lCopyConfig.push({\r\n                data: lCopyTexture.data as any,\r\n                external: lExternal,\r\n                mipLevel: lCopyTexture.mipLevel ?? 0,\r\n                dimension: {\r\n                    width: lCopyTexture.dimension?.width ?? lCopyTexture.data.width,\r\n                    height: lCopyTexture.dimension?.height ?? lCopyTexture.data.height,\r\n                    depthOrArrayLayers: lCopyTexture.dimension?.depth ?? ('depth' in lCopyTexture.data ? lCopyTexture.data.depth : 1)\r\n                },\r\n                sourceOrigin: lCopyTexture.sourceOrigin ?? { x: 0, y: 0, z: 0 },\r\n                targetOrigin: lCopyTexture.targetOrigin ?? { x: 0, y: 0, z: 0 }\r\n            });\r\n        }\r\n\r\n        // Extend usage to be able to copy from external and gpu textures.\r\n        this.extendUsage(TextureUsage.CopyDestination);\r\n        this.extendUsage(TextureUsage.RenderAttachment);\r\n\r\n        // Generate native texture.\r\n        const lDestination: GPUImageCopyTexture = {\r\n            texture: this.native,\r\n            aspect: 'all'\r\n        };\r\n\r\n        // Create copy command encoder to store copy actions.\r\n        const lCommandDecoder: GPUCommandEncoder = this.device.gpu.createCommandEncoder();\r\n\r\n        for (const lSourceTexture of lCopyConfig) {\r\n            // Skip copy of textures outside of targets mip level.\r\n            if (lDestination.texture.mipLevelCount < lSourceTexture.mipLevel) {\r\n                continue;\r\n            }\r\n\r\n            // Apply destination config.\r\n            lDestination.origin = lSourceTexture.targetOrigin;\r\n            lDestination.mipLevel = lSourceTexture.mipLevel;\r\n\r\n            // Calculate target max size for the specific mip map.\r\n            const lDestinationMaxSize: GpuTextureDimension = {\r\n                width: Math.floor(lDestination.texture.width / Math.pow(2, lDestination.mipLevel)),\r\n                height: Math.floor(lDestination.texture.height / Math.pow(2, lDestination.mipLevel)),\r\n                // On 3D textures the depth count to the mip.\r\n                depthOrArrayLayers: (lDestination.texture.dimension === '3d') ?\r\n                    Math.floor(lDestination.texture.depthOrArrayLayers / Math.pow(2, lDestination.mipLevel)) :\r\n                    lDestination.texture.depthOrArrayLayers,\r\n            };\r\n\r\n            // Clamp copy sizes to lowest.\r\n            const lClampedCopySize: GpuTextureDimension = {\r\n                width: Math.min(\r\n                    lDestinationMaxSize.width - lSourceTexture.targetOrigin.x,\r\n                    lSourceTexture.dimension.width - lSourceTexture.sourceOrigin.x\r\n                ),\r\n                height: Math.min(\r\n                    lDestinationMaxSize.height - lSourceTexture.targetOrigin.y,\r\n                    lSourceTexture.dimension.height - lSourceTexture.sourceOrigin.y\r\n                ),\r\n                depthOrArrayLayers: Math.min(\r\n                    lDestinationMaxSize.depthOrArrayLayers - lSourceTexture.targetOrigin.z,\r\n                    lSourceTexture.dimension.depthOrArrayLayers - lSourceTexture.sourceOrigin.z\r\n                )\r\n            };\r\n\r\n            // Omit copy when nothing should by copied.\r\n            if (lClampedCopySize.width < 1 || lClampedCopySize.height < 1 || lClampedCopySize.depthOrArrayLayers < 1) {\r\n                continue;\r\n            }\r\n\r\n            // Copy external.\r\n            if (lSourceTexture.external) {\r\n                // Create External source.\r\n                const lSource: GPUImageCopyExternalImage = {\r\n                    source: lSourceTexture.data,\r\n                    origin: [lSourceTexture.sourceOrigin.x, lSourceTexture.sourceOrigin.y]\r\n                };\r\n\r\n                // Add external copy into queue.\r\n                this.device.gpu.queue.copyExternalImageToTexture(lSource, lDestination, lClampedCopySize);\r\n\r\n                continue;\r\n            }\r\n\r\n            // Create copy source information.\r\n            const lSource: GPUImageCopyTexture = {\r\n                texture: lSourceTexture.data.native,\r\n                aspect: 'all',\r\n                origin: lSourceTexture.targetOrigin,\r\n                mipLevel: 0\r\n            };\r\n\r\n            // Add copy action to command queue.\r\n            lCommandDecoder.copyTextureToTexture(lSource, lDestination, lClampedCopySize);\r\n        }\r\n\r\n        // Submit copy actions.\r\n        this.device.gpu.queue.submit([lCommandDecoder.finish()]);\r\n    }\r\n\r\n    /**\r\n     * Use texture as view. \r\n     * @returns Texture view.\r\n     */\r\n    public useAs(pDimension?: TextureViewDimension /* Others Optional, layer, mip ... */): GpuTextureView {\r\n        // Use dimension form parameter or convert texture dimension to view dimension.\r\n        const lViewDimension: TextureViewDimension = pDimension ?? (() => {\r\n            switch (this.mDimension) {\r\n                case TextureDimension.OneDimension: {\r\n                    return TextureViewDimension.OneDimension;\r\n                }\r\n                case TextureDimension.TwoDimension: {\r\n                    return TextureViewDimension.TwoDimension;\r\n                }\r\n                case TextureDimension.ThreeDimension: {\r\n                    return TextureViewDimension.ThreeDimension;\r\n                }\r\n            }\r\n        })();\r\n\r\n        const lLayout: TextureViewMemoryLayout = new TextureViewMemoryLayout(this.device, {\r\n            format: this.mFormat,\r\n            dimension: lViewDimension,\r\n            multisampled: this.mMultisampled\r\n        });\r\n\r\n        return new GpuTextureView(this.device, this, lLayout);\r\n    }\r\n\r\n    /**\r\n     * Destory texture object.\r\n     * \r\n     * @param _pNativeObject - Native gpu texture.\r\n     */\r\n    protected override destroyNative(pNativeObject: GPUTexture): void {\r\n        pNativeObject.destroy();\r\n    }\r\n\r\n    /**\r\n     * Generate native canvas texture view.\r\n     */\r\n    protected override generateNative(pOldTexture: GPUTexture): GPUTexture {\r\n        // Generate gpu dimension from memory layout dimension and enforce limits.\r\n        const lTextureDimensions: { textureDimension: GPUTextureDimension, clampedDimensions: [number, number, number]; } = (() => {\r\n            switch (this.mDimension) {\r\n                case TextureDimension.OneDimension: {\r\n                    // Enforce dimension limits.\r\n                    const lDimensionLimit: number = this.device.capabilities.getLimit(GpuLimit.MaxTextureDimension1D);\r\n                    if (this.mWidth > lDimensionLimit) {\r\n                        throw new Exception(`Texture dimension exeeced for 1D Texture(${this.mWidth}).`, this);\r\n                    }\r\n\r\n                    return {\r\n                        textureDimension: '1d',\r\n                        clampedDimensions: [this.mWidth, 1, 1]\r\n                    };\r\n                }\r\n                case TextureDimension.TwoDimension: {\r\n                    // Enforce dimension limits.\r\n                    const lDimensionLimit: number = this.device.capabilities.getLimit(GpuLimit.MaxTextureDimension1D);\r\n                    if (this.mWidth > lDimensionLimit || this.mHeight > lDimensionLimit) {\r\n                        throw new Exception(`Texture dimension exeeced for 2D Texture(${this.mWidth}, ${this.mHeight}).`, this);\r\n                    }\r\n\r\n                    // Enforce array layer limits.\r\n                    const lArrayLayerLimit: number = this.device.capabilities.getLimit(GpuLimit.MaxTextureArrayLayers);\r\n                    if (this.mDepth > lArrayLayerLimit) {\r\n                        throw new Exception(`Texture array layer exeeced for 2D Texture(${this.mDepth}).`, this);\r\n                    }\r\n\r\n                    return {\r\n                        textureDimension: '2d',\r\n                        clampedDimensions: [this.mWidth, this.mHeight, this.mDepth]\r\n                    };\r\n                }\r\n                case TextureDimension.ThreeDimension: {\r\n                    // Enforce dimension limits.\r\n                    const lDimensionLimit: number = this.device.capabilities.getLimit(GpuLimit.MaxTextureDimension3D);\r\n                    if (this.mWidth > lDimensionLimit || this.mHeight > lDimensionLimit || this.mDepth > lDimensionLimit) {\r\n                        throw new Exception(`Texture dimension exeeced for 3D Texture(${this.mWidth}, ${this.mHeight}, ${this.mDepth}).`, this);\r\n                    }\r\n\r\n                    return {\r\n                        textureDimension: '3d',\r\n                        clampedDimensions: [this.mWidth, this.mHeight, this.mDepth]\r\n                    };\r\n                }\r\n            }\r\n        })();\r\n\r\n        // Calculate max mip count.\r\n        let lMaxMipCount;\r\n        if (lTextureDimensions.textureDimension === '3d') {\r\n            lMaxMipCount = 1 + Math.floor(Math.log2(Math.max(this.mWidth, this.mHeight, this.mDepth)));\r\n        } else {\r\n            lMaxMipCount = 1 + Math.floor(Math.log2(Math.max(this.mWidth, this.mHeight)));\r\n        }\r\n\r\n        // Create and configure canvas context.\r\n        const lNewTexture: GPUTexture = this.device.gpu.createTexture({\r\n            label: 'GPU-Texture',\r\n            size: lTextureDimensions.clampedDimensions,\r\n            format: this.mFormat as GPUTextureFormat,\r\n            usage: this.usage,\r\n            dimension: lTextureDimensions.textureDimension,\r\n            sampleCount: this.mMultisampled ? 4 : 1,\r\n            mipLevelCount: Math.min(this.mMipLevelCount, lMaxMipCount)\r\n        });\r\n\r\n        // Copy old texture data into new texture.\r\n        if (pOldTexture !== null && lNewTexture.sampleCount === 1) {\r\n            // Create copy command encoder to store copy actions.\r\n            const lCommandDecoder: GPUCommandEncoder = this.device.gpu.createCommandEncoder();\r\n\r\n            // Copy each mip level.\r\n            const lCopyMipCount: number = Math.min(lNewTexture.mipLevelCount, pOldTexture.mipLevelCount);\r\n            for (let lMipLevel: number = 0; lMipLevel < lCopyMipCount; lMipLevel++) {\r\n\r\n                // Create copy source settings.\r\n                const lSource: GPUImageCopyTexture = {\r\n                    texture: pOldTexture,\r\n                    aspect: 'all',\r\n                    origin: [0, 0, 0],\r\n                    mipLevel: lMipLevel\r\n                };\r\n\r\n                // Create copy destination settings.\r\n                const lDestination: GPUImageCopyTexture = {\r\n                    texture: lNewTexture,\r\n                    aspect: 'all',\r\n                    origin: [0, 0, 0],\r\n                    mipLevel: lMipLevel\r\n                };\r\n\r\n                // Destination clamped sizes to mip level.\r\n                const lDestinationMaxSize: GpuTextureDimension = {\r\n                    width: Math.floor(lNewTexture.width / Math.pow(2, lMipLevel)),\r\n                    height: Math.floor(lNewTexture.height / Math.pow(2, lMipLevel)),\r\n                    // On 3D textures the depth count to the mip.\r\n                    depthOrArrayLayers: (lNewTexture.dimension === '3d') ?\r\n                        Math.floor(lNewTexture.depthOrArrayLayers / Math.pow(2, lMipLevel)) :\r\n                        lNewTexture.depthOrArrayLayers,\r\n                };\r\n\r\n                // Source clamped sizes to mip level.\r\n                const lSourceMaxSize: GpuTextureDimension = {\r\n                    width: Math.floor(pOldTexture.width / Math.pow(2, lMipLevel)),\r\n                    height: Math.floor(pOldTexture.height / Math.pow(2, lMipLevel)),\r\n                    // On 3D textures the depth count to the mip.\r\n                    depthOrArrayLayers: (pOldTexture.dimension === '3d') ?\r\n                        Math.floor(pOldTexture.depthOrArrayLayers / Math.pow(2, lMipLevel)) :\r\n                        pOldTexture.depthOrArrayLayers,\r\n                };\r\n\r\n                // Clamp copy sizes to lowest.\r\n                const lClampedCopySize: GpuTextureDimension = {\r\n                    width: Math.min(lSourceMaxSize.width, lDestinationMaxSize.width),\r\n                    height: Math.min(lSourceMaxSize.height, lDestinationMaxSize.height),\r\n                    depthOrArrayLayers: Math.min(lSourceMaxSize.depthOrArrayLayers, lDestinationMaxSize.depthOrArrayLayers)\r\n                };\r\n\r\n\r\n                // Add copy action to command queue.\r\n                lCommandDecoder.copyTextureToTexture(lSource, lDestination, lClampedCopySize);\r\n            }\r\n\r\n            // Submit copy actions.\r\n            this.device.gpu.queue.submit([lCommandDecoder.finish()]);\r\n        }\r\n\r\n        return lNewTexture;\r\n    }\r\n}\r\n\r\ntype GpuTextureParameter = {\r\n    format: TextureFormat;\r\n    dimension: TextureDimension;\r\n    multisampled: boolean;\r\n};\r\n\r\ntype GpuTextureDimension = {\r\n    width: number;\r\n    height: number;\r\n    depthOrArrayLayers: number;\r\n};\r\n\r\ntype GpuTextureOrigin = {\r\n    x: number;\r\n    y: number;\r\n    z: number;\r\n};\r\n\r\ntype GpuTextureCopyDefinition = ({ data: GpuTexture; external: false; } | { data: ImageBitmap; external: true; }) & {\r\n    mipLevel: number;\r\n    dimension: GpuTextureDimension;\r\n    sourceOrigin: GpuTextureOrigin;\r\n    targetOrigin: GpuTextureOrigin;\r\n};\r\n\r\ntype GpuTextureCopyData = GpuTexture | ImageBitmap;\r\nexport type GpuTextureCopyOptions = {\r\n    data: GpuTextureCopyData;\r\n    mipLevel?: number;\r\n    dimension?: {\r\n        width: number;\r\n        height: number;\r\n        depth: number;\r\n    };\r\n    sourceOrigin?: GpuTextureOrigin;\r\n    targetOrigin?: GpuTextureOrigin;\r\n};", "import { BaseMemoryLayout } from '../../base-memory-layout.ts';\r\nimport { SamplerType } from '../../constant/sampler-type.enum.ts';\r\nimport { GpuDevice } from '../../device/gpu-device.ts';\r\n\r\n/**\r\n * Memory layouts for texture samplers.\r\n */\r\nexport class SamplerMemoryLayout extends BaseMemoryLayout {\r\n    private readonly mSamplerType: SamplerType;\r\n\r\n    /**\r\n     * Sampler type.\r\n     */\r\n    public get samplerType(): SamplerType {\r\n        return this.mSamplerType;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pDevice - Device reference.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pType: SamplerType) {\r\n        super(pDevice);\r\n\r\n        this.mSamplerType = pType;\r\n    }\r\n}\r\n", "import { Exception, TypedArray } from '@kartoffelgames/core';\r\nimport { GpuBuffer } from '../../buffer/gpu-buffer.ts';\r\nimport { GpuBufferView, GpuBufferViewFormat } from '../../buffer/gpu-buffer-view.ts';\r\nimport { ArrayBufferMemoryLayout } from '../../buffer/memory_layout/array-buffer-memory-layout.ts';\r\nimport { BaseBufferMemoryLayout } from '../../buffer/memory_layout/base-buffer-memory-layout.ts';\r\nimport { PrimitiveBufferMemoryLayout } from '../../buffer/memory_layout/primitive-buffer-memory-layout.ts';\r\nimport { StructBufferMemoryLayout } from '../../buffer/memory_layout/struct-buffer-memory-layout.ts';\r\nimport { BufferItemFormat } from '../../constant/buffer-item-format.enum.ts';\r\nimport { GpuLimit } from '../../constant/gpu-limit.enum.ts';\r\nimport { StorageBindingType } from '../../constant/storage-binding-type.enum.ts';\r\nimport { TextureDimension } from '../../constant/texture-dimension.enum.ts';\r\nimport { TextureViewDimension } from '../../constant/texture-view-dimension.enum.ts';\r\nimport { GpuObjectSetupReferences } from '../../gpu_object/gpu-object.ts';\r\nimport { GpuObjectChildSetup } from '../../gpu_object/gpu-object-child-setup.ts';\r\nimport { GpuResourceObject } from '../../gpu_object/gpu-resource-object.ts';\r\nimport { GpuTexture } from '../../texture/gpu-texture.ts';\r\nimport { GpuTextureView } from '../../texture/gpu-texture-view.ts';\r\nimport { SamplerMemoryLayout } from '../../texture/memory_layout/sampler-memory-layout.ts';\r\nimport { TextureViewMemoryLayout } from '../../texture/memory_layout/texture-view-memory-layout.ts';\r\nimport { TextureSampler } from '../../texture/texture-sampler.ts';\r\nimport { BindLayout } from '../bind_group_layout/bind-group-layout.ts';\r\n\r\n/**\r\n * Setup child object for setup bind group gpu data resources. \r\n */\r\nexport class BindGroupDataSetup extends GpuObjectChildSetup<null, BindGroupDataCallback> {\r\n    private readonly mBindLayout: Readonly<BindLayout>;\r\n    private readonly mCurrentData: GpuResourceObject | null;\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pLayout - Target layout.\r\n     * @param pCurrentData - Current set data.\r\n     * @param pSetupReference - Setup data references.\r\n     * @param pDataCallback - Bind data callback.\r\n     */\r\n    public constructor(pLayout: Readonly<BindLayout>, pCurrentData: GpuResourceObject | null, pSetupReference: GpuObjectSetupReferences<null>, pDataCallback: BindGroupDataCallback) {\r\n        super(pSetupReference, pDataCallback);\r\n\r\n        // Set initial data.\r\n        this.mCurrentData = pCurrentData;\r\n        this.mBindLayout = pLayout;\r\n    }\r\n\r\n    /**\r\n     * Create a view with the attached buffer and binding layout. \r\n     * \r\n     * @param pValueType - Number item type of view.\r\n     * \r\n     * @returns view of buffer from bind group layout.\r\n     */\r\n    public asBufferView<T extends TypedArray>(pValueType: GpuBufferViewFormat<T>, pDynamicOffsetIndex?: number): GpuBufferView<T> {\r\n        const lData: GpuResourceObject = this.getRaw();\r\n        if (!(lData instanceof GpuBuffer)) {\r\n            throw new Exception('Bind data can not be converted into a buffer view.', this);\r\n        }\r\n\r\n        // Read layout buffer.\r\n        const lBufferLayout: BaseBufferMemoryLayout = this.mBindLayout.layout as BaseBufferMemoryLayout;\r\n\r\n        // Create view.\r\n        return lData.view(lBufferLayout, pValueType, pDynamicOffsetIndex);\r\n    }\r\n\r\n    /**\r\n     * Create na new buffer.\r\n     * \r\n     * @param pDataOrVariableLength - Buffer data without applied alignment,\r\n     *                                repeat count of variable parts of a layout or\r\n     *                                Offset count when binding has dynamic offsets. \r\n     * \r\n     * @returns created buffer.\r\n     */\r\n    public createBuffer(pData: Array<number>): GpuBuffer;\r\n    public createBuffer(pVariableSizeCount?: number): GpuBuffer;\r\n    public createBuffer(pDataOrVariableLength?: Array<number> | number): GpuBuffer {\r\n        // Create empty when no data array is set or fill it with the data array.\r\n        let lBuffer: GpuBuffer;\r\n        if (Array.isArray(pDataOrVariableLength)) {\r\n            lBuffer = this.createBufferFromArray(pDataOrVariableLength);\r\n        } else {\r\n            lBuffer = this.createEmptyBuffer(pDataOrVariableLength);\r\n        }\r\n\r\n        // Send created data.\r\n        this.sendData(lBuffer);\r\n\r\n        return lBuffer;\r\n    }\r\n\r\n    /**\r\n     * Create and init buffer with raw array buffer data.\r\n     * Data needs to have the right alignment and size.\r\n     * \r\n     * @param pData - Raw data. \r\n     * \r\n     * @returns - Created buffer.\r\n     */\r\n    public createBufferWithRawData(pData: ArrayBufferLike): GpuBuffer {\r\n        // Layout must be a buffer memory layout.\r\n        if (!(this.mBindLayout.layout instanceof BaseBufferMemoryLayout)) {\r\n            throw new Exception(`Bind data layout is not suitable for buffers.`, this);\r\n        }\r\n\r\n        // Calculate variable item count from initial buffer data.  \r\n        const lVariableItemCount: number = (() => {\r\n            // No need to calculate was it is allways zero.\r\n            if (this.mBindLayout.layout.variableSize === 0) {\r\n                return 0;\r\n            }\r\n\r\n            // Get initial buffer data byte length.\r\n            const lBufferByteLength: number = pData.byteLength;\r\n\r\n            // calculate item count and check if initial data meets requirments.\r\n            const lItemCount: number = (lBufferByteLength - this.mBindLayout.layout.fixedSize) / this.mBindLayout.layout.variableSize;\r\n            if (lItemCount % 1 > 0) {\r\n                throw new Exception(`Raw bind group data buffer data \"${this.mBindLayout.name}\" does not meet alignment.`, this);\r\n            }\r\n\r\n            return lItemCount;\r\n        })();\r\n\r\n        // Calculate buffer size with correct alignment.\r\n        let lByteSize: number = (lVariableItemCount ?? 0) * this.mBindLayout.layout.variableSize + this.mBindLayout.layout.fixedSize;\r\n        if (this.mBindLayout.hasDynamicOffset) {\r\n            // Read correct alignment limitations for storage type.\r\n            const lOffsetAlignment: number = (() => {\r\n                if (this.mBindLayout.storageType === StorageBindingType.None) {\r\n                    return this.device.capabilities.getLimit(GpuLimit.MinUniformBufferOffsetAlignment);\r\n                } else {\r\n                    return this.device.capabilities.getLimit(GpuLimit.MinStorageBufferOffsetAlignment);\r\n                }\r\n            })();\r\n\r\n            // Apply offset alignment to byte size.\r\n            lByteSize = Math.ceil(lByteSize / lOffsetAlignment) * lOffsetAlignment;\r\n            lByteSize *= Math.floor(pData.byteLength / lByteSize);\r\n        }\r\n\r\n        // Validate size.\r\n        if (pData.byteLength !== lByteSize) {\r\n            throw new Exception(`Raw bind group data buffer data \"${this.mBindLayout.name}\" does not meet data size (Should:${lByteSize} => Has:${pData.byteLength}) requirements.`, this);\r\n        }\r\n\r\n        // Create buffer.\r\n        const lBuffer: GpuBuffer = new GpuBuffer(this.device, lByteSize).initialData(pData);\r\n\r\n        // Send created data.\r\n        this.sendData(lBuffer);\r\n\r\n        return lBuffer;\r\n    }\r\n\r\n    /**\r\n     * Create new sampler.\r\n     * \r\n     * @returns created texture sampler.\r\n     */\r\n    public createSampler(): TextureSampler {\r\n        // Layout must be a sampler memory layout.\r\n        if (!(this.mBindLayout.layout instanceof SamplerMemoryLayout)) {\r\n            throw new Exception(`Bind data layout is not suitable for samplers.`, this);\r\n        }\r\n\r\n        // Create texture sampler.\r\n        const lSampler: TextureSampler = new TextureSampler(this.device, this.mBindLayout.layout);\r\n\r\n        // Send created data.\r\n        this.sendData(lSampler);\r\n\r\n        return lSampler;\r\n    }\r\n\r\n    /**\r\n     * Create texture view.\r\n     * Generates a new texture.\r\n     * \r\n      * @returns created texture view.\r\n     */\r\n    public createTexture(): GpuTextureView {\r\n        // Layout must be a texture viw memory layout.\r\n        if (!(this.mBindLayout.layout instanceof TextureViewMemoryLayout)) {\r\n            throw new Exception(`Bind data layout is not suitable for image textures.`, this);\r\n        }\r\n\r\n        // Generate texture dimension from view dimensions.\r\n        const lTextureDimension: TextureDimension = (() => {\r\n            switch (this.mBindLayout.layout.dimension) {\r\n                case TextureViewDimension.OneDimension: {\r\n                    return TextureDimension.OneDimension;\r\n                }\r\n                case TextureViewDimension.TwoDimensionArray:\r\n                case TextureViewDimension.Cube:\r\n                case TextureViewDimension.CubeArray:\r\n                case TextureViewDimension.TwoDimension: {\r\n                    return TextureDimension.TwoDimension;\r\n                }\r\n                case TextureViewDimension.ThreeDimension: {\r\n                    return TextureDimension.ThreeDimension;\r\n                }\r\n            }\r\n        })();\r\n\r\n        // Create texture.\r\n        const lTexture: GpuTexture = new GpuTexture(this.device, {\r\n            dimension: lTextureDimension,\r\n            format: this.mBindLayout.layout.format,\r\n            multisampled: this.mBindLayout.layout.multisampled\r\n        });\r\n\r\n        // Create view from texture.\r\n        const lTextureView: GpuTextureView = lTexture.useAs(this.mBindLayout.layout.dimension);\r\n\r\n        // Send created texture to parent bind group.\r\n        this.sendData(lTextureView);\r\n\r\n        return lTextureView;\r\n    }\r\n\r\n    /**\r\n     * Get current binded data.\r\n     * \r\n     * @returns current set bind data.\r\n     * \r\n     * @throws {@link Exception}\r\n     * When no data was set.\r\n     */\r\n    public getRaw<T extends GpuResourceObject<any, any, any, any>>(): T {\r\n        // Validate existence.\r\n        if (!this.mCurrentData) {\r\n            throw new Exception('No binding data was set.', this);\r\n        }\r\n\r\n        // Return current set data.\r\n        return this.mCurrentData as T;\r\n    }\r\n\r\n    /**\r\n     * Set already created bind data.\r\n     * \r\n     * @param pData - Created data.\r\n     * \r\n     * @returns set data.\r\n     */\r\n    public set<T extends GpuResourceObject<any, any, any, any>>(pData: T): T {\r\n        this.sendData(pData);\r\n\r\n        // Return same data.\r\n        return pData;\r\n    }\r\n\r\n    /**\r\n     * Create na new buffer.\r\n     * \r\n     * @param pData - Buffer data without right alignment.\r\n     * \r\n     * @returns created buffer.\r\n     */\r\n    private createBufferFromArray(pData: Array<number>): GpuBuffer {\r\n        // Layout must be a buffer memory layout.\r\n        if (!(this.mBindLayout.layout instanceof BaseBufferMemoryLayout)) {\r\n            throw new Exception(`Bind data layout is not suitable for buffers.`, this);\r\n        }\r\n\r\n        // Unwrap layout.\r\n        const lUnwrapedLayout: UnwrappedBufferLayout = this.unwrapLayouts(this.mBindLayout.layout);\r\n\r\n        // Validate data length that should be written.\r\n        if (lUnwrapedLayout.fixedItemCount > pData.length) {\r\n            throw new Exception(`Data has not enough numbers (count: ${pData.length}) to fill fixed buffer data (count: ${lUnwrapedLayout.fixedItemCount}).`, this);\r\n        }\r\n\r\n        // Get variable data repetitions.\r\n        let lVariableRepetitionCount: number = 0;\r\n        if (lUnwrapedLayout.variableItemCount > 0) {\r\n            lVariableRepetitionCount = (pData.length - lUnwrapedLayout.fixedItemCount) / lUnwrapedLayout.variableItemCount;\r\n        }\r\n\r\n        // Variable count should be an integer.\r\n        if (lVariableRepetitionCount % 1 !== 0) {\r\n            throw new Exception(`Data has not the right alignment to fill variable spaces without null space.`, this);\r\n        }\r\n\r\n        // Calculate buffer size with correct alignment.\r\n        let lDynamicOffsetAlignment: number = -1;\r\n        let lDynamicOffsetCount: number = 1;\r\n        let lByteSize: number = (lVariableRepetitionCount ?? 0) * this.mBindLayout.layout.variableSize + this.mBindLayout.layout.fixedSize;\r\n        if (this.mBindLayout.hasDynamicOffset) {\r\n            // Read correct alignment limitations for storage type.\r\n            lDynamicOffsetAlignment = (() => {\r\n                if (this.mBindLayout.storageType === StorageBindingType.None) {\r\n                    return this.device.capabilities.getLimit(GpuLimit.MinUniformBufferOffsetAlignment);\r\n                } else {\r\n                    return this.device.capabilities.getLimit(GpuLimit.MinStorageBufferOffsetAlignment);\r\n                }\r\n            })();\r\n\r\n            // Calculate dynamic offset count from data length.\r\n            lDynamicOffsetCount = (pData.length / lUnwrapedLayout.fixedItemCount);\r\n\r\n            // Apply offset alignment to byte size.\r\n            lByteSize = Math.ceil(lByteSize / lDynamicOffsetAlignment) * lDynamicOffsetAlignment;\r\n            lByteSize *= lDynamicOffsetCount;\r\n        }\r\n\r\n        // Create buffer with correct length.\r\n        const lBufferData: ArrayBuffer = new ArrayBuffer(lByteSize);\r\n        const lBufferDataView: DataView = new DataView(lBufferData);\r\n\r\n        // Write data.\r\n        let lDataIndex: number = 0;\r\n        let lByteOffset: number = 0;\r\n        const lWriteLayout = (pUnwrappedLayout: UnwrappedBufferLayout, pOverwrittenAlignment: number = -1) => {\r\n            const lLayoutAlignment: number = pOverwrittenAlignment !== -1 ? pOverwrittenAlignment : pUnwrappedLayout.alignment;\r\n\r\n            // Apply layout alignment to offset.\r\n            lByteOffset = Math.ceil(lByteOffset / lLayoutAlignment) * lLayoutAlignment;\r\n\r\n            // buffer layout is a layered format.\r\n            if (Array.isArray(pUnwrappedLayout.format)) {\r\n                // Set repetition count to variable count when layout repetition count is uncapped.\r\n                const lRepetitionCount: number = (pUnwrappedLayout.count !== -1) ? pUnwrappedLayout.count : lVariableRepetitionCount;\r\n                for (let lLayoutRepetionIndex: number = 0; lLayoutRepetionIndex < lRepetitionCount; lLayoutRepetionIndex++) {\r\n                    // Add each inner format.\r\n                    for (const lInnerFormat of pUnwrappedLayout.format) {\r\n                        lWriteLayout(lInnerFormat);\r\n                    }\r\n                }\r\n\r\n                return;\r\n            }\r\n\r\n            // write each single number.\r\n            for (let lItemIndex: number = 0; lItemIndex < pUnwrappedLayout.count; lItemIndex++) {\r\n                // Add and iterate data.\r\n                this.setBufferData(lBufferDataView, lByteOffset, pUnwrappedLayout.format.itemFormat, pData[lDataIndex]);\r\n                lDataIndex++;\r\n\r\n                // Increase offset by format byte count.\r\n                lByteOffset += pUnwrappedLayout.format.itemByteCount;\r\n            }\r\n        };\r\n\r\n        // Repeat layout for each dynamic offset.\r\n        for (let lOffsetIndex: number = 0; lOffsetIndex < lDynamicOffsetCount; lOffsetIndex++) {\r\n            lWriteLayout(lUnwrapedLayout, lDynamicOffsetAlignment);\r\n        }\r\n\r\n        // Create buffer with initial data.\r\n        const lBuffer: GpuBuffer = new GpuBuffer(this.device, lBufferData.byteLength).initialData(lBufferData);\r\n\r\n        return lBuffer;\r\n    }\r\n\r\n    /**\r\n     * Create a empty buffer.\r\n     * \r\n     * @param pVariableSizeCount - Variable item count.\r\n     * \r\n     * @returns - Created buffer. \r\n     */\r\n    private createEmptyBuffer(pVariableSizeCount: number | null = null): GpuBuffer {\r\n        // Layout must be a buffer memory layout.\r\n        if (!(this.mBindLayout.layout instanceof BaseBufferMemoryLayout)) {\r\n            throw new Exception(`Bind data layout is not suitable for buffers.`, this);\r\n        }\r\n\r\n        // Calculate variable item count from initial buffer data.  \r\n        const lVariableItemCount: number = (() => {\r\n            // Use set variable count.\r\n            if (pVariableSizeCount !== null) {\r\n                return pVariableSizeCount;\r\n            }\r\n\r\n            // No need to calculate was it is allways zero.\r\n            if (this.mBindLayout.layout.variableSize === 0) {\r\n                return 0;\r\n            }\r\n\r\n            throw new Exception(`For bind group data buffer \"${this.mBindLayout.name}\" a variable item count must be set.`, this);\r\n        })();\r\n\r\n        // Calculate buffer size with correct alignment.\r\n        let lByteSize: number = (lVariableItemCount ?? 0) * this.mBindLayout.layout.variableSize + this.mBindLayout.layout.fixedSize;\r\n        if (this.mBindLayout.hasDynamicOffset) {\r\n            // Read correct alignment limitations for storage type.\r\n            const lOffsetAlignment: number = (() => {\r\n                if (this.mBindLayout.storageType === StorageBindingType.None) {\r\n                    return this.device.capabilities.getLimit(GpuLimit.MinUniformBufferOffsetAlignment);\r\n                } else {\r\n                    return this.device.capabilities.getLimit(GpuLimit.MinStorageBufferOffsetAlignment);\r\n                }\r\n            })();\r\n\r\n            // Apply offset alignment to byte size.\r\n            lByteSize = Math.ceil(lByteSize / lOffsetAlignment) * lOffsetAlignment;\r\n            lByteSize *= pVariableSizeCount ?? 1; \r\n        }\r\n\r\n        // Create buffer.\r\n        const lBuffer: GpuBuffer = new GpuBuffer(this.device, lByteSize);\r\n\r\n        return lBuffer;\r\n    }\r\n\r\n    /**\r\n     * Set data in little endian according to the set item format and offset. \r\n     * \r\n     * @param pBufferDataView - Data view of buffer.\r\n     * @param pByteOffset - Byte offset in buffer.\r\n     * @param pFormat - Format to write.\r\n     * @param pData - Data to write.\r\n     */\r\n    private setBufferData(pBufferDataView: DataView, pByteOffset: number, pFormat: BufferItemFormat, pData: number): void {\r\n        switch (pFormat) {\r\n            case BufferItemFormat.Float32: { pBufferDataView.setFloat32(pByteOffset, pData, true); break; }\r\n            case BufferItemFormat.Uint32: { pBufferDataView.setUint32(pByteOffset, pData, true); break; }\r\n            case BufferItemFormat.Sint32: { pBufferDataView.setInt32(pByteOffset, pData, true); break; }\r\n\r\n            // Unsupported\r\n            case BufferItemFormat.Uint8:\r\n            case BufferItemFormat.Sint8:\r\n            case BufferItemFormat.Uint16:\r\n            case BufferItemFormat.Sint16:\r\n            case BufferItemFormat.Float16:\r\n            case BufferItemFormat.Unorm16:\r\n            case BufferItemFormat.Snorm16:\r\n            case BufferItemFormat.Unorm8:\r\n            case BufferItemFormat.Snorm8:\r\n            default: {\r\n                throw new Exception(`Currently \"${pFormat}\" is not supported for uniform parameter.`, this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unwrap layout.\r\n     * \r\n     * @param pLayout - Buffer layout.\r\n     * \r\n     * @returns - unwrapped layout. \r\n     */\r\n    private unwrapLayouts(pLayout: BaseBufferMemoryLayout): UnwrappedBufferLayout {\r\n        // Recursion end condition. Primitives have no inner formats.\r\n        if (pLayout instanceof PrimitiveBufferMemoryLayout) {\r\n            // Read item count and format of parameter.\r\n            const lParameterItemCount: number = PrimitiveBufferMemoryLayout.itemCountOfMultiplier(pLayout.itemMultiplier);\r\n            const lParameterItemFormat: BufferItemFormat = pLayout.itemFormat;\r\n\r\n            // Add formats for each item of parameter.\r\n            return {\r\n                // Global data.\r\n                fixedItemCount: lParameterItemCount,\r\n                variableItemCount: 0,\r\n\r\n                // Local layout data.\r\n                count: lParameterItemCount,\r\n                alignment: pLayout.alignment,\r\n                format: {\r\n                    itemFormat: lParameterItemFormat,\r\n                    itemByteCount: PrimitiveBufferMemoryLayout.itemFormatByteCount(lParameterItemFormat)\r\n                }\r\n            };\r\n        }\r\n\r\n        // Recursive array.\r\n        if (pLayout instanceof ArrayBufferMemoryLayout) {\r\n            // Unwrap inner format.\r\n            const lInnerFormatUnwrapped: UnwrappedBufferLayout = this.unwrapLayouts(pLayout.innerType);\r\n\r\n            // Add formats for each item of parameter.\r\n            return {\r\n                // Global data.\r\n                fixedItemCount: Math.max(pLayout.arraySize, 0) * lInnerFormatUnwrapped.fixedItemCount,\r\n                variableItemCount: (pLayout.variableSize > 0) ? lInnerFormatUnwrapped.fixedItemCount : 0,\r\n\r\n                // Local layout data.\r\n                count: pLayout.fixedSize || -1,\r\n                alignment: pLayout.alignment,\r\n                format: [lInnerFormatUnwrapped]\r\n            };\r\n        }\r\n\r\n        // Recursive struct.\r\n        if (pLayout instanceof StructBufferMemoryLayout) {\r\n            let lFixedItemCount: number = 0;\r\n            let lVariableItemCount: number = 0;\r\n\r\n            // Create new unwrapped layout for each property.\r\n            const lPropertyFormats: Array<UnwrappedBufferLayout> = new Array<UnwrappedBufferLayout>();\r\n            for (const lProperty of pLayout.properties) {\r\n                // Unwrap property format.\r\n                const lPropertyFormatUnwrapped: UnwrappedBufferLayout = this.unwrapLayouts(lProperty.layout);\r\n\r\n                // Count of fixed and variable item size.\r\n                lFixedItemCount += lPropertyFormatUnwrapped.fixedItemCount;\r\n                lVariableItemCount += lPropertyFormatUnwrapped.variableItemCount;\r\n\r\n                lPropertyFormats.push(lPropertyFormatUnwrapped);\r\n            }\r\n\r\n            // Add formats for each item of parameter.\r\n            return {\r\n                // Global data.\r\n                fixedItemCount: lFixedItemCount,\r\n                variableItemCount: lVariableItemCount,\r\n\r\n                // Local layout data.\r\n                count: 1,\r\n                alignment: pLayout.alignment,\r\n                format: lPropertyFormats\r\n            };\r\n        }\r\n\r\n        throw new Exception('Memory layout not suppored for bindings', this);\r\n    }\r\n}\r\n\r\ntype BindGroupDataCallback = (pData: GpuResourceObject<any, any, any, any>) => void;\r\n\r\ntype UnwrappedBufferLayout = {\r\n    // Global data.\r\n    fixedItemCount: number;\r\n    variableItemCount: number;\r\n\r\n    // Local layout data.\r\n    count: number;\r\n    alignment: number;\r\n    format: Array<UnwrappedBufferLayout> | {\r\n        itemFormat: BufferItemFormat,\r\n        itemByteCount: number;\r\n    };\r\n};", "import { Dictionary, Exception } from '@kartoffelgames/core';\r\nimport { GpuBuffer } from '../../buffer/gpu-buffer.ts';\r\nimport { BufferUsage } from '../../constant/buffer-usage.enum.ts';\r\nimport { StorageBindingType } from '../../constant/storage-binding-type.enum.ts';\r\nimport { TextureUsage } from '../../constant/texture-usage.enum.ts';\r\nimport { TextureSampler } from '../../texture/texture-sampler.ts';\r\nimport { BindGroupDataSetup } from './bind-group-data-setup.ts';\r\nimport { BindGroupLayout, BindLayout } from '../bind_group_layout/bind-group-layout.ts';\r\nimport { BaseBufferMemoryLayout } from '../../buffer/memory_layout/base-buffer-memory-layout.ts';\r\nimport { GpuDevice } from '../../device/gpu-device.ts';\r\nimport { GpuObject, GpuObjectSetupReferences } from '../../gpu_object/gpu-object.ts';\r\nimport { GpuResourceObject, GpuResourceObjectInvalidationType } from '../../gpu_object/gpu-resource-object.ts';\r\nimport { IGpuObjectNative } from '../../gpu_object/interface/i-gpu-object-native.ts';\r\nimport { GpuTextureView } from '../../texture/gpu-texture-view.ts';\r\nimport { SamplerMemoryLayout } from '../../texture/memory_layout/sampler-memory-layout.ts';\r\nimport { TextureViewMemoryLayout } from '../../texture/memory_layout/texture-view-memory-layout.ts';\r\n\r\n/**\r\n * Pipeline bind group unbound from a group binding index.\r\n */\r\nexport class BindGroup extends GpuObject<GPUBindGroup, BindGroupInvalidationType> implements IGpuObjectNative<GPUBindGroup> {\r\n    private readonly mBindData: Dictionary<string, GpuResourceObject<any, any>>;\r\n    private readonly mDataInvalidationListener: WeakMap<GpuResourceObject, BindGroupDataInvalidationListener>;\r\n    private readonly mLayout: BindGroupLayout;\r\n\r\n    /**\r\n     * Layout of bind group.\r\n     */\r\n    public get layout(): BindGroupLayout {\r\n        return this.mLayout;\r\n    }\r\n\r\n    /**\r\n     * Native gpu object.\r\n     */\r\n    public override get native(): GPUBindGroup {\r\n        return super.native;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Gpu Device reference.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pBindGroupLayout: BindGroupLayout) {\r\n        super(pDevice);\r\n\r\n        this.mLayout = pBindGroupLayout;\r\n        this.mBindData = new Dictionary<string, GpuResourceObject>();\r\n        this.mDataInvalidationListener = new WeakMap<GpuResourceObject, BindGroupDataInvalidationListener>();\r\n    }\r\n\r\n    /**\r\n     * Read binding data references.\r\n     * \r\n     * @param pBindName - Binding name.\r\n     * \r\n     * @returns Data setup object. \r\n     */\r\n    public data(pBindName: string): BindGroupDataSetup {\r\n        const lBindLayout: Readonly<BindLayout> = this.mLayout.getBind(pBindName);\r\n        const lData: GpuResourceObject | null = this.mBindData.get(pBindName) ?? null;\r\n\r\n        // Construct setup data to data.\r\n        const lDataSetupReferences: GpuObjectSetupReferences<null> = {\r\n            device: this.device,\r\n            inSetup: true, // No need to defuse setup.\r\n            data: null\r\n        };\r\n\r\n        return new BindGroupDataSetup(lBindLayout, lData, lDataSetupReferences, (pData: GpuResourceObject) => {\r\n            // Validate if layout fits bind data and dynamicly extend usage type of bind data.\r\n            switch (true) {\r\n                // Textures must use a buffer memory layout.\r\n                case pData instanceof GpuBuffer: {\r\n                    if (!(lBindLayout.layout instanceof BaseBufferMemoryLayout)) {\r\n                        throw new Exception(`Buffer added to bind data \"${pBindName}\" but binding does not expect a buffer.`, this);\r\n                    }\r\n\r\n                    // Extend buffer usage based on if it is a storage or not.\r\n                    if (lBindLayout.storageType !== StorageBindingType.None) {\r\n                        pData.extendUsage(BufferUsage.Storage);\r\n                    } else {\r\n                        pData.extendUsage(BufferUsage.Uniform);\r\n                    }\r\n\r\n                    break;\r\n                }\r\n\r\n                // Samplers must use a texture sampler memory layout.\r\n                case pData instanceof TextureSampler: {\r\n                    if (!(lBindLayout.layout instanceof SamplerMemoryLayout)) {\r\n                        throw new Exception(`Texture sampler added to bind data \"${pBindName}\" but binding does not expect a texture sampler.`, this);\r\n                    }\r\n\r\n                    break;\r\n                }\r\n\r\n                // Textures must use a texture memory layout.\r\n                case pData instanceof GpuTextureView: {\r\n                    if (!(lBindLayout.layout instanceof TextureViewMemoryLayout)) {\r\n                        throw new Exception(`Texture added to bind data \"${pBindName}\" but binding does not expect a texture.`, this);\r\n                    }\r\n\r\n                    // Extend buffer usage based on if it is a storage or not.\r\n                    if (lBindLayout.storageType !== StorageBindingType.None) {\r\n                        pData.texture.extendUsage(TextureUsage.Storage);\r\n                    } else {\r\n                        pData.texture.extendUsage(TextureUsage.TextureBinding);\r\n                    }\r\n\r\n                    break;\r\n                }\r\n\r\n                default: {\r\n                    throw new Exception(`Unsupported resource added to bind data \"${pBindName}\".`, this);\r\n                }\r\n            }\r\n\r\n            // Remove invalidationlistener from old data.\r\n            const lOldData: GpuResourceObject | undefined = this.mBindData.get(pBindName);\r\n            if (lOldData) {\r\n                const lBindDataInvalidationListener: BindGroupDataInvalidationListener | undefined = this.mDataInvalidationListener.get(lOldData);\r\n                if (lBindDataInvalidationListener) {\r\n                    lOldData.removeInvalidationListener(lBindDataInvalidationListener);\r\n                }\r\n            }\r\n\r\n            // Set data.\r\n            this.mBindData.set(pBindName, pData);\r\n\r\n            // Trigger update data is invalid.\r\n            pData.addInvalidationListener(() => {\r\n                this.invalidate(BindGroupInvalidationType.NativeRebuild);\r\n            }, GpuResourceObjectInvalidationType.ResourceRebuild);\r\n\r\n            // Trigger update on data change. \r\n            this.invalidate(BindGroupInvalidationType.NativeRebuild);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generate native gpu bind data group.\r\n     */\r\n    protected override generateNative(): GPUBindGroup {\r\n        // Invalidate group.\r\n        this.invalidate(BindGroupInvalidationType.NativeRebuild);\r\n\r\n        const lEntryList: Array<GPUBindGroupEntry> = new Array<GPUBindGroupEntry>();\r\n\r\n        for (const lBindname of this.layout.orderedBindingNames) {\r\n            // Read bind data.\r\n            const lBindData: GpuResourceObject | undefined = this.mBindData.get(lBindname);\r\n            if (!lBindData) {\r\n                throw new Exception(`Data for binding \"${lBindname}\" is not set.`, this);\r\n            }\r\n\r\n            // Read bind layout.\r\n            const lBindLayout: Readonly<BindLayout> = this.layout.getBind(lBindname);\r\n\r\n            // Set resource to group entry for each \r\n            const lGroupEntry: GPUBindGroupEntry = { binding: lBindLayout.index, resource: <any>null };\r\n\r\n            // Buffer bind.\r\n            if (lBindData instanceof GpuBuffer) {\r\n                lGroupEntry.resource = { buffer: lBindData.native };\r\n\r\n                // Fix buffer size when it has dynamic offsets.\r\n                if (lBindLayout.hasDynamicOffset) {\r\n                    lGroupEntry.resource.size = (<BaseBufferMemoryLayout>lBindLayout.layout).fixedSize;\r\n                }\r\n\r\n                lEntryList.push(lGroupEntry);\r\n                continue;\r\n            }\r\n\r\n            // Sampler bind\r\n            if (lBindData instanceof TextureSampler) {\r\n                lGroupEntry.resource = lBindData.native;\r\n                lEntryList.push(lGroupEntry);\r\n                continue;\r\n            }\r\n\r\n            // Texture bind.\r\n            if (lBindData instanceof GpuTextureView) {\r\n                lGroupEntry.resource = lBindData.native;\r\n\r\n                lEntryList.push(lGroupEntry);\r\n                continue;\r\n            }\r\n\r\n            throw new Exception(`Bind type for \"${lBindData}\" not supported`, this);\r\n        }\r\n\r\n        return this.device.gpu.createBindGroup({\r\n            label: 'Bind-Group',\r\n            layout: this.layout.native,\r\n            entries: lEntryList\r\n        });\r\n    }\r\n}\r\n\r\nexport enum BindGroupInvalidationType {\r\n    NativeRebuild = 'NativeRebuild',\r\n}\r\n\r\ntype BindGroupDataInvalidationListener = () => void;", "import { GpuObjectChildSetup } from '../../gpu_object/gpu-object-child-setup.ts';\r\nimport { PipelineDataSetupData } from './pipeline-data-setup.ts';\r\n\r\n/**\r\n * Child setup for a single pipeline data group binding buffer.\r\n */\r\nexport class PipelineDataGroupSetup extends GpuObjectChildSetup<PipelineDataSetupData, PipelineDataGroupSetupDataCallback> {\r\n    /**\r\n     * Apply offset to bind group.\r\n     * \r\n     * @param pBindingName - Name of one of binding sof group. \r\n     * @param pOffsetIndex - Offset index.\r\n     * \r\n     * @returns this.\r\n     */\r\n    public withOffset(pBindingName: string, pOffsetIndex: number): this {\r\n        this.sendData({\r\n            bindingName: pBindingName,\r\n            offsetIndex: pOffsetIndex\r\n        });\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nexport type PipelineDataGroupSetupData = {\r\n    bindingName: string;\r\n    offsetIndex: number;\r\n};\r\ntype PipelineDataGroupSetupDataCallback = (pBindOffset: PipelineDataGroupSetupData) => void;", "import { Dictionary } from '@kartoffelgames/core';\r\nimport { BindGroup } from '../bind_group/bind-group.ts';\r\nimport { PipelineDataGroupSetup, PipelineDataGroupSetupData } from './pipeline-data-group-setup.ts';\r\nimport { GpuObjectSetup } from '../../gpu_object/gpu-object-setup.ts';\r\n\r\n/**\r\n * Setup object for a pipline data.\r\n */\r\nexport class PipelineDataSetup extends GpuObjectSetup<PipelineDataSetupData> {\r\n    /**\r\n     * Add bind group to pipeline data.\r\n     * \r\n     * @param pBindGroup - Bind group.\r\n     * \r\n     * @returns group setup. \r\n     */\r\n    public addGroup(pBindGroup: BindGroup): PipelineDataGroupSetup {\r\n        // Create binding group information.\r\n        const lBindGroup: PipelineDataSetupDataGroup = {\r\n            bindGroup: pBindGroup,\r\n            offsets: new Dictionary<string, number>()\r\n        };\r\n\r\n        this.setupData.groups.push(lBindGroup);\r\n\r\n        // Can be used to add \"optional\" binding offsets to bind group.\r\n        return new PipelineDataGroupSetup(this.setupReferences, (pBindingOffsets: PipelineDataGroupSetupData) => {\r\n            lBindGroup.offsets.set(pBindingOffsets.bindingName, pBindingOffsets.offsetIndex);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fill in default data before the setup starts.\r\n     * \r\n     * @param pDataReference - Setup data reference.\r\n     */\r\n    protected override fillDefaultData(pDataReference: PipelineDataSetupData): void {\r\n        pDataReference.groups = new Array<PipelineDataSetupDataGroup>();\r\n    }\r\n}\r\n\r\nexport type PipelineDataSetupDataGroup = {\r\n    offsets: Dictionary<string, number>;\r\n    bindGroup: BindGroup;\r\n};\r\n\r\nexport type PipelineDataSetupData = {\r\n    groups: Array<PipelineDataSetupDataGroup>;\r\n};\r\n", "import { Dictionary, Exception } from '@kartoffelgames/core';\r\nimport { GpuBuffer } from '../../buffer/gpu-buffer.ts';\r\nimport { BaseBufferMemoryLayout } from '../../buffer/memory_layout/base-buffer-memory-layout.ts';\r\nimport { GpuLimit } from '../../constant/gpu-limit.enum.ts';\r\nimport { StorageBindingType } from '../../constant/storage-binding-type.enum.ts';\r\nimport { GpuDevice } from '../../device/gpu-device.ts';\r\nimport { GpuObject, GpuObjectSetupReferences } from '../../gpu_object/gpu-object.ts';\r\nimport { IGpuObjectSetup } from '../../gpu_object/interface/i-gpu-object-setup.ts';\r\nimport { BindGroup, BindGroupInvalidationType } from '../bind_group/bind-group.ts';\r\nimport { BindLayout } from '../bind_group_layout/bind-group-layout.ts';\r\nimport { PipelineLayout } from '../pipeline-layout.ts';\r\nimport { PipelineDataSetup, PipelineDataSetupData, PipelineDataSetupDataGroup } from './pipeline-data-setup.ts';\r\n\r\n/**\r\n * Bundle of bind groups.\r\n * Handles validation and offset calculations.\r\n */\r\nexport class PipelineData extends GpuObject<null, PipelineDataInvalidationType, PipelineDataSetup> implements IGpuObjectSetup<PipelineDataSetup> {\r\n    private readonly mBindData: Dictionary<string, PipelineDataGroup>;\r\n    private readonly mInvalidationListener: () => void;\r\n    private readonly mLayout: PipelineLayout;\r\n    private readonly mOrderedBindData: Array<PipelineDataGroup>;\r\n\r\n    /**\r\n     * Orderes pipeline data.\r\n     */\r\n    public get data(): Array<PipelineDataGroup> {\r\n        // Setup needed.\r\n        this.ensureSetup();\r\n\r\n        return this.mOrderedBindData;\r\n    }\r\n\r\n    /**\r\n     * Pipline layout of data.\r\n     */\r\n    public get layout(): PipelineLayout {\r\n        return this.mLayout;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pPipelineLayout - Pipeline data. \r\n     * @param pBindData - Every bind data of pipeline layout.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pPipelineLayout: PipelineLayout) {\r\n        super(pDevice);\r\n\r\n        // Set pipeline layout.\r\n        this.mLayout = pPipelineLayout;\r\n\r\n        // Easy access dictionary.\r\n        this.mBindData = new Dictionary<string, PipelineDataGroup>();\r\n\r\n        // Invalidate pipeline data when any data has changed.\r\n        this.mInvalidationListener = () => {\r\n            this.invalidate(PipelineDataInvalidationType.Data);\r\n        };\r\n\r\n        this.mOrderedBindData = new Array<PipelineDataGroup>();\r\n    }\r\n\r\n    /**\r\n     * Deconstruct native object.\r\n     */\r\n    public override deconstruct(): void {\r\n        super.deconstruct();\r\n\r\n        // Remove all invalidation listener from bind groups.\r\n        for (const lBindGroup of this.mOrderedBindData) {\r\n            lBindGroup.bindGroup.removeInvalidationListener(this.mInvalidationListener);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get bind group by name.\r\n     * \r\n     * @param pBindGroupName  - Bind group name.\r\n     * \r\n     * @returns bind group. \r\n     */\r\n    public group(pBindGroupName: string): PipelineDataGroup {\r\n        if (!this.mBindData.has(pBindGroupName)) {\r\n            throw new Exception(`Bind group \"${pBindGroupName}\" does not exists in pipeline data.`, this);\r\n        }\r\n\r\n        return this.mBindData.get(pBindGroupName)!;\r\n    }\r\n\r\n    /**\r\n     * Call setup.\r\n     * \r\n     * @param pSetupCallback - Setup callback.\r\n     *\r\n     * @returns \u2014 this. \r\n     */\r\n    public override setup(pSetupCallback?: ((pSetup: PipelineDataSetup) => void) | undefined): this {\r\n        return super.setup(pSetupCallback);\r\n    }\r\n\r\n    /**\r\n     * Setup pipeline data.\r\n     * \r\n     * @param pReferences - Setup data references. \r\n     */\r\n    protected override onSetup(pReferences: PipelineDataSetupData): void {\r\n        // All bind groups must be set.\r\n        if (this.mLayout.groups.length !== pReferences.groups.length) {\r\n            // Generate a better error message.\r\n            for (const lGroupName of this.mLayout.groups) {\r\n                // Get and validate existence of set bind group.\r\n                const lBindGroupSetupData: PipelineDataSetupDataGroup | undefined = pReferences.groups.find((pBindGroup) => { return pBindGroup.bindGroup.layout.name === lGroupName; });\r\n                if (!lBindGroupSetupData) {\r\n                    throw new Exception(`Required bind group \"${lGroupName}\" not set.`, this);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Validate and order bind data.\r\n        for (const lBindGroupSetupData of pReferences.groups) {\r\n            const lBindGroupName: string = lBindGroupSetupData.bindGroup.layout.name;\r\n            const lBindGroupIndex: number = this.mLayout.groupIndex(lBindGroupName);\r\n            const lBindGroup: BindGroup = lBindGroupSetupData.bindGroup;\r\n\r\n            // Only distinct bind group names.\r\n            if (this.mOrderedBindData[lBindGroupIndex]) {\r\n                throw new Exception(`Bind group \"${lBindGroupName}\" was added multiple times to render pass step.`, this);\r\n            }\r\n\r\n            // Validate same layout bind layout.\r\n            const lBindGroupLayout = this.mLayout.getGroupLayout(lBindGroupName);\r\n            if (lBindGroup.layout !== lBindGroupLayout) {\r\n                throw new Exception(`Source bind group layout for \"${lBindGroupName}\" does not match target layout.`, this);\r\n            }\r\n\r\n            // Restrict double names.\r\n            if (this.mBindData.has(lBindGroupName)) {\r\n                throw new Exception(`Bind group \"${lBindGroupName}\" name already exists in pipeline data.`, this);\r\n            }\r\n\r\n            // When the bind group has dynamic offsets, build a array of it.\r\n            const lPipelineDataGroup: PipelineDataGroup = {\r\n                offsetId: '',\r\n                bindGroup: lBindGroup,\r\n                offsets: new Array<number>()\r\n            };\r\n            if (lBindGroupLayout.hasDynamicOffset) {\r\n                for (const lBindingName of lBindGroupLayout.orderedBindingNames) {\r\n                    // Skip any binding not having a dynamic offset.\r\n                    const lBindingLayout: Readonly<BindLayout> = lBindGroupLayout.getBind(lBindingName);\r\n                    if (!lBindingLayout.hasDynamicOffset) {\r\n                        continue;\r\n                    }\r\n\r\n                    // Dynamic bindings need a offset.\r\n                    if (!lBindGroupSetupData.offsets.has(lBindingName)) {\r\n                        throw new Exception(`Binding \"${lBindingName}\" of group \"${lBindGroupName} requires a offset.\"`, this);\r\n                    }\r\n\r\n                    // Read correct alignment limitations for storage type.\r\n                    const lOffsetAlignment: number = (() => {\r\n                        if (lBindingLayout.storageType === StorageBindingType.None) {\r\n                            return this.device.capabilities.getLimit(GpuLimit.MinUniformBufferOffsetAlignment);\r\n                        } else {\r\n                            return this.device.capabilities.getLimit(GpuLimit.MinStorageBufferOffsetAlignment);\r\n                        }\r\n                    })();\r\n\r\n                    // Read and validate assigned offset index of binding.\r\n                    const lBindingDynamicOffsetIndex: number = lBindGroupSetupData.offsets.get(lBindingName)!;\r\n\r\n                    // Get offset byte count.\r\n                    const lBufferMemoryLayout: BaseBufferMemoryLayout = lBindingLayout.layout as BaseBufferMemoryLayout;\r\n                    const lSingleLayoutLength: number = Math.ceil(lBufferMemoryLayout.fixedSize / lOffsetAlignment) * lOffsetAlignment;\r\n\r\n                    // Read buffer size and validate if it meets offset bound.\r\n                    const lBufferSize: number = lBindGroup.data(lBindingName).getRaw<GpuBuffer>().size;\r\n                    if (Math.floor(lBufferSize / lSingleLayoutLength) <= lBindingDynamicOffsetIndex) {\r\n                        throw new Exception(`Binding \"${lBindingName}\" of group \"${lBindGroupName} exceedes dynamic offset limits.\"`, this);\r\n                    }\r\n\r\n                    // Save offset byte count in order.\r\n                    lPipelineDataGroup.offsets.push(lSingleLayoutLength * lBindingDynamicOffsetIndex);\r\n                }\r\n\r\n                // Rebuild offset \"id\".\r\n                lPipelineDataGroup.offsetId = lPipelineDataGroup.offsets.join('-');\r\n            }\r\n\r\n            // Set name to bind group mapping.\r\n            this.mBindData.set(lBindGroupName, lPipelineDataGroup);\r\n\r\n            // Set bind group.\r\n            this.mOrderedBindData[lBindGroupIndex] = lPipelineDataGroup;\r\n\r\n            // Invalidate native data when bind group has changed.\r\n            lBindGroup.addInvalidationListener(this.mInvalidationListener, BindGroupInvalidationType.NativeRebuild);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create setup object. Return null to skip any setups.\r\n     * \r\n     * @param pReferences - Setup references.\r\n     * \r\n     * @returns setup.\r\n     */\r\n    protected override onSetupObjectCreate(pReferences: GpuObjectSetupReferences<PipelineDataSetupData>): PipelineDataSetup {\r\n        return new PipelineDataSetup(pReferences);\r\n    }\r\n}\r\n\r\nexport type PipelineDataGroup = {\r\n    offsetId: string;\r\n    bindGroup: BindGroup;\r\n    offsets: Array<number>;\r\n};\r\n\r\nexport enum PipelineDataInvalidationType {\r\n    Data = 'DataChange',\r\n}", "export enum PrimitiveFrontFace {\r\n    CounterClockWise = 'cw',\r\n    ClockWise = 'ccw'\r\n}", "export enum PrimitiveTopology {\r\n    PointList = 'point-list',\r\n    LineList = 'line-list',\r\n    LineStrip = 'line-strip',\r\n    TriangleList = 'triangle-list',\r\n    TriangleStrip = 'triangle-strip'\r\n}", "export enum StencilOperation {\r\n    Keep = 'keep',\r\n    Zero = 'zero',\r\n    Replace = 'replace',\r\n    Invert = 'invert',\r\n    IncrementClamp = 'increment-clamp',\r\n    DecrementClamp = 'decrement-clamp',\r\n    IncrementWrap = 'increment-wrap',\r\n    DecrementWrap = 'decrement-wrap',\r\n}", "export enum TextureAspect {\r\n    Red = 'red',\r\n    Green = 'green',\r\n    Blue = 'blue',\r\n    Alpha = 'alpha',\r\n    Stencil = 'stencil',\r\n    Depth = 'depth',\r\n}", "import { CompareFunction } from '../../constant/compare-function.enum.ts';\r\nimport { VertexFragmentPipelineDepthConfigurationData } from './vertex-fragment-pipeline.ts';\r\n\r\n/**\r\n * Configuration object for pipeline depth target. \r\n */\r\nexport class VertexFragmentPipelineDepthConfiguration {\r\n    private readonly mCallback: VertexFragmentPipelineDepthConfigurationCallback;\r\n    private readonly mDataReference: VertexFragmentPipelineDepthConfigurationData;\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pCallback - Data callback.\r\n     */\r\n    public constructor(pDataReference: VertexFragmentPipelineDepthConfigurationData, pCallback: VertexFragmentPipelineDepthConfigurationCallback) {\r\n        this.mCallback = pCallback;\r\n        this.mDataReference = pDataReference;\r\n    }\r\n\r\n    /**\r\n     * Set constant depth bias added to each fragment\r\n     * \r\n     * @param pFunction - Constant depth bias added to each fragment\r\n     * \r\n     * @returns this. \r\n     */\r\n    public bias(pBias: number): this {\r\n        // Set data.\r\n        this.mDataReference.depthBias = pBias;\r\n\r\n        // Callback change.\r\n        this.mCallback();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the maximum depth bias of a fragment. \r\n     * \r\n     * @param pFunction - The maximum depth bias of a fragment.\r\n     * \r\n     * @returns this. \r\n     */\r\n    public biasClamp(pBias: number): this {\r\n        // Set data.\r\n        this.mDataReference.depthBiasClamp = pBias;\r\n\r\n        // Callback change.\r\n        this.mCallback();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set depth bias that scales with the fragment\u2019s slope\r\n     * \r\n     * @param pFunction - Depth bias that scales with the fragment\u2019s slope\r\n     * \r\n     * @returns this. \r\n     */\r\n    public biasSlopeScale(pBias: number): this {\r\n        // Set data.\r\n        this.mDataReference.depthBiasSlopeScale = pBias;\r\n\r\n        // Callback change.\r\n        this.mCallback();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the depth compare function.\r\n     * \r\n     * @param pFunction - Compare function\r\n     * \r\n     * @returns this. \r\n     */\r\n    public compareWith(pFunction: CompareFunction): this {\r\n        // Set data.\r\n        this.mDataReference.depthCompare = pFunction;\r\n\r\n        // Callback change.\r\n        this.mCallback();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Enable depth write.\r\n     * \r\n     * @param pEnable - Enable state of depth write.\r\n     * \r\n     * @returns this. \r\n     */\r\n    public enableWrite(pEnable: boolean): this {\r\n        // Set data.\r\n        this.mDataReference.depthWriteEnabled = pEnable;\r\n\r\n        // Callback change.\r\n        this.mCallback();\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nexport type VertexFragmentPipelineDepthConfigurationCallback = () => void;\r\n\r\n", "import { CompareFunction } from '../../constant/compare-function.enum.ts';\r\nimport { StencilOperation } from '../../constant/stencil-operation.enum.ts';\r\nimport { VertexFragmentPipelineStencilConfigurationData } from './vertex-fragment-pipeline.ts';\r\n\r\n/**\r\n * Configuration object for pipeline stencil target. \r\n */\r\nexport class VertexFragmentPipelineStencilConfiguration {\r\n    private readonly mCallback: VertexFragmentPipelineStencilConfigurationCallback;\r\n    private readonly mDataReference: VertexFragmentPipelineStencilConfigurationData;\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pCallback - Data callback.\r\n     */\r\n    public constructor(pDataReference: VertexFragmentPipelineStencilConfigurationData, pCallback: VertexFragmentPipelineStencilConfigurationCallback) {\r\n        this.mCallback = pCallback;\r\n        this.mDataReference = pDataReference;\r\n    }\r\n\r\n    /**\r\n     * Back operations.\r\n     * \r\n     * @param pCompare - Compare function.\r\n     * @param pFailOperation - Operation on compare fail.\r\n     * @param pPassOperation  - Operation on compare pass.\r\n     * @param pDepthFailOperation  - Operation on depth compare fail.\r\n     * \r\n     * @returns this. \r\n     */\r\n    public back(pCompare: CompareFunction, pFailOperation?: StencilOperation, pPassOperation?: StencilOperation, pDepthFailOperation?: StencilOperation): this {\r\n        // Set data.\r\n        this.mDataReference.stencilBack.compare = pCompare;\r\n\r\n        // Optionals.\r\n        if (pFailOperation) {\r\n            this.mDataReference.stencilBack.failOperation = pFailOperation;\r\n        }\r\n        if (pPassOperation) {\r\n            this.mDataReference.stencilBack.passOperation = pPassOperation;\r\n        }\r\n        if (pDepthFailOperation) {\r\n            this.mDataReference.stencilBack.depthFailOperation = pDepthFailOperation;\r\n        }\r\n\r\n        // Callback change.\r\n        this.mCallback();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Front operations.\r\n     * \r\n     * @param pCompare - Compare function.\r\n     * @param pFailOperation - Operation on compare fail.\r\n     * @param pPassOperation  - Operation on compare pass.\r\n     * @param pDepthFailOperation  - Operation on depth compare fail.\r\n     * \r\n     * @returns this. \r\n     */\r\n    public front(pCompare: CompareFunction, pFailOperation?: StencilOperation, pPassOperation?: StencilOperation, pDepthFailOperation?: StencilOperation): this {\r\n        // Set data.\r\n        this.mDataReference.stencilFront.compare = pCompare;\r\n\r\n        // Optionals.\r\n        if (pFailOperation) {\r\n            this.mDataReference.stencilFront.failOperation = pFailOperation;\r\n        }\r\n        if (pPassOperation) {\r\n            this.mDataReference.stencilFront.passOperation = pPassOperation;\r\n        }\r\n        if (pDepthFailOperation) {\r\n            this.mDataReference.stencilFront.depthFailOperation = pDepthFailOperation;\r\n        }\r\n\r\n        // Callback change.\r\n        this.mCallback();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set writemask witch bit will be read for comparison tests.\r\n     * \r\n     * @param pBitMask - Bitmask.\r\n     * \r\n     * @returns this. \r\n     */\r\n    public readMask(pBitMask: number): this {\r\n        // Set data.\r\n        this.mDataReference.stencilReadMask = pBitMask;\r\n\r\n        // Callback change.\r\n        this.mCallback();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set writemask witch bit will be written for comparison tests.\r\n     * \r\n     * @param pBitMask - Bitmask.\r\n     * \r\n     * @returns this. \r\n     */\r\n    public writeMask(pBitMask: number): this {\r\n        // Set data.\r\n        this.mDataReference.stencilWriteMask = pBitMask;\r\n\r\n        // Callback change.\r\n        this.mCallback();\r\n\r\n        return this;\r\n    }\r\n\r\n}\r\n\r\nexport type VertexFragmentPipelineStencilConfigurationCallback = () => void;\r\n\r\n", "import { TextureAspect } from '../../constant/texture-aspect.enum.ts';\r\nimport { TextureBlendFactor } from '../../constant/texture-blend-factor.enum.ts';\r\nimport { TextureBlendOperation } from '../../constant/texture-blend-operation.enum.ts';\r\nimport { VertexFragmentPipelineTargetConfigData } from './vertex-fragment-pipeline.ts';\r\n\r\n/**\r\n * Configuration object for piplines target.\r\n */\r\nexport class VertexFragmentPipelineTargetConfiguration {\r\n    private readonly mCallback: VertexFragmentPipelineTargetConfigCallback;\r\n    private readonly mDataReference: VertexFragmentPipelineTargetConfigData;\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pCallback - Data callback.\r\n     */\r\n    public constructor(pDataReference: VertexFragmentPipelineTargetConfigData, pCallback: VertexFragmentPipelineTargetConfigCallback) {\r\n        this.mCallback = pCallback;\r\n        this.mDataReference = pDataReference;\r\n    }\r\n\r\n    /**\r\n     * Set alpha blends.\r\n     * \r\n     * @param pOperation - Blend operation.\r\n     * @param pSourceFactor - Factor of source value.\r\n     * @param pDestinationFactor - Factor of destination value.\r\n     * \r\n     * @returns this. \r\n     */\r\n    public alphaBlend(pOperation: TextureBlendOperation, pSourceFactor: TextureBlendFactor, pDestinationFactor: TextureBlendFactor): this {\r\n        // Set data.\r\n        this.mDataReference.alphaBlend = {\r\n            operation: pOperation,\r\n            sourceFactor: pSourceFactor,\r\n            destinationFactor: pDestinationFactor\r\n        };\r\n\r\n        // Callback change.\r\n        this.mCallback();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set color blends.\r\n     * \r\n     * @param pOperation - Blend operation.\r\n     * @param pSourceFactor - Factor of source value.\r\n     * @param pDestinationFactor - Factor of destination value.\r\n     * \r\n     * @returns this. \r\n     */\r\n    public colorBlend(pOperation: TextureBlendOperation, pSourceFactor: TextureBlendFactor, pDestinationFactor: TextureBlendFactor): this {\r\n        // Set data.\r\n        this.mDataReference.colorBlend = {\r\n            operation: pOperation,\r\n            sourceFactor: pSourceFactor,\r\n            destinationFactor: pDestinationFactor\r\n        };\r\n\r\n        // Callback change.\r\n        this.mCallback();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set texture aspect writemask.\r\n     * \r\n     * @param pAspects - Aspect to write into.\r\n     * \r\n     * @returns this. \r\n     */\r\n    public writeMask(...pAspects: Array<TextureAspect>): this {\r\n        // Set data.\r\n        this.mDataReference.aspectWriteMask = new Set<TextureAspect>(pAspects);\r\n\r\n        // Callback change.\r\n        this.mCallback();\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nexport type VertexFragmentPipelineTargetConfigCallback = () => void;\r\n\r\n", "import { Dictionary, Exception } from '@kartoffelgames/core';\r\nimport { CompareFunction } from '../../constant/compare-function.enum.ts';\r\nimport { ComputeStage } from '../../constant/compute-stage.enum.ts';\r\nimport { PrimitiveCullMode } from '../../constant/primitive-cullmode.enum.ts';\r\nimport { PrimitiveFrontFace } from '../../constant/primitive-front-face.enum.ts';\r\nimport { PrimitiveTopology } from '../../constant/primitive-topology.enum.ts';\r\nimport { StencilOperation } from '../../constant/stencil-operation.enum.ts';\r\nimport { TextureAspect } from '../../constant/texture-aspect.enum.ts';\r\nimport { TextureBlendFactor } from '../../constant/texture-blend-factor.enum.ts';\r\nimport { TextureBlendOperation } from '../../constant/texture-blend-operation.enum.ts';\r\nimport { GpuDevice } from '../../device/gpu-device.ts';\r\nimport { GpuObject } from '../../gpu_object/gpu-object.ts';\r\nimport { GpuObjectInvalidationReasons } from '../../gpu_object/gpu-object-invalidation-reasons.ts';\r\nimport { IGpuObjectNative } from '../../gpu_object/interface/i-gpu-object-native.ts';\r\nimport { ShaderRenderModule } from '../../shader/shader-render-module.ts';\r\nimport { GpuTextureView } from '../../texture/gpu-texture-view.ts';\r\nimport { PipelineLayout } from '../pipeline-layout.ts';\r\nimport { RenderTargets } from '../render_targets/render-targets.ts';\r\nimport { VertexFragmentPipelineDepthConfiguration } from './vertex-fragment-pipeline-depth-configuration.ts';\r\nimport { VertexFragmentPipelineStencilConfiguration } from './vertex-fragment-pipeline-stencil-configuration.ts';\r\nimport { VertexFragmentPipelineTargetConfiguration } from './vertex-fragment-pipeline-target-configuration.ts';\r\n\r\n/**\r\n * Gpu pipeline resource for rendering with a vertex and fragment shader. \r\n */\r\nexport class VertexFragmentPipeline extends GpuObject<GPURenderPipeline | null, VertexFragmentPipelineInvalidationType> implements IGpuObjectNative<GPURenderPipeline | null> {\r\n    private readonly mDepthConfiguration: VertexFragmentPipelineDepthConfigurationData;\r\n    private mLoadedPipeline: GPURenderPipeline | null;\r\n    private readonly mParameter: Dictionary<ComputeStage, Record<string, number>>;\r\n    private mPrimitiveCullMode: PrimitiveCullMode;\r\n    private mPrimitiveFrontFace: PrimitiveFrontFace;\r\n    private mPrimitiveTopology: PrimitiveTopology;\r\n    private readonly mRenderTargetConfig: Dictionary<string, VertexFragmentPipelineTargetConfigData>;\r\n    private readonly mRenderTargets: RenderTargets;\r\n    private readonly mShaderModule: ShaderRenderModule;\r\n    private readonly mStencilConfiguration: VertexFragmentPipelineStencilConfigurationData;\r\n\r\n    /**\r\n     * Pipeline layout.\r\n     */\r\n    public get layout(): PipelineLayout {\r\n        return this.mShaderModule.shader.layout;\r\n    }\r\n\r\n    /**\r\n     * Pipeline shader.\r\n     */\r\n    public get module(): ShaderRenderModule {\r\n        return this.mShaderModule;\r\n    }\r\n\r\n    /**\r\n     * Native gpu object.\r\n     */\r\n    public override get native(): GPURenderPipeline | null {\r\n        return super.native;\r\n    }\r\n\r\n    /**\r\n     * Defines which polygon orientation will be culled.\r\n     */\r\n    public get primitiveCullMode(): PrimitiveCullMode {\r\n        return this.mPrimitiveCullMode;\r\n    } set primitiveCullMode(pValue: PrimitiveCullMode) {\r\n        this.mPrimitiveCullMode = pValue;\r\n\r\n        // Invalidate pipeline on setting change.\r\n        this.invalidate(VertexFragmentPipelineInvalidationType.NativeRebuild);\r\n    }\r\n\r\n    /**\r\n     * Defines which polygons are considered front-facing.\r\n     */\r\n    public get primitiveFrontFace(): PrimitiveFrontFace {\r\n        return this.mPrimitiveFrontFace;\r\n    } set primitiveFrontFace(pValue: PrimitiveFrontFace) {\r\n        this.mPrimitiveFrontFace = pValue;\r\n\r\n        // Invalidate pipeline on setting change.\r\n        this.invalidate(VertexFragmentPipelineInvalidationType.NativeRebuild);\r\n    }\r\n\r\n    /**\r\n     * The type of primitive to be constructed from the vertex inputs.\r\n     */\r\n    public get primitiveTopology(): PrimitiveTopology {\r\n        return this.mPrimitiveTopology;\r\n    } set primitiveTopology(pValue: PrimitiveTopology) {\r\n        this.mPrimitiveTopology = pValue;\r\n\r\n        // Invalidate pipeline on setting change.\r\n        this.invalidate(VertexFragmentPipelineInvalidationType.NativeRebuild);\r\n    }\r\n\r\n    /**\r\n     * Render targets.\r\n     */\r\n    public get renderTargets(): RenderTargets {\r\n        return this.mRenderTargets;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * Set default data.\r\n     * \r\n     * @param pDevice - Device.\r\n     * @param pShaderRenderModule - Pipeline shader.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pShaderRenderModule: ShaderRenderModule, pRenderTargets: RenderTargets) {\r\n        super(pDevice);\r\n\r\n        // Loaded pipeline for async creation.\r\n        this.mLoadedPipeline = null;\r\n\r\n        // Set config objects.\r\n        this.mShaderModule = pShaderRenderModule;\r\n        this.mRenderTargets = pRenderTargets;\r\n        this.mRenderTargetConfig = new Dictionary<string, VertexFragmentPipelineTargetConfigData>();\r\n\r\n        // Pipeline constants.\r\n        this.mParameter = new Dictionary<ComputeStage, Record<string, number>>();\r\n\r\n        // Depth default settings.\r\n        this.mDepthConfiguration = {\r\n            depthWriteEnabled: this.mRenderTargets.hasDepth,\r\n            depthCompare: CompareFunction.Less,\r\n            depthBias: 0,\r\n            depthBiasSlopeScale: 0,\r\n            depthBiasClamp: 0\r\n        };\r\n\r\n        // Default stencil settings.\r\n        this.mStencilConfiguration = {\r\n            stencilReadMask: 0,\r\n            stencilWriteMask: 0,\r\n            stencilBack: {\r\n                compare: CompareFunction.Allways,\r\n                failOperation: StencilOperation.Keep,\r\n                depthFailOperation: StencilOperation.Keep,\r\n                passOperation: StencilOperation.Keep,\r\n            },\r\n            stencilFront: {\r\n                compare: CompareFunction.Allways,\r\n                failOperation: StencilOperation.Keep,\r\n                depthFailOperation: StencilOperation.Keep,\r\n                passOperation: StencilOperation.Keep,\r\n            }\r\n        };\r\n\r\n        // Primitive default settings.\r\n        this.mPrimitiveTopology = PrimitiveTopology.TriangleList;\r\n        this.mPrimitiveCullMode = PrimitiveCullMode.Back;\r\n        this.mPrimitiveFrontFace = PrimitiveFrontFace.ClockWise;\r\n    }\r\n\r\n    /**\r\n     * Set depth process configuration.\r\n     */\r\n    public depthConfig(): VertexFragmentPipelineDepthConfiguration {\r\n        return new VertexFragmentPipelineDepthConfiguration(this.mDepthConfiguration, () => {\r\n            // Generate pipeline anew.\r\n            this.invalidate(VertexFragmentPipelineInvalidationType.NativeRebuild);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set optional parameter of pipeline.\r\n     * \r\n     * @param pParameterName - name of parameter.\r\n     * @param pValue - Value.\r\n     * \r\n     * @returns this. \r\n     */\r\n    public setParameter(pParameterName: string, pValue: number): this {\r\n        const lParameterUsage: Set<ComputeStage> | undefined = this.mShaderModule.shader.parameter(pParameterName);\r\n\r\n        // Set parameter for each assigned compute stage.\r\n        for (const lUsage of lParameterUsage) {\r\n            // Init parameters for computestage when not set.\r\n            if (!this.mParameter.has(lUsage)) {\r\n                this.mParameter.set(lUsage, {});\r\n            }\r\n\r\n            // Set value for compute stage.\r\n            this.mParameter.get(lUsage)![pParameterName] = pValue;\r\n        }\r\n\r\n        // Generate pipeline anew.\r\n        this.invalidate(VertexFragmentPipelineInvalidationType.NativeRebuild);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set stencil process configuration.\r\n     */\r\n    public stencilConfig(): VertexFragmentPipelineStencilConfiguration {\r\n        return new VertexFragmentPipelineStencilConfiguration(this.mStencilConfiguration, () => {\r\n            // Generate pipeline anew.\r\n            this.invalidate(VertexFragmentPipelineInvalidationType.NativeRebuild);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create or update target config.\r\n     * \r\n     * @param pTargetName - Target name.\r\n     * \r\n     * @returns config object. \r\n     */\r\n    public targetConfig(pTargetName: string): VertexFragmentPipelineTargetConfiguration {\r\n        if (!this.mRenderTargets.hasColorTarget(pTargetName)) {\r\n            throw new Exception(`Color target \"${pTargetName}\" does not exists.`, this);\r\n        }\r\n\r\n        // Create default config when not already set.\r\n        if (!this.mRenderTargetConfig.has(pTargetName)) {\r\n            this.mRenderTargetConfig.set(pTargetName, {\r\n                colorBlend: {\r\n                    operation: TextureBlendOperation.Add,\r\n                    sourceFactor: TextureBlendFactor.One,\r\n                    destinationFactor: TextureBlendFactor.Zero\r\n                },\r\n                alphaBlend: {\r\n                    operation: TextureBlendOperation.Add,\r\n                    sourceFactor: TextureBlendFactor.One,\r\n                    destinationFactor: TextureBlendFactor.Zero\r\n                },\r\n                aspectWriteMask: new Set<TextureAspect>([TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha])\r\n            });\r\n        }\r\n\r\n        return new VertexFragmentPipelineTargetConfiguration(this.mRenderTargetConfig.get(pTargetName)!, () => {\r\n            // Generate pipeline anew.\r\n            this.invalidate(VertexFragmentPipelineInvalidationType.NativeRebuild);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generate native gpu pipeline data layout.\r\n     */\r\n    protected override generateNative(_pLastNative: GPURenderPipeline | null, pInvalidationReason: GpuObjectInvalidationReasons<VertexFragmentPipelineInvalidationType>): GPURenderPipeline | null {\r\n        // When a pipeline was loaded, return the loaded instead of creating a new pipeline.\r\n        if (this.mLoadedPipeline !== null && !pInvalidationReason.has(VertexFragmentPipelineInvalidationType.NativeRebuild)) {\r\n            const lLoadedPipeline: GPURenderPipeline = this.mLoadedPipeline;\r\n            this.mLoadedPipeline = null;\r\n\r\n            return lLoadedPipeline;\r\n        }\r\n\r\n        // Generate pipeline layout from bind group layouts.\r\n        const lPipelineLayout: GPUPipelineLayout = this.mShaderModule.shader.layout.native;\r\n\r\n        // Construct basic GPURenderPipelineDescriptor.\r\n        const lPipelineDescriptor: GPURenderPipelineDescriptor = {\r\n            layout: lPipelineLayout,\r\n            vertex: {\r\n                module: this.mShaderModule.shader.native,\r\n                entryPoint: this.mShaderModule.vertexEntryPoint,\r\n                buffers: this.mShaderModule.vertexParameter.native,\r\n                constants: this.mParameter.get(ComputeStage.Vertex) ?? {}\r\n            },\r\n            primitive: this.generatePrimitive()\r\n        };\r\n\r\n        // Optional fragment state.\r\n        if (this.module.fragmentEntryPoint) {\r\n            // Generate fragment targets only when fragment state is needed.\r\n            const lFragmentTargetList: Array<GPUColorTargetState> = new Array<GPUColorTargetState>();\r\n            for (const lRenderTargetName of this.mRenderTargets.colorTargetNames) {\r\n                const lRenderTarget: GpuTextureView = this.mRenderTargets.colorTarget(lRenderTargetName);\r\n\r\n                lFragmentTargetList.push({\r\n                    format: lRenderTarget.layout.format as GPUTextureFormat,\r\n                    blend: this.generateRenderTargetBlendState(lRenderTargetName),\r\n                    writeMask: this.generateRenderTargetWriteMask(lRenderTargetName)\r\n                });\r\n            }\r\n\r\n            lPipelineDescriptor.fragment = {\r\n                module: this.mShaderModule.shader.native,\r\n                entryPoint: this.module.fragmentEntryPoint,\r\n                targets: lFragmentTargetList,\r\n                constants: this.mParameter.get(ComputeStage.Fragment) ?? {}\r\n            };\r\n        }\r\n\r\n        // Setup optional depth or and stencil attachment.\r\n        if (this.mRenderTargets.hasDepth || this.mRenderTargets.hasStencil) {\r\n            lPipelineDescriptor.depthStencil = {\r\n                format: this.mRenderTargets.depthStencilTarget().layout.format as GPUTextureFormat\r\n            };\r\n\r\n            // Setup depth options.\r\n            if (this.mRenderTargets.hasDepth) {\r\n                lPipelineDescriptor.depthStencil.depthWriteEnabled = this.mDepthConfiguration.depthWriteEnabled;\r\n                lPipelineDescriptor.depthStencil.depthCompare = this.mDepthConfiguration.depthCompare;\r\n                lPipelineDescriptor.depthStencil.depthBias = this.mDepthConfiguration.depthBias;\r\n                lPipelineDescriptor.depthStencil.depthBiasSlopeScale = this.mDepthConfiguration.depthBiasSlopeScale;\r\n                lPipelineDescriptor.depthStencil.depthBiasClamp = this.mDepthConfiguration.depthBiasClamp;\r\n\r\n                // Bias settings must be zero for list topologies.\r\n                if (this.mPrimitiveTopology === PrimitiveTopology.LineList || this.mPrimitiveTopology === PrimitiveTopology.LineStrip || this.mPrimitiveTopology === PrimitiveTopology.PointList) {\r\n                    if (lPipelineDescriptor.depthStencil.depthBias !== 0 || lPipelineDescriptor.depthStencil.depthBiasSlopeScale !== 0 || lPipelineDescriptor.depthStencil.depthBiasClamp !== 0) {\r\n                        throw new Exception(`Pipelines depth bias settings must be zero for \"${this.mPrimitiveTopology}\"-Topology`, this);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Setup stencil options.\r\n            if (this.mRenderTargets.hasStencil) {\r\n                lPipelineDescriptor.depthStencil.stencilReadMask = this.mStencilConfiguration.stencilReadMask;\r\n                lPipelineDescriptor.depthStencil.stencilWriteMask = this.mStencilConfiguration.stencilWriteMask;\r\n                lPipelineDescriptor.depthStencil.stencilBack = {\r\n                    compare: this.mStencilConfiguration.stencilBack.compare,\r\n                    failOp: this.mStencilConfiguration.stencilBack.failOperation,\r\n                    depthFailOp: this.mStencilConfiguration.stencilBack.depthFailOperation,\r\n                    passOp: this.mStencilConfiguration.stencilBack.passOperation\r\n                };\r\n                lPipelineDescriptor.depthStencil.stencilFront = {\r\n                    compare: this.mStencilConfiguration.stencilFront.compare,\r\n                    failOp: this.mStencilConfiguration.stencilFront.failOperation,\r\n                    depthFailOp: this.mStencilConfiguration.stencilFront.depthFailOperation,\r\n                    passOp: this.mStencilConfiguration.stencilFront.passOperation\r\n                };\r\n            }\r\n        }\r\n\r\n        // Set multisample count.\r\n        if (this.mRenderTargets.multisampled) {\r\n            lPipelineDescriptor.multisample = {\r\n                count: 4\r\n            };\r\n        }\r\n\r\n        // Load pipeline asyncron and update native after promise resolve.\r\n        this.device.gpu.createRenderPipelineAsync(lPipelineDescriptor).then((pPipeline: GPURenderPipeline) => {\r\n            this.mLoadedPipeline = pPipeline;\r\n            this.invalidate(VertexFragmentPipelineInvalidationType.NativeLoaded);\r\n        });\r\n\r\n        // Null as long as pipeline is loading.\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Primitive settings.\r\n     */\r\n    private generatePrimitive(): GPUPrimitiveState {\r\n        // Convert topology to native. Set strip format for strip topology.\r\n        let lStripIndexFormat: GPUIndexFormat | undefined = undefined;\r\n\r\n        switch (this.primitiveTopology) {\r\n            case PrimitiveTopology.LineStrip:\r\n            case PrimitiveTopology.TriangleStrip: {\r\n                lStripIndexFormat = 'uint32';\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Create primitive state.\r\n        const lPrimitiveState: GPUPrimitiveState = {\r\n            topology: this.primitiveTopology,\r\n            frontFace: this.primitiveFrontFace,\r\n            cullMode: this.primitiveCullMode,\r\n            unclippedDepth: false\r\n        };\r\n\r\n        // Set optional strip format.\r\n        if (lStripIndexFormat) {\r\n            lPrimitiveState.stripIndexFormat = lStripIndexFormat;\r\n        }\r\n\r\n        return lPrimitiveState;\r\n    }\r\n\r\n    /**\r\n     * Generate blend state for render target.\r\n     * \r\n     * @param pTargetName - Render target name.\r\n     * \r\n     * @returns generated blend state. \r\n     */\r\n    private generateRenderTargetBlendState(pTargetName: string): GPUBlendState {\r\n        const lConfig: VertexFragmentPipelineTargetConfigData | undefined = this.mRenderTargetConfig.get(pTargetName);\r\n\r\n        // Set defaults for blend state.\r\n        const lBlendState: GPUBlendState = {\r\n            color: {\r\n                operation: 'add',\r\n                srcFactor: 'one',\r\n                dstFactor: 'zero'\r\n            },\r\n            alpha: {\r\n                operation: 'add',\r\n                srcFactor: 'one',\r\n                dstFactor: 'zero'\r\n            }\r\n        };\r\n\r\n        // Set alpha and alpha blend when set.\r\n        if (lConfig) {\r\n            lBlendState.alpha = {\r\n                operation: lConfig.alphaBlend.operation,\r\n                srcFactor: lConfig.alphaBlend.sourceFactor,\r\n                dstFactor: lConfig.alphaBlend.destinationFactor\r\n            };\r\n            lBlendState.color = {\r\n                operation: lConfig.colorBlend.operation,\r\n                srcFactor: lConfig.colorBlend.sourceFactor,\r\n                dstFactor: lConfig.colorBlend.destinationFactor\r\n            };\r\n        }\r\n\r\n        return lBlendState;\r\n    }\r\n\r\n    /**\r\n     * Generate gpu color write mask for the set render target.\r\n     * \r\n     * @param pTargetName - Target name.\r\n     * \r\n     * @returns color write flags.\r\n     */\r\n    private generateRenderTargetWriteMask(pTargetName: string): GPUColorWriteFlags {\r\n        const lConfig: VertexFragmentPipelineTargetConfigData | undefined = this.mRenderTargetConfig.get(pTargetName);\r\n\r\n        // Convert color aspects config to write mask.\r\n        let lWriteMask: GPUColorWriteFlags = 0xf;\r\n        if (lConfig) {\r\n            lWriteMask = 0x0;\r\n            if (lConfig.aspectWriteMask.has(TextureAspect.Red)) {\r\n                lWriteMask += 0x1;\r\n            }\r\n            if (lConfig.aspectWriteMask.has(TextureAspect.Green)) {\r\n                lWriteMask += 0x2;\r\n            }\r\n            if (lConfig.aspectWriteMask.has(TextureAspect.Red)) {\r\n                lWriteMask += 0x4;\r\n            }\r\n            if (lConfig.aspectWriteMask.has(TextureAspect.Alpha)) {\r\n                lWriteMask += 0x8;\r\n            }\r\n        }\r\n\r\n        return lWriteMask;\r\n    }\r\n}\r\n\r\nexport type VertexFragmentPipelineDepthConfigurationData = {\r\n    depthCompare: CompareFunction;\r\n    depthWriteEnabled: boolean;\r\n    depthBias: number;\r\n    depthBiasSlopeScale: number;\r\n    depthBiasClamp: number;\r\n};\r\n\r\n\r\ntype VertexFragmentPipelineStencilConfigurationFaceData = {\r\n    compare: CompareFunction;\r\n    failOperation: StencilOperation;\r\n    depthFailOperation: StencilOperation;\r\n    passOperation: StencilOperation;\r\n};\r\n\r\nexport type VertexFragmentPipelineStencilConfigurationData = {\r\n    stencilBack: VertexFragmentPipelineStencilConfigurationFaceData;\r\n    stencilFront: VertexFragmentPipelineStencilConfigurationFaceData;\r\n    stencilReadMask: number;\r\n    stencilWriteMask: number;\r\n};\r\n\r\nexport enum VertexFragmentPipelineInvalidationType {\r\n    NativeRebuild = 'NativeRebuild',\r\n    NativeLoaded = 'NativeLoaded',\r\n}\r\n\r\ntype VertexFragmentPipelineTargetConfigBlendData = {\r\n    operation: TextureBlendOperation;\r\n    sourceFactor: TextureBlendFactor;\r\n    destinationFactor: TextureBlendFactor;\r\n};\r\n\r\nexport type VertexFragmentPipelineTargetConfigData = {\r\n    colorBlend: VertexFragmentPipelineTargetConfigBlendData;\r\n    alphaBlend: VertexFragmentPipelineTargetConfigBlendData;\r\n    aspectWriteMask: Set<TextureAspect>;\r\n};", "import { Dictionary, Exception } from '@kartoffelgames/core';\r\nimport { GpuBuffer } from '../../buffer/gpu-buffer.ts';\r\nimport { GpuBufferView } from '../../buffer/gpu-buffer-view.ts';\r\nimport { BufferAlignmentType } from '../../constant/buffer-alignment-type.enum.ts';\r\nimport { BufferItemFormat } from '../../constant/buffer-item-format.enum.ts';\r\nimport { BufferItemMultiplier } from '../../constant/buffer-item-multiplier.enum.ts';\r\nimport { BufferUsage } from '../../constant/buffer-usage.enum.ts';\r\nimport { VertexParameterStepMode } from '../../constant/vertex-parameter-step-mode.enum.ts';\r\nimport { VertexParameterLayout, VertexParameterLayoutBuffer } from './vertex-parameter-layout.ts';\r\nimport { ArrayBufferMemoryLayout } from '../../buffer/memory_layout/array-buffer-memory-layout.ts';\r\nimport { PrimitiveBufferMemoryLayout } from '../../buffer/memory_layout/primitive-buffer-memory-layout.ts';\r\nimport { GpuDevice } from '../../device/gpu-device.ts';\r\nimport { GpuObject } from '../../gpu_object/gpu-object.ts';\r\n\r\n/**\r\n * Vertex parameters used for a single render draw call.\r\n * Flats out parameters that are indexed when another vertex data is not indexed.\r\n */\r\nexport class VertexParameter extends GpuObject<null, VertexParameterInvalidationType> {\r\n    private readonly mBuffer: Dictionary<string, GpuBuffer>;\r\n    private readonly mIndexBufferView: GpuBufferView<Uint16Array | Uint32Array> | null;\r\n    private readonly mIndices: Array<number>;\r\n    private readonly mLayout: VertexParameterLayout;\r\n\r\n    /**\r\n     * Get index buffer.\r\n     */\r\n    public get indexBuffer(): GpuBufferView<Uint16Array | Uint32Array> | null {\r\n        return this.mIndexBufferView;\r\n    }\r\n\r\n    /**\r\n     * Get parameter layout.\r\n     */\r\n    public get layout(): VertexParameterLayout {\r\n        return this.mLayout;\r\n    }\r\n\r\n    /**\r\n     * Vertex count.\r\n     */\r\n    public get vertexCount(): number {\r\n        return this.mIndices.length;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Device reference.\r\n     * @param pVertexParameterLayout - Parameter layout.\r\n     * @param pIndices - Index buffer data.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pVertexParameterLayout: VertexParameterLayout, pIndices: Array<number>) {\r\n        super(pDevice);\r\n\r\n        // Set vertex parameter layout.\r\n        this.mLayout = pVertexParameterLayout;\r\n        this.mBuffer = new Dictionary<string, GpuBuffer>();\r\n\r\n        // Save index information.\r\n        this.mIndices = pIndices;\r\n\r\n        // Create index buffer.\r\n        this.mIndexBufferView = null;\r\n        if (this.mLayout.indexable) {\r\n            // Decide wich format to use.\r\n            if (pIndices.length < Math.pow(2, 16)) {\r\n                // Create index buffer layout.\r\n                const lIndexBufferLayout: ArrayBufferMemoryLayout = new ArrayBufferMemoryLayout(this.device, {\r\n                    arraySize: pIndices.length,\r\n                    innerType: new PrimitiveBufferMemoryLayout(this.device, {\r\n                        alignmentType: BufferAlignmentType.Packed,\r\n                        primitiveFormat: BufferItemFormat.Uint16,\r\n                        primitiveMultiplier: BufferItemMultiplier.Single,\r\n                    })\r\n                });\r\n\r\n                // Create index buffer.\r\n                const lIndexBuffer: GpuBuffer = new GpuBuffer(pDevice, pIndices.length * 2);\r\n                lIndexBuffer.extendUsage(BufferUsage.Index);\r\n                lIndexBuffer.initialData(new Uint16Array(pIndices).buffer);\r\n\r\n                // Create view of buffer.\r\n                this.mIndexBufferView = lIndexBuffer.view(lIndexBufferLayout, Uint16Array);\r\n            } else {\r\n                // Create index buffer layout.\r\n                const lIndexBufferLayout: ArrayBufferMemoryLayout = new ArrayBufferMemoryLayout(this.device, {\r\n                    arraySize: pIndices.length,\r\n                    innerType: new PrimitiveBufferMemoryLayout(this.device, {\r\n                        alignmentType: BufferAlignmentType.Packed,\r\n                        primitiveFormat: BufferItemFormat.Uint32,\r\n                        primitiveMultiplier: BufferItemMultiplier.Single,\r\n                    })\r\n                });\r\n\r\n                // Create index buffer.\r\n                const lIndexBuffer: GpuBuffer = new GpuBuffer(pDevice, pIndices.length * 4);\r\n                lIndexBuffer.extendUsage(BufferUsage.Index);\r\n                lIndexBuffer.initialData(new Uint32Array(pIndices).buffer);\r\n\r\n                // Create view of buffer.\r\n                this.mIndexBufferView = lIndexBuffer.view(lIndexBufferLayout, Uint32Array);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set parameter data.\r\n     * @param pName - parameter buffer name.\r\n     * @param pData - Parameter data with ignored alignments.\r\n     */\r\n    public create(pBufferName: string, pData: Array<number>): GpuBuffer {\r\n        const lParameterLayout: VertexParameterLayoutBuffer = this.mLayout.parameterBuffer(pBufferName);\r\n\r\n        // Get item count of layout. => Vec3<float> + int + Vex2<uint> => 6 Items\r\n        const lStrideParameter: Array<{ format: BufferItemFormat, count: number, alignment: number; itemByteCount: number; }> = new Array<{ format: BufferItemFormat, count: number, alignment: number; itemByteCount: number; }>();\r\n        let lStrideDataCount: number = 0;\r\n        for (const lBufferParameter of lParameterLayout.layout.properties) {\r\n            const lParameterLayout: PrimitiveBufferMemoryLayout = lBufferParameter.layout as PrimitiveBufferMemoryLayout;\r\n\r\n            // Read item count and format of parameter.\r\n            const lParameterItemCount: number = PrimitiveBufferMemoryLayout.itemCountOfMultiplier(lParameterLayout.itemMultiplier);\r\n            const lParameterItemFormat: BufferItemFormat = lParameterLayout.itemFormat;\r\n\r\n            // Add stride data count.\r\n            lStrideDataCount += lParameterItemCount;\r\n\r\n            // Add formats for each item of parameter.\r\n            lStrideParameter.push({\r\n                count: lParameterItemCount,\r\n                format: lParameterItemFormat,\r\n                alignment: lParameterLayout.alignment,\r\n                itemByteCount: PrimitiveBufferMemoryLayout.itemFormatByteCount(lParameterItemFormat)\r\n            });\r\n        }\r\n\r\n        // Buffer data must align with layout.\r\n        if (pData.length % lStrideDataCount !== 0) {\r\n            throw new Exception('Vertex parameter buffer data does not align with layout.', this);\r\n        }\r\n\r\n        // When parameter is indexed but vertex parameter are not indexed, extend data. Based on index data.\r\n        let lData: Array<number> = pData;\r\n        if (!this.mLayout.indexable && lParameterLayout.stepMode === VertexParameterStepMode.Index) {\r\n            // Dublicate dependent on index information.\r\n            lData = new Array<number>();\r\n            for (const lIndex of this.mIndices) {\r\n                const lDataStart: number = lIndex * lStrideDataCount;\r\n                const lDataEnd: number = lDataStart + lStrideDataCount;\r\n\r\n                // Copy vertex parameter data.\r\n                lData.push(...pData.slice(lDataStart, lDataEnd));\r\n            }\r\n        }\r\n\r\n        // Calculate struct count in buffer. Fallback to vertex mode when buffer is in index step mode but parameters cant be indexed.\r\n        let lStrideCount: number = lData.length / lStrideDataCount;\r\n        if (!this.mLayout.indexable && lParameterLayout.stepMode === VertexParameterStepMode.Index) {\r\n            lStrideCount = this.mIndices.length;\r\n        }\r\n\r\n        // Create buffer data.\r\n        const lBufferData: ArrayBuffer = new ArrayBuffer(lParameterLayout.layout.fixedSize * lStrideCount);\r\n        const lBufferDataView: DataView = new DataView(lBufferData);\r\n\r\n        // Set data in little endian according to the set item format and offset. \r\n        const lSetData = (pByteOffset: number, pFormat: BufferItemFormat, pData: number) => {\r\n            switch (pFormat) {\r\n                case BufferItemFormat.Float32: { lBufferDataView.setFloat32(pByteOffset, pData, true); break; }\r\n                case BufferItemFormat.Uint32: { lBufferDataView.setUint32(pByteOffset, pData, true); break; }\r\n                case BufferItemFormat.Sint32: { lBufferDataView.setInt32(pByteOffset, pData, true); break; }\r\n                case BufferItemFormat.Uint8: { lBufferDataView.setUint8(pByteOffset, pData); break; }\r\n                case BufferItemFormat.Sint8: { lBufferDataView.setInt8(pByteOffset, pData); break; }\r\n                case BufferItemFormat.Uint16: { lBufferDataView.setUint16(pByteOffset, pData, true); break; }\r\n                case BufferItemFormat.Sint16: { lBufferDataView.setInt16(pByteOffset, pData, true); break; }\r\n\r\n                // Unsupported\r\n                case BufferItemFormat.Float16:\r\n                case BufferItemFormat.Unorm16:\r\n                case BufferItemFormat.Snorm16:\r\n                case BufferItemFormat.Unorm8:\r\n                case BufferItemFormat.Snorm8:\r\n                default: {\r\n                    throw new Exception(`Currently \"${pFormat}\" is not supported for vertex parameter.`, this);\r\n                }\r\n            }\r\n        };\r\n\r\n        // Add data with correct alignment.\r\n        let lDataIndex: number = 0;\r\n        let lByteOffset: number = 0;\r\n        for (let lStrideIndex: number = 0; lStrideIndex < lStrideCount; lStrideIndex++) {\r\n            for (const lStrideItem of lStrideParameter) {\r\n                // Apply stride item alignment to offset.\r\n                lByteOffset = Math.ceil(lByteOffset / lStrideItem.alignment) * lStrideItem.alignment;\r\n\r\n                // Add each parameter to buffer.\r\n                for (let lStrideItemIndex: number = 0; lStrideItemIndex < lStrideItem.count; lStrideItemIndex++) {\r\n                    // Add and iterate data.\r\n                    lSetData(lByteOffset, lStrideItem.format, lData[lDataIndex]);\r\n                    lDataIndex++;\r\n\r\n                    // Increase offset by format byte count.\r\n                    lByteOffset += lStrideItem.itemByteCount;\r\n                }\r\n            }\r\n\r\n            // Apply stride alignment\r\n            lByteOffset = Math.ceil(lByteOffset / lParameterLayout.layout.alignment) * lParameterLayout.layout.alignment;\r\n        }\r\n\r\n        // Load typed array from layout format.\r\n        const lParameterBuffer: GpuBuffer = new GpuBuffer(this.device, lBufferData.byteLength).initialData(lBufferData);\r\n\r\n        // Extend buffer to be a vertex buffer.\r\n        lParameterBuffer.extendUsage(BufferUsage.Vertex);\r\n\r\n        // Save gpu buffer in correct index.\r\n        this.mBuffer.set(pBufferName, lParameterBuffer);\r\n\r\n        // Invalidate on data set.\r\n        this.invalidate(VertexParameterInvalidationType.Data);\r\n\r\n        return lParameterBuffer;\r\n    }\r\n\r\n    /**\r\n     * Get parameter buffer.\r\n     * @param pBufferName - Parameter buffer name.\r\n     */\r\n    public get(pBufferName: string): GpuBuffer {\r\n        // Validate.\r\n        if (!this.mBuffer.has(pBufferName)) {\r\n            throw new Exception(`Vertex parameter buffer for \"${pBufferName}\" not set.`, this);\r\n        }\r\n\r\n        return this.mBuffer.get(pBufferName)!;\r\n    }\r\n\r\n    /**\r\n     * Add raw buffer as vertex parameter.\r\n     * \r\n     * @param pBufferName - Buffer name.\r\n     * @param pBuffer - Buffer.\r\n     */\r\n    public set(pBufferName: string, pBuffer: GpuBuffer): GpuBuffer {\r\n        const lParameterLayout: VertexParameterLayoutBuffer = this.mLayout.parameterBuffer(pBufferName);\r\n\r\n        // Validate alignment.\r\n        if (pBuffer.size % lParameterLayout.layout.fixedSize !== 0) {\r\n            throw new Exception('Set vertex parameter buffer does not align with layout.', this);\r\n        }\r\n\r\n        // Calculate stride count.\r\n        let lStrideCount: number = pBuffer.size / lParameterLayout.layout.fixedSize;\r\n        if (!this.mLayout.indexable && lParameterLayout.stepMode === VertexParameterStepMode.Index) {\r\n            lStrideCount = this.mIndices.length;\r\n        }\r\n\r\n        // Validate length.\r\n        if (pBuffer.size !== (lParameterLayout.layout.fixedSize * lStrideCount)) {\r\n            throw new Exception(`Set vertex parameter buffer does not fit needed buffer size (Has:${pBuffer.size} => Should:${lParameterLayout.layout.fixedSize * lStrideCount}).`, this);\r\n        }\r\n\r\n        // Extend usage.\r\n        pBuffer.extendUsage(BufferUsage.Vertex);\r\n\r\n        // Add buffer.\r\n        this.mBuffer.set(pBufferName, pBuffer);\r\n\r\n        // Invalidate on data set.\r\n        this.invalidate(VertexParameterInvalidationType.Data);\r\n\r\n        return pBuffer;\r\n    }\r\n}\r\n\r\nexport enum VertexParameterInvalidationType {\r\n    Data = 'DataChange',\r\n}", "import { Dictionary, Exception } from '@kartoffelgames/core';\r\nimport { GpuBuffer } from '../../buffer/gpu-buffer.ts';\r\nimport { BufferUsage } from '../../constant/buffer-usage.enum.ts';\r\nimport { PipelineData, PipelineDataGroup } from '../../pipeline/pipeline_data/pipeline-data.ts';\r\nimport { RenderTargets } from '../../pipeline/render_targets/render-targets.ts';\r\nimport { VertexFragmentPipeline } from '../../pipeline/vertex_fragment_pipeline/vertex-fragment-pipeline.ts';\r\nimport { VertexParameter } from '../../pipeline/vertex_parameter/vertex-parameter.ts';\r\n\r\n/**\r\n * Context for a render pass.\r\n * Used to execute draw calles.\r\n */\r\nexport class RenderPassContext {\r\n    private readonly mEncoder: GPURenderPassEncoder | GPURenderBundleEncoder;\r\n    private readonly mRecordResources: boolean;\r\n    private readonly mRenderResourceBuffer: RenderPassContextRenderBuffer;\r\n    private readonly mRenderTargets: RenderTargets;\r\n    private readonly mUsedResources: RenderPassContextUsedResource;\r\n\r\n    /**\r\n     * Used resource.\r\n     * Only filled when recording is enabled. \r\n     */\r\n    public get usedResources(): RenderPassContextUsedResource {\r\n        return this.mUsedResources;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pEncoder - Encoder.\r\n     * @param pRenderTargets - Render targets.\r\n     * @param pRecordResources - Records used resources on render. \r\n     */\r\n    public constructor(pEncoder: GPURenderPassEncoder | GPURenderBundleEncoder, pRenderTargets: RenderTargets, pRecordResources: boolean) {\r\n        this.mEncoder = pEncoder;\r\n        this.mRenderTargets = pRenderTargets;\r\n        this.mRecordResources = pRecordResources;\r\n        this.mUsedResources = {\r\n            parameter: new Set<VertexParameter>(),\r\n            indirectBuffer: new Set<GpuBuffer>(),\r\n            pipelines: new Set<VertexFragmentPipeline>(),\r\n            pipelineData: new Set<PipelineData>()\r\n        };\r\n        this.mRenderResourceBuffer = {\r\n            pipeline: null,\r\n            vertexBuffer: new Dictionary<number, GpuBuffer>(),\r\n            highestVertexParameterIndex: -1,\r\n            pipelineDataGroupList: new Array<PipelineDataGroup>(),\r\n            highestBindGroupListIndex: -1\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Draw direct with set parameter.\r\n     * \r\n     * @param pPipeline - Pipeline.\r\n     * @param pParameter - Vertex parameter.\r\n     * @param pPipelineData - Pipline bind data groups.\r\n     * @param pInstanceCount - Instance count.\r\n     * @param pInstanceOffset - Instance offset. \r\n     */\r\n    public drawDirect(pPipeline: VertexFragmentPipeline, pParameter: VertexParameter, pPipelineData: PipelineData, pInstanceCount: number = 1, pInstanceOffset: number = 0): void {\r\n        // Validate same render targets.\r\n        if (this.mRenderTargets !== pPipeline.renderTargets) {\r\n            throw new Exception('Pipelines render targets not valid for this render pass.', this);\r\n        }\r\n\r\n        // Validate parameter.\r\n        if (pParameter.layout !== pPipeline.module.vertexParameter) {\r\n            throw new Exception('Vertex parameter not valid for set pipeline.', this);\r\n        }\r\n\r\n        // Validate pipeline data matches pipeline layout of pipeline.\r\n        if (pPipeline.layout !== pPipelineData.layout) {\r\n            throw new Exception('Pipline data not valid for set pipeline.', this);\r\n        }\r\n\r\n        // Record resource when config is set.\r\n        if (this.mRecordResources) {\r\n            // Pipelines.\r\n            if (!this.mUsedResources.pipelines.has(pPipeline)) {\r\n                this.mUsedResources.pipelines.add(pPipeline);\r\n            }\r\n\r\n            // Parameter\r\n            if (!this.mUsedResources.parameter.has(pParameter)) {\r\n                this.mUsedResources.parameter.add(pParameter);\r\n            }\r\n\r\n            // Pipeline data.\r\n            if (!this.mUsedResources.pipelineData.has(pPipelineData)) {\r\n                this.mUsedResources.pipelineData.add(pPipelineData);\r\n            }\r\n        }\r\n\r\n        // Execute draw.\r\n        if (this.setupEncoderData(pPipeline, pParameter, pPipelineData)) {\r\n            this.executeDirectDraw(pParameter, pInstanceCount, pInstanceOffset);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw indirect with parameters set in buffer.\r\n     * \r\n     * @param pPipeline - Pipeline.\r\n     * @param pParameter - Vertex parameter.\r\n     * @param pPipelineData - Pipline bind data groups.\r\n     * @param pIndirectBuffer - Buffer with indirect parameter data.\r\n     */\r\n    public drawIndirect(pPipeline: VertexFragmentPipeline, pParameter: VertexParameter, pPipelineData: PipelineData, pIndirectBuffer: GpuBuffer): void {\r\n        // Extend usage.\r\n        pIndirectBuffer.extendUsage(BufferUsage.Indirect);\r\n\r\n        // Validate same render targets.\r\n        if (this.mRenderTargets !== pPipeline.renderTargets) {\r\n            throw new Exception('Pipelines render targets not valid for this render pass.', this);\r\n        }\r\n\r\n        // Validate parameter.\r\n        if (pParameter.layout !== pPipeline.module.vertexParameter) {\r\n            throw new Exception('Vertex parameter not valid for set pipeline.', this);\r\n        }\r\n\r\n        // Validate pipeline data matches pipeline layout of pipeline.\r\n        if (pPipeline.layout !== pPipelineData.layout) {\r\n            throw new Exception('Pipline data not valid for set pipeline.', this);\r\n        }\r\n\r\n        // Record resource when config is set.\r\n        if (this.mRecordResources) {\r\n            // Pipelines.\r\n            if (!this.mUsedResources.pipelines.has(pPipeline)) {\r\n                this.mUsedResources.pipelines.add(pPipeline);\r\n            }\r\n\r\n            // Parameter\r\n            if (!this.mUsedResources.parameter.has(pParameter)) {\r\n                this.mUsedResources.parameter.add(pParameter);\r\n            }\r\n\r\n            // Pipeline data.\r\n            if (!this.mUsedResources.pipelineData.has(pPipelineData)) {\r\n                this.mUsedResources.pipelineData.add(pPipelineData);\r\n            }\r\n        }\r\n\r\n        // Execute draw.\r\n        if (this.setupEncoderData(pPipeline, pParameter, pPipelineData)) {\r\n            this.executeIndirectDraw(pParameter, pIndirectBuffer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set pipeline and any bind and vertex data.\r\n     * \r\n     * @param pPipeline - Pipeline.\r\n     * @param pParameter  - Pipeline vertex parameter.\r\n     * @param pPipelineData - Pipeline binding data.\r\n     * \r\n     * @returns true when everything has been successfully set. \r\n     */\r\n    public setupEncoderData(pPipeline: VertexFragmentPipeline, pParameter: VertexParameter, pPipelineData: PipelineData): boolean {\r\n        // Skip pipelines that are currently loading.\r\n        const lNativePipeline: GPURenderPipeline | null = pPipeline.native;\r\n        if (lNativePipeline === null) {\r\n            return false;\r\n        }\r\n\r\n        // Cache for bind group length of this instruction.\r\n        let lLocalHighestBindGroupListIndex: number = -1;\r\n\r\n        // Add bind groups.\r\n        const lPipelineDataGroupList: Array<PipelineDataGroup> = pPipelineData.data;\r\n        for (let lBindGroupIndex: number = 0; lBindGroupIndex < lPipelineDataGroupList.length; lBindGroupIndex++) {\r\n            const lPipelineDataGroup: PipelineDataGroup | undefined = lPipelineDataGroupList[lBindGroupIndex];\r\n            const lCurrentPipelineDataGroup: PipelineDataGroup | null = this.mRenderResourceBuffer.pipelineDataGroupList[lBindGroupIndex];\r\n\r\n            // Extend group list length.\r\n            if (lBindGroupIndex > lLocalHighestBindGroupListIndex) {\r\n                lLocalHighestBindGroupListIndex = lBindGroupIndex;\r\n            }\r\n\r\n            // Use cached bind group or use new.\r\n            if (!lCurrentPipelineDataGroup || lPipelineDataGroup.bindGroup !== lCurrentPipelineDataGroup.bindGroup || lPipelineDataGroup.offsetId !== lCurrentPipelineDataGroup.offsetId) {\r\n                // Set bind group buffer to cache current set bind groups.\r\n                this.mRenderResourceBuffer.pipelineDataGroupList[lBindGroupIndex] = lPipelineDataGroup;\r\n\r\n                // Set bind group to gpu.\r\n                if (lPipelineDataGroup.bindGroup.layout.hasDynamicOffset) {\r\n                    this.mEncoder.setBindGroup(lBindGroupIndex, lPipelineDataGroup.bindGroup.native, lPipelineDataGroup.offsets);\r\n                } else {\r\n                    this.mEncoder.setBindGroup(lBindGroupIndex, lPipelineDataGroup.bindGroup.native);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Cache for bind group length of this instruction.\r\n        let lLocalHighestVertexParameterListIndex: number = -1;\r\n\r\n        // Add vertex attribute buffer.\r\n        const lBufferNames: Array<string> = pPipeline.module.vertexParameter.bufferNames;\r\n        for (let lBufferIndex: number = 0; lBufferIndex < lBufferNames.length; lBufferIndex++) {\r\n            // Read buffer information.\r\n            const lAttributeBufferName: string = lBufferNames[lBufferIndex];\r\n            const lNewAttributeBuffer: GpuBuffer = pParameter.get(lAttributeBufferName);\r\n\r\n            // Extend group list length.\r\n            if (lBufferIndex > lLocalHighestVertexParameterListIndex) {\r\n                lLocalHighestVertexParameterListIndex = lBufferIndex;\r\n            }\r\n\r\n            // Use cached vertex buffer or use new.\r\n            if (lNewAttributeBuffer !== this.mRenderResourceBuffer.vertexBuffer.get(lBufferIndex)) {\r\n                this.mRenderResourceBuffer.vertexBuffer.set(lBufferIndex, lNewAttributeBuffer);\r\n                this.mEncoder.setVertexBuffer(lBufferIndex, lNewAttributeBuffer.native);\r\n            }\r\n        }\r\n\r\n        // Use cached pipeline or use new.\r\n        if (pPipeline !== this.mRenderResourceBuffer.pipeline) {\r\n            this.mRenderResourceBuffer.pipeline = pPipeline;\r\n\r\n            // Generate and set new pipeline.\r\n            this.mEncoder.setPipeline(lNativePipeline);\r\n\r\n            // Only clear bind buffer when a new pipeline is set.\r\n            // Same pipelines must have set the same bind group layouts.\r\n            if (this.mRenderResourceBuffer.highestBindGroupListIndex > lLocalHighestBindGroupListIndex) {\r\n                for (let lBindGroupIndex: number = (lLocalHighestBindGroupListIndex + 1); lBindGroupIndex < (this.mRenderResourceBuffer.highestBindGroupListIndex + 1); lBindGroupIndex++) {\r\n                    this.mEncoder.setBindGroup(lBindGroupIndex, null);\r\n                }\r\n            }\r\n\r\n            // Update global bind group list length.\r\n            this.mRenderResourceBuffer.highestBindGroupListIndex = lLocalHighestBindGroupListIndex;\r\n\r\n            // Only clear vertex buffer when a new pipeline is set.\r\n            // Same pipeline must have the same vertex parameter layout.\r\n            if (this.mRenderResourceBuffer.highestVertexParameterIndex > lLocalHighestVertexParameterListIndex) {\r\n                for (let lVertexParameterBufferIndex: number = (lLocalHighestVertexParameterListIndex + 1); lVertexParameterBufferIndex < (this.mRenderResourceBuffer.highestVertexParameterIndex + 1); lVertexParameterBufferIndex++) {\r\n                    this.mEncoder.setVertexBuffer(lVertexParameterBufferIndex, null);\r\n                }\r\n            }\r\n\r\n            // Update global bind group list length.\r\n            this.mRenderResourceBuffer.highestVertexParameterIndex = lLocalHighestVertexParameterListIndex;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Execute direct draw call.\r\n     * \r\n     * @param pParameter - Vertex parameter.\r\n     * @param pInstanceCount - Index count.\r\n     * @param pInstanceOffset - Instance offset. \r\n     */\r\n    private executeDirectDraw(pParameter: VertexParameter, pInstanceCount: number, pInstanceOffset: number): void {\r\n        // Draw indexed when parameters are indexable.\r\n        if (pParameter.layout.indexable) {\r\n            // Set indexbuffer. Dynamicly switch between 32 and 16 bit based on length.\r\n            if (pParameter.indexBuffer!.format === Uint16Array) {\r\n                this.mEncoder.setIndexBuffer(pParameter.indexBuffer!.buffer.native, 'uint16');\r\n            } else {\r\n                this.mEncoder.setIndexBuffer(pParameter.indexBuffer!.buffer.native, 'uint32');\r\n            }\r\n\r\n            // Create draw call.\r\n            this.mEncoder.drawIndexed(pParameter.indexBuffer!.length, pInstanceCount, 0, 0, pInstanceOffset);\r\n        } else {\r\n            // Create draw call.\r\n            this.mEncoder.draw(pParameter.vertexCount, pInstanceCount, 0, pInstanceOffset);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a indirect draw call.\r\n     * If indexed or normal indirect calls are used is defined by the buffer length.\r\n     * \r\n     * @param pParameter - Vertex parameter.\r\n     * @param pBuffer - Indirect buffer.\r\n     */\r\n    private executeIndirectDraw(pParameter: VertexParameter, pBuffer: GpuBuffer): void {\r\n        // 4 Byte * 5 => 20 Byte => Indexed draw \r\n        // 4 Byte * 4 => 16 Byte => Normal draw \r\n        if (pBuffer.size === 20) {\r\n            // Buffer does not match when parameters are not indexable.\r\n            if (!pParameter.layout.indexable) {\r\n                throw new Exception('Indirect indexed draw call failed, because parameter are not indexable', this);\r\n            }\r\n\r\n            // Set indexbuffer. Dynamicly switch between 32 and 16 bit based on length.\r\n            if (pParameter.indexBuffer!.format === Uint16Array) {\r\n                this.mEncoder.setIndexBuffer(pParameter.indexBuffer!.buffer.native, 'uint16');\r\n            } else {\r\n                this.mEncoder.setIndexBuffer(pParameter.indexBuffer!.buffer.native, 'uint32');\r\n            }\r\n\r\n            // Start indirect indexed call.\r\n            this.mEncoder.drawIndexedIndirect(pBuffer.native, 0);\r\n        } else if (pBuffer.size === 16) {\r\n            // Start indirect call.\r\n            this.mEncoder.drawIndirect(pBuffer.native, 0);\r\n        } else {\r\n            throw new Exception('Indirect draw calls can only be done with 20 or 16 byte long buffers', this);\r\n        }\r\n    }\r\n}\r\ntype RenderPassContextUsedResource = {\r\n    readonly parameter: Set<VertexParameter>;\r\n    readonly indirectBuffer: Set<GpuBuffer>;\r\n    readonly pipelines: Set<VertexFragmentPipeline>;\r\n    readonly pipelineData: Set<PipelineData>;\r\n};\r\n\r\ntype RenderPassContextRenderBuffer = {\r\n    pipeline: VertexFragmentPipeline | null;\r\n\r\n    // Vertex buffer.\r\n    vertexBuffer: Dictionary<number, GpuBuffer>;\r\n    highestVertexParameterIndex: number;\r\n\r\n    pipelineDataGroupList: Array<PipelineDataGroup>;\r\n    highestBindGroupListIndex: number;\r\n};", "import { GpuBuffer } from '../../buffer/gpu-buffer.ts';\r\nimport { BufferUsage } from '../../constant/buffer-usage.enum.ts';\r\nimport { GpuFeature } from '../../constant/gpu-feature.enum.ts';\r\nimport { GpuDevice } from '../../device/gpu-device.ts';\r\nimport { GpuObject } from '../../gpu_object/gpu-object.ts';\r\nimport { GpuResourceObjectInvalidationType } from '../../gpu_object/gpu-resource-object.ts';\r\nimport { PipelineData, PipelineDataInvalidationType } from '../../pipeline/pipeline_data/pipeline-data.ts';\r\nimport { RenderTargets } from '../../pipeline/render_targets/render-targets.ts';\r\nimport { VertexFragmentPipeline, VertexFragmentPipelineInvalidationType } from '../../pipeline/vertex_fragment_pipeline/vertex-fragment-pipeline.ts';\r\nimport { VertexParameter, VertexParameterInvalidationType } from '../../pipeline/vertex_parameter/vertex-parameter.ts';\r\nimport { GpuExecutionContext } from '../gpu-execution.ts';\r\nimport { RenderPassContext } from './render-pass-context.ts';\r\n\r\n/**\r\n * Gpu render pass. Has the ability to bundle render calls for static lists.\r\n */\r\nexport class RenderPass extends GpuObject {\r\n    private readonly mBundleConfig: RenderBundleConfig;\r\n    private readonly mExecutionFunction: RenderPassExecutionFunction;\r\n    private readonly mQueries: RenderPassQuery;\r\n    private readonly mRenderTargets: RenderTargets;\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pDevice - Device reference.\r\n     * @param pRenderTargets - Render targets.\r\n     * @param pStaticBundle - Bundle is static and does not update very often.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pRenderTargets: RenderTargets, pStaticBundle: boolean, pExecution: RenderPassExecutionFunction) {\r\n        super(pDevice);\r\n\r\n        // Set config.\r\n        this.mExecutionFunction = pExecution;\r\n        this.mQueries = {};\r\n        this.mRenderTargets = pRenderTargets;\r\n        this.mBundleConfig = {\r\n            enabled: pStaticBundle,\r\n            bundle: null,\r\n            descriptor: null,\r\n            usedResources: {\r\n                parameter: new Set<VertexParameter>(),\r\n                indirectBuffer: new Set<GpuBuffer>(),\r\n                pipelines: new Set<VertexFragmentPipeline>(),\r\n                pipelineData: new Set<PipelineData>(),\r\n            },\r\n            resourceInvalidator: () => {\r\n                // Only invalidate bundle on resource changes.\r\n                this.mBundleConfig.bundle = null;\r\n            }\r\n        };\r\n\r\n        // RenderTargets cant change texture formats, so the bundle descriptor does not need to be rebuild.\r\n        // When textures are resized, the new render descriptor with updated views gets applied automaticly on execute.\r\n    }\r\n\r\n    /**\r\n     * Execute steps in a row.\r\n     * \r\n     * @param pExecutor - Executor context.\r\n     */\r\n    public execute(pExecutionContext: GpuExecutionContext): void {\r\n        // Read render pass descriptor and inject timestamp query when it is setup.\r\n        const lRenderPassDescriptor: GPURenderPassDescriptor = this.mRenderTargets.native;\r\n        if (this.mQueries.timestamp) {\r\n            lRenderPassDescriptor.timestampWrites = this.mQueries.timestamp.query;\r\n        }\r\n\r\n        // Pass descriptor is set, when the pipeline is set.\r\n        const lRenderPassEncoder: GPURenderPassEncoder = pExecutionContext.commandEncoder.beginRenderPass(lRenderPassDescriptor);\r\n\r\n        // Execute cached or execute direct based on static or variable bundles.\r\n        if (this.mBundleConfig.enabled) {\r\n            this.cachedExecute(lRenderPassEncoder);\r\n        } else {\r\n            // Directly execute nothing gets cached.\r\n            this.mExecutionFunction(new RenderPassContext(lRenderPassEncoder, this.mRenderTargets, false));\r\n        }\r\n\r\n        // End render queue.\r\n        lRenderPassEncoder.end();\r\n\r\n        // Resolve query.\r\n        if (this.mQueries.timestamp) {\r\n            pExecutionContext.commandEncoder.resolveQuerySet(this.mQueries.timestamp.query.querySet, 0, 2, this.mQueries.timestamp.buffer.native, 0);\r\n        }\r\n\r\n        // Execute optional resolve targets.\r\n        this.resolveCanvasTargets(pExecutionContext);\r\n    }\r\n\r\n    /**\r\n     * Probe timestamp data from render pass.\r\n     * Resolves into two big ints with start and end time in nanoseconds.\r\n     * \r\n     * @returns Promise that resolves with the latest timestamp data.\r\n     */\r\n    public async probeTimestamp(): Promise<[bigint, bigint]> {\r\n        // Skip when not enabled.\r\n        if (!this.device.capabilities.hasFeature(GpuFeature.TimestampQuery)) {\r\n            return [0n, 0n];\r\n        }\r\n\r\n        // Init timestamp query when not already set.\r\n        if (!this.mQueries.timestamp) {\r\n            // Create timestamp query.\r\n            const lTimestampQuerySet: GPUQuerySet = this.device.gpu.createQuerySet({\r\n                type: 'timestamp',\r\n                count: 2\r\n            });\r\n\r\n            // Create timestamp buffer.\r\n            const lTimestampBuffer: GpuBuffer = new GpuBuffer(this.device, 16);\r\n            lTimestampBuffer.extendUsage(GPUBufferUsage.QUERY_RESOLVE);\r\n            lTimestampBuffer.extendUsage(BufferUsage.CopySource);\r\n\r\n            // Create query.\r\n            this.mQueries.timestamp = {\r\n                query: {\r\n                    querySet: lTimestampQuerySet,\r\n                    beginningOfPassWriteIndex: 0,\r\n                    endOfPassWriteIndex: 1\r\n                },\r\n                buffer: lTimestampBuffer,\r\n                resolver: null\r\n            };\r\n        }\r\n\r\n        // Use existing resolver.\r\n        if (this.mQueries.timestamp.resolver) {\r\n            return this.mQueries.timestamp.resolver;\r\n        }\r\n\r\n        this.mQueries.timestamp.resolver = this.mQueries.timestamp.buffer.read(0, 16).then((pData: ArrayBuffer) => {\r\n            // Reset resolver.\r\n            this.mQueries.timestamp!.resolver = null;\r\n\r\n            // Read and resolve timestamp data.\r\n            const lTimedata: BigUint64Array = new BigUint64Array(pData);\r\n            return [lTimedata[0], lTimedata[1]];\r\n        });\r\n\r\n        return this.mQueries.timestamp.resolver;\r\n    }\r\n\r\n    /**\r\n     * Execute render pass as cached bundle.\r\n     * \r\n     * @param pExecutor - Executor context.\r\n     */\r\n    private cachedExecute(pRenderPassEncoder: GPURenderPassEncoder): void {\r\n        if (!this.mBundleConfig.descriptor) {\r\n            // Generate GPURenderBundleEncoderDescriptor from GPURenderPassDescriptor.\r\n            const lRenderBundleEncoderDescriptor: GPURenderBundleEncoderDescriptor = {\r\n                colorFormats: this.mRenderTargets.colorTargetNames.map<GPUTextureFormat>((pColorTargetName) => {\r\n                    return this.mRenderTargets.colorTarget(pColorTargetName).layout.format as GPUTextureFormat;\r\n                }),\r\n\r\n                // Render target multisample level.\r\n                sampleCount: this.mRenderTargets.multisampled ? 4 : 1,\r\n\r\n                // Enable depth or stencil write.\r\n                depthReadOnly: false,\r\n                stencilReadOnly: false\r\n            };\r\n\r\n            // Optional depth stencil.\r\n            if (this.mRenderTargets.hasDepth || this.mRenderTargets.hasStencil) {\r\n                lRenderBundleEncoderDescriptor.depthStencilFormat = this.mRenderTargets.depthStencilTarget().layout.format as GPUTextureFormat;\r\n            }\r\n\r\n            // Save descriptor.\r\n            this.mBundleConfig.descriptor = lRenderBundleEncoderDescriptor;\r\n        }\r\n\r\n        // Generate new bundle when not already cached or render target got changed.\r\n        if (!this.mBundleConfig.bundle) {\r\n            // Clear old invalidation listener on old bundles.\r\n            for (const lParameter of this.mBundleConfig.usedResources.parameter) {\r\n                lParameter.removeInvalidationListener(this.mBundleConfig.resourceInvalidator);\r\n            }\r\n            for (const lBuffer of this.mBundleConfig.usedResources.indirectBuffer) {\r\n                lBuffer.removeInvalidationListener(this.mBundleConfig.resourceInvalidator);\r\n            }\r\n            for (const lBindgroup of this.mBundleConfig.usedResources.pipelineData) {\r\n                lBindgroup.removeInvalidationListener(this.mBundleConfig.resourceInvalidator);\r\n            }\r\n            for (const lPipeline of this.mBundleConfig.usedResources.pipelines) {\r\n                lPipeline.removeInvalidationListener(this.mBundleConfig.resourceInvalidator);\r\n            }\r\n\r\n            // Clear used resources.\r\n            this.mBundleConfig.usedResources.indirectBuffer.clear();\r\n            this.mBundleConfig.usedResources.pipelineData.clear();\r\n            this.mBundleConfig.usedResources.pipelines.clear();\r\n\r\n            // Create render bundle.\r\n            const lRenderBundleEncoder: GPURenderBundleEncoder = this.device.gpu.createRenderBundleEncoder(this.mBundleConfig.descriptor);\r\n\r\n            // Create context.\r\n            const lRenderPassContext: RenderPassContext = new RenderPassContext(lRenderBundleEncoder, this.mRenderTargets, true);\r\n\r\n            // Fill render queue.\r\n            this.mExecutionFunction(lRenderPassContext);\r\n\r\n            // Save render bundle.\r\n            this.mBundleConfig.bundle = lRenderBundleEncoder.finish();\r\n\r\n            // Save and track used resources.\r\n            for (const lParameter of this.mBundleConfig.usedResources.parameter) {\r\n                lParameter.addInvalidationListener(this.mBundleConfig.resourceInvalidator, VertexParameterInvalidationType.Data);\r\n            }\r\n            for (const lBuffer of lRenderPassContext.usedResources.indirectBuffer) {\r\n                this.mBundleConfig.usedResources.indirectBuffer.add(lBuffer);\r\n                lBuffer.addInvalidationListener(this.mBundleConfig.resourceInvalidator, GpuResourceObjectInvalidationType.ResourceRebuild);\r\n            }\r\n            for (const lBindgroup of lRenderPassContext.usedResources.pipelineData) {\r\n                this.mBundleConfig.usedResources.pipelineData.add(lBindgroup);\r\n                lBindgroup.addInvalidationListener(this.mBundleConfig.resourceInvalidator, PipelineDataInvalidationType.Data);\r\n            }\r\n            for (const lPipeline of lRenderPassContext.usedResources.pipelines) {\r\n                this.mBundleConfig.usedResources.pipelines.add(lPipeline);\r\n                lPipeline.addInvalidationListener(this.mBundleConfig.resourceInvalidator, VertexFragmentPipelineInvalidationType.NativeRebuild);\r\n            }\r\n        }\r\n\r\n        // Add cached render bundle.\r\n        pRenderPassEncoder.executeBundles([this.mBundleConfig.bundle]);\r\n    }\r\n\r\n    /**\r\n     * Resolve gpu textures into canvas textures.\r\n     * \r\n     * @param pExecutionContext - Executor context.\r\n     */\r\n    private resolveCanvasTargets(pExecutionContext: GpuExecutionContext): void {\r\n        // Skip when nothing to be resolved.\r\n        if (this.mRenderTargets.resolveCanvasList.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (this.mRenderTargets.multisampled) {\r\n            // Generate resolve target descriptor with operation that does nothing.\r\n            const lColorTargetList: Array<GPURenderPassColorAttachment> = this.mRenderTargets.resolveCanvasList.map((pResolveTexture) => {\r\n                return {\r\n                    view: pResolveTexture.source.native,\r\n                    resolveTarget: pResolveTexture.canvas.native.createView(),\r\n                    loadOp: 'load',\r\n                    storeOp: 'store'\r\n                };\r\n            });\r\n\r\n            // Begin and end render pass. Render pass does only resolve targets.\r\n            pExecutionContext.commandEncoder.beginRenderPass({\r\n                colorAttachments: lColorTargetList\r\n            }).end();\r\n        } else {\r\n            // Copy targets into canvas.\r\n            for (const lResolveTexture of this.mRenderTargets.resolveCanvasList) {\r\n                // Create External source.\r\n                const lSource: GPUImageCopyTexture = {\r\n                    texture: lResolveTexture.source.texture.native,\r\n                    aspect: 'all',\r\n                    mipLevel: lResolveTexture.source.mipLevelStart,\r\n                };\r\n\r\n                // Generate native texture.\r\n                const lDestination: GPUImageCopyTexture = {\r\n                    texture: lResolveTexture.canvas.native,\r\n                    aspect: 'all',\r\n                    mipLevel: 0,\r\n                };\r\n\r\n                // Clamp copy sizes to lowest.\r\n                const lCopySize: GPUExtent3DStrict = {\r\n                    width: this.mRenderTargets.width,\r\n                    height: this.mRenderTargets.height,\r\n                    depthOrArrayLayers: lResolveTexture.source.arrayLayerStart + 1\r\n                };\r\n\r\n                pExecutionContext.commandEncoder.copyTextureToTexture(lSource, lDestination, lCopySize);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport type RenderPassExecutionFunction = (pContext: RenderPassContext) => void;\r\n\r\ntype RenderPassQuery = {\r\n    timestamp?: {\r\n        query: GPURenderPassTimestampWrites;\r\n        buffer: GpuBuffer;\r\n        resolver: null | Promise<[bigint, bigint]>;\r\n    };\r\n};\r\n\r\ntype RenderBundleConfig = {\r\n    enabled: boolean;\r\n    bundle: GPURenderBundle | null;\r\n    descriptor: GPURenderBundleEncoderDescriptor | null;\r\n    usedResources: {\r\n        parameter: Set<VertexParameter>;\r\n        indirectBuffer: Set<GpuBuffer>;\r\n        pipelines: Set<VertexFragmentPipeline>;\r\n        pipelineData: Set<PipelineData>;\r\n    };\r\n    resourceInvalidator: () => void;\r\n};", "export enum TextureOperation {\r\n    Keep = 'keep',\r\n    Clear = 'clear'\r\n}", "import { TextureDimension } from '../../constant/texture-dimension.enum.ts';\r\nimport { TextureFormat } from '../../constant/texture-format.enum.ts';\r\nimport { TextureViewDimension } from '../../constant/texture-view-dimension.enum.ts';\r\nimport { GpuObjectSetupReferences } from '../../gpu_object/gpu-object.ts';\r\nimport { GpuObjectChildSetup } from '../../gpu_object/gpu-object-child-setup.ts';\r\nimport { CanvasTexture } from '../../texture/canvas-texture.ts';\r\nimport { GpuTexture } from '../../texture/gpu-texture.ts';\r\nimport { GpuTextureView } from '../../texture/gpu-texture-view.ts';\r\nimport { RenderTargetSetupData } from './render-targets-setup.ts';\r\n\r\n/**\r\n * Child setup to add or create textures to render target bundles.\r\n */\r\nexport class RenderTargetTextureSetup extends GpuObjectChildSetup<RenderTargetSetupData, RenderTargetTextureCallback> {\r\n    private readonly mMultisampled: boolean;\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pSetupReference - Setup references.\r\n     * @param pMultisampled - Multisample state.\r\n     * @param pDataCallback - Setup data callback.\r\n     */\r\n    public constructor(pSetupReference: GpuObjectSetupReferences<RenderTargetSetupData>, pMultisampled: boolean, pDataCallback: RenderTargetTextureCallback) {\r\n        super(pSetupReference, pDataCallback);\r\n\r\n        // Set static multisampled state.\r\n        this.mMultisampled = pMultisampled;\r\n    }\r\n\r\n    /**\r\n     * Create new color render target.\r\n     * \r\n     * @param pFormat - Texture format.\r\n     * @param pResolve - Optional resolve target.\r\n     * \r\n     * @returns created texture view.\r\n     */\r\n    public new(pFormat: TextureFormat, pResolve: CanvasTexture | null = null): GpuTextureView {\r\n        // Lock setup to a setup call.\r\n        this.ensureThatInSetup();\r\n\r\n        // Create new texture.\r\n        const lTexture: GpuTexture = new GpuTexture(this.device, {\r\n            format: pFormat,\r\n            dimension: TextureDimension.TwoDimension,\r\n            multisampled: this.mMultisampled\r\n        });\r\n\r\n        // Create view from texture.\r\n        const lTextureView: GpuTextureView = lTexture.useAs(TextureViewDimension.TwoDimension);\r\n\r\n        // Callback texture.\r\n        this.sendData({\r\n            view: lTextureView,\r\n            resolveCanvas: pResolve\r\n        });\r\n\r\n        return lTextureView;\r\n    }\r\n\r\n    /**\r\n     * Use a existing texture.\r\n     * \r\n     * @param pTexture - Existing texture.\r\n     */\r\n    public use(pTextureView: GpuTextureView, pResolve: CanvasTexture | null = null): GpuTextureView {\r\n        // Lock setup to a setup call.\r\n        this.ensureThatInSetup();\r\n\r\n        // Callback texture.\r\n        this.sendData({\r\n            view: pTextureView,\r\n            resolveCanvas: pResolve\r\n        });\r\n\r\n        // Return same data.\r\n        return pTextureView;\r\n    }\r\n}\r\n\r\nexport type RenderTargetSetupTextures = {\r\n    view: GpuTextureView,\r\n    resolveCanvas: CanvasTexture | null;\r\n};\r\n\r\ntype RenderTargetTextureCallback = (pTexture: RenderTargetSetupTextures) => void;", "import { Exception } from '@kartoffelgames/core';\r\nimport { TextureOperation } from '../../constant/texture-operation.enum.ts';\r\nimport { GpuObjectSetupReferences } from '../../gpu_object/gpu-object.ts';\r\nimport { GpuObjectSetup } from '../../gpu_object/gpu-object-setup.ts';\r\nimport { CanvasTexture } from '../../texture/canvas-texture.ts';\r\nimport { GpuTextureView } from '../../texture/gpu-texture-view.ts';\r\nimport { RenderTargetSetupTextures, RenderTargetTextureSetup } from './render-targets-texture-setup.ts';\r\n\r\n/**\r\n * Render target setup.\r\n */\r\nexport class RenderTargetsSetup extends GpuObjectSetup<RenderTargetSetupData> {\r\n    private readonly mMultisampled: boolean;\r\n\r\n    /**\r\n     * Constructor\r\n     * \r\n     * @param pSetupReference -Setup references.\r\n     */\r\n    public constructor(pSetupReference: GpuObjectSetupReferences<RenderTargetSetupData>, pMultisampled: boolean) {\r\n        super(pSetupReference);\r\n\r\n        // Set static multisampled state.\r\n        this.mMultisampled = pMultisampled;\r\n    }\r\n\r\n    /**\r\n     * Add color target.\r\n     * \r\n     * @param pName - Color target name.\r\n     * @param pLocationIndex - Target location index. \r\n     * @param pKeepOnEnd - Keep information after render pass end.\r\n     * @param pClearValue - Clear value on render pass start. Omit to never clear.\r\n     */\r\n    public addColor(pName: string, pLocationIndex: number, pKeepOnEnd: boolean = true, pClearValue?: { r: number; g: number; b: number; a: number; }): RenderTargetTextureSetup {\r\n        // Lock setup to a setup call.\r\n        this.ensureThatInSetup();\r\n\r\n        // Convert render attachment to a location mapping. \r\n        const lTarget: RenderTargetsColorTargetSetupData = {\r\n            name: pName,\r\n            index: pLocationIndex,\r\n            clearValue: pClearValue ?? null,\r\n            storeOperation: (pKeepOnEnd) ? TextureOperation.Keep : TextureOperation.Clear,\r\n            textureView: null,\r\n            resolveCanvas: null\r\n        };\r\n\r\n        // Add to color attachment list.\r\n        this.setupData.colorTargets.push(lTarget);\r\n\r\n        // Return texture setup. Set texture on texture resolve.\r\n        return new RenderTargetTextureSetup(this.setupReferences, this.mMultisampled, (pTexture: RenderTargetSetupTextures) => {\r\n            lTarget.textureView = pTexture.view;\r\n            lTarget.resolveCanvas = pTexture.resolveCanvas;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add depth and stencil target. Actual usage of depth and stencil is the used texture format.\r\n     * \r\n     * @param pDepthKeepOnEnd - Keep information after render pass end.\r\n     * @param pDepthClearValue - Clear value on render pass start. Omit to never clear.\r\n     * @param pStencilKeepOnEnd - Keep information after render pass end.\r\n     * @param pStencilClearValue - Clear value on render pass start. Omit to never clear.\r\n     */\r\n    public addDepthStencil(pDepthKeepOnEnd: boolean | null = null, pDepthClearValue: number | null = null, pStencilKeepOnEnd: boolean | null = null, pStencilClearValue: number | null = null): RenderTargetTextureSetup {\r\n        // Lock setup to a setup call.\r\n        this.ensureThatInSetup();\r\n\r\n        this.setupData.depthStencil = {\r\n            textureView: null\r\n        };\r\n\r\n        // Setup depth when values where set.\r\n        if (pDepthKeepOnEnd !== null || pDepthClearValue !== null) {\r\n            this.setupData.depthStencil.depth = {\r\n                clearValue: pDepthClearValue ?? null,\r\n                storeOperation: (pDepthKeepOnEnd) ? TextureOperation.Keep : TextureOperation.Clear,\r\n            };\r\n        }\r\n\r\n        // Setup stencil when values where set.\r\n        if (pStencilKeepOnEnd !== null || pStencilClearValue !== null) {\r\n            this.setupData.depthStencil.stencil = {\r\n                clearValue: pStencilClearValue ?? null,\r\n                storeOperation: (pStencilKeepOnEnd) ? TextureOperation.Keep : TextureOperation.Clear,\r\n            };\r\n        }\r\n\r\n        // Return texture setup. Set texture on texture resolve.\r\n        return new RenderTargetTextureSetup(this.setupReferences, this.mMultisampled, (pTexture: RenderTargetSetupTextures) => {\r\n            // Restrict used texture type to a frame buffer.\r\n            if (pTexture.resolveCanvas) {\r\n                throw new Exception(`Can't use a canvas texture as depth or stencil texture.`, this);\r\n            }\r\n\r\n            this.setupData.depthStencil!.textureView = pTexture.view;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fill in default data before the setup starts.\r\n     * \r\n     * @param pDataReference - Setup data reference.\r\n     */\r\n    protected override fillDefaultData(pDataReference: RenderTargetSetupData): void {\r\n        pDataReference.colorTargets = new Array<RenderTargetsColorTargetSetupData>();\r\n    }\r\n}\r\n\r\ntype RenderTargetsDepthStencilTextureSetupData = {\r\n    textureView: GpuTextureView | null;\r\n    depth?: {\r\n        clearValue: number | null;\r\n        storeOperation: TextureOperation;\r\n    };\r\n    stencil?: {\r\n        clearValue: number | null;\r\n        storeOperation: TextureOperation;\r\n    };\r\n};\r\n\r\ntype RenderTargetsColorTargetSetupData = {\r\n    name: string;\r\n    index: number;\r\n    clearValue: { r: number; g: number; b: number; a: number; } | null;\r\n    storeOperation: TextureOperation;\r\n    textureView: GpuTextureView | null;\r\n    resolveCanvas: CanvasTexture | null;\r\n};\r\n\r\nexport interface RenderTargetSetupData {\r\n    colorTargets: Array<RenderTargetsColorTargetSetupData>;\r\n    depthStencil?: RenderTargetsDepthStencilTextureSetupData;\r\n}\r\n", "import { Dictionary, Exception } from '@kartoffelgames/core';\r\nimport { GpuLimit } from '../../constant/gpu-limit.enum.ts';\r\nimport { TextureAspect } from '../../constant/texture-aspect.enum.ts';\r\nimport { TextureOperation } from '../../constant/texture-operation.enum.ts';\r\nimport { TextureUsage } from '../../constant/texture-usage.enum.ts';\r\nimport { TextureViewDimension } from '../../constant/texture-view-dimension.enum.ts';\r\nimport { TextureFormatCapability } from '../../device/capabilities/gpu-texture-format-capabilities.ts';\r\nimport { GpuDevice } from '../../device/gpu-device.ts';\r\nimport { GpuObject, GpuObjectSetupReferences } from '../../gpu_object/gpu-object.ts';\r\nimport { GpuResourceObjectInvalidationType } from '../../gpu_object/gpu-resource-object.ts';\r\nimport { IGpuObjectNative } from '../../gpu_object/interface/i-gpu-object-native.ts';\r\nimport { IGpuObjectSetup } from '../../gpu_object/interface/i-gpu-object-setup.ts';\r\nimport { CanvasTexture } from '../../texture/canvas-texture.ts';\r\nimport { GpuTextureView } from '../../texture/gpu-texture-view.ts';\r\nimport { RenderTargetSetupData, RenderTargetsSetup } from './render-targets-setup.ts';\r\n\r\n/**\r\n * Group of textures with the same size and multisample level.\r\n * Bundled for attaching it to render passes.\r\n */\r\nexport class RenderTargets extends GpuObject<GPURenderPassDescriptor, RenderTargetsInvalidationType, RenderTargetsSetup> implements IGpuObjectSetup<RenderTargetsSetup>, IGpuObjectNative<GPURenderPassDescriptor> {\r\n    private readonly mColorTargetNames: Dictionary<string, number>;\r\n    private readonly mColorTargets: Array<RenderTargetsColorTarget>;\r\n    private mDepthStencilTarget: RenderTargetsDepthStencilTexture | null;\r\n    private readonly mMultisampled: boolean;\r\n    private readonly mResolveCanvasList: Array<RenderTargetResolveCanvas>;\r\n    private readonly mSize: TextureSize;\r\n    private readonly mTargetViewUpdateQueue: Set<number>;\r\n\r\n    /**\r\n     * Color attachment names ordered by index.\r\n     */\r\n    public get colorTargetNames(): Array<string> {\r\n        // Ensure setup was called.\r\n        this.ensureSetup();\r\n\r\n        // Create color attachment list in order.\r\n        const lColorAttachmentNameList: Array<string> = new Array<string>();\r\n        for (const lColorAttachment of this.mColorTargets.values()) {\r\n            lColorAttachmentNameList[lColorAttachment.index] = lColorAttachment.name;\r\n        }\r\n\r\n        return lColorAttachmentNameList;\r\n    }\r\n\r\n    /**\r\n     * Stencil attachment texture.\r\n     */\r\n    public get hasDepth(): boolean {\r\n        // Ensure setup was called.\r\n        this.ensureSetup();\r\n\r\n        return !!this.mDepthStencilTarget?.depth;\r\n    }\r\n\r\n    /**\r\n     * Stencil attachment texture.\r\n     */\r\n    public get hasStencil(): boolean {\r\n        // Ensure setup was called.\r\n        this.ensureSetup();\r\n\r\n        return !!this.mDepthStencilTarget?.stencil;\r\n    }\r\n\r\n    /**\r\n     * Render target height.\r\n     */\r\n    public get height(): number {\r\n        return this.mSize.height;\r\n    }\r\n\r\n    /**\r\n     * Render target multisample level.\r\n     */\r\n    public get multisampled(): boolean {\r\n        return this.mMultisampled;\r\n    }\r\n\r\n    /**\r\n     * Native gpu object.\r\n     */\r\n    public override get native(): GPURenderPassDescriptor {\r\n        return super.native;\r\n    }\r\n\r\n    /**\r\n     * List of all resolve canvases.\r\n     */\r\n    public get resolveCanvasList(): Array<RenderTargetResolveCanvas> {\r\n        return this.mResolveCanvasList;\r\n    }\r\n\r\n    /**\r\n     * Render target height.\r\n     */\r\n    public get width(): number {\r\n        return this.mSize.width;\r\n    }\r\n\r\n    /**\r\n     * Constuctor.\r\n     * @param pDevice - Gpu device reference.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pMultisampled: boolean) {\r\n        super(pDevice);\r\n\r\n        // Set statics.\r\n        this.mMultisampled = pMultisampled;\r\n\r\n        // Set default size. \r\n        this.mSize = { width: 1, height: 1 };\r\n\r\n        // Setup initial data.\r\n        this.mDepthStencilTarget = null;\r\n        this.mColorTargets = new Array<RenderTargetsColorTarget>();\r\n        this.mColorTargetNames = new Dictionary<string, number>();\r\n        this.mTargetViewUpdateQueue = new Set<number>();\r\n        this.mResolveCanvasList = new Array<RenderTargetResolveCanvas>();\r\n    }\r\n\r\n    /**\r\n     * Get color target by name.\r\n     * \r\n     * @param pTargetName - Target name.\r\n     *  \r\n     * @returns target texture. \r\n     */\r\n    public colorTarget(pTargetName: string): GpuTextureView {\r\n        // Read index of color target.\r\n        const lColorTargetIndex: number | null = this.mColorTargetNames.get(pTargetName) ?? null;\r\n        if (lColorTargetIndex === null) {\r\n            throw new Exception(`Color target \"${pTargetName}\" does not exists.`, this);\r\n        }\r\n\r\n        return this.mColorTargets[lColorTargetIndex].texture.target;\r\n    }\r\n\r\n    /**\r\n     * Get depth attachment texture.\r\n     */\r\n    public depthStencilTarget(): GpuTextureView {\r\n        // Ensure setup was called.\r\n        this.ensureSetup();\r\n\r\n        // No depth texture setup.\r\n        if (!this.mDepthStencilTarget || !this.mDepthStencilTarget.depth) {\r\n            throw new Exception(`Depth or stencil target does not exists.`, this);\r\n        }\r\n\r\n        return this.mDepthStencilTarget.target;\r\n    }\r\n\r\n    /**\r\n     * Check for color target existence.\r\n     * \r\n     * @param pTargetName - Color target name.\r\n     * \r\n     * @returns true when color target exists. \r\n     */\r\n    public hasColorTarget(pTargetName: string): boolean {\r\n        return this.mColorTargetNames.has(pTargetName);\r\n    }\r\n\r\n    /**\r\n     * Resize all render targets.\r\n     * \r\n     * @param pWidth - New texture width.\r\n     * @param pHeight - New texture height.\r\n     * @param pMultisampleLevel - New texture multisample level.\r\n     *  \r\n     * @returns this. \r\n     */\r\n    public resize(pHeight: number, pWidth: number): this {\r\n        // Set 2D size dimensions\r\n        this.mSize.width = pWidth;\r\n        this.mSize.height = pHeight;\r\n\r\n        // Apply resize for all textures.\r\n        // This trigger RenderTargetsInvalidationType.NativeUpdate for textures set in setTextureInvalidationListener.\r\n        this.applyResize();\r\n\r\n        // Trigger resize invalidation. Does not automaticly trigger rebuild.\r\n        this.invalidate(RenderTargetsInvalidationType.Resize);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Call setup.\r\n     * Exposes internal setup.\r\n     * \r\n     * @param pSetupCallback - Setup callback. \r\n     * \r\n     * @returns this. \r\n     */\r\n    public override setup(pSetupCallback?: ((pSetup: RenderTargetsSetup) => void) | undefined): this {\r\n        return super.setup(pSetupCallback);\r\n    }\r\n\r\n    /**\r\n     * Generate native gpu bind data group.\r\n     */\r\n    protected override generateNative(): GPURenderPassDescriptor {\r\n        // Create color attachments.\r\n        const lColorAttachments: Array<GPURenderPassColorAttachment> = new Array<GPURenderPassColorAttachment>();\r\n        for (const lColorAttachment of this.mColorTargets) {\r\n            // Convert Texture operation to load operations.\r\n            const lStoreOperation: GPUStoreOp = lColorAttachment.storeOperation === TextureOperation.Keep ? 'store' : 'discard';\r\n\r\n            // Create basic color attachment.\r\n            const lPassColorAttachment: GPURenderPassColorAttachment = {\r\n                view: lColorAttachment.texture!.target.native,\r\n                storeOp: lStoreOperation,\r\n                loadOp: 'clear' // Placeholder\r\n            };\r\n\r\n            // Set clear value \r\n            if (lColorAttachment.clearValue !== null) {\r\n                lPassColorAttachment.clearValue = lColorAttachment.clearValue;\r\n                lPassColorAttachment.loadOp = 'clear';\r\n            } else {\r\n                lPassColorAttachment.loadOp = 'load';\r\n            }\r\n\r\n            lColorAttachments.push(lPassColorAttachment satisfies GPURenderPassColorAttachment);\r\n        }\r\n\r\n        // Create descriptor with color attachments.\r\n        const lDescriptor: GPURenderPassDescriptor = {\r\n            colorAttachments: lColorAttachments\r\n        };\r\n\r\n        // Set optional depth attachment.\r\n        if (this.mDepthStencilTarget) {\r\n            const lDepthStencilTexture: GpuTextureView = this.mDepthStencilTarget.target;\r\n\r\n            // Add texture view for depth.\r\n            lDescriptor.depthStencilAttachment = {\r\n                view: lDepthStencilTexture.native,\r\n            };\r\n\r\n            // Add depth values when depth formats are used.\r\n            if (this.mDepthStencilTarget.depth) {\r\n                // Set clear value of depth texture.\r\n                if (this.mDepthStencilTarget.depth.clearValue !== null) {\r\n                    lDescriptor.depthStencilAttachment.depthClearValue = this.mDepthStencilTarget.depth.clearValue;\r\n                    lDescriptor.depthStencilAttachment.depthLoadOp = 'clear';\r\n                } else {\r\n                    lDescriptor.depthStencilAttachment.depthLoadOp = 'load';\r\n                }\r\n\r\n                // Convert Texture operation to load operations.\r\n                lDescriptor.depthStencilAttachment.depthStoreOp = this.mDepthStencilTarget.depth.storeOperation === TextureOperation.Keep ? 'store' : 'discard';\r\n            }\r\n\r\n            // Add stencil values when stencil formats are used.\r\n            if (this.mDepthStencilTarget.stencil) {\r\n                // Set clear value of stencil texture.\r\n                if (this.mDepthStencilTarget.stencil.clearValue !== null) {\r\n                    lDescriptor.depthStencilAttachment.stencilClearValue = this.mDepthStencilTarget.stencil.clearValue;\r\n                    lDescriptor.depthStencilAttachment.stencilLoadOp = 'clear';\r\n                } else {\r\n                    lDescriptor.depthStencilAttachment.stencilLoadOp = 'load';\r\n                }\r\n\r\n                // Convert Texture operation to load operations.\r\n                lDescriptor.depthStencilAttachment.stencilStoreOp = this.mDepthStencilTarget.stencil.storeOperation === TextureOperation.Keep ? 'store' : 'discard';\r\n            }\r\n        }\r\n\r\n        return lDescriptor;\r\n    }\r\n\r\n    /**\r\n     * Setup object based on setup data.\r\n     * \r\n     * @param pReferenceData - Referenced setup data.\r\n     */\r\n    protected override onSetup(pReferenceData: RenderTargetSetupData): void {\r\n        // Enforce gpu color attachment limits.\r\n        const lMaxRenderTargets: number = this.device.capabilities.getLimit(GpuLimit.MaxColorAttachments);\r\n        if (pReferenceData.colorTargets.length > (lMaxRenderTargets - 1)) {\r\n            throw new Exception(`Max color targets count exeeced.`, this);\r\n        }\r\n\r\n        // Setup depth stencil targets.\r\n        if (pReferenceData.depthStencil) {\r\n            // Validate existence of depth stencil texture.\r\n            if (!pReferenceData.depthStencil.textureView) {\r\n                throw new Exception(`Depth/ stencil attachment defined but no texture was assigned.`, this);\r\n            }\r\n\r\n            // Only two dimensional textures.\r\n            if (pReferenceData.depthStencil.textureView.layout.dimension !== TextureViewDimension.TwoDimension) {\r\n                throw new Exception(`Color attachment can only two dimensional.`, this);\r\n            }\r\n\r\n            // Save setup texture.\r\n            this.mDepthStencilTarget = {\r\n                target: pReferenceData.depthStencil.textureView\r\n            };\r\n\r\n            // Add render attachment texture usage to depth stencil texture.\r\n            pReferenceData.depthStencil.textureView.texture.extendUsage(TextureUsage.RenderAttachment);\r\n\r\n            // Passthrough depth stencil texture changes.\r\n            this.setTextureInvalidationListener(pReferenceData.depthStencil.textureView, -1);\r\n\r\n            // Read capability of used depth stencil texture format.\r\n            const lFormatCapability: TextureFormatCapability = this.device.formatValidator.capabilityOf(pReferenceData.depthStencil.textureView.layout.format);\r\n\r\n            // Setup depth texture.\r\n            if (pReferenceData.depthStencil.depth) {\r\n                // Validate if depth texture\r\n                if (!lFormatCapability.aspects.has(TextureAspect.Depth)) {\r\n                    throw new Exception('Used texture for the depth texture attachment must have a depth aspect. ', this);\r\n                }\r\n\r\n                this.mDepthStencilTarget.depth = {\r\n                    clearValue: pReferenceData.depthStencil.depth.clearValue,\r\n                    storeOperation: pReferenceData.depthStencil.depth.storeOperation\r\n                };\r\n            }\r\n\r\n            // Setup stencil texture.\r\n            if (pReferenceData.depthStencil.stencil) {\r\n                // Validate if depth texture\r\n                if (!lFormatCapability.aspects.has(TextureAspect.Stencil)) {\r\n                    throw new Exception('Used texture for the stencil texture attachment must have a depth aspect. ', this);\r\n                }\r\n\r\n                this.mDepthStencilTarget.stencil = {\r\n                    clearValue: pReferenceData.depthStencil.stencil.clearValue,\r\n                    storeOperation: pReferenceData.depthStencil.stencil.storeOperation\r\n                };\r\n            }\r\n        }\r\n\r\n        // Setup color targets.\r\n        for (const lAttachment of pReferenceData.colorTargets.values()) {\r\n            // Validate existence of color texture.\r\n            if (!lAttachment.textureView) {\r\n                throw new Exception(`Color attachment \"${lAttachment.name}\" defined but no texture was assigned.`, this);\r\n            }\r\n\r\n            // No double names.\r\n            if (this.mColorTargetNames.has(lAttachment.name)) {\r\n                throw new Exception(`Color attachment name \"${lAttachment.name}\" can only be defined once.`, this);\r\n            }\r\n\r\n            // No double location indices.\r\n            if (this.mColorTargets[lAttachment.index]) {\r\n                throw new Exception(`Color attachment location index \"${lAttachment.index}\" can only be defined once.`, this);\r\n            }\r\n\r\n            // When a resolve canvas is specified, the texture must have the same texture format.\r\n            if (lAttachment.resolveCanvas && lAttachment.resolveCanvas.format !== lAttachment.textureView.layout.format) {\r\n                throw new Exception(`Color attachment can only be resolved into a canvas with the same texture format.`, this);\r\n            }\r\n\r\n            // Only two dimensional textures.\r\n            if (lAttachment.textureView.layout.dimension !== TextureViewDimension.TwoDimension) {\r\n                throw new Exception(`Color attachment can only two dimensional.`, this);\r\n            }\r\n\r\n            // Only two dimensional textures.\r\n            if (lAttachment.textureView.mipLevelStart !== 0) {\r\n                throw new Exception(`Color attachment can only rendered into mip level 0.`, this);\r\n            }\r\n\r\n            // Passthrough color texture changes. Any change.\r\n            this.setTextureInvalidationListener(lAttachment.textureView, lAttachment.index);\r\n\r\n            // Add render attachment texture usage to color texture.\r\n            lAttachment.textureView.texture.extendUsage(TextureUsage.RenderAttachment);\r\n\r\n            // Save color target name and index mapping.\r\n            this.mColorTargetNames.set(lAttachment.name, lAttachment.index);\r\n\r\n            // Set resolve canvas.\r\n            if (lAttachment.resolveCanvas) {\r\n                // Add copy source to texture usage to be copied into canvas.\r\n                lAttachment.textureView.texture.extendUsage(TextureUsage.CopySource);\r\n\r\n                this.mResolveCanvasList.push({\r\n                    source: lAttachment.textureView,\r\n                    canvas: lAttachment.resolveCanvas\r\n                });\r\n            }\r\n\r\n            // Convert setup into storage data.\r\n            this.mColorTargets[lAttachment.index] = {\r\n                name: lAttachment.name,\r\n                index: lAttachment.index,\r\n                clearValue: lAttachment.clearValue,\r\n                storeOperation: lAttachment.storeOperation,\r\n                texture: {\r\n                    target: lAttachment.textureView,\r\n                    resolveCanvas: lAttachment.resolveCanvas\r\n                }\r\n            };\r\n        }\r\n\r\n        // Validate attachment list.\r\n        if (this.mColorTargetNames.size !== this.mColorTargets.length) {\r\n            throw new Exception(`Color attachment locations must be in order.`, this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * On setup object creation. Create setup object.\r\n     * \r\n     * @param pReferences - Setup references.\r\n     * \r\n     * @returns build setup object. \r\n     */\r\n    protected override onSetupObjectCreate(pReferences: GpuObjectSetupReferences<RenderTargetSetupData>): RenderTargetsSetup {\r\n        return new RenderTargetsSetup(pReferences, this.mMultisampled);\r\n    }\r\n\r\n    /**\r\n     * Try to update views of pass descriptor.\r\n     * \r\n     * @param pNative - Native pass descriptor.\r\n     * @param pReasons - Update reason.\r\n     * \r\n     * @returns true when native was updated.\r\n     */\r\n    protected override updateNative(pNative: GPURenderPassDescriptor): boolean {\r\n        // Update depth stencil view. -1 Marks depth stencil texture updates. \r\n        if (this.mTargetViewUpdateQueue.has(-1) && pNative.depthStencilAttachment) {\r\n            pNative.depthStencilAttachment.view = this.mDepthStencilTarget!.target.native;\r\n\r\n            // Remove depth stencil from update queue.\r\n            this.mTargetViewUpdateQueue.delete(-1);\r\n        }\r\n\r\n        // Update color attachments.\r\n        for (const lTargetIndex of this.mTargetViewUpdateQueue) {\r\n            // Read current attachment.\r\n            const lCurrentAttachment: GPURenderPassColorAttachment = (<Array<GPURenderPassColorAttachment>>pNative.colorAttachments)[lTargetIndex];\r\n\r\n            // Read setup attachments.\r\n            const lColorAttachment = this.mColorTargets[lTargetIndex];\r\n\r\n            // Update view.\r\n            lCurrentAttachment.view = lColorAttachment.texture.target.native;\r\n        }\r\n\r\n        // Reset updateable views.\r\n        this.mTargetViewUpdateQueue.clear();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Resize all textures.\r\n     */\r\n    private applyResize(): void {\r\n        // Update buffer texture sizes.\r\n        for (const lAttachment of this.mColorTargets) {\r\n            lAttachment.texture.target.texture.height = this.mSize.height;\r\n            lAttachment.texture.target.texture.width = this.mSize.width;\r\n\r\n            if (lAttachment.texture.resolveCanvas) {\r\n                lAttachment.texture.resolveCanvas.height = this.mSize.height;\r\n                lAttachment.texture.resolveCanvas.width = this.mSize.width;\r\n            }\r\n        }\r\n\r\n        // Update target texture sizes.\r\n        if (this.mDepthStencilTarget) {\r\n            this.mDepthStencilTarget.target.texture.height = this.mSize.height;\r\n            this.mDepthStencilTarget.target.texture.width = this.mSize.width;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add all needed texture invalidation listener for passthrow and descriptor invalidation. \r\n     * \r\n     * @param pTexture - Texture. \r\n     */\r\n    private setTextureInvalidationListener(pTexture: GpuTextureView, pTextureIndex: number): void {\r\n        // Update descriptor only on view changes.\r\n        pTexture.addInvalidationListener(() => {\r\n            // Invalidate.\r\n            this.invalidate(RenderTargetsInvalidationType.NativeUpdate);\r\n\r\n            // Set texture as updateable.\r\n            this.mTargetViewUpdateQueue.add(pTextureIndex);\r\n        }, GpuResourceObjectInvalidationType.ResourceRebuild);\r\n    }\r\n}\r\n\r\ntype TextureSize = {\r\n    width: number;\r\n    height: number;\r\n};\r\n\r\nexport type RenderTargetsDepthStencilTexture = {\r\n    target: GpuTextureView;\r\n    depth?: {\r\n        clearValue: number | null;\r\n        storeOperation: TextureOperation;\r\n    };\r\n    stencil?: {\r\n        clearValue: number | null;\r\n        storeOperation: TextureOperation;\r\n    };\r\n};\r\n\r\ntype RenderTargetsColorTexture = {\r\n    resolveCanvas: CanvasTexture | null;\r\n    target: GpuTextureView;\r\n};\r\n\r\nexport type RenderTargetResolveCanvas = {\r\n    canvas: CanvasTexture;\r\n    source: GpuTextureView;\r\n};\r\n\r\nexport type RenderTargetsColorTarget = {\r\n    name: string;\r\n    index: number;\r\n    clearValue: { r: number; g: number; b: number; a: number; } | null;\r\n    storeOperation: TextureOperation;\r\n    texture: RenderTargetsColorTexture;\r\n};\r\n\r\nexport enum RenderTargetsInvalidationType {\r\n    NativeUpdate = 'NativeUpdate',\r\n    Resize = 'Resize'\r\n}", "import { Dictionary, Exception } from '@kartoffelgames/core';\r\nimport { GpuLimit } from '../constant/gpu-limit.enum.ts';\r\nimport { GpuDevice } from '../device/gpu-device.ts';\r\nimport { GpuObject } from '../gpu_object/gpu-object.ts';\r\nimport { IGpuObjectNative } from '../gpu_object/interface/i-gpu-object-native.ts';\r\nimport { BindGroupLayout } from './bind_group_layout/bind-group-layout.ts';\r\nimport { PipelineData } from './pipeline_data/pipeline-data.ts';\r\nimport { PipelineDataSetup } from './pipeline_data/pipeline-data-setup.ts';\r\n\r\n/**\r\n * Gpu pipeline layout.\r\n */\r\nexport class PipelineLayout extends GpuObject<GPUPipelineLayout> implements IGpuObjectNative<GPUPipelineLayout> {\r\n    private readonly mBindGroupNames: Dictionary<string, number>;\r\n    private readonly mBindGroups: Dictionary<number, BindGroupLayout>;\r\n\r\n    /**\r\n     * Bind group names.\r\n     */\r\n    public get groups(): Array<string> {\r\n        return [...this.mBindGroupNames.keys()];\r\n    }\r\n\r\n    /**\r\n     * Native gpu object.\r\n     */\r\n    public override get native(): GPUPipelineLayout {\r\n        return super.native;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pDevice - Gpu Device reference.\r\n     * @param pInitialGroups - Initial groups.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pInitialGroups: Dictionary<number, BindGroupLayout>) {\r\n        super(pDevice);\r\n\r\n        // Init storages.\r\n        this.mBindGroupNames = new Dictionary<string, number>();\r\n        this.mBindGroups = new Dictionary<number, BindGroupLayout>();\r\n\r\n        // Pipeline global resource counter.\r\n        const lMaxCounter = {\r\n            dynamicStorageBuffers: 0,\r\n            dynamicUniformBuffers: 0,\r\n            sampler: 0,\r\n            sampledTextures: 0,\r\n            storageTextures: 0,\r\n            uniformBuffers: 0,\r\n            storageBuffers: 0\r\n        };\r\n\r\n        // Set initial work groups.\r\n        const lMaxBindGroupCount: number = this.device.capabilities.getLimit(GpuLimit.MaxBindGroups);\r\n        for (const [lGroupIndex, lGroup] of pInitialGroups) {\r\n            if (lGroupIndex > (lMaxBindGroupCount - 1)) {\r\n                throw new Exception(`Bind group limit exceeded with index: ${lGroupIndex} and group \"${lGroup.name}\"`, this);\r\n            }\r\n\r\n            // Restrict dublicate names.\r\n            if (this.mBindGroupNames.has(lGroup.name)) {\r\n                throw new Exception(`Can add group name \"${lGroup.name}\" only once.`, this);\r\n            }\r\n\r\n            // Restrict dublicate locations.\r\n            if (this.mBindGroups.has(lGroupIndex)) {\r\n                throw new Exception(`Can add group location index \"${lGroupIndex}\" only once.`, this);\r\n            }\r\n\r\n            // Set name to index mapping.\r\n            this.mBindGroupNames.set(lGroup.name, lGroupIndex);\r\n\r\n            // Set bind groups to bind group.\r\n            this.mBindGroups.set(lGroupIndex, lGroup);\r\n\r\n            // Count counters.\r\n            lMaxCounter.dynamicStorageBuffers += lGroup.resourceCounter.storageDynamicOffset;\r\n            lMaxCounter.dynamicUniformBuffers += lGroup.resourceCounter.uniformDynamicOffset;\r\n            lMaxCounter.sampler += lGroup.resourceCounter.sampler;\r\n            lMaxCounter.sampledTextures += lGroup.resourceCounter.sampledTextures;\r\n            lMaxCounter.storageTextures += lGroup.resourceCounter.storageTextures;\r\n            lMaxCounter.uniformBuffers += lGroup.resourceCounter.uniformBuffers;\r\n            lMaxCounter.storageBuffers += lGroup.resourceCounter.storageBuffers;\r\n        }\r\n\r\n        // Max dynamic storage buffers.\r\n        if (lMaxCounter.dynamicStorageBuffers > this.device.capabilities.getLimit(GpuLimit.MaxDynamicStorageBuffersPerPipelineLayout)) {\r\n            throw new Exception(`Max dynamic storage buffer reached pipeline. Max allowed \"${this.device.capabilities.getLimit(GpuLimit.MaxDynamicStorageBuffersPerPipelineLayout)}\" has \"${lMaxCounter.dynamicStorageBuffers}\"`, this);\r\n        }\r\n\r\n        // Max dynamic unform buffers.\r\n        if (lMaxCounter.dynamicUniformBuffers > this.device.capabilities.getLimit(GpuLimit.MaxDynamicUniformBuffersPerPipelineLayout)) {\r\n            throw new Exception(`Max dynamic uniform buffer reached pipeline. Max allowed \"${this.device.capabilities.getLimit(GpuLimit.MaxDynamicUniformBuffersPerPipelineLayout)}\" has \"${lMaxCounter.dynamicUniformBuffers}\"`, this);\r\n        }\r\n\r\n        // Max sampler. Ignore shader stage limitation. Just apply it to the complete pipeline.\r\n        if (lMaxCounter.sampler > this.device.capabilities.getLimit(GpuLimit.MaxSamplersPerShaderStage)) {\r\n            throw new Exception(`Max sampler reached pipeline. Max allowed \"${this.device.capabilities.getLimit(GpuLimit.MaxSamplersPerShaderStage)}\" has \"${lMaxCounter.sampler}\"`, this);\r\n        }\r\n\r\n        // Max sampled textures. Ignore shader stage limitation. Just apply it to the complete pipeline.\r\n        if (lMaxCounter.sampledTextures > this.device.capabilities.getLimit(GpuLimit.MaxSampledTexturesPerShaderStage)) {\r\n            throw new Exception(`Max sampled textures reached pipeline. Max allowed \"${this.device.capabilities.getLimit(GpuLimit.MaxSampledTexturesPerShaderStage)}\" has \"${lMaxCounter.sampledTextures}\"`, this);\r\n        }\r\n\r\n        // Max storage textures. Ignore shader stage limitation. Just apply it to the complete pipeline.\r\n        if (lMaxCounter.storageTextures > this.device.capabilities.getLimit(GpuLimit.MaxStorageTexturesPerShaderStage)) {\r\n            throw new Exception(`Max storage textures reached pipeline. Max allowed \"${this.device.capabilities.getLimit(GpuLimit.MaxStorageTexturesPerShaderStage)}\" has \"${lMaxCounter.storageTextures}\"`, this);\r\n        }\r\n\r\n        // Max storage buffers. Ignore shader stage limitation. Just apply it to the complete pipeline.\r\n        if (lMaxCounter.storageBuffers > this.device.capabilities.getLimit(GpuLimit.MaxStorageBuffersPerShaderStage)) {\r\n            throw new Exception(`Max storage buffers reached pipeline. Max allowed \"${this.device.capabilities.getLimit(GpuLimit.MaxStorageBuffersPerShaderStage)}\" has \"${lMaxCounter.storageBuffers}\"`, this);\r\n        }\r\n\r\n        // Max uniform buffers. Ignore shader stage limitation. Just apply it to the complete pipeline.\r\n        if (lMaxCounter.uniformBuffers > this.device.capabilities.getLimit(GpuLimit.MaxUniformBuffersPerShaderStage)) {\r\n            throw new Exception(`Max uniform buffers reached pipeline. Max allowed \"${this.device.capabilities.getLimit(GpuLimit.MaxUniformBuffersPerShaderStage)}\" has \"${lMaxCounter.uniformBuffers}\"`, this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get bind group layout by name.\r\n     * \r\n     * @param pGroupName - Group name.\r\n     */\r\n    public getGroupLayout(pGroupName: string): BindGroupLayout {\r\n        const lGroupIndex: number | undefined = this.mBindGroupNames.get(pGroupName);\r\n\r\n        // Throw on unaccessable group.\r\n        if (typeof lGroupIndex === 'undefined') {\r\n            throw new Exception(`Bind group layout (${pGroupName}) does not exists.`, this);\r\n        }\r\n\r\n        // Bind group should allways exist.\r\n        return this.mBindGroups.get(lGroupIndex)!;\r\n    }\r\n\r\n    /**\r\n     * Get group binding index by name.\r\n     * \r\n     * @param pGroupName - Group name.\r\n     * \r\n     * @returns group binding index. \r\n     */\r\n    public groupIndex(pGroupName: string): number {\r\n        const lBindGroupIndex: number | undefined = this.mBindGroupNames.get(pGroupName);\r\n        if (typeof lBindGroupIndex === 'undefined') {\r\n            throw new Exception(`Pipeline does not contain a group with name \"${pGroupName}\".`, this);\r\n        }\r\n\r\n        return lBindGroupIndex;\r\n    }\r\n\r\n    /**\r\n     * Create pipeline data.\r\n     * \r\n     * @param pBindData - Any bind group of pipeline layout.\r\n     * \r\n     * @returns validated pipeline data. \r\n     */\r\n    public withData(pSetupCallback: (pSetup: PipelineDataSetup) => void): PipelineData {\r\n        return new PipelineData(this.device, this).setup(pSetupCallback);\r\n    }\r\n\r\n    /**\r\n     * Generate native gpu pipeline data layout.\r\n     */\r\n    protected override generateNative(): GPUPipelineLayout {\r\n        // Generate pipeline layout from bind group layouts.\r\n        const lPipelineLayoutDescriptor = { bindGroupLayouts: new Array<GPUBindGroupLayout>() };\r\n        for (const [lGroupIndex, lBindGroupLayout] of this.mBindGroups) {\r\n            lPipelineLayoutDescriptor.bindGroupLayouts[lGroupIndex] = lBindGroupLayout.native;\r\n        }\r\n\r\n        // Validate continunity.\r\n        if (this.mBindGroups.size !== lPipelineLayoutDescriptor.bindGroupLayouts.length) {\r\n            throw new Exception(`Bind group gap detected. Group not set.`, this);\r\n        }\r\n\r\n        // Generate pipeline layout from descriptor.\r\n        return this.device.gpu.createPipelineLayout(lPipelineLayoutDescriptor);\r\n    }\r\n}", "import { Exception } from '@kartoffelgames/core';\r\nimport { ArrayBufferMemoryLayout } from '../../buffer/memory_layout/array-buffer-memory-layout.ts';\r\nimport { BaseBufferMemoryLayout } from '../../buffer/memory_layout/base-buffer-memory-layout.ts';\r\nimport { PrimitiveBufferMemoryLayout } from '../../buffer/memory_layout/primitive-buffer-memory-layout.ts';\r\nimport { StructBufferMemoryLayout } from '../../buffer/memory_layout/struct-buffer-memory-layout.ts';\r\nimport { StructBufferMemoryLayoutSetup } from '../../buffer/memory_layout/struct-buffer-memory-layout-setup.ts';\r\nimport { BufferAlignmentType } from '../../constant/buffer-alignment-type.enum.ts';\r\nimport { BufferItemFormat } from '../../constant/buffer-item-format.enum.ts';\r\nimport { BufferItemMultiplier } from '../../constant/buffer-item-multiplier.enum.ts';\r\nimport { GpuObjectSetupReferences } from '../../gpu_object/gpu-object.ts';\r\nimport { GpuObjectChildSetup } from '../../gpu_object/gpu-object-child-setup.ts';\r\nimport { BindGroupLayoutSetupData } from './bind-group-layout-setup.ts';\r\n\r\n/**\r\n * Buffer memory layout setup object for bind group layouts.\r\n */\r\nexport class BindGroupLayoutBufferMemoryLayoutSetup extends GpuObjectChildSetup<BindGroupLayoutSetupData, MemoryLayoutCallback> {\r\n    private readonly mAlignmentType: BufferAlignmentType;\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pSetupReference - Setup references.\r\n     * @param pAlignmentType - Buffers alignment type.\r\n     * @param pDataCallback - Data callback.\r\n     */\r\n    public constructor(pSetupReference: GpuObjectSetupReferences<BindGroupLayoutSetupData>, pAlignmentType: BufferAlignmentType, pDataCallback: MemoryLayoutCallback) {\r\n        super(pSetupReference, pDataCallback);\r\n\r\n        this.mAlignmentType = pAlignmentType;\r\n    }\r\n\r\n    /**\r\n     * Inner type as array.\r\n     * \r\n     * @param pSize - Optional. Set size fixed.\r\n     *  \r\n     * @returns array setup. \r\n     */\r\n    public withArray(pSize: number = -1): BindGroupLayoutBufferMemoryLayoutSetup {\r\n        return new BindGroupLayoutBufferMemoryLayoutSetup(this.setupReferences, this.mAlignmentType, (pMemoryLayout: BaseBufferMemoryLayout) => {\r\n            const lLayout: ArrayBufferMemoryLayout = new ArrayBufferMemoryLayout(this.device, {\r\n                arraySize: pSize,\r\n                innerType: pMemoryLayout\r\n            });\r\n\r\n            this.sendData(lLayout);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Inner type as primitive.\r\n     * \r\n     * @param pPrimitiveFormat - Primitive format.\r\n     * @param pPrimitiveMultiplier - Value multiplier.\r\n     */\r\n    public withPrimitive(pPrimitiveFormat: BufferItemFormat, pPrimitiveMultiplier: BufferItemMultiplier): void {\r\n        // Validate for 32bit formats.\r\n        if (pPrimitiveFormat !== BufferItemFormat.Float32 && pPrimitiveFormat !== BufferItemFormat.Uint32 && pPrimitiveFormat !== BufferItemFormat.Sint32) {\r\n            throw new Exception('Uniform layout must be a 32bit format.', this);\r\n        }\r\n\r\n        const lLayout: PrimitiveBufferMemoryLayout = new PrimitiveBufferMemoryLayout(this.device, {\r\n            alignmentType: this.mAlignmentType,\r\n            primitiveFormat: pPrimitiveFormat,\r\n            primitiveMultiplier: pPrimitiveMultiplier,\r\n        });\r\n\r\n        // Send created data.\r\n        this.sendData(lLayout);\r\n    }\r\n\r\n    /**\r\n     * Inner type as struct\r\n     * \r\n     * @param pSetupCall - Struct setup call.\r\n     */\r\n    public withStruct(pSetupCall: (pSetup: StructBufferMemoryLayoutSetup) => void): void {\r\n        // Create and setup struct buffer memory layout.\r\n        const lLayout: StructBufferMemoryLayout = new StructBufferMemoryLayout(this.device, this.mAlignmentType);\r\n        lLayout.setup(pSetupCall);\r\n\r\n        // Send created data.\r\n        this.sendData(lLayout);\r\n    }\r\n}\r\n\r\ntype MemoryLayoutCallback = (pMemoryLayout: BaseBufferMemoryLayout) => void;", "import { BaseMemoryLayout } from '../../base-memory-layout.ts';\r\nimport { BaseBufferMemoryLayout } from '../../buffer/memory_layout/base-buffer-memory-layout.ts';\r\nimport { BufferAlignmentType } from '../../constant/buffer-alignment-type.enum.ts';\r\nimport { SamplerType } from '../../constant/sampler-type.enum.ts';\r\nimport { TextureFormat } from '../../constant/texture-format.enum.ts';\r\nimport { TextureViewDimension } from '../../constant/texture-view-dimension.enum.ts';\r\nimport { GpuObjectSetupReferences } from '../../gpu_object/gpu-object.ts';\r\nimport { GpuObjectChildSetup } from '../../gpu_object/gpu-object-child-setup.ts';\r\nimport { SamplerMemoryLayout } from '../../texture/memory_layout/sampler-memory-layout.ts';\r\nimport { TextureViewMemoryLayout } from '../../texture/memory_layout/texture-view-memory-layout.ts';\r\nimport { BindGroupLayoutBufferMemoryLayoutSetup } from './bind-group-layout-buffer-memory-layout-setup.ts';\r\nimport { BindGroupLayoutSetupData } from './bind-group-layout-setup.ts';\r\n\r\n/**\r\n * Child setup object to set types to single bindings.\r\n */\r\nexport class BindGroupLayoutMemoryLayoutSetup extends GpuObjectChildSetup<BindGroupLayoutSetupData, MemoryLayoutCallback> {\r\n    private readonly mAlignmentType: BufferAlignmentType;\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pSetupReference - Setup references.\r\n     * @param pAlignmentType - Buffers alignment type.\r\n     * @param pDataCallback - Data callback.\r\n     */\r\n    public constructor(pSetupReference: GpuObjectSetupReferences<BindGroupLayoutSetupData>, pAlignmentType: BufferAlignmentType, pDataCallback: MemoryLayoutCallback) {\r\n        super(pSetupReference, pDataCallback);\r\n\r\n        this.mAlignmentType = pAlignmentType;\r\n    }\r\n\r\n    /**\r\n     * Memory layout as buffer with optional dynamic offsets.\r\n     * Dynamic offsets are only available for fixed size layouts.\r\n     * \r\n     * @param pDynamicOffsets - Number of available dynamic offsets.\r\n     * \r\n     * @returns buffer setup.\r\n     */\r\n    public asBuffer(pHasDynamicOffset: boolean = false): BindGroupLayoutBufferMemoryLayoutSetup {\r\n        return new BindGroupLayoutBufferMemoryLayoutSetup(this.setupReferences, this.mAlignmentType, (pMemoryLayout: BaseBufferMemoryLayout) => {\r\n            this.sendData({\r\n                layout: pMemoryLayout,\r\n                hasDynamicOffset: pHasDynamicOffset\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Memory layout as sampler.\r\n     * \r\n     * @param pSamplerType - Sampler type.\r\n     */\r\n    public asSampler(pSamplerType: SamplerType): void {\r\n        const lLayout: SamplerMemoryLayout = new SamplerMemoryLayout(this.device, pSamplerType);\r\n\r\n        // Send created data.\r\n        this.sendData({\r\n            layout: lLayout,\r\n            hasDynamicOffset: false\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Memory layout as texture.\r\n     * \r\n     * @param pTextureDimension - Texture dimension.\r\n     * @param pTextureFormat - Texture format.\r\n     * @param pTextureBindType - Texture binding.\r\n     */\r\n    public asTexture(pTextureDimension: TextureViewDimension, pTextureFormat: TextureFormat): void {\r\n        const lLayout: TextureViewMemoryLayout = new TextureViewMemoryLayout(this.device, {\r\n            dimension: pTextureDimension,\r\n            format: pTextureFormat,\r\n            multisampled: false\r\n        });\r\n\r\n        // Send created data.\r\n        this.sendData({\r\n            layout: lLayout,\r\n            hasDynamicOffset: false\r\n        });\r\n    }\r\n}\r\n\r\nexport type BindGroupBindingMemoryLayoutSetuData = {\r\n    layout: BaseMemoryLayout;\r\n    hasDynamicOffset: boolean;\r\n};\r\ntype MemoryLayoutCallback = (pMemoryLayout: BindGroupBindingMemoryLayoutSetuData) => void;", "import { BaseMemoryLayout } from '../../base-memory-layout.ts';\r\nimport { BufferAlignmentType } from '../../constant/buffer-alignment-type.enum.ts';\r\nimport { ComputeStage } from '../../constant/compute-stage.enum.ts';\r\nimport { StorageBindingType } from '../../constant/storage-binding-type.enum.ts';\r\nimport { GpuObjectSetup } from '../../gpu_object/gpu-object-setup.ts';\r\nimport { BindGroupBindingMemoryLayoutSetuData, BindGroupLayoutMemoryLayoutSetup } from './bind-group-layout-memory-layout-setup.ts';\r\n\r\n/**\r\n * setup object to add bindings to bind group layouts.\r\n */\r\nexport class BindGroupLayoutSetup extends GpuObjectSetup<BindGroupLayoutSetupData> {\r\n    /**\r\n     * Add binding to group.\r\n     * \r\n     * @param pName - Binding name.\r\n     * @param pIndex - - Binding index.\r\n     * @param pUsage - Buffer usage.\r\n     * @param pVisibility - Visibility.\r\n     * @param pAccessMode - Access mode.\r\n     */\r\n    public binding(pIndex: number, pName: string, pVisibility: ComputeStage, pStorageBinding?: StorageBindingType): BindGroupLayoutMemoryLayoutSetup {\r\n        // Lock setup to a setup call.\r\n        this.ensureThatInSetup();\r\n\r\n        // Create empty bind layout.\r\n        const lBind: BindLayoutSetupData = {\r\n            name: pName,\r\n            index: pIndex,\r\n            visibility: pVisibility,\r\n            layout: null,\r\n            storageType: pStorageBinding ?? StorageBindingType.None,\r\n            hasDynamicOffset: false,\r\n        };\r\n\r\n        // Set layout.\r\n        this.setupData.bindings.push(lBind);\r\n\r\n        // Aligment type of memory layout. When it is not a storage buffer then is is a uniform buffer.\r\n        const lAlignmentType: BufferAlignmentType = (lBind.storageType === StorageBindingType.None) ? BufferAlignmentType.Uniform : BufferAlignmentType.Storage;\r\n\r\n        // Create layout memory layout.\r\n        return new BindGroupLayoutMemoryLayoutSetup(this.setupReferences, lAlignmentType, (pMemoryLayout: BindGroupBindingMemoryLayoutSetuData) => {\r\n            lBind.layout = pMemoryLayout.layout;\r\n            lBind.hasDynamicOffset = pMemoryLayout.hasDynamicOffset;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fill in default data before the setup starts.\r\n     * \r\n     * @param pDataReference - Setup data reference.\r\n     */\r\n    protected override fillDefaultData(pDataReference: BindGroupLayoutSetupData): void {\r\n        pDataReference.bindings = new Array<BindLayoutSetupData>();\r\n    }\r\n}\r\n\r\ntype BindLayoutSetupData = {\r\n    name: string;\r\n    index: number;\r\n    layout: BaseMemoryLayout | null;\r\n    visibility: ComputeStage;\r\n    storageType: StorageBindingType;\r\n    hasDynamicOffset: boolean;\r\n};\r\n\r\nexport type BindGroupLayoutSetupData = {\r\n    bindings: Array<BindLayoutSetupData>;\r\n};", "import { Dictionary, Exception } from '@kartoffelgames/core';\r\nimport { BaseMemoryLayout } from '../../base-memory-layout.ts';\r\nimport { BaseBufferMemoryLayout } from '../../buffer/memory_layout/base-buffer-memory-layout.ts';\r\nimport { ComputeStage } from '../../constant/compute-stage.enum.ts';\r\nimport { GpuLimit } from '../../constant/gpu-limit.enum.ts';\r\nimport { StorageBindingType } from '../../constant/storage-binding-type.enum.ts';\r\nimport { TextureFormatCapability } from '../../device/capabilities/gpu-texture-format-capabilities.ts';\r\nimport { GpuDevice } from '../../device/gpu-device.ts';\r\nimport { GpuObject, GpuObjectSetupReferences } from '../../gpu_object/gpu-object.ts';\r\nimport { IGpuObjectNative } from '../../gpu_object/interface/i-gpu-object-native.ts';\r\nimport { IGpuObjectSetup } from '../../gpu_object/interface/i-gpu-object-setup.ts';\r\nimport { SamplerMemoryLayout } from '../../texture/memory_layout/sampler-memory-layout.ts';\r\nimport { TextureViewMemoryLayout } from '../../texture/memory_layout/texture-view-memory-layout.ts';\r\nimport { BindGroup } from '../bind_group/bind-group.ts';\r\nimport { BindGroupLayoutSetup, BindGroupLayoutSetupData } from './bind-group-layout-setup.ts';\r\n\r\n/**\r\n * Bind group layout. Fixed at creation. \r\n */\r\nexport class BindGroupLayout extends GpuObject<GPUBindGroupLayout, '', BindGroupLayoutSetup> implements IGpuObjectNative<GPUBindGroupLayout>, IGpuObjectSetup<BindGroupLayoutSetup> {\r\n    private readonly mBindings: Dictionary<string, BindLayout>;\r\n    private mHasDynamicOffset: boolean;\r\n    private readonly mName: string;\r\n    private readonly mOrderedBindingNames: Array<string>;\r\n    private readonly mResourceCounter: BindGroupLayoutResourceCounter;\r\n\r\n    /**\r\n     * Bindgroup has a dynamic offset binding.\r\n     */\r\n    public get hasDynamicOffset(): boolean {\r\n        return this.mHasDynamicOffset;\r\n    }\r\n\r\n    /**\r\n     * Bind group name.\r\n     */\r\n    public get name(): string {\r\n        return this.mName;\r\n    }\r\n\r\n    /**\r\n     * Native gpu object.\r\n     */\r\n    public override get native(): GPUBindGroupLayout {\r\n        return super.native;\r\n    }\r\n\r\n    /**\r\n     * Get binding names ordered by index.\r\n     */\r\n    public get orderedBindingNames(): Array<string> {\r\n        // Ensure setup.\r\n        this.ensureSetup();\r\n\r\n        return this.mOrderedBindingNames;\r\n    }\r\n\r\n    /**\r\n     * Resource counter.\r\n     */\r\n    public get resourceCounter(): Readonly<BindGroupLayoutResourceCounter> {\r\n        return this.mResourceCounter;\r\n    }\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pDevice - Gpu Device reference.\r\n     * @param pName - Name of binding group.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pName: string) {\r\n        super(pDevice);\r\n\r\n        // Set binding group name.\r\n        this.mName = pName;\r\n        this.mHasDynamicOffset = false;\r\n        this.mResourceCounter = {\r\n            storageDynamicOffset: 0,\r\n            uniformDynamicOffset: 0,\r\n            sampler: 0,\r\n            sampledTextures: 0,\r\n            storageTextures: 0,\r\n            storageBuffers: 0,\r\n            uniformBuffers: 0\r\n        };\r\n\r\n        // Init bindings.\r\n        this.mBindings = new Dictionary<string, BindLayout>();\r\n        this.mOrderedBindingNames = new Array<string>();\r\n    }\r\n\r\n    /**\r\n     * Create new bind group from layout.\r\n     * \r\n     * @returns new bind group.\r\n     */\r\n    public create(): BindGroup {\r\n        // Ensure setup.\r\n        this.ensureSetup();\r\n\r\n        return new BindGroup(this.device, this);\r\n    }\r\n\r\n    /**\r\n     * Get full bind information.\r\n     * @param pName - Bind name.\r\n     */\r\n    public getBind(pName: string): Readonly<BindLayout> {\r\n        // Ensure setup.\r\n        this.ensureSetup();\r\n\r\n        if (!this.mBindings.has(pName)) {\r\n            throw new Exception(`Bind ${pName} does not exist.`, this);\r\n        }\r\n\r\n        return this.mBindings.get(pName)!;\r\n    }\r\n\r\n    /**\r\n     * Call setup.\r\n     * \r\n     * @param pSetupCallback - Setup callback.\r\n     *\r\n     * @returns \u2014 this. \r\n     */\r\n    public override setup(pSetupCallback?: ((pSetup: BindGroupLayoutSetup) => void) | undefined): this {\r\n        return super.setup(pSetupCallback);\r\n    }\r\n\r\n    /**\r\n     * Generate native bind data group layout object.\r\n     */\r\n    protected override generateNative(): GPUBindGroupLayout {\r\n        const lEntryList: Array<GPUBindGroupLayoutEntry> = new Array<GPUBindGroupLayoutEntry>();\r\n\r\n        // Generate layout entry for each binding.\r\n        for (const lEntry of this.mBindings.values()) {\r\n            // Generate default properties.\r\n            const lLayoutEntry: GPUBindGroupLayoutEntry = {\r\n                visibility: lEntry.visibility,\r\n                binding: lEntry.index\r\n            };\r\n\r\n            // Different binding for different\r\n            switch (true) {\r\n                // Buffer layouts.\r\n                case lEntry.layout instanceof BaseBufferMemoryLayout: {\r\n                    // Convert bind type info bufer binding type.\r\n                    const lBufferBindingType: GPUBufferBindingType = (() => {\r\n                        switch (lEntry.storageType) {\r\n                            case StorageBindingType.None: {\r\n                                return 'uniform';\r\n                            }\r\n                            case StorageBindingType.Read: {\r\n                                return 'read-only-storage';\r\n                            }\r\n                            default: {\r\n                                return 'storage';\r\n                            }\r\n                        }\r\n                    })();\r\n\r\n                    // Create buffer layout with all optional values.\r\n                    lLayoutEntry.buffer = {\r\n                        type: lBufferBindingType,\r\n                        minBindingSize: 0,\r\n                        hasDynamicOffset: lEntry.hasDynamicOffset\r\n                    } satisfies Required<GPUBufferBindingLayout>;\r\n\r\n                    break;\r\n                }\r\n\r\n                // Sampler layouts.\r\n                case lEntry.layout instanceof SamplerMemoryLayout: {\r\n                    // Create sampler layout with all optional values.\r\n                    lLayoutEntry.sampler = {\r\n                        type: lEntry.layout.samplerType\r\n                    } satisfies Required<GPUSamplerBindingLayout>;\r\n\r\n                    break;\r\n                }\r\n\r\n                // Texture layouts.\r\n                case lEntry.layout instanceof TextureViewMemoryLayout: {\r\n                    // Uniform bind when without storage binding.\r\n                    if (lEntry.storageType === StorageBindingType.None) {\r\n                        // Read texture capabilities.\r\n                        const lTextureFormatCapabilities: TextureFormatCapability = this.device.formatValidator.capabilityOf(lEntry.layout.format);\r\n\r\n                        // Create image texture bind information.\r\n                        lLayoutEntry.texture = {\r\n                            sampleType: lTextureFormatCapabilities.sampleTypes.primary,\r\n                            multisampled: lEntry.layout.multisampled,\r\n                            viewDimension: lEntry.layout.dimension\r\n                        } satisfies Required<GPUTextureBindingLayout>;\r\n\r\n                        break;\r\n                    }\r\n\r\n                    // Storage textures need to be write only.\r\n                    let lStorageAccess: GPUStorageTextureAccess;\r\n                    switch (lEntry.storageType) {\r\n                        case StorageBindingType.ReadWrite: {\r\n                            lStorageAccess = 'read-write';\r\n                            break;\r\n                        }\r\n                        case StorageBindingType.Write: {\r\n                            lStorageAccess = 'write-only';\r\n                            break;\r\n                        }\r\n                        case StorageBindingType.Read: {\r\n                            lStorageAccess = 'read-only';\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    // Create storage texture bind information.\r\n                    lLayoutEntry.storageTexture = {\r\n                        access: lStorageAccess!,\r\n                        format: lEntry.layout.format as GPUTextureFormat,\r\n                        viewDimension: lEntry.layout.dimension,\r\n                    } satisfies Required<GPUStorageTextureBindingLayout>;\r\n                }\r\n            }\r\n\r\n            // Add binding entry to bindings.\r\n            lEntryList.push(lLayoutEntry);\r\n        }\r\n\r\n        // Create binding group layout.\r\n        return this.device.gpu.createBindGroupLayout({\r\n            label: `BindGroupLayout-${this.mName}`,\r\n            entries: lEntryList\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Setup bind group.\r\n     * \r\n     * @param pReferences - Setup data references. \r\n     */\r\n    protected override onSetup(pReferences: BindGroupLayoutSetupData): void {\r\n        // Check capabilities.\r\n        const lMaxBindGroupCount: number = this.device.capabilities.getLimit(GpuLimit.MaxBindingsPerBindGroup);\r\n        if (pReferences.bindings.length > (lMaxBindGroupCount - 1)) {\r\n            throw new Exception(`Bind group \"${this.mName}\" exceeds max binding count.`, this);\r\n        }\r\n\r\n        // Validation set.\r\n        const lBindingIndices: Set<number> = new Set<number>();\r\n        const lBindingName: Set<string> = new Set<string>();\r\n\r\n        // Add each binding.\r\n        for (const lBinding of pReferences.bindings) {\r\n            // Validate layout.\r\n            if (!lBinding.layout) {\r\n                throw new Exception(`Bind group binding \"${lBinding.name}\" has no setup layout.`, this);\r\n            }\r\n\r\n            // Only buffers can have a dynamic offset.\r\n            if (lBinding.hasDynamicOffset && !(lBinding.layout instanceof BaseBufferMemoryLayout)) {\r\n                throw new Exception(`Bind group binding \"${lBinding.name}\" must be a buffer binding to have dynamic offsets.`, this);\r\n            }\r\n\r\n            // Buffers with dynamic offsets must be fixed in size.\r\n            if (lBinding.hasDynamicOffset && (<BaseBufferMemoryLayout>lBinding.layout).variableSize > 0) {\r\n                throw new Exception(`Bind group binding \"${lBinding.name}\" must have a fixed buffer layout to have dynamic offsets.`, this);\r\n            }\r\n\r\n            // Layout validation for 32bit formats are in setup.\r\n\r\n            // Shallow copy binding.\r\n            this.mBindings.set(lBinding.name, {\r\n                name: lBinding.name,\r\n                index: lBinding.index,\r\n                layout: lBinding.layout,\r\n                visibility: lBinding.visibility,\r\n                storageType: lBinding.storageType,\r\n                hasDynamicOffset: lBinding.hasDynamicOffset\r\n            });\r\n\r\n            // Set dynamic offset flag when any is active.\r\n            if (lBinding.hasDynamicOffset) {\r\n                this.mHasDynamicOffset = true;\r\n\r\n                // Count dynamic resources\r\n                if (lBinding.storageType === StorageBindingType.None) {\r\n                    this.mResourceCounter.uniformDynamicOffset++;\r\n                } else {\r\n                    this.mResourceCounter.storageDynamicOffset++;\r\n                }\r\n            }\r\n\r\n            // Validate dublicate indices.\r\n            if (lBindingIndices.has(lBinding.index) || lBindingName.has(lBinding.name)) {\r\n                throw new Exception(`Binding \"${lBinding.name}\" with index \"${lBinding.index}\" added twice.`, this);\r\n            }\r\n\r\n            // Add binding index to already binded indices. \r\n            lBindingIndices.add(lBinding.index);\r\n            lBindingName.add(lBinding.name);\r\n\r\n            // Add binding ordered by index.\r\n            this.mOrderedBindingNames[lBinding.index] = lBinding.name;\r\n\r\n            // Count resources.\r\n            switch (true) {\r\n                case lBinding.layout instanceof SamplerMemoryLayout: {\r\n                    this.mResourceCounter.sampler++;\r\n                    break;\r\n                }\r\n                case lBinding.layout instanceof TextureViewMemoryLayout: {\r\n                    if (lBinding.storageType === StorageBindingType.None) {\r\n                        this.mResourceCounter.sampledTextures++;\r\n                    } else {\r\n                        this.mResourceCounter.storageTextures++;\r\n                    }\r\n\r\n                    break;\r\n                }\r\n                case lBinding.layout instanceof BaseBufferMemoryLayout: {\r\n                    if (lBinding.storageType === StorageBindingType.None) {\r\n                        this.mResourceCounter.uniformBuffers++;\r\n                    } else {\r\n                        this.mResourceCounter.storageBuffers++;\r\n                    }\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create setup object. Return null to skip any setups.\r\n     * \r\n     * @param pReferences - Setup references.\r\n     * \r\n     * @returns setup.\r\n     */\r\n    protected override onSetupObjectCreate(pReferences: GpuObjectSetupReferences<BindGroupLayoutSetupData>): BindGroupLayoutSetup {\r\n        return new BindGroupLayoutSetup(pReferences);\r\n    }\r\n}\r\n\r\nexport type BindLayout = {\r\n    name: string,\r\n    index: number,\r\n    layout: BaseMemoryLayout;\r\n    visibility: ComputeStage;\r\n    storageType: StorageBindingType;\r\n    hasDynamicOffset: boolean;\r\n};\r\n\r\ntype BindGroupLayoutResourceCounter = {\r\n    // Dynamic resources.\r\n    storageDynamicOffset: number;\r\n    uniformDynamicOffset: number;\r\n\r\n    // Texture resource.\r\n    sampler: number;\r\n    sampledTextures: number;\r\n    storageTextures: number;\r\n\r\n    // Buffers.\r\n    storageBuffers: number;\r\n    uniformBuffers: number;\r\n};", "import { BufferItemFormat } from '../../constant/buffer-item-format.enum.ts';\r\nimport { BufferItemMultiplier } from '../../constant/buffer-item-multiplier.enum.ts';\r\nimport { GpuObjectChildSetup } from '../../gpu_object/gpu-object-child-setup.ts';\r\nimport { VertexParameterLayoutSetupData } from './vertex-parameter-layout-setup.ts';\r\n\r\n/**\r\n * Child setup object to divide and add new names parameters to a vertex parameter buffer layout.\r\n */\r\nexport class VertexParameterBufferLayoutSetup extends GpuObjectChildSetup<VertexParameterLayoutSetupData, VertexParameterBufferLayoutCallback> {\r\n    /**\r\n     * Add new parameter to vertex layout.\r\n     * \r\n     * @param pName - Parameter name.\r\n     * @param pLocation - Parameter location.\r\n     * @param pFormat - Parameter data format.\r\n     * @param pMultiplier - Data multiplication.\r\n     * @param pAdditionalOffset - Additional offset. Offset 0 aligns right after the last parameter.\r\n     * @returns \r\n     */\r\n    public withParameter(pName: string, pLocation: number, pFormat: BufferItemFormat, pMultiplier: BufferItemMultiplier, pAlignment: number | null = null): this {\r\n        // Send layout data.\r\n        this.sendData({\r\n            name: pName,\r\n            location: pLocation,\r\n            format: pFormat,\r\n            multiplier: pMultiplier,\r\n            alignment: pAlignment\r\n        });\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\ntype VertexParameterBufferLayoutCallback = (pLayout: VertexParameterBufferLayoutData) => void;\r\n\r\nexport type VertexParameterBufferLayoutData = {\r\n    name: string;\r\n    location: number;\r\n    format: BufferItemFormat;\r\n    multiplier: BufferItemMultiplier;\r\n    alignment: number | null;\r\n};", "import { VertexParameterStepMode } from '../../constant/vertex-parameter-step-mode.enum.ts';\r\nimport { GpuObjectSetup } from '../../gpu_object/gpu-object-setup.ts';\r\nimport { VertexParameterBufferLayoutData, VertexParameterBufferLayoutSetup } from './vertex-parameter-buffer-layout-setup.ts';\r\n\r\n/**\r\n * setup object for vertex layouts.\r\n */\r\nexport class VertexParameterLayoutSetup extends GpuObjectSetup<VertexParameterLayoutSetupData> {\r\n    /**\r\n     * Add a new buffer layout to vertex parameter layout.\r\n     * \r\n     * @param pStepMode - Buffer step mode.\r\n     * \r\n     * @returns vertex buffer layout setup \r\n     */\r\n    public buffer(pBufferName: string, pStepMode: VertexParameterStepMode): VertexParameterBufferLayoutSetup {\r\n        // Create buffer.\r\n        const lBuffer: VertexParameterLayoutSetupBufferData = {\r\n            name: pBufferName,\r\n            stepMode: pStepMode,\r\n            parameter: new Array<VertexParameterBufferLayoutData>()\r\n        };\r\n\r\n        // Add buffer to result.\r\n        this.setupData.buffer.push(lBuffer);\r\n\r\n        // Create and return buffer setup.\r\n        return new VertexParameterBufferLayoutSetup(this.setupReferences, (pLayout: VertexParameterBufferLayoutData) => {\r\n            lBuffer.parameter.push(pLayout);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fill in default data before the setup starts.\r\n     * \r\n     * @param pDataReference - Setup data.\r\n     */\r\n    protected override fillDefaultData(pDataReference: Partial<VertexParameterLayoutSetupData>): void {\r\n        pDataReference.buffer = new Array<VertexParameterLayoutSetupBufferData>();\r\n    }\r\n}\r\n\r\ntype VertexParameterLayoutSetupBufferData = {\r\n    name: string;\r\n    stepMode: VertexParameterStepMode;\r\n    parameter: Array<VertexParameterBufferLayoutData>;\r\n};\r\n\r\nexport type VertexParameterLayoutSetupData = {\r\n    buffer: Array<VertexParameterLayoutSetupBufferData>;\r\n};", "import { Dictionary, Exception } from '@kartoffelgames/core';\r\nimport { PrimitiveBufferMemoryLayout } from '../../buffer/memory_layout/primitive-buffer-memory-layout.ts';\r\nimport { StructBufferMemoryLayout } from '../../buffer/memory_layout/struct-buffer-memory-layout.ts';\r\nimport { BufferAlignmentType } from '../../constant/buffer-alignment-type.enum.ts';\r\nimport { BufferItemMultiplier } from '../../constant/buffer-item-multiplier.enum.ts';\r\nimport { VertexParameterStepMode } from '../../constant/vertex-parameter-step-mode.enum.ts';\r\nimport { GpuDevice } from '../../device/gpu-device.ts';\r\nimport { GpuObject, GpuObjectSetupReferences } from '../../gpu_object/gpu-object.ts';\r\nimport { IGpuObjectNative } from '../../gpu_object/interface/i-gpu-object-native.ts';\r\nimport { IGpuObjectSetup } from '../../gpu_object/interface/i-gpu-object-setup.ts';\r\nimport { VertexParameter } from './vertex-parameter.ts';\r\nimport { VertexParameterLayoutSetup, VertexParameterLayoutSetupData } from './vertex-parameter-layout-setup.ts';\r\n\r\n/**\r\n * Vertex parameter layout.\r\n */\r\nexport class VertexParameterLayout extends GpuObject<Array<GPUVertexBufferLayout>, '', VertexParameterLayoutSetup> implements IGpuObjectNative<Array<GPUVertexBufferLayout>>, IGpuObjectSetup<VertexParameterLayoutSetup> {\r\n    private readonly mBuffer: Dictionary<string, VertexParameterLayoutBuffer>;\r\n    private mIndexable: boolean;\r\n    private readonly mParameter: Dictionary<string, VertexParameterLayoutBufferParameter>;\r\n\r\n    /**\r\n     * Get all parameter buffer names.\r\n     */\r\n    public get bufferNames(): Array<string> {\r\n        // Setup must be called.\r\n        this.ensureSetup();\r\n\r\n        return [...this.mBuffer.keys()];\r\n    }\r\n\r\n    /**\r\n     * If parameters are indexable.\r\n     * Meanins every parameter is eighter stepmode index or instance.\r\n     * When even one parameter has a stepmode of vertex, any index parameters must be converted. \r\n     */\r\n    public get indexable(): boolean {\r\n        // Setup must be called.\r\n        this.ensureSetup();\r\n\r\n        return this.mIndexable;\r\n    }\r\n\r\n    /**\r\n     * Native gpu object.\r\n     */\r\n    public override get native(): Array<GPUVertexBufferLayout> {\r\n        return super.native;\r\n    }\r\n\r\n    /**\r\n     * Get all parameter names.\r\n     */\r\n    public get parameterNames(): Array<string> {\r\n        // Setup must be called.\r\n        this.ensureSetup();\r\n\r\n        return [...this.mParameter.keys()];\r\n    }\r\n\r\n    /**\r\n     * Construct.\r\n     * \r\n     * @param pDevice - Device reference.\r\n     * @param pLayout - Simple layout of parameter.\r\n     */\r\n    public constructor(pDevice: GpuDevice) {\r\n        super(pDevice);\r\n\r\n        this.mIndexable = false;\r\n        this.mBuffer = new Dictionary<string, VertexParameterLayoutBuffer>();\r\n        this.mParameter = new Dictionary<string, VertexParameterLayoutBufferParameter>();\r\n    }\r\n\r\n    /**\r\n     * Create vertex parameters from layout.\r\n     * @param pIndexData - Index data.\r\n     */\r\n    public create(pIndexData: Array<number>): VertexParameter {\r\n        return new VertexParameter(this.device, this, pIndexData);\r\n    }\r\n\r\n    /**\r\n     * Get vertex parameter layout definition by name.\r\n     * \r\n     * @param pName - Parameter name.\r\n     */\r\n    public parameter(pName: string): Readonly<VertexParameterLayoutBufferParameter> {\r\n        const lLayout: VertexParameterLayoutBufferParameter | undefined = this.mParameter.get(pName);\r\n        if (!lLayout) {\r\n            throw new Exception(`Vertex parameter \"${pName}\" is not defined.`, this);\r\n        }\r\n\r\n        return lLayout;\r\n    }\r\n\r\n    /**\r\n     * Get vertex parameter layout definition by name.\r\n     * \r\n     * @param pBufferName - Parameter name.\r\n     */\r\n    public parameterBuffer(pBufferName: string): Readonly<VertexParameterLayoutBuffer> {\r\n        const lLayout: VertexParameterLayoutBuffer | undefined = this.mBuffer.get(pBufferName);\r\n        if (!lLayout) {\r\n            throw new Exception(`Vertex parameter buffer \"${pBufferName}\" is not defined.`, this);\r\n        }\r\n\r\n        return lLayout;\r\n    }\r\n\r\n    /**\r\n     * Call setup.\r\n     * \r\n     * @param pSetupCallback - Setup callback.\r\n     *\r\n     * @returns \u2014 this.\r\n     */\r\n    public override setup(pSetupCallback?: ((pSetup: VertexParameterLayoutSetup) => void)): this {\r\n        return super.setup(pSetupCallback);\r\n    }\r\n\r\n    /**\r\n     * Generate new native object.\r\n     */\r\n    protected override generateNative(): Array<GPUVertexBufferLayout> {\r\n        // Create vertex buffer layout for each parameter.\r\n        const lLayoutList: Array<GPUVertexBufferLayout> = new Array<GPUVertexBufferLayout>();\r\n        for (const lBuffer of this.mBuffer.values()) {\r\n            let lCurrentBufferByteLength: number = 0;\r\n            // Create parameter layouts.\r\n            const lVertexAttributes: Array<GPUVertexAttribute> = new Array<GPUVertexAttribute>();\r\n            for (const lParameter of lBuffer.layout.properties) {\r\n                // Convert parameter layout to primitive buffer layout.\r\n                const lPrimitiveParameterLayout: PrimitiveBufferMemoryLayout = lParameter.layout as PrimitiveBufferMemoryLayout;\r\n\r\n                // Convert multiplier to value.\r\n                const lItemMultiplier = PrimitiveBufferMemoryLayout.itemCountOfMultiplier(lPrimitiveParameterLayout.itemMultiplier);\r\n\r\n                // Convert multiplier to float32 format.\r\n                let lFormat: GPUVertexFormat = `${lPrimitiveParameterLayout.itemFormat}x${lItemMultiplier}` as GPUVertexFormat;\r\n                if (lPrimitiveParameterLayout.itemMultiplier === BufferItemMultiplier.Single) {\r\n                    lFormat = lPrimitiveParameterLayout.itemFormat as GPUVertexFormat;\r\n                }\r\n\r\n                // Read location of parameter.\r\n                const lParameterLocation: number = this.mParameter.get(lParameter.name)!.location;\r\n\r\n                // Create buffer layout.\r\n                lVertexAttributes.push({\r\n                    format: lFormat,\r\n                    offset: lCurrentBufferByteLength,\r\n                    shaderLocation: lParameterLocation\r\n                });\r\n\r\n                // Apply alignment and extend buffer size by parameter length.\r\n                lCurrentBufferByteLength = Math.ceil(lCurrentBufferByteLength / lPrimitiveParameterLayout.alignment) * lPrimitiveParameterLayout.alignment;\r\n                lCurrentBufferByteLength += lPrimitiveParameterLayout.fixedSize;\r\n            }\r\n\r\n            // Convert stepmode.\r\n            let lStepmode: GPUVertexStepMode = 'vertex';\r\n            if (lBuffer.stepMode === VertexParameterStepMode.Instance) {\r\n                lStepmode = 'instance';\r\n            }\r\n\r\n            lLayoutList.push({\r\n                stepMode: lStepmode,\r\n                arrayStride: lBuffer.layout.fixedSize,\r\n                attributes: lVertexAttributes\r\n            });\r\n        }\r\n\r\n        return lLayoutList;\r\n    }\r\n\r\n    /**\r\n     * Setup with setup object.\r\n     * \r\n     * @param pReferences - Used references.\r\n     */\r\n    protected override onSetup(pReferences: VertexParameterLayoutSetupData): void {\r\n        let lCanBeIndexed: boolean = true;\r\n\r\n        // Build allowed multiplier list.\r\n        const lAllowedMultiplier: Set<BufferItemMultiplier> = new Set<BufferItemMultiplier>([\r\n            BufferItemMultiplier.Single,\r\n            BufferItemMultiplier.Vector2,\r\n            BufferItemMultiplier.Vector3,\r\n            BufferItemMultiplier.Vector4\r\n        ]);\r\n\r\n        // Create each buffer.\r\n        const lParameterIndicies: Array<true> = new Array<true>();\r\n        for (const lBufferSetupData of pReferences.buffer) {\r\n            // Create struct layout with packed alignment.\r\n            const lBufferLayout: StructBufferMemoryLayout = new StructBufferMemoryLayout(this.device, BufferAlignmentType.Packed);\r\n            lBufferLayout.setup((pSetup) => {\r\n                for (const lParameterSetupData of lBufferSetupData.parameter) {\r\n                    // No double locations.\r\n                    if (lParameterIndicies[lParameterSetupData.location]) {\r\n                        throw new Exception(`Vertex parameter location \"${lParameterSetupData.location}\" can't be defined twice.`, this);\r\n                    }\r\n\r\n                    // Validate multiplier.\r\n                    if (!lAllowedMultiplier.has(lParameterSetupData.multiplier)) {\r\n                        throw new Exception(`Vertex parameter item multiplier \"${lParameterSetupData.multiplier}\" not supported.`, this);\r\n                    }\r\n\r\n                    // Add parameter as struct property.\r\n                    pSetup.property(lParameterSetupData.name)\r\n                        .asPrimitive(lParameterSetupData.format, lParameterSetupData.multiplier, lParameterSetupData.alignment);\r\n\r\n                    // Add to parameter list.\r\n                    this.mParameter.set(lParameterSetupData.name, {\r\n                        name: lParameterSetupData.name,\r\n                        location: lParameterSetupData.location,\r\n                    });\r\n\r\n                    // Save location index for checkind double\r\n                    lParameterIndicies[lParameterSetupData.location] = true;\r\n                }\r\n            });\r\n\r\n            // Create buffer description.\r\n            this.mBuffer.set(lBufferSetupData.name, {\r\n                name: lBufferSetupData.name,\r\n                stepMode: lBufferSetupData.stepMode,\r\n                layout: lBufferLayout\r\n            });\r\n\r\n            // When one buffer is not indexable than no buffer is it.\r\n            if (lBufferSetupData.stepMode === VertexParameterStepMode.Vertex) {\r\n                lCanBeIndexed = false;\r\n            }\r\n        }\r\n\r\n        // Validate continuity of parameter locations.\r\n        if (lParameterIndicies.length !== this.mParameter.size) {\r\n            throw new Exception(`Vertex parameter locations need to be in continious order.`, this);\r\n        }\r\n\r\n        this.mIndexable = lCanBeIndexed;\r\n    }\r\n\r\n    /**\r\n     * Create setup object. Return null to skip any setups.\r\n     * \r\n     * @param pReferences - Setup references.\r\n     * \r\n     * @returns created setup. \r\n     */\r\n    protected override onSetupObjectCreate(pReferences: GpuObjectSetupReferences<VertexParameterLayoutSetupData>): VertexParameterLayoutSetup {\r\n        return new VertexParameterLayoutSetup(pReferences);\r\n    }\r\n}\r\n\r\nexport type VertexParameterLayoutBuffer = {\r\n    name: string;\r\n    stepMode: VertexParameterStepMode;\r\n    layout: StructBufferMemoryLayout;\r\n};\r\n\r\nexport type VertexParameterLayoutBufferParameter = {\r\n    name: string;\r\n    location: number;\r\n};", "import { GpuObjectChildSetup } from '../../gpu_object/gpu-object-child-setup.ts';\r\nimport { ShaderSetupReferenceData } from './shader-setup.ts';\r\n\r\n/**\r\n * Child setup object to add compute entry points for shaders. \r\n */\r\nexport class ShaderComputeEntryPointSetup extends GpuObjectChildSetup<ShaderSetupReferenceData, ComputeSizeCallback> {\r\n    /**\r\n     * Setup compute entry with a static size.\r\n     */\r\n    public size(pX: number, pY: number = 1, pZ: number = 1): void {\r\n        // Lock setup to a setup call.\r\n        this.ensureThatInSetup();\r\n\r\n        // Callback size.\r\n        this.sendData(pX, pY, pZ);\r\n    }\r\n}\r\n\r\ntype ComputeSizeCallback = (pX: number, pY: number, pZ: number) => void;", "import { BufferItemFormat } from '../../constant/buffer-item-format.enum.ts';\r\nimport { BufferItemMultiplier } from '../../constant/buffer-item-multiplier.enum.ts';\r\nimport { GpuObjectChildSetup } from '../../gpu_object/gpu-object-child-setup.ts';\r\nimport { ShaderSetupReferenceData } from './shader-setup.ts';\r\n\r\n/**\r\n * Child setup object to render targets to shaders. \r\n */\r\nexport class ShaderFragmentEntryPointSetup extends GpuObjectChildSetup<ShaderSetupReferenceData, RenderTargetCallback> {\r\n    /**\r\n     * Setup fragment render target.\r\n     */\r\n    public addRenderTarget(pName: string, pLocationIndex: number, pDataFormat: BufferItemFormat, pDataMultiplier: BufferItemMultiplier): this {\r\n        // Lock setup to a setup call.\r\n        this.ensureThatInSetup();\r\n\r\n        const lRenderTarget: ShaderFragmentEntryPointRenderTargetSetupData = {\r\n            name: pName,\r\n            location: pLocationIndex,\r\n            format: pDataFormat,\r\n            multiplier: pDataMultiplier\r\n        };\r\n\r\n        // Callback size.\r\n        this.sendData(lRenderTarget);\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nexport type ShaderFragmentEntryPointRenderTargetSetupData = {\r\n    name: string;\r\n    location: number;\r\n    format: BufferItemFormat;\r\n    multiplier: BufferItemMultiplier;\r\n};\r\n\r\ntype RenderTargetCallback = (pRenderTarget: ShaderFragmentEntryPointRenderTargetSetupData) => void;", "import { ComputeStage } from '../../constant/compute-stage.enum.ts';\r\nimport { GpuObjectSetup } from '../../gpu_object/gpu-object-setup.ts';\r\nimport { BindGroupLayout } from '../../pipeline/bind_group_layout/bind-group-layout.ts';\r\nimport { BindGroupLayoutSetup } from '../../pipeline/bind_group_layout/bind-group-layout-setup.ts';\r\nimport { VertexParameterLayout } from '../../pipeline/vertex_parameter/vertex-parameter-layout.ts';\r\nimport { VertexParameterLayoutSetup } from '../../pipeline/vertex_parameter/vertex-parameter-layout-setup.ts';\r\nimport { ShaderModuleEntryPointFragmentRenderTarget } from '../shader.ts';\r\nimport { ShaderComputeEntryPointSetup } from './shader-compute-entry-point-setup.ts';\r\nimport { ShaderFragmentEntryPointRenderTargetSetupData, ShaderFragmentEntryPointSetup } from './shader-fragment-entry-point-setup.ts';\r\n\r\n/**\r\n * Setup object to setup all layout and constant informations for shaders.\r\n */\r\nexport class ShaderSetup extends GpuObjectSetup<ShaderSetupReferenceData> {\r\n    /**\r\n     * Setup compute entry point.\r\n     * When size is not called, the compute entry point will be setup with a dynamic size.\r\n     * \r\n     * @param pName - Compute entry name.\r\n     */\r\n    public computeEntryPoint(pName: string): ShaderComputeEntryPointSetup {\r\n        // Lock setup to a setup call.\r\n        this.ensureThatInSetup();\r\n\r\n        // Create dynamic compute entry point.\r\n        const lEntryPoint: ShaderEntryPointComputeSetupData = {\r\n            name: pName,\r\n            workgroupDimension: null\r\n        };\r\n\r\n        // Append compute entry.\r\n        this.setupData.computeEntrypoints.push(lEntryPoint);\r\n\r\n        // Return compute entry setup object.\r\n        return new ShaderComputeEntryPointSetup(this.setupReferences, (pX: number, pY: number, pZ: number) => {\r\n            lEntryPoint.workgroupDimension = {\r\n                x: pX,\r\n                y: pY,\r\n                z: pZ\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Setup fragment entry point.\r\n     * \r\n     * @param pName - Fragment entry name.\r\n     */\r\n    public fragmentEntryPoint(pName: string): ShaderFragmentEntryPointSetup {\r\n        // Lock setup to a setup call.\r\n        this.ensureThatInSetup();\r\n\r\n        // Create empty fragment entry point.\r\n        const lEntryPoint: ShaderEntryPointFragmentSetupData = {\r\n            name: pName,\r\n            renderTargets: new Array<ShaderFragmentEntryPointRenderTargetSetupData>()\r\n        };\r\n\r\n        // Append compute entry.\r\n        this.setupData.fragmentEntrypoints.push(lEntryPoint);\r\n\r\n        // Return fragment entry setup object.\r\n        return new ShaderFragmentEntryPointSetup(this.setupReferences, (pRenderTarget: ShaderModuleEntryPointFragmentRenderTarget) => {\r\n            lEntryPoint.renderTargets.push(pRenderTarget);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add group to layout.\r\n     * \r\n     * @param pIndex - Bind group index.\r\n     * @param pGroup - Group.\r\n     * \r\n     * @returns the same group.\r\n     */\r\n    public group(pIndex: number, pGroup: BindGroupLayout): BindGroupLayout;\r\n    public group(pIndex: number, pGroupName: string, pSetupCall: ((pSetup: BindGroupLayoutSetup) => void)): BindGroupLayout;\r\n    public group(pIndex: number, pGroupOrName: BindGroupLayout | string, pSetupCall?: ((pSetup: BindGroupLayoutSetup) => void)): BindGroupLayout {\r\n        // Use existing or create new bind group.\r\n        let lBindGroupLayout: BindGroupLayout;\r\n        if (typeof pGroupOrName === 'string') {\r\n            // Create new group\r\n            lBindGroupLayout = new BindGroupLayout(this.device, pGroupOrName).setup(pSetupCall);\r\n        } else {\r\n            // Use existing group.\r\n            lBindGroupLayout = pGroupOrName;\r\n        }\r\n\r\n        // Register group.\r\n        this.setupData.bindingGroups.push({\r\n            index: pIndex,\r\n            group: lBindGroupLayout\r\n        });\r\n\r\n        return lBindGroupLayout;\r\n    }\r\n\r\n    /**\r\n     * Add static pipeline parameters definitions.\r\n     * \r\n     * @param pName- Parameter name.\r\n     * @param pFormat - Parameter format.\r\n     * \r\n     * @returns this. \r\n     */\r\n    public parameter(pName: string, ...pStageUsage: Array<ComputeStage>): this {\r\n        // Lock setup to a setup call.\r\n        this.ensureThatInSetup();\r\n\r\n        // Add parameter.\r\n        this.setupData.parameter.push({ name: pName, usage: pStageUsage });\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Setup vertex entry point.\r\n     * \r\n     * @param pName - Vertex entry name.\r\n     */\r\n    public vertexEntryPoint(pName: string, pSetupCallback: (pSetup: VertexParameterLayoutSetup) => void): VertexParameterLayout {\r\n        // Lock setup to a setup call.\r\n        this.ensureThatInSetup();\r\n\r\n        // Create and setup vertex parameter.\r\n        const lVertexParameterLayout: VertexParameterLayout = new VertexParameterLayout(this.device)\r\n            .setup(pSetupCallback);\r\n\r\n        // Create empty fragment entry point.\r\n        const lEntryPoint: ShaderEntryPointVertexSetupData = {\r\n            name: pName,\r\n            parameter: lVertexParameterLayout\r\n        };\r\n\r\n        // Append compute entry.\r\n        this.setupData.vertexEntrypoints.push(lEntryPoint);\r\n\r\n        return lVertexParameterLayout;\r\n    }\r\n\r\n    /**\r\n     * Fill in default data before the setup starts.\r\n     *\r\n     * @param pDataReference - Setup data reference.\r\n     */\r\n    protected override fillDefaultData(pDataReference: ShaderSetupReferenceData): void {\r\n        // Entry points.\r\n        pDataReference.computeEntrypoints = new Array<ShaderEntryPointComputeSetupData>();\r\n        pDataReference.fragmentEntrypoints = new Array<ShaderEntryPointFragmentSetupData>();\r\n        pDataReference.vertexEntrypoints = new Array<ShaderEntryPointVertexSetupData>();\r\n\r\n        // Parameter.\r\n        pDataReference.parameter = new Array<{\r\n            name: string;\r\n            usage: Array<ComputeStage>;\r\n        }>();\r\n\r\n        // Bind groups.\r\n        pDataReference.bindingGroups = new Array<{\r\n            index: number;\r\n            group: BindGroupLayout;\r\n        }>();\r\n    }\r\n}\r\n\r\ntype ShaderEntryPointComputeSetupData = {\r\n    name: string;\r\n    workgroupDimension: {\r\n        x: number;\r\n        y: number;\r\n        z: number;\r\n    } | null;\r\n};\r\n\r\ntype ShaderEntryPointVertexSetupData = {\r\n    name: string;\r\n    parameter: VertexParameterLayout;\r\n};\r\n\r\ntype ShaderEntryPointFragmentSetupData = {\r\n    name: string;\r\n    renderTargets: Array<ShaderFragmentEntryPointRenderTargetSetupData>;\r\n};\r\n\r\nexport type ShaderSetupReferenceData = {\r\n    // Entry points.\r\n    computeEntrypoints: Array<ShaderEntryPointComputeSetupData>;\r\n    fragmentEntrypoints: Array<ShaderEntryPointFragmentSetupData>;\r\n    vertexEntrypoints: Array<ShaderEntryPointVertexSetupData>;\r\n\r\n    // Parameter.\r\n    parameter: Array<{\r\n        name: string;\r\n        usage: Array<ComputeStage>;\r\n    }>;\r\n\r\n    // Bind groups.\r\n    bindingGroups: Array<{\r\n        index: number;\r\n        group: BindGroupLayout;\r\n    }>;\r\n};", "import { Dictionary } from '@kartoffelgames/core';\r\nimport { ComputeStage } from '../constant/compute-stage.enum.ts';\r\nimport { GpuDevice } from '../device/gpu-device.ts';\r\nimport { GpuObject } from '../gpu_object/gpu-object.ts';\r\nimport { GpuObjectInvalidationReasons } from '../gpu_object/gpu-object-invalidation-reasons.ts';\r\nimport { IGpuObjectNative } from '../gpu_object/interface/i-gpu-object-native.ts';\r\nimport { ShaderComputeModule } from '../shader/shader-compute-module.ts';\r\nimport { PipelineLayout } from './pipeline-layout.ts';\r\n\r\n/**\r\n * Gpu pipeline resource for computing with a compute shader. \r\n */\r\nexport class ComputePipeline extends GpuObject<GPUComputePipeline | null, ComputePipelineInvalidationType> implements IGpuObjectNative<GPUComputePipeline | null> {\r\n    private mLoadedPipeline: GPUComputePipeline | null;\r\n    private readonly mParameter: Dictionary<ComputeStage, Record<string, number>>;\r\n    private readonly mShaderModule: ShaderComputeModule;\r\n\r\n    /**\r\n     * Pipeline layout.\r\n     */\r\n    public get layout(): PipelineLayout {\r\n        return this.mShaderModule.shader.layout;\r\n    }\r\n\r\n    /**\r\n     * Pipeline shader.\r\n     */\r\n    public get module(): ShaderComputeModule {\r\n        return this.mShaderModule;\r\n    }\r\n\r\n    /**\r\n     * Native gpu object.\r\n     */\r\n    public override get native(): GPUComputePipeline | null {\r\n        return super.native;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * Set default data.\r\n     * @param pDevice - Device.\r\n     * @param pShader - Pipeline shader.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pShader: ShaderComputeModule) {\r\n        super(pDevice);\r\n        this.mShaderModule = pShader;\r\n\r\n        // Loaded pipeline for async creation.\r\n        this.mLoadedPipeline = null;\r\n\r\n        // Pipeline constants.\r\n        this.mParameter = new Dictionary<ComputeStage, Record<string, number>>();\r\n    }\r\n\r\n    /**\r\n     * Set optional parameter of pipeline.\r\n     * \r\n     * @param pParameterName - name of parameter.\r\n     * @param pValue - Value.\r\n     * \r\n     * @returns this. \r\n     */\r\n    public setParameter(pParameterName: string, pValue: number): this {\r\n        const lParameterUsage: Set<ComputeStage> | undefined = this.mShaderModule.shader.parameter(pParameterName);\r\n\r\n        // Set parameter for each assigned compute stage.\r\n        for (const lUsage of lParameterUsage) {\r\n            // Init parameters for computestage when not set.\r\n            if (!this.mParameter.has(lUsage)) {\r\n                this.mParameter.set(lUsage, {});\r\n            }\r\n\r\n            // Set value for compute stage.\r\n            this.mParameter.get(lUsage)![pParameterName] = pValue;\r\n        }\r\n\r\n        // Generate pipeline anew.\r\n        this.invalidate(ComputePipelineInvalidationType.NativeRebuild);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Generate native gpu pipeline data layout.\r\n     */\r\n    protected override generateNative(_pLastNative: GPUComputePipeline | null, pInvalidationReason: GpuObjectInvalidationReasons<ComputePipelineInvalidationType>): GPUComputePipeline | null {\r\n        // When a pipeline was loaded, return the loaded instead of creating a new pipeline.\r\n        if (this.mLoadedPipeline !== null && !pInvalidationReason.has(ComputePipelineInvalidationType.NativeRebuild)) {\r\n            const lLoadedPipeline: GPUComputePipeline = this.mLoadedPipeline;\r\n            this.mLoadedPipeline = null;\r\n\r\n            return lLoadedPipeline;\r\n        }\r\n\r\n        // Construct basic GPUComputePipelineDescriptor.\r\n        const lPipelineDescriptor: GPUComputePipelineDescriptor = {\r\n            layout: this.mShaderModule.shader.layout.native,\r\n            compute: {\r\n                module: this.mShaderModule.shader.native,\r\n                entryPoint: this.mShaderModule.entryPoint,\r\n                constants: this.mParameter.get(ComputeStage.Compute) ?? {}\r\n            }\r\n        };\r\n\r\n        // Load pipeline asyncron and update native after promise resolve.\r\n        this.device.gpu.createComputePipelineAsync(lPipelineDescriptor).then((pPipeline: GPUComputePipeline) => {\r\n            this.mLoadedPipeline = pPipeline;\r\n            this.invalidate(ComputePipelineInvalidationType.NativeLoaded);\r\n        });\r\n\r\n        // Null as long as pipeline is loading.\r\n        return null;\r\n    }\r\n}\r\n\r\nexport enum ComputePipelineInvalidationType {\r\n    NativeRebuild = 'NativeRebuild',\r\n    NativeLoaded = 'NativeLoaded',\r\n}", "import { GpuDevice } from '../device/gpu-device.ts';\r\nimport { GpuObject } from '../gpu_object/gpu-object.ts';\r\nimport { ComputePipeline } from '../pipeline/compute-pipeline.ts';\r\nimport { PipelineLayout } from '../pipeline/pipeline-layout.ts';\r\nimport { Shader } from './shader.ts';\r\n\r\n/**\r\n * Compute part of a shader programm.\r\n */\r\nexport class ShaderComputeModule extends GpuObject {\r\n    private readonly mEntryPoint: string;\r\n    private readonly mShader: Shader;\r\n    private readonly mSize: [number, number, number];\r\n\r\n    /**\r\n     * Compute entry point.\r\n     */\r\n    public get entryPoint(): string {\r\n        return this.mEntryPoint;\r\n    }\r\n\r\n    /**\r\n     * Shader pipeline layout.\r\n     */\r\n    public get layout(): PipelineLayout {\r\n        return this.mShader.layout;\r\n    }\r\n\r\n    /**\r\n     * Module shader.\r\n     */\r\n    public get shader(): Shader {\r\n        return this.mShader;\r\n    }\r\n\r\n    /**\r\n     * Workgroup size x.\r\n     */\r\n    public get workGroupSizeX(): number {\r\n        return this.mSize[0];\r\n    }\r\n\r\n    /**\r\n     * Workgroup size y.\r\n     */\r\n    public get workGroupSizeY(): number {\r\n        return this.mSize[1];\r\n    }\r\n\r\n    /**\r\n     * Workgroup size z.\r\n     */\r\n    public get workGroupSizeZ(): number {\r\n        return this.mSize[2];\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pDevice - Device reference.\r\n     * @param pShader - Shader.\r\n     * @param pEntryPointName - Compute entry point.\r\n     * @param pSize - Workgroup size.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pShader: Shader, pEntryPointName: string, pSize?: [number, number, number]) {\r\n        super(pDevice);\r\n\r\n        this.mEntryPoint = pEntryPointName;\r\n        this.mShader = pShader;\r\n        this.mSize = pSize ?? [-1, -1, -1];\r\n    }\r\n\r\n    /**\r\n     * Create a new compute pipeline.\r\n     * \r\n     * @returns new compute pipeline. \r\n     */\r\n    public create(): ComputePipeline {\r\n        return new ComputePipeline(this.device, this);\r\n    }\r\n}", "import { GpuDevice } from '../device/gpu-device.ts';\r\nimport { GpuObject } from '../gpu_object/gpu-object.ts';\r\nimport { PipelineLayout } from '../pipeline/pipeline-layout.ts';\r\nimport { RenderTargets } from '../pipeline/render_targets/render-targets.ts';\r\nimport { VertexFragmentPipeline } from '../pipeline/vertex_fragment_pipeline/vertex-fragment-pipeline.ts';\r\nimport { VertexParameterLayout } from '../pipeline/vertex_parameter/vertex-parameter-layout.ts';\r\nimport { Shader } from './shader.ts';\r\n\r\n/**\r\n * Render parts of a shader programm.\r\n * Uses vertex and fragment shader.\r\n */\r\nexport class ShaderRenderModule extends GpuObject {\r\n    private readonly mFragmentEntryPoint: string | null;\r\n    private readonly mShader: Shader;\r\n    private readonly mVertexEntryPoint: string;\r\n    private readonly mVertexParameter: VertexParameterLayout;\r\n\r\n    /**\r\n     * Fragment entry point.\r\n     */\r\n    public get fragmentEntryPoint(): string | null {\r\n        return this.mFragmentEntryPoint;\r\n    }\r\n\r\n    /**\r\n     * Shader pipeline layout.\r\n     */\r\n    public get layout(): PipelineLayout {\r\n        return this.mShader.layout;\r\n    }\r\n\r\n    /**\r\n     * Module shader.\r\n     */\r\n    public get shader(): Shader {\r\n        return this.mShader;\r\n    }\r\n\r\n    /**\r\n     * Compute entry point.\r\n     */\r\n    public get vertexEntryPoint(): string {\r\n        return this.mVertexEntryPoint;\r\n    }\r\n\r\n    /**\r\n     * Vertex parameter.\r\n     */\r\n    public get vertexParameter(): VertexParameterLayout {\r\n        return this.mVertexParameter;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pDevice - Device reference.\r\n     * @param pShader - Shader.\r\n     * @param pEntryPointName - Compute entry point.\r\n     * @param pSize - Workgroup size.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pShader: Shader, pVertexEntryPointName: string, pVertexParameter: VertexParameterLayout, pFragmentEntryPointName?: string) {\r\n        super(pDevice);\r\n\r\n        this.mVertexEntryPoint = pVertexEntryPointName;\r\n        this.mVertexParameter = pVertexParameter;\r\n        this.mFragmentEntryPoint = pFragmentEntryPointName ?? null;\r\n        this.mShader = pShader;\r\n    }\r\n\r\n    /**\r\n     * Create a new render pipeline for set render targets.\r\n     * \r\n     * @param pRenderTargets - Render targets of pipeline.\r\n     * \r\n     * @returns new render pipeline. \r\n     */\r\n    public create(pRenderTargets: RenderTargets): VertexFragmentPipeline {\r\n        return new VertexFragmentPipeline(this.device, this, pRenderTargets);\r\n    }\r\n}", "import { Dictionary, Exception } from '@kartoffelgames/core';\r\nimport { BufferItemFormat } from '../constant/buffer-item-format.enum.ts';\r\nimport { BufferItemMultiplier } from '../constant/buffer-item-multiplier.enum.ts';\r\nimport { ComputeStage } from '../constant/compute-stage.enum.ts';\r\nimport { GpuDevice } from '../device/gpu-device.ts';\r\nimport { GpuObject, GpuObjectSetupReferences } from '../gpu_object/gpu-object.ts';\r\nimport { IGpuObjectNative } from '../gpu_object/interface/i-gpu-object-native.ts';\r\nimport { IGpuObjectSetup } from '../gpu_object/interface/i-gpu-object-setup.ts';\r\nimport { BindGroupLayout } from '../pipeline/bind_group_layout/bind-group-layout.ts';\r\nimport { PipelineLayout } from '../pipeline/pipeline-layout.ts';\r\nimport { VertexParameterLayout } from '../pipeline/vertex_parameter/vertex-parameter-layout.ts';\r\nimport { ShaderSetup, ShaderSetupReferenceData } from './setup/shader-setup.ts';\r\nimport { ShaderComputeModule } from './shader-compute-module.ts';\r\nimport { ShaderRenderModule } from './shader-render-module.ts';\r\n\r\n/**\r\n * Gpu shader program.\r\n * Can be split into its program modules.\r\n */\r\nexport class Shader extends GpuObject<GPUShaderModule, '', ShaderSetup> implements IGpuObjectNative<GPUShaderModule>, IGpuObjectSetup<ShaderSetup> {\r\n    private readonly mEntryPoints: ShaderModuleEntryPoints;\r\n    private readonly mParameter: Dictionary<string, Set<ComputeStage>>;\r\n    private mPipelineLayout: PipelineLayout | null;\r\n    private readonly mSource: string;\r\n    private readonly mSourceMap: any | null;\r\n\r\n    /**\r\n     * Shader pipeline layout.\r\n     */\r\n    public get layout(): PipelineLayout {\r\n        // Ensure setup is called.\r\n        this.ensureSetup();\r\n\r\n        return this.mPipelineLayout!;\r\n    }\r\n\r\n    /**\r\n     * Native gpu object.\r\n     */\r\n    public override get native(): GPUShaderModule {\r\n        return super.native;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Gpu Device reference.\r\n     * @param pSource - Shader source as wgsl code.\r\n     * @param pLayout - Shader layout information.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pSource: string, pSourceMap: any | null = null) {\r\n        super(pDevice);\r\n\r\n        // Create shader information for source.\r\n        this.mSource = pSource;\r\n        this.mSourceMap = pSourceMap;\r\n\r\n        // Init default unset values.\r\n        this.mParameter = new Dictionary<string, Set<ComputeStage>>();\r\n        this.mPipelineLayout = null;\r\n        this.mEntryPoints = {\r\n            compute: new Dictionary<string, ShaderModuleEntryPointCompute>(),\r\n            vertex: new Dictionary<string, ShaderModuleEntryPointVertex>(),\r\n            fragment: new Dictionary<string, ShaderModuleEntryPointFragment>()\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Create a compute module from shader entry point.\r\n     * \r\n     * @param pEntryName - Compute entry name.\r\n     * \r\n     * @returns shader compute module. \r\n     */\r\n    public createComputeModule(pEntryName: string): ShaderComputeModule {\r\n        // Ensure setup is called.\r\n        this.ensureSetup();\r\n\r\n        const lEntryPoint: ShaderModuleEntryPointCompute | undefined = this.mEntryPoints.compute.get(pEntryName);\r\n        if (!lEntryPoint) {\r\n            throw new Exception(`Compute entry point \"${pEntryName}\" does not exists.`, this);\r\n        }\r\n\r\n        // Return shader module without defined workgroup sizes.\r\n        if (!lEntryPoint.static) {\r\n            return new ShaderComputeModule(this.device, this, pEntryName);\r\n        }\r\n\r\n        // Define workgroup sizes.\r\n        return new ShaderComputeModule(this.device, this, pEntryName, [lEntryPoint.workgroupDimension.x ?? 1, lEntryPoint.workgroupDimension.y ?? 1, lEntryPoint.workgroupDimension.z ?? 1]);\r\n    }\r\n\r\n    /**\r\n     * Create a render module from a vertex and fragment entry point.\r\n     * \r\n     * @param pVertexEntryName - Vertex entry point.\r\n     * @param pFragmentEntryName - Optional fragment entry point.\r\n     * \r\n     * @returns shader render module. \r\n     */\r\n    public createRenderModule(pVertexEntryName: string, pFragmentEntryName?: string): ShaderRenderModule {\r\n        // Ensure setup is called.\r\n        this.ensureSetup();\r\n\r\n        const lVertexEntryPoint: ShaderModuleEntryPointVertex | undefined = this.mEntryPoints.vertex.get(pVertexEntryName);\r\n        if (!lVertexEntryPoint) {\r\n            throw new Exception(`Vertex entry point \"${pVertexEntryName}\" does not exists.`, this);\r\n        }\r\n\r\n        // Return shader module without fragment entry.\r\n        if (!pFragmentEntryName) {\r\n            return new ShaderRenderModule(this.device, this, pVertexEntryName, lVertexEntryPoint.parameter);\r\n        }\r\n\r\n        // Validate fragment entry point.\r\n        const lFragmentEntryPoint: ShaderModuleEntryPointFragment | undefined = this.mEntryPoints.fragment.get(pFragmentEntryName);\r\n        if (!lFragmentEntryPoint) {\r\n            throw new Exception(`Fragment entry point \"${pFragmentEntryName}\" does not exists.`, this);\r\n        }\r\n\r\n        return new ShaderRenderModule(this.device, this, pVertexEntryName, lVertexEntryPoint.parameter, pFragmentEntryName);\r\n    }\r\n\r\n    /**\r\n     * Get shader pipeline parameters.\r\n     * \r\n     * @param pParameterName - Parameter name.\r\n     */\r\n    public parameter(pParameterName: string): Set<ComputeStage> {\r\n        // Ensure setup is called.\r\n        this.ensureSetup();\r\n\r\n        // Try to read parameter type.\r\n        const lParameterType: Set<ComputeStage> | undefined = this.mParameter.get(pParameterName);\r\n        if (!lParameterType) {\r\n            throw new Exception(`Shader has parameter \"${pParameterName}\" not defined.`, this);\r\n        }\r\n\r\n        return new Set(lParameterType);\r\n    }\r\n\r\n    /**\r\n     * Setup render targets.\r\n     * Can only be called once and is the only way to create or add target textures.\r\n     * \r\n     * @param pSetup - Setup call.\r\n     * \r\n     * @returns this. \r\n     */\r\n    public override setup(pSetupCallback?: ((pSetup: ShaderSetup) => void) | undefined): this {\r\n        return super.setup(pSetupCallback);\r\n    }\r\n\r\n    /**\r\n     * Generate shader module.\r\n     */\r\n    protected override generateNative(): GPUShaderModule {\r\n        // Read pipeline for compilation hints.\r\n        const lPipelineLayout = this.mPipelineLayout!.native;\r\n\r\n        // Create compilationHints for every entry point\r\n        const lCompilationHints: Array<GPUShaderModuleCompilationHint> = new Array<GPUShaderModuleCompilationHint>();\r\n        for (const lEntryName of [...this.mEntryPoints.vertex.keys(), ...this.mEntryPoints.fragment.keys(), ...this.mEntryPoints.compute.keys()]) {\r\n            lCompilationHints.push({\r\n                entryPoint: lEntryName,\r\n                layout: lPipelineLayout\r\n            });\r\n        }\r\n\r\n        // Create shader module use hints to speed up compilation on safari.\r\n        return this.device.gpu.createShaderModule({\r\n            code: this.mSource,\r\n            compilationHints: lCompilationHints,\r\n            // sourceMap: this.mSourceMap ?? {} // TODO: For now\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Setup with setup object.\r\n     * \r\n     * @param pReferences - Used references.\r\n     */\r\n    protected override onSetup(pReferences: ShaderSetupReferenceData): void {\r\n        // Setup parameter.\r\n        for (const lParameter of pReferences.parameter) {\r\n            // Dont override parameters.\r\n            if (this.mParameter.has(lParameter.name)) {\r\n                throw new Exception(`Can't add parameter \"${lParameter.name}\" more than once.`, this);\r\n            }\r\n\r\n            // Add parameter.\r\n            this.mParameter.set(lParameter.name, new Set<ComputeStage>(lParameter.usage));\r\n        }\r\n\r\n        // Convert fragment entry point informations\r\n        for (const lFragmentEntry of pReferences.fragmentEntrypoints) {\r\n            // Restrict doublicate fragment entry names.\r\n            if (this.mEntryPoints.fragment.has(lFragmentEntry.name)) {\r\n                throw new Exception(`Fragment entry \"${lFragmentEntry.name}\" was setup more than once.`, this);\r\n            }\r\n\r\n            // Convert all render attachments to a location mapping.\r\n            const lRenderTargetLocations: Set<number> = new Set<number>();\r\n            const lRenderTargets: ShaderModuleEntryPointFragment['renderTargets'] = new Dictionary<string, any>();\r\n            for (const lRenderTarget of lFragmentEntry.renderTargets) {\r\n                // Restrict doublicate fragment entry render target names.\r\n                if (lRenderTargets.has(lRenderTarget.name)) {\r\n                    throw new Exception(`Fragment entry \"${lFragmentEntry.name}\" was has doublicate render attachment name \"${lRenderTarget.name}\".`, this);\r\n                }\r\n\r\n                // Restrict doublicate fragment entry render target locations.\r\n                if (lRenderTargetLocations.has(lRenderTarget.location)) {\r\n                    throw new Exception(`Fragment entry \"${lFragmentEntry.name}\" was has doublicate render attachment location index \"${lRenderTarget.location}\".`, this);\r\n                }\r\n\r\n                // Add location to location index buffer. Used for finding dublicates.\r\n                lRenderTargetLocations.add(lRenderTarget.location);\r\n\r\n                // Add target to list. \r\n                lRenderTargets.set(lRenderTarget.name, {\r\n                    name: lRenderTarget.name,\r\n                    location: lRenderTarget.location,\r\n                    format: lRenderTarget.format,\r\n                    multiplier: lRenderTarget.multiplier\r\n                });\r\n            }\r\n\r\n            // Set fragment entry point definition. \r\n            this.mEntryPoints.fragment.set(lFragmentEntry.name, {\r\n                renderTargets: lRenderTargets\r\n            });\r\n        }\r\n\r\n        // Convert vertex entry point informations\r\n        for (const lVertexEntry of pReferences.vertexEntrypoints) {\r\n            // Restrict doublicate vertex entry names.\r\n            if (this.mEntryPoints.vertex.has(lVertexEntry.name)) {\r\n                throw new Exception(`Vertex entry \"${lVertexEntry.name}\" was setup more than once.`, this);\r\n            }\r\n\r\n            // Set vertex entry point definition. \r\n            this.mEntryPoints.vertex.set(lVertexEntry.name, {\r\n                parameter: lVertexEntry.parameter\r\n            });\r\n        }\r\n\r\n        // Convert compute entry point informations\r\n        for (const lComputeEntry of pReferences.computeEntrypoints) {\r\n            // Restrict doublicate compute entry names.\r\n            if (this.mEntryPoints.compute.has(lComputeEntry.name)) {\r\n                throw new Exception(`Vertex entry \"${lComputeEntry.name}\" was setup more than once.`, this);\r\n            }\r\n\r\n            // Set vertex entry point definition. \r\n            this.mEntryPoints.compute.set(lComputeEntry.name, {\r\n                static: lComputeEntry.workgroupDimension !== null,\r\n                workgroupDimension: {\r\n                    x: lComputeEntry.workgroupDimension?.x ?? null,\r\n                    y: lComputeEntry.workgroupDimension?.y ?? null,\r\n                    z: lComputeEntry.workgroupDimension?.z ?? null\r\n                }\r\n            });\r\n        }\r\n\r\n        // Generate initial pipeline layout.\r\n        const lInitialPipelineLayout: Dictionary<number, BindGroupLayout> = new Dictionary<number, BindGroupLayout>();\r\n        for (const lGroup of pReferences.bindingGroups) {\r\n            // Set bind group layout with group index.\r\n            lInitialPipelineLayout.set(lGroup.index, lGroup.group);\r\n        }\r\n        this.mPipelineLayout = new PipelineLayout(this.device, lInitialPipelineLayout);\r\n    }\r\n\r\n    /**\r\n     * Create setup object. Return null to skip any setups.\r\n     * \r\n     *  @param pReferences - Unfilled setup references.\r\n     * \r\n     *  @returns Setup object.\r\n     */\r\n    protected override onSetupObjectCreate(pReferences: GpuObjectSetupReferences<ShaderSetupReferenceData>): ShaderSetup {\r\n        return new ShaderSetup(pReferences);\r\n    }\r\n}\r\n\r\nexport type ShaderModuleEntryPointCompute = {\r\n    static: boolean;\r\n    workgroupDimension: {\r\n        x: number | null;\r\n        y: number | null;\r\n        z: number | null;\r\n    };\r\n};\r\n\r\nexport type ShaderModuleEntryPointVertex = {\r\n    parameter: VertexParameterLayout;\r\n};\r\n\r\nexport type ShaderModuleEntryPointFragmentRenderTarget = {\r\n    name: string;\r\n    location: number;\r\n    format: BufferItemFormat;\r\n    multiplier: BufferItemMultiplier;\r\n};\r\nexport type ShaderModuleEntryPointFragment = {\r\n    renderTargets: Dictionary<string, ShaderModuleEntryPointFragmentRenderTarget>;\r\n};\r\n\r\ntype ShaderModuleEntryPoints = {\r\n    compute: Dictionary<string, ShaderModuleEntryPointCompute>,\r\n    vertex: Dictionary<string, ShaderModuleEntryPointVertex>,\r\n    fragment: Dictionary<string, ShaderModuleEntryPointFragment>,\r\n};", "import { TextureDimension } from '../constant/texture-dimension.enum.ts';\r\nimport { TextureFormat } from '../constant/texture-format.enum.ts';\r\nimport { TextureUsage } from '../constant/texture-usage.enum.ts';\r\nimport { GpuDevice } from '../device/gpu-device.ts';\r\nimport { GpuObject } from '../gpu_object/gpu-object.ts';\r\nimport { GpuObjectInvalidationReasons } from '../gpu_object/gpu-object-invalidation-reasons.ts';\r\nimport { IGpuObjectNative } from '../gpu_object/interface/i-gpu-object-native.ts';\r\n\r\n/**\r\n * Canvas texture. Can only be used as render attachment or to be copied into.\r\n * Allways 2D with preferred format.\r\n */\r\nexport class CanvasTexture extends GpuObject<GPUTexture, CanvasTextureInvalidationType> implements IGpuObjectNative<GPUTexture> {\r\n    private readonly mCanvas: HTMLCanvasElement;\r\n    private mContext: GPUCanvasContext | null;\r\n    private readonly mFrameListener: () => void;\r\n\r\n    /**\r\n     * HTML canvas element.\r\n     */\r\n    public get canvas(): HTMLCanvasElement {\r\n        return this.mCanvas;\r\n    }\r\n\r\n    /**\r\n     * Texture depth.\r\n     */\r\n    public get depth(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Texture dimension.\r\n     */\r\n    public get dimension(): TextureDimension {\r\n        return TextureDimension.ThreeDimension;\r\n    }\r\n\r\n    /**\r\n     * Canvas format.\r\n     */\r\n    public get format(): TextureFormat {\r\n        return this.device.formatValidator.preferredCanvasFormat;\r\n    }\r\n\r\n    /**\r\n     * Texture height.\r\n     */\r\n    public get height(): number {\r\n        return this.mCanvas.height;\r\n    } set height(pValue: number) {\r\n        this.mCanvas.height = pValue;\r\n    }\r\n\r\n    /**\r\n     * Texture mip level count.\r\n     */\r\n    public get mipCount(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Native gpu object.\r\n     */\r\n    public override get native(): GPUTexture {\r\n        return super.native;\r\n    }\r\n\r\n    /**\r\n     * Texture width.\r\n     */\r\n    public get width(): number {\r\n        return this.mCanvas.width;\r\n    } set width(pValue: number) {\r\n        this.mCanvas.width = pValue;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Device.\r\n     * @param pLayout - Texture layout.\r\n     * @param pCanvas - Canvas of texture.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pCanvas: HTMLCanvasElement) {\r\n        super(pDevice);\r\n\r\n        // Set canvas reference.\r\n        this.mCanvas = pCanvas;\r\n        this.mContext = null;\r\n\r\n        // Set defaults.\r\n        this.height = 1;\r\n        this.width = 1;\r\n\r\n        // Rebuild view on every frame.\r\n        this.mFrameListener = () => {\r\n            this.invalidate(CanvasTextureInvalidationType.NativeRebuild);\r\n        };\r\n        this.device.addFrameChangeListener(this.mFrameListener);\r\n    }\r\n\r\n    /**\r\n     * Destory texture object.\r\n     * @param _pNativeObject - Native canvas texture.\r\n     */\r\n    protected override destroyNative(_pNativeObject: GPUTexture, pReasons: GpuObjectInvalidationReasons<CanvasTextureInvalidationType>): void {\r\n        // Only destroy context when child data/layout has changes.\r\n        if (pReasons.deconstruct) {\r\n            // Remove frame listener.\r\n            this.device.removeFrameChangeListener(this.mFrameListener);\r\n\r\n            // Destory context.\r\n            this.mContext!.unconfigure();\r\n            this.mContext = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate native canvas texture view.\r\n     */\r\n    protected override generateNative(): GPUTexture {\r\n        // Configure new context when not alread configured or destroyed.\r\n        if (!this.mContext) {\r\n            // Create and configure canvas context.\r\n            this.mContext = <GPUCanvasContext><any>this.canvas.getContext('webgpu');\r\n            this.mContext.configure({\r\n                device: this.device.gpu,\r\n                format: this.device.formatValidator.preferredCanvasFormat as GPUTextureFormat,\r\n                usage: TextureUsage.CopyDestination | TextureUsage.RenderAttachment,\r\n                alphaMode: 'opaque'\r\n            });\r\n        }\r\n\r\n        // Read current texture of canvas. Needs to be retrieved for each frame.\r\n        const lTexture = this.mContext.getCurrentTexture();\r\n        lTexture.label = 'Canvas-Texture';\r\n\r\n        return lTexture;\r\n    }\r\n}\r\n\r\n\r\nexport enum CanvasTextureInvalidationType {\r\n    NativeRebuild = 'NativeRebuild'\r\n}", "import { Dictionary, EnumUtil } from '@kartoffelgames/core';\r\nimport { GpuFeature } from '../../constant/gpu-feature.enum.ts';\r\nimport { GpuLimit } from '../../constant/gpu-limit.enum.ts';\r\n\r\n/**\r\n * Gpu limits and features.\r\n */\r\nexport class GpuDeviceCapabilities {\r\n    private readonly mFeatures: Set<GpuFeature>;\r\n    private readonly mLimits: Dictionary<GpuLimit, number>;\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pDevice - Gpu adapter.\r\n     */\r\n    public constructor(pDevice: GPUDevice) {\r\n        // Convert all gpu features.\r\n        this.mFeatures = new Set<GpuFeature>();\r\n        for (const lFeature of pDevice.features) {\r\n            const lGpuFeature: GpuFeature | undefined = EnumUtil.cast<GpuFeature>(GpuFeature, lFeature);\r\n            if (lGpuFeature) {\r\n                this.mFeatures.add(lGpuFeature);\r\n            }\r\n        }\r\n\r\n        // Convert gpu limits.\r\n        this.mLimits = new Dictionary<GpuLimit, number>();\r\n        for (const lLimitName of EnumUtil.valuesOf<GpuLimit>(GpuLimit)) {\r\n            this.mLimits.set(lLimitName, pDevice.limits[lLimitName] ?? null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get limit value.\r\n     * \r\n     * @param pLimit - Limit name.\r\n     * \r\n     * @returns limitation value. \r\n     */\r\n    public getLimit(pLimit: GpuLimit): number {\r\n        return this.mLimits.get(pLimit)!;\r\n    }\r\n\r\n    /**\r\n     * Check if gpu has the specified feature.\r\n     * \r\n     * @param pFeature - Feature name.\r\n     * \r\n     * @returns true when gpu has the feature. \r\n     */\r\n    public hasFeature(pFeature: GpuFeature): boolean {\r\n        return this.mFeatures.has(pFeature);\r\n    }\r\n}\r\n", "export enum TextureSampleType {\r\n    Float = 'float',\r\n    SignedInteger = 'sint',\r\n    UnsignedInteger = 'uint',\r\n    UnfilterableFloat = 'unfilterable-float',\r\n    Depth = 'depth'\r\n}", "import { Dictionary, Exception } from '@kartoffelgames/core';\r\nimport { GpuFeature } from '../../constant/gpu-feature.enum.ts';\r\nimport { TextureAspect } from '../../constant/texture-aspect.enum.ts';\r\nimport { TextureDimension } from '../../constant/texture-dimension.enum.ts';\r\nimport { TextureFormat } from '../../constant/texture-format.enum.ts';\r\nimport { TextureSampleType } from '../../constant/texture-sample-type.enum.ts';\r\nimport { TextureUsage } from '../../constant/texture-usage.enum.ts';\r\nimport { GpuDevice } from '../gpu-device.ts';\r\n\r\nexport class GpuTextureFormatCapabilities {\r\n    private readonly mDevice: GpuDevice;\r\n    private readonly mFormatCapabilitys: Dictionary<TextureFormat, TextureFormatCapabilityDefinition>;\r\n\r\n    /**\r\n     * Get prefered canvas format.\r\n     */\r\n    public get preferredCanvasFormat(): TextureFormat {\r\n        return globalThis.navigator.gpu.getPreferredCanvasFormat() as TextureFormat;\r\n    }\r\n\r\n    /**\r\n     * Constructor. Inits capabilities.\r\n     * \r\n     * @param pDevice - Device.\r\n     */\r\n    public constructor(pDevice: GpuDevice) {\r\n        this.mDevice = pDevice;\r\n\r\n        // Construct sample type for float32 texture types.\r\n        const lFloat32Filterable: Array<TextureSampleType> = [TextureSampleType.UnfilterableFloat];\r\n        if (this.mDevice.capabilities.hasFeature(GpuFeature.Float32Filterable)) {\r\n            lFloat32Filterable.push(TextureSampleType.Float);\r\n        }\r\n\r\n        // Setup any format with its capabilities.\r\n        this.mFormatCapabilitys = new Dictionary<TextureFormat, TextureFormatCapabilityDefinition>();\r\n\r\n        // 8-bit formats\r\n        this.mFormatCapabilitys.set(TextureFormat.R8unorm, {\r\n            format: TextureFormat.R8unorm,\r\n            aspect: {\r\n                types: [TextureAspect.Red],\r\n                byteCost: 1\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.Float, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: true,\r\n                    blendable: true,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.R8unorm],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false,\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.R8snorm, {\r\n            format: TextureFormat.R8snorm,\r\n            aspect: {\r\n                types: [TextureAspect.Red],\r\n                byteCost: 1\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.Float, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: false,\r\n                copy: {\r\n                    compatible: [TextureFormat.R8snorm],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.R8uint, {\r\n            format: TextureFormat.R8uint,\r\n            aspect: {\r\n                types: [TextureAspect.Red],\r\n                byteCost: 1\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.UnsignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.R8uint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.R8sint, {\r\n            format: TextureFormat.R8sint,\r\n            aspect: {\r\n                types: [TextureAspect.Red],\r\n                byteCost: 1\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.SignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.R8sint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n\r\n        // 16-bit formats\r\n        this.mFormatCapabilitys.set(TextureFormat.R16uint, {\r\n            format: TextureFormat.R16uint,\r\n            aspect: {\r\n                types: [TextureAspect.Red],\r\n                byteCost: 2\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.UnsignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.R16uint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.R16sint, {\r\n            format: TextureFormat.R16sint,\r\n            aspect: {\r\n                types: [TextureAspect.Red],\r\n                byteCost: 2\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.SignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.R16sint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.R16float, {\r\n            format: TextureFormat.R16float,\r\n            aspect: {\r\n                types: [TextureAspect.Red],\r\n                byteCost: 2\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.Float, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: true,\r\n                    blendable: true,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.R16float],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rg8unorm, {\r\n            format: TextureFormat.Rg8unorm,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green],\r\n                byteCost: 1\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.Float, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: true,\r\n                    blendable: true,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rg8unorm],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rg8snorm, {\r\n            format: TextureFormat.Rg8snorm,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green],\r\n                byteCost: 1\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.Float, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: false,\r\n                copy: {\r\n                    compatible: [TextureFormat.Rg8snorm],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rg8uint, {\r\n            format: TextureFormat.Rg8uint,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green],\r\n                byteCost: 1\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.UnsignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rg8uint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rg8sint, {\r\n            format: TextureFormat.Rg8sint,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green],\r\n                byteCost: 1\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.SignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rg8sint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n\r\n        // 32-bit formats\r\n        this.mFormatCapabilitys.set(TextureFormat.R32uint, {\r\n            format: TextureFormat.R32uint,\r\n            aspect: {\r\n                types: [TextureAspect.Red],\r\n                byteCost: 4\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.UnsignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: false,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.R32uint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: {\r\n                    readonly: true,\r\n                    writeonly: true,\r\n                    readwrite: true\r\n                }\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.R32sint, {\r\n            format: TextureFormat.R32sint,\r\n            aspect: {\r\n                types: [TextureAspect.Red],\r\n                byteCost: 4\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.SignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: false,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.R32sint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: {\r\n                    readonly: true,\r\n                    writeonly: true,\r\n                    readwrite: true\r\n                }\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.R32float, {\r\n            format: TextureFormat.R32float,\r\n            aspect: {\r\n                types: [TextureAspect.Red],\r\n                byteCost: 4\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: lFloat32Filterable,\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.R32float],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: {\r\n                    readonly: true,\r\n                    writeonly: true,\r\n                    readwrite: true\r\n                }\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rg16uint, {\r\n            format: TextureFormat.Rg16uint,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green],\r\n                byteCost: 2\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.UnsignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rg16uint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rg16sint, {\r\n            format: TextureFormat.Rg16sint,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green],\r\n                byteCost: 2\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.SignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rg16sint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rg16float, {\r\n            format: TextureFormat.Rg16float,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green],\r\n                byteCost: 2\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.Float, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: true,\r\n                    blendable: true,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rg16float],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rgba8unorm, {\r\n            format: TextureFormat.Rgba8unorm,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                byteCost: 1\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.Float, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: true,\r\n                    blendable: true,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rgba8unorm, TextureFormat.Rgba8unormSrgb],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: {\r\n                    readonly: true,\r\n                    writeonly: true,\r\n                    readwrite: false\r\n                }\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rgba8unormSrgb, {\r\n            format: TextureFormat.Rgba8unormSrgb,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                byteCost: 1\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.Float, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: true,\r\n                    blendable: true,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rgba8unormSrgb, TextureFormat.Rgba8unorm],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rgba8snorm, {\r\n            format: TextureFormat.Rgba8snorm,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                byteCost: 1\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.Float, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: false,\r\n                copy: {\r\n                    compatible: [TextureFormat.Rgba8snorm],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: {\r\n                    readonly: true,\r\n                    writeonly: true,\r\n                    readwrite: false\r\n                }\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rgba8uint, {\r\n            format: TextureFormat.Rgba8uint,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                byteCost: 1\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.UnsignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rgba8uint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: {\r\n                    readonly: true,\r\n                    writeonly: true,\r\n                    readwrite: false\r\n                }\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rgba8sint, {\r\n            format: TextureFormat.Rgba8sint,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                byteCost: 1\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.SignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rgba8sint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: {\r\n                    readonly: true,\r\n                    writeonly: true,\r\n                    readwrite: false\r\n                }\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Bgra8unorm, {\r\n            format: TextureFormat.Bgra8unorm,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                byteCost: 1\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.Float, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: true,\r\n                    blendable: true,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Bgra8unorm, TextureFormat.Bgra8unormSrgb],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: {\r\n                    readonly: pDevice.capabilities.hasFeature(GpuFeature.Bgra8unormStorage),\r\n                    writeonly: false,\r\n                    readwrite: false\r\n                }\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Bgra8unormSrgb, {\r\n            format: TextureFormat.Bgra8unormSrgb,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                byteCost: 1\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.Float, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: true,\r\n                    blendable: true,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Bgra8unormSrgb, TextureFormat.Bgra8unorm],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n\r\n        // Packed 32-bit formats\r\n        this.mFormatCapabilitys.set(TextureFormat.Rgb9e5ufloat, {\r\n            format: TextureFormat.Rgb9e5ufloat,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                byteCost: 1\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.Float, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: false,\r\n                copy: {\r\n                    compatible: [TextureFormat.Rgb9e5ufloat],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rgb10a2uint, {\r\n            format: TextureFormat.Rgb10a2uint,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                byteCost: 2\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.UnsignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rgb10a2uint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rgb10a2unorm, {\r\n            format: TextureFormat.Rgb10a2unorm,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                byteCost: 2\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.Float, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: true,\r\n                    blendable: true,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rgb10a2unorm],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rg11b10ufloat, {\r\n            format: TextureFormat.Rg11b10ufloat,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                byteCost: 2\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.Float, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: pDevice.capabilities.hasFeature(GpuFeature.Rg11b10ufloatRenderable) ? {\r\n                    resolveTarget: true,\r\n                    blendable: true,\r\n                    multisample: true,\r\n                } : false,\r\n                copy: {\r\n                    compatible: [TextureFormat.Rg11b10ufloat],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n\r\n        // 64-bit formats\r\n        this.mFormatCapabilitys.set(TextureFormat.Rg32uint, {\r\n            format: TextureFormat.Rg32uint,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green],\r\n                byteCost: 4\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.UnsignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: false,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rg32uint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: {\r\n                    readonly: true,\r\n                    writeonly: true,\r\n                    readwrite: false\r\n                }\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rg32sint, {\r\n            format: TextureFormat.Rg32sint,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green],\r\n                byteCost: 4\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.SignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: false,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rg32sint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: {\r\n                    readonly: true,\r\n                    writeonly: true,\r\n                    readwrite: false\r\n                }\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rg32float, {\r\n            format: TextureFormat.Rg32float,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green],\r\n                byteCost: 4\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: lFloat32Filterable,\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: false,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rg32float],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: {\r\n                    readonly: true,\r\n                    writeonly: true,\r\n                    readwrite: false\r\n                }\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rgba16uint, {\r\n            format: TextureFormat.Rgba16uint,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                byteCost: 2\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.UnsignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rgba16uint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: {\r\n                    readonly: true,\r\n                    writeonly: true,\r\n                    readwrite: false\r\n                }\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rgba16sint, {\r\n            format: TextureFormat.Rgba16sint,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                byteCost: 2\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.SignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rgba16sint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: {\r\n                    readonly: true,\r\n                    writeonly: true,\r\n                    readwrite: false\r\n                }\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rgba16float, {\r\n            format: TextureFormat.Rgba16float,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                byteCost: 2\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.Float, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: true,\r\n                    blendable: true,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rgba16float],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: {\r\n                    readonly: true,\r\n                    writeonly: true,\r\n                    readwrite: false\r\n                }\r\n            }\r\n        });\r\n\r\n        // 128-bit formats\r\n        this.mFormatCapabilitys.set(TextureFormat.Rgba32uint, {\r\n            format: TextureFormat.Rgba32uint,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                byteCost: 4\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.UnsignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: false,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rgba32uint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: {\r\n                    readonly: true,\r\n                    writeonly: true,\r\n                    readwrite: false\r\n                }\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rgba32sint, {\r\n            format: TextureFormat.Rgba32sint,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                byteCost: 4\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: [TextureSampleType.SignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: false,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rgba32sint],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: {\r\n                    readonly: true,\r\n                    writeonly: true,\r\n                    readwrite: false\r\n                }\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Rgba32float, {\r\n            format: TextureFormat.Rgba32float,\r\n            aspect: {\r\n                types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                byteCost: 4\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension, TextureDimension.ThreeDimension],\r\n            type: lFloat32Filterable,\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: false,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Rgba32float],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: {\r\n                    readonly: true,\r\n                    writeonly: true,\r\n                    readwrite: false\r\n                }\r\n            }\r\n        });\r\n\r\n        // Depth/stencil formats\r\n        this.mFormatCapabilitys.set(TextureFormat.Stencil8, {\r\n            format: TextureFormat.Stencil8,\r\n            aspect: {\r\n                types: [TextureAspect.Stencil],\r\n                byteCost: 1\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension],\r\n            type: [TextureSampleType.UnsignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Stencil8],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Depth16unorm, {\r\n            format: TextureFormat.Depth16unorm,\r\n            aspect: {\r\n                types: [TextureAspect.Depth],\r\n                byteCost: 2\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension],\r\n            type: [TextureSampleType.Depth, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Depth16unorm],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: true\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Depth24plus, {\r\n            format: TextureFormat.Depth24plus,\r\n            aspect: {\r\n                types: [TextureAspect.Depth],\r\n                byteCost: 4\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension],\r\n            type: [TextureSampleType.Depth, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Depth24plus],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: false,\r\n                    imageDestination: false\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Depth24plusStencil8, {\r\n            format: TextureFormat.Depth24plusStencil8,\r\n            aspect: {\r\n                types: [TextureAspect.Depth, TextureAspect.Stencil],\r\n                byteCost: 2\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension],\r\n            type: [TextureSampleType.Depth, TextureSampleType.UnfilterableFloat, TextureSampleType.UnsignedInteger],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Depth24plusStencil8],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: false, // Stencil supports image copy but depth does not.\r\n                    imageDestination: false // Stencil supports image copy but depth does not.\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n        this.mFormatCapabilitys.set(TextureFormat.Depth32float, {\r\n            format: TextureFormat.Depth32float,\r\n            aspect: {\r\n                types: [TextureAspect.Depth],\r\n                byteCost: 4\r\n            },\r\n            dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension],\r\n            type: [TextureSampleType.Depth, TextureSampleType.UnfilterableFloat],\r\n            compressionBlock: { width: 1, height: 1 },\r\n            usage: {\r\n                textureBinding: true,\r\n                renderAttachment: {\r\n                    resolveTarget: false,\r\n                    blendable: false,\r\n                    multisample: true,\r\n                },\r\n                copy: {\r\n                    compatible: [TextureFormat.Depth32float],\r\n                    textureSource: true,\r\n                    textureDestination: true,\r\n                    imageSource: true,\r\n                    imageDestination: false\r\n                },\r\n                storage: false\r\n            }\r\n        });\r\n\r\n        // \"depth32float-stencil8\" feature\r\n        if (pDevice.capabilities.hasFeature(GpuFeature.Depth32floatStencil8)) {\r\n            this.mFormatCapabilitys.set(TextureFormat.Depth32floatStencil8, {\r\n                format: TextureFormat.Depth32floatStencil8,\r\n                aspect: {\r\n                    types: [TextureAspect.Depth, TextureAspect.Stencil],\r\n                    byteCost: 4\r\n                },\r\n                dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension],\r\n                type: [TextureSampleType.Depth, TextureSampleType.UnfilterableFloat, TextureSampleType.UnsignedInteger],\r\n                compressionBlock: { width: 1, height: 1 },\r\n                usage: {\r\n                    textureBinding: true,\r\n                    renderAttachment: {\r\n                        resolveTarget: false,\r\n                        blendable: false,\r\n                        multisample: true,\r\n                    },\r\n                    copy: {\r\n                        compatible: [TextureFormat.Depth32floatStencil8],\r\n                        textureSource: true,\r\n                        textureDestination: true,\r\n                        imageSource: true,\r\n                        imageDestination: false\r\n                    },\r\n                    storage: false\r\n                }\r\n            });\r\n        }\r\n\r\n        // BC compressed formats\r\n        if (pDevice.capabilities.hasFeature(GpuFeature.TextureCompressionBc)) {\r\n            const lBcTextureFormatCapability = (pFormat: TextureFormat, pAspects: Array<TextureAspect>, pByteOfAspect: number, pCompatible: Array<TextureFormat>) => {\r\n                const lFormat: TextureFormatCapabilityDefinition = {\r\n                    format: pFormat,\r\n                    aspect: {\r\n                        types: pAspects,\r\n                        byteCost: pByteOfAspect\r\n                    },\r\n                    dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension],\r\n                    type: [TextureSampleType.UnfilterableFloat, TextureSampleType.Float],\r\n                    compressionBlock: { width: 4, height: 4 },\r\n                    usage: {\r\n                        textureBinding: true,\r\n                        renderAttachment: false,\r\n                        copy: {\r\n                            compatible: [pFormat, ...pCompatible],\r\n                            textureSource: true,\r\n                            textureDestination: true,\r\n                            imageSource: true,\r\n                            imageDestination: true\r\n                        },\r\n                        storage: false\r\n                    }\r\n                };\r\n\r\n                if (pDevice.capabilities.hasFeature(GpuFeature.TextureCompressionBcSliced3d)) {\r\n                    lFormat.dimensions.push(TextureDimension.ThreeDimension);\r\n                }\r\n\r\n                return lFormat;\r\n            };\r\n\r\n            this.mFormatCapabilitys.set(TextureFormat.Bc1RgbaUnorm, lBcTextureFormatCapability(TextureFormat.Bc1RgbaUnorm, [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha], 2, [TextureFormat.Bc1RgbaUnormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Bc1RgbaUnormSrgb, lBcTextureFormatCapability(TextureFormat.Bc1RgbaUnormSrgb, [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha], 2, [TextureFormat.Bc1RgbaUnorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Bc2RgbaUnorm, lBcTextureFormatCapability(TextureFormat.Bc2RgbaUnorm, [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha], 4, [TextureFormat.Bc2RgbaUnormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Bc2RgbaUnormSrgb, lBcTextureFormatCapability(TextureFormat.Bc2RgbaUnormSrgb, [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha], 4, [TextureFormat.Bc2RgbaUnorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Bc3RgbaUnorm, lBcTextureFormatCapability(TextureFormat.Bc3RgbaUnorm, [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha], 4, [TextureFormat.Bc3RgbaUnormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Bc3RgbaUnormSrgb, lBcTextureFormatCapability(TextureFormat.Bc3RgbaUnormSrgb, [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha], 4, [TextureFormat.Bc3RgbaUnorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Bc4Runorm, lBcTextureFormatCapability(TextureFormat.Bc4Runorm, [TextureAspect.Red], 8, []));\r\n            this.mFormatCapabilitys.set(TextureFormat.Bc4Rsnorm, lBcTextureFormatCapability(TextureFormat.Bc4Rsnorm, [TextureAspect.Red], 8, []));\r\n            this.mFormatCapabilitys.set(TextureFormat.Bc5RgUnorm, lBcTextureFormatCapability(TextureFormat.Bc5RgUnorm, [TextureAspect.Red, TextureAspect.Green], 8, []));\r\n            this.mFormatCapabilitys.set(TextureFormat.Bc5RgSnorm, lBcTextureFormatCapability(TextureFormat.Bc5RgSnorm, [TextureAspect.Red, TextureAspect.Green], 8, []));\r\n            this.mFormatCapabilitys.set(TextureFormat.Bc6hRgbUfloat, lBcTextureFormatCapability(TextureFormat.Bc6hRgbUfloat, [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue], 4, []));\r\n            this.mFormatCapabilitys.set(TextureFormat.Bc6hRgbFloat, lBcTextureFormatCapability(TextureFormat.Bc6hRgbFloat, [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue], 4, []));\r\n            this.mFormatCapabilitys.set(TextureFormat.Bc7RgbaUnorm, lBcTextureFormatCapability(TextureFormat.Bc7RgbaUnorm, [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha], 4, [TextureFormat.Bc7RgbaUnormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Bc7RgbaUnormSrgb, lBcTextureFormatCapability(TextureFormat.Bc7RgbaUnormSrgb, [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha], 4, [TextureFormat.Bc7RgbaUnorm]));\r\n        }\r\n\r\n        // ETC2 compressed formats\r\n        if (pDevice.capabilities.hasFeature(GpuFeature.TextureCompressionEtc2)) {\r\n            const lEtc2TextureFormatCapability = (pFormat: TextureFormat, pAspects: Array<TextureAspect>, pByteOfAspect: number, pCompatible: Array<TextureFormat>) => {\r\n                const lFormat: TextureFormatCapabilityDefinition = {\r\n                    format: pFormat,\r\n                    aspect: {\r\n                        types: pAspects,\r\n                        byteCost: pByteOfAspect\r\n                    },\r\n                    dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension],\r\n                    type: [TextureSampleType.UnfilterableFloat, TextureSampleType.Float],\r\n                    compressionBlock: { width: 4, height: 4 },\r\n                    usage: {\r\n                        textureBinding: true,\r\n                        renderAttachment: false,\r\n                        copy: {\r\n                            compatible: [pFormat, ...pCompatible],\r\n                            textureSource: true,\r\n                            textureDestination: true,\r\n                            imageSource: true,\r\n                            imageDestination: true\r\n                        },\r\n                        storage: false\r\n                    }\r\n                };\r\n\r\n                return lFormat;\r\n            };\r\n\r\n            this.mFormatCapabilitys.set(TextureFormat.Etc2Rgb8unorm, lEtc2TextureFormatCapability(TextureFormat.Etc2Rgb8unorm, [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue], 2, [TextureFormat.Etc2Rgb8unormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Etc2Rgb8unormSrgb, lEtc2TextureFormatCapability(TextureFormat.Etc2Rgb8unormSrgb, [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue], 2, [TextureFormat.Etc2Rgb8unorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Etc2Rgb8a1unorm, lEtc2TextureFormatCapability(TextureFormat.Etc2Rgb8a1unorm, [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha], 2, [TextureFormat.Etc2Rgb8a1unormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Etc2Rgb8a1unormSrgb, lEtc2TextureFormatCapability(TextureFormat.Etc2Rgb8a1unormSrgb, [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha], 2, [TextureFormat.Etc2Rgb8a1unorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Etc2Rgba8unorm, lEtc2TextureFormatCapability(TextureFormat.Etc2Rgba8unorm, [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha], 4, [TextureFormat.Etc2Rgba8unormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Etc2Rgba8unormSrgb, lEtc2TextureFormatCapability(TextureFormat.Etc2Rgba8unormSrgb, [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha], 4, [TextureFormat.Etc2Rgba8unorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.EacR11unorm, lEtc2TextureFormatCapability(TextureFormat.EacR11unorm, [TextureAspect.Red], 8, []));\r\n            this.mFormatCapabilitys.set(TextureFormat.EacR11snorm, lEtc2TextureFormatCapability(TextureFormat.EacR11snorm, [TextureAspect.Red], 8, []));\r\n            this.mFormatCapabilitys.set(TextureFormat.EacRg11unorm, lEtc2TextureFormatCapability(TextureFormat.EacRg11unorm, [TextureAspect.Red, TextureAspect.Green], 8, []));\r\n            this.mFormatCapabilitys.set(TextureFormat.EacRg11snorm, lEtc2TextureFormatCapability(TextureFormat.EacRg11snorm, [TextureAspect.Red, TextureAspect.Green], 8, []));\r\n        }\r\n\r\n        // ASTC compressed formats\r\n        if (pDevice.capabilities.hasFeature(GpuFeature.TextureCompressionAstc)) {\r\n            const lAstcTextureFormatCapability = (pFormat: TextureFormat, pCompressionLevel: [number, number], pCompatible: Array<TextureFormat>) => {\r\n                const lFormat: TextureFormatCapabilityDefinition = {\r\n                    format: pFormat,\r\n                    aspect: {\r\n                        types: [TextureAspect.Red, TextureAspect.Green, TextureAspect.Blue, TextureAspect.Alpha],\r\n                        byteCost: 4\r\n                    },\r\n                    dimensions: [TextureDimension.OneDimension, TextureDimension.TwoDimension],\r\n                    type: [TextureSampleType.UnfilterableFloat, TextureSampleType.Float],\r\n                    compressionBlock: {\r\n                        width: pCompressionLevel[0],\r\n                        height: pCompressionLevel[1]\r\n                    },\r\n                    usage: {\r\n                        textureBinding: true,\r\n                        renderAttachment: false,\r\n                        copy: {\r\n                            compatible: [pFormat, ...pCompatible],\r\n                            textureSource: true,\r\n                            textureDestination: true,\r\n                            imageSource: true,\r\n                            imageDestination: true\r\n                        },\r\n                        storage: false\r\n                    }\r\n                };\r\n\r\n                return lFormat;\r\n            };\r\n\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc4x4unorm, lAstcTextureFormatCapability(TextureFormat.Astc4x4unorm, [4, 4], [TextureFormat.Astc4x4unormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc4x4unormSrgb, lAstcTextureFormatCapability(TextureFormat.Astc4x4unormSrgb, [4, 4], [TextureFormat.Astc4x4unorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc5x4unorm, lAstcTextureFormatCapability(TextureFormat.Astc5x4unorm, [5, 4], [TextureFormat.Astc5x4unormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc5x4unormSrgb, lAstcTextureFormatCapability(TextureFormat.Astc5x4unormSrgb, [5, 4], [TextureFormat.Astc5x4unorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc5x5unorm, lAstcTextureFormatCapability(TextureFormat.Astc5x5unorm, [5, 5], [TextureFormat.Astc5x5unormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc5x5unormSrgb, lAstcTextureFormatCapability(TextureFormat.Astc5x5unormSrgb, [5, 5], [TextureFormat.Astc5x5unorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc6x5unorm, lAstcTextureFormatCapability(TextureFormat.Astc6x5unorm, [6, 5], [TextureFormat.Astc6x5unormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc6x5unormSrgb, lAstcTextureFormatCapability(TextureFormat.Astc6x5unormSrgb, [6, 5], [TextureFormat.Astc6x5unorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc6x6unorm, lAstcTextureFormatCapability(TextureFormat.Astc6x6unorm, [6, 6], [TextureFormat.Astc6x6unormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc6x6unormSrgb, lAstcTextureFormatCapability(TextureFormat.Astc6x6unormSrgb, [6, 6], [TextureFormat.Astc6x6unorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc8x5unorm, lAstcTextureFormatCapability(TextureFormat.Astc8x5unorm, [8, 5], [TextureFormat.Astc8x5unormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc8x5unormSrgb, lAstcTextureFormatCapability(TextureFormat.Astc8x5unormSrgb, [8, 5], [TextureFormat.Astc8x5unorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc8x6unorm, lAstcTextureFormatCapability(TextureFormat.Astc8x6unorm, [8, 6], [TextureFormat.Astc8x6unormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc8x6unormSrgb, lAstcTextureFormatCapability(TextureFormat.Astc8x6unormSrgb, [8, 6], [TextureFormat.Astc8x6unorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc8x8unorm, lAstcTextureFormatCapability(TextureFormat.Astc8x8unorm, [8, 8], [TextureFormat.Astc8x8unormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc8x8unormSrgb, lAstcTextureFormatCapability(TextureFormat.Astc8x8unormSrgb, [8, 8], [TextureFormat.Astc8x8unorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc10x5unorm, lAstcTextureFormatCapability(TextureFormat.Astc10x5unorm, [10, 5], [TextureFormat.Astc10x5unormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc10x5unormSrgb, lAstcTextureFormatCapability(TextureFormat.Astc10x5unormSrgb, [10, 5], [TextureFormat.Astc10x5unorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc10x6unorm, lAstcTextureFormatCapability(TextureFormat.Astc10x6unorm, [10, 6], [TextureFormat.Astc10x6unormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc10x6unormSrgb, lAstcTextureFormatCapability(TextureFormat.Astc10x6unormSrgb, [10, 6], [TextureFormat.Astc10x6unorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc10x8unorm, lAstcTextureFormatCapability(TextureFormat.Astc10x8unorm, [10, 8], [TextureFormat.Astc10x8unormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc10x8unormSrgb, lAstcTextureFormatCapability(TextureFormat.Astc10x8unormSrgb, [10, 8], [TextureFormat.Astc10x8unorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc10x10unorm, lAstcTextureFormatCapability(TextureFormat.Astc10x10unorm, [10, 10], [TextureFormat.Astc10x10unormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc10x10unormSrgb, lAstcTextureFormatCapability(TextureFormat.Astc10x10unormSrgb, [10, 10], [TextureFormat.Astc10x10unorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc12x10unorm, lAstcTextureFormatCapability(TextureFormat.Astc12x10unorm, [12, 10], [TextureFormat.Astc12x10unormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc12x10unormSrgb, lAstcTextureFormatCapability(TextureFormat.Astc12x10unormSrgb, [12, 10], [TextureFormat.Astc12x10unorm]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc12x12unorm, lAstcTextureFormatCapability(TextureFormat.Astc12x12unorm, [12, 12], [TextureFormat.Astc12x12unormSrgb]));\r\n            this.mFormatCapabilitys.set(TextureFormat.Astc12x12unormSrgb, lAstcTextureFormatCapability(TextureFormat.Astc12x12unormSrgb, [12, 12], [TextureFormat.Astc12x12unorm]));\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Get all texture format capabilities of format.\r\n     * \r\n     * @param pFormat - Format.\r\n     * \r\n     * @returns capabilities of format. \r\n     */\r\n    public capabilityOf(pFormat: TextureFormat): TextureFormatCapability {\r\n        const lCapabilityDefinition: TextureFormatCapabilityDefinition | undefined = this.mFormatCapabilitys.get(pFormat);\r\n        if (!lCapabilityDefinition) {\r\n            throw new Exception(`Format \"${pFormat}\" has no capabilities.`, this);\r\n        }\r\n\r\n        // Gather all texture usages.\r\n        const lTextureUsages: Set<TextureUsage> = new Set<TextureUsage>();\r\n        if (lCapabilityDefinition.usage.copy) {\r\n            // Can be copied.\r\n            if (lCapabilityDefinition.usage.copy.imageSource || lCapabilityDefinition.usage.copy.textureSource) {\r\n                lTextureUsages.add(TextureUsage.CopySource);\r\n            }\r\n            // Can be copied into.\r\n            if (lCapabilityDefinition.usage.copy.imageDestination || lCapabilityDefinition.usage.copy.textureDestination) {\r\n                lTextureUsages.add(TextureUsage.CopyDestination);\r\n            }\r\n        }\r\n        if (lCapabilityDefinition.usage.textureBinding) {\r\n            lTextureUsages.add(TextureUsage.TextureBinding);\r\n        }\r\n        if (lCapabilityDefinition.usage.storage) {\r\n            lTextureUsages.add(TextureUsage.Storage);\r\n        }\r\n        if (lCapabilityDefinition.usage.renderAttachment) {\r\n            lTextureUsages.add(TextureUsage.RenderAttachment);\r\n        }\r\n\r\n        // All sample types and primary filterable.\r\n        const lSampleTypes: [Set<TextureSampleType>, TextureSampleType] = (() => {\r\n            const lAllSampleTypes: Set<TextureSampleType> = new Set<TextureSampleType>(lCapabilityDefinition.type);\r\n            if (lAllSampleTypes.has(TextureSampleType.Float)) {\r\n                return [lAllSampleTypes, TextureSampleType.Float];\r\n            }\r\n            if (lAllSampleTypes.has(TextureSampleType.UnsignedInteger)) {\r\n                return [lAllSampleTypes, TextureSampleType.UnsignedInteger];\r\n            }\r\n            if (lAllSampleTypes.has(TextureSampleType.SignedInteger)) {\r\n                return [lAllSampleTypes, TextureSampleType.SignedInteger];\r\n            }\r\n            if (lAllSampleTypes.has(TextureSampleType.SignedInteger)) {\r\n                return [lAllSampleTypes, TextureSampleType.SignedInteger];\r\n            }\r\n            if (lAllSampleTypes.has(TextureSampleType.Depth)) {\r\n                return [lAllSampleTypes, TextureSampleType.Depth];\r\n            }\r\n\r\n            // Default\r\n            return [lAllSampleTypes, TextureSampleType.UnfilterableFloat];\r\n        })();\r\n\r\n        return {\r\n            format: lCapabilityDefinition.format,\r\n            copyCompatible: new Set<TextureFormat>((lCapabilityDefinition.usage.copy) ? lCapabilityDefinition.usage.copy.compatible : []),\r\n            textureUsages: lTextureUsages,\r\n            dimensions: new Set<TextureDimension>(lCapabilityDefinition.dimensions),\r\n            aspects: new Set<TextureAspect>(lCapabilityDefinition.aspect.types),\r\n            sampleTypes: {\r\n                primary: lSampleTypes[1],\r\n                all: lSampleTypes[0]\r\n            },\r\n            renderAttachment: {\r\n                resolveTarget: (lCapabilityDefinition.usage.renderAttachment) ? lCapabilityDefinition.usage.renderAttachment.resolveTarget : false,\r\n                multisample: (lCapabilityDefinition.usage.renderAttachment) ? lCapabilityDefinition.usage.renderAttachment.multisample : false,\r\n                blendable: (lCapabilityDefinition.usage.renderAttachment) ? lCapabilityDefinition.usage.renderAttachment.blendable : false,\r\n            },\r\n            storage: {\r\n                readonly: (lCapabilityDefinition.usage.storage) ? lCapabilityDefinition.usage.storage.readonly : false,\r\n                writeonly: (lCapabilityDefinition.usage.storage) ? lCapabilityDefinition.usage.storage.writeonly : false,\r\n                readwrite: (lCapabilityDefinition.usage.storage) ? lCapabilityDefinition.usage.storage.readwrite : false,\r\n            },\r\n            copy: {\r\n                textureSource: (lCapabilityDefinition.usage.copy) ? lCapabilityDefinition.usage.copy.textureSource : false,\r\n                textureTarget: (lCapabilityDefinition.usage.copy) ? lCapabilityDefinition.usage.copy.textureDestination : false,\r\n                imageSource: (lCapabilityDefinition.usage.copy) ? lCapabilityDefinition.usage.copy.imageSource : false,\r\n                imageTarget: (lCapabilityDefinition.usage.copy) ? lCapabilityDefinition.usage.copy.imageDestination : false,\r\n            }\r\n        };\r\n    }\r\n}\r\n\r\nexport type TextureFormatCapability = {\r\n    // Format.\r\n    format: TextureFormat;\r\n\r\n    // Copy compatible array: Same format or srgb-Prefix.\r\n    copyCompatible: Set<TextureFormat>;\r\n\r\n    // Usages.\r\n    textureUsages: Set<TextureUsage>;\r\n\r\n    // Usable dimensions. When multisample is used only 2d is allowed. \r\n    dimensions: Set<TextureDimension>;\r\n\r\n    // All aspects for format.\r\n    aspects: Set<TextureAspect>;\r\n\r\n    // Usable sample types.\r\n    sampleTypes: {\r\n        primary: TextureSampleType,\r\n        all: Set<TextureSampleType>;\r\n    },\r\n\r\n    // Usage as render attachment.\r\n    renderAttachment: {\r\n        resolveTarget: boolean;\r\n        multisample: boolean;\r\n        blendable: boolean;\r\n    };\r\n\r\n    // Usages as storage.\r\n    storage: {\r\n        readonly: boolean;\r\n        writeonly: boolean;\r\n        readwrite: boolean;\r\n    };\r\n\r\n    // Usages as copy target or destination.\r\n    copy: {\r\n        textureSource: boolean;\r\n        textureTarget: boolean;\r\n        imageSource: boolean;\r\n        imageTarget: boolean;\r\n    };\r\n};\r\n\r\ntype TextureFormatCapabilityDefinition = {\r\n    // Format.\r\n    format: TextureFormat;\r\n\r\n    // Compression level. Higher level means higher compression.\r\n    compressionBlock: {\r\n        width: number;\r\n        height: number;\r\n    };\r\n\r\n    // Aspects of texture. Only really relevant for depth and stencil textures.\r\n    aspect: {\r\n        types: Array<TextureAspect>;\r\n        byteCost: number;\r\n    };\r\n\r\n    // Usable dimensions. When multisample is used only 2d is allowed. \r\n    dimensions: Array<TextureDimension>;\r\n\r\n    // Primitive type that can be used in shaders.\r\n    type: Array<TextureSampleType>;\r\n\r\n    // Usages\r\n    usage: {\r\n        // Texture can be bound.\r\n        textureBinding: boolean;\r\n\r\n        // Texture can be renderd into\r\n        renderAttachment: {\r\n            resolveTarget: boolean;\r\n            multisample: boolean;\r\n            blendable: boolean;\r\n        } | false;\r\n\r\n        // Can be used to copy textures.\r\n        copy: {\r\n            // Copy compatible array: Same format or srgb-Prefix.\r\n            compatible: Array<TextureFormat>;\r\n\r\n            // Copy capabilities.\r\n            textureSource: boolean;\r\n            textureDestination: boolean;\r\n            imageSource: boolean;\r\n            imageDestination: boolean;\r\n        } | false;\r\n\r\n        // Can be used as a storage.\r\n        storage: {\r\n            readonly: boolean;\r\n            writeonly: boolean;\r\n            readwrite: boolean;\r\n        } | false;\r\n    };\r\n};", "import { Exception, List } from '@kartoffelgames/core';\r\nimport { GpuFeature } from '../constant/gpu-feature.enum.ts';\r\nimport { GpuLimit } from '../constant/gpu-limit.enum.ts';\r\nimport { GpuExecution, GpuExecutionFunction } from '../execution/gpu-execution.ts';\r\nimport { ComputePass, ComputePassExecutionFunction } from '../execution/pass/compute-pass.ts';\r\nimport { RenderPass, RenderPassExecutionFunction } from '../execution/pass/render-pass.ts';\r\nimport { RenderTargets } from '../pipeline/render_targets/render-targets.ts';\r\nimport { Shader } from '../shader/shader.ts';\r\nimport { CanvasTexture } from '../texture/canvas-texture.ts';\r\nimport { GpuDeviceCapabilities } from './capabilities/gpu-device-capabilities.ts';\r\nimport { GpuTextureFormatCapabilities } from './capabilities/gpu-texture-format-capabilities.ts';\r\n\r\nexport class GpuDevice {\r\n    /**\r\n     * Request new gpu device.\r\n     * \r\n     * @param pGenerator - Native object generator.\r\n     */\r\n    public static async request(pPerformance: GPUPowerPreference, pOptions?: GpuDeviceLimitConfiguration): Promise<GpuDevice> {\r\n        // Try to load cached adapter. When not cached, request new one.\r\n        const lAdapter: GPUAdapter | null = await window.navigator.gpu.requestAdapter({ powerPreference: pPerformance });\r\n        if (!lAdapter) {\r\n            throw new Exception('Error requesting GPU adapter', GpuDevice);\r\n        }\r\n\r\n        // Fill in required features and limits.\r\n        const lFeatures: Array<GpuFeature> = new Array<GpuFeature>();\r\n        const lLimits: Record<string, number> = {};\r\n        if (pOptions) {\r\n            // Setup gpu features.\r\n            if (pOptions.features) {\r\n                // Fill in required features.\r\n                for (const lFeature of pOptions.features) {\r\n                    // Exit when required feature is not available.\r\n                    if (!lAdapter.features.has(lFeature.name)) {\r\n                        // Exit when feature was not optional.\r\n                        if (lFeature.required) {\r\n                            throw new Exception(`No Gpu found with the required feature \"${lFeature.name}\"`, this);\r\n                        }\r\n\r\n                        // Skip optional features.\r\n                        continue;\r\n                    }\r\n\r\n                    lFeatures.push(lFeature.name);\r\n                }\r\n            }\r\n\r\n            // Setup gpu limits.\r\n            if (pOptions.limits) {\r\n                // Fill in required features.\r\n                for (const lLimit of pOptions.limits) {\r\n                    // Read available limit.\r\n                    const lAdapterLimit: number | undefined = lAdapter.limits[lLimit.name] as number | undefined;\r\n                    if (typeof lAdapterLimit === 'undefined') {\r\n                        throw new Exception(`Gpu does not support any \"${lLimit.name}\" limit.`, this);\r\n                    }\r\n\r\n                    // Check for adapter available limit.\r\n                    let lAvailableLimit: number = lLimit.value;\r\n                    if (lAdapterLimit < lLimit.value) {\r\n                        // Exit when required limit is not available.\r\n                        if (lLimit.required) {\r\n                            throw new Exception(`No Gpu found with the required limit \"${lLimit.name}\" (has: ${lAdapterLimit}, required: ${lLimit.value})`, this);\r\n                        }\r\n\r\n                        // When not required, use the highest available limit.\r\n                        lAvailableLimit = lAdapterLimit;\r\n                    }\r\n\r\n                    lLimits[lLimit.name] = lAvailableLimit;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Try to load cached device. When not cached, request new one.\r\n        const lDevice: GPUDevice | null = await lAdapter.requestDevice({\r\n            requiredFeatures: lFeatures as Array<GPUFeatureName>,\r\n            requiredLimits: lLimits\r\n        });\r\n        if (!lDevice) {\r\n            throw new Exception('Error requesting GPU device', GpuDevice);\r\n        }\r\n\r\n        return new GpuDevice(lDevice);\r\n    }\r\n\r\n    private readonly mCapabilities: GpuDeviceCapabilities;\r\n    private readonly mFormatValidator: GpuTextureFormatCapabilities;\r\n    private readonly mFrameChangeListener: List<GpuDeviceFrameChangeListener>;\r\n    private mFrameCounter: number;\r\n    private readonly mGpuDevice: GPUDevice;\r\n\r\n\r\n    /**\r\n     * Gpu capabilities.\r\n     */\r\n    public get capabilities(): GpuDeviceCapabilities {\r\n        return this.mCapabilities;\r\n    }\r\n\r\n    /**\r\n     * Texture format validator.\r\n     */\r\n    public get formatValidator(): GpuTextureFormatCapabilities {\r\n        return this.mFormatValidator;\r\n    }\r\n\r\n    /**\r\n     * Get frame count.\r\n     */\r\n    public get frameCount(): number {\r\n        return this.mFrameCounter;\r\n    }\r\n\r\n    /**\r\n     * Gpu device.\r\n     */\r\n    public get gpu(): GPUDevice {\r\n        return this.mGpuDevice;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * \r\n     * @param pGenerator - Native GPU-Object Generator.\r\n     */\r\n    private constructor(pDevice: GPUDevice) {\r\n        this.mGpuDevice = pDevice;\r\n\r\n        // Setup capabilities.\r\n        this.mCapabilities = new GpuDeviceCapabilities(pDevice);\r\n\r\n        // Set default for frame counter.\r\n        this.mFrameCounter = 0;\r\n\r\n        // Init form validator.\r\n        this.mFormatValidator = new GpuTextureFormatCapabilities(this);\r\n\r\n        // Frame change listener.\r\n        this.mFrameChangeListener = new List<GpuDeviceFrameChangeListener>();\r\n    }\r\n\r\n    /**\r\n     * Add listener called on frame change.\r\n     * \r\n     * @param pListener - Listener.\r\n     */\r\n    public addFrameChangeListener(pListener: GpuDeviceFrameChangeListener): void {\r\n        this.mFrameChangeListener.push(pListener);\r\n    }\r\n\r\n    /**\r\n     * Create or use a html canvas to create a canvas texture.\r\n     * \r\n     * @param pCanvas - Created canvas element.\r\n     * \r\n     * @returns canvas texture. \r\n     */\r\n    public canvas(pCanvas?: HTMLCanvasElement): CanvasTexture {\r\n        // Create or use canvas.\r\n        const lCanvas: HTMLCanvasElement = pCanvas ?? document.createElement('canvas');\r\n\r\n        return new CanvasTexture(this, lCanvas);\r\n    }\r\n\r\n    /**\r\n     * Create new compute pass.\r\n     *\r\n     * @returns new compute pass. \r\n     */\r\n    public computePass(pExecution: ComputePassExecutionFunction): ComputePass {\r\n        return new ComputePass(this, pExecution);\r\n    }\r\n\r\n    /**\r\n     * Create pass executor.\r\n     * \r\n     * @param pOnExecute - On executor execute.\r\n     */\r\n    public executor(pOnExecute: GpuExecutionFunction): GpuExecution {\r\n        return new GpuExecution(this, pOnExecute);\r\n    }\r\n\r\n    /**\r\n     * Remove listener called on frame change.\r\n     * \r\n     * @param pListener - Listener.\r\n     */\r\n    public removeFrameChangeListener(pListener: GpuDeviceFrameChangeListener): void {\r\n        this.mFrameChangeListener.remove(pListener);\r\n    }\r\n\r\n    /**\r\n     * Create new render pass.\r\n     * \r\n     * @param pRenderTargets - Render targets of pass.\r\n     * @param pStaticBundle - Bundle is static and does not update very often.\r\n     * \r\n     * @returns new render pass. \r\n     */\r\n    public renderPass(pRenderTargets: RenderTargets, pExecution: RenderPassExecutionFunction, pStaticBundle: boolean = true): RenderPass {\r\n        return new RenderPass(this, pRenderTargets, pStaticBundle, pExecution);\r\n    }\r\n\r\n    /**\r\n     * Create render target object.\r\n     * \r\n     * @param pMultisampled - Render targets are multisampled.\r\n     * \r\n     * @returns render target object. \r\n     */\r\n    public renderTargets(pMultisampled: boolean = false): RenderTargets {\r\n        return new RenderTargets(this, pMultisampled);\r\n    }\r\n\r\n    /**\r\n     * Create shader.\r\n     * \r\n     * @param pSource - Shader source as wgsl.\r\n     */\r\n    public shader(pSource: string): Shader {\r\n        return new Shader(this, pSource);\r\n    }\r\n\r\n    /**\r\n     * Start new frame.\r\n     */\r\n    public startNewFrame(): void {\r\n        this.mFrameCounter++;\r\n\r\n        // Call all frame change listener.\r\n        for (const lListener of this.mFrameChangeListener) {\r\n            lListener();\r\n        }\r\n    }\r\n}\r\n\r\nexport type GpuDeviceFrameChangeListener = () => void;\r\n\r\ntype GpuDeviceLimitConfiguration = {\r\n    features?: Array<{\r\n        name: GpuFeature,\r\n        required?: boolean;\r\n    }>;\r\n    limits?: Array<{\r\n        name: GpuLimit,\r\n        value: number,\r\n        required?: boolean;\r\n    }>;\r\n};", "import { Exception } from '@kartoffelgames/core';\r\n\r\nexport class Vector {\r\n    private readonly mData: Array<number>;\r\n\r\n    /**\r\n     * Get vector data.\r\n     */\r\n    public get data(): Array<number> {\r\n        return this.mData;\r\n    }\r\n\r\n    /**\r\n     * W value quick access. \r\n     */\r\n    public get w(): number {\r\n        return this.mData[3];\r\n    }\r\n\r\n    /**\r\n     * X value quick access. \r\n     */\r\n    public get x(): number {\r\n        return this.mData[0];\r\n    }\r\n\r\n    /**\r\n     * Y value quick access. \r\n     */\r\n    public get y(): number {\r\n        return this.mData[1];\r\n    }\r\n\r\n    /**\r\n     * Z value quick access. \r\n     */\r\n    public get z(): number {\r\n        return this.mData[2];\r\n    }\r\n    \r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pData - Vector data.\r\n     */\r\n    public constructor(pData: Array<number>) {\r\n        this.mData = [...pData];\r\n    }\r\n\r\n    /**\r\n     * Add two vectors.\r\n     * @param pAddData - Vector or scalar.\r\n     */\r\n    public add(pAddData: Vector | number): Vector {\r\n        const lData: Array<number> = new Array<number>();\r\n\r\n        if (pAddData instanceof Vector) {\r\n            // Restrict on same length.\r\n            if (this.mData.length !== pAddData.data.length) {\r\n                throw new Exception('Vectors need to be the same length for calculation.', this);\r\n            }\r\n\r\n            // Add values.\r\n            for (let lIndex: number = 0; lIndex < this.mData.length; lIndex++) {\r\n                lData.push(this.mData[lIndex] + pAddData.data[lIndex]);\r\n            }\r\n        } else {\r\n            // Add scalar to each vector component.\r\n            for (const lItem of this.mData) {\r\n                lData.push(lItem + pAddData);\r\n            }\r\n        }\r\n\r\n        return new Vector(lData);\r\n    }\r\n\r\n    /**\r\n     * Get length of vector.\r\n     */\r\n    public length(): number {\r\n        // Square root sum.\r\n        return Math.hypot(...this.mData);\r\n    }\r\n\r\n    /**\r\n     * Calulate cross product of two vector3.\r\n     * @param pVector - Vector3.\r\n     */\r\n    public multCross(pVector: Vector): Vector {\r\n        // Restrict on same length.\r\n        if (this.mData.length !== pVector.data.length && this.mData.length !== 3) {\r\n            throw new Exception('Vectors need to be the length of 3 for corss product calculation.', this);\r\n        }\r\n\r\n        /*\r\n         * cx = ay*bz \u2212 az*by\r\n         * cy = az*bx \u2212 ax*bz\r\n         * cz = ax*by \u2212 ay*bx\r\n         */\r\n        return new Vector([\r\n            this.mData[1] * pVector.data[2] - this.mData[2] * pVector.data[1],\r\n            this.mData[2] * pVector.data[0] - this.mData[0] * pVector.data[2],\r\n            this.mData[0] * pVector.data[1] - this.mData[1] * pVector.data[0]\r\n        ]);\r\n    }\r\n\r\n    /**\r\n     * Multiply with dot procedure.\r\n     * @param pVector - Vector.\r\n     */\r\n    public multDot(pVector: Vector): number {\r\n        // Restrict on same length.\r\n        if (this.mData.length !== pVector.data.length) {\r\n            throw new Exception('Vectors need to be the same length for calculation.', this);\r\n        }\r\n\r\n        // Calculate dot product.\r\n        let lProduct: number = 0;\r\n        for (let lIndex: number = 0; lIndex < this.mData.length; lIndex++) {\r\n            lProduct += this.mData[lIndex] * pVector.data[lIndex];\r\n        }\r\n\r\n        return lProduct;\r\n    }\r\n\r\n    /**\r\n     * Normalize vector.\r\n     */\r\n    public normalize(): Vector {\r\n        const lLength: number = this.length();\r\n\r\n        // Devide each vector component with it vector length.\r\n        const lData: Array<number> = new Array<number>();\r\n        for (const lItem of this.mData) {\r\n            lData.push(lItem / lLength);\r\n        }\r\n\r\n        return new Vector(lData);\r\n    }\r\n\r\n    /**\r\n     * Substract two vectors.\r\n     * @param pSubData - Vector or scalar\r\n     */\r\n    public sub(pSubData: Vector | number): Vector {\r\n        const lData: Array<number> = new Array<number>();\r\n\r\n        if (pSubData instanceof Vector) {\r\n            // Restrict on same length.\r\n            if (this.mData.length !== pSubData.data.length) {\r\n                throw new Exception('Vectors need to be the same length for calculation.', this);\r\n            }\r\n\r\n            // Add values.\r\n            for (let lIndex: number = 0; lIndex < this.mData.length; lIndex++) {\r\n                lData.push(this.mData[lIndex] - pSubData.data[lIndex]);\r\n            }\r\n        } else {\r\n            // Substract scalar to each vector component.\r\n            for (const lItem of this.mData) {\r\n                lData.push(lItem - pSubData);\r\n            }\r\n        }\r\n\r\n        return new Vector(lData);\r\n    }\r\n}", "import { Exception } from '@kartoffelgames/core';\r\nimport { Vector } from '../math/vector.ts';\r\n\r\nexport class AmbientLight {\r\n    private readonly mColor: Vector;\r\n\r\n    /**\r\n     * Ambient light Vector4 data.\r\n     */\r\n    public get data(): Array<number> {\r\n        return this.mColor.data;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mColor = new Vector([1, 1, 1, 1]);\r\n    }\r\n\r\n    /**\r\n     * Set ambient light color.\r\n     * @param pRed - Red.\r\n     * @param pGreen - Green.\r\n     * @param pBlue - Blue.\r\n     */\r\n    public setColor(pRed: number, pGreen: number, pBlue: number): void {\r\n        if(pRed > 1 || pRed < 0 || pGreen > 1 || pGreen < 0 || pBlue > 1 || pBlue < 0){\r\n            throw new Exception(`Color values need to be in 0 to 1 range. (R:${pRed}, G:${pGreen}, B:${pBlue})`, this);\r\n        }\r\n\r\n        this.mColor.data[0] = pRed;\r\n        this.mColor.data[1] = pGreen;\r\n        this.mColor.data[2] = pBlue;\r\n    }\r\n}", "import { Exception } from '@kartoffelgames/core';\r\nimport { Vector } from './vector.ts';\r\n\r\nexport class Matrix {\r\n    /**\r\n     * Create matrix from data array.\r\n     * Direction from reading columns than rows.\r\n     * @param pArray - Array data. \r\n     * @param pHeight \r\n     * @param pWidth \r\n     * @returns \r\n     */\r\n    public static fromArray(pArray: Array<number>, pHeight: number, pWidth: number): Matrix {\r\n        const lData: Array<Array<number>> = new Array<Array<number>>();\r\n\r\n        for (let lRowIndex = 0; lRowIndex < pHeight; lRowIndex++) {\r\n            const lRowData: Array<number> = new Array<number>(pWidth);\r\n\r\n            for (let lColumnIndex = 0; lColumnIndex < pWidth; lColumnIndex++) {\r\n                lRowData[lColumnIndex] = pArray[(lColumnIndex * pHeight) + lRowIndex];\r\n            }\r\n\r\n            // Add row to data array.\r\n            lData.push(lRowData);\r\n        }\r\n\r\n        return new Matrix(lData);\r\n    }\r\n\r\n    /**\r\n     * Create identity matrix.\r\n     * @param pSize - Matix size: nxn\r\n     * @param pValue - Value of identity. \r\n     */\r\n    public static identity(pSize: number): Matrix {\r\n        const lData: Array<Array<number>> = new Array<Array<number>>();\r\n        for (let lRowIndex = 0; lRowIndex < pSize; lRowIndex++) {\r\n            // Create Array filled with zeros.\r\n            const lRowData: Array<number> = new Array<number>(pSize).fill(0);\r\n\r\n            // Set identity column to value.\r\n            lRowData[lRowIndex] = 1;\r\n\r\n            // Add row to data array.\r\n            lData.push(lRowData);\r\n        }\r\n\r\n        return new Matrix(lData);\r\n    }\r\n\r\n    private readonly mData: Array<Array<number>>;\r\n\r\n    /**\r\n     * Get matix raw data.\r\n     */\r\n    public get data(): Array<Array<number>> {\r\n        return this.mData;\r\n    }\r\n\r\n    /**\r\n     * Data as number array.\r\n     */\r\n    public get dataArray(): Array<number> {\r\n        const lData: Array<number> = new Array<number>();\r\n\r\n        // Read from columns to rows.\r\n        for (let lColumnIndex = 0; lColumnIndex < this.width; lColumnIndex++) {\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                lData.push(this.mData[lRowIndex][lColumnIndex]);\r\n            }\r\n        }\r\n\r\n        return lData;\r\n    }\r\n\r\n    /**\r\n     * Get matrix height.\r\n     */\r\n    public get height(): number {\r\n        return this.mData.length;\r\n    }\r\n\r\n    /**\r\n     * Get matrix width.\r\n     */\r\n    public get width(): number {\r\n        return this.mData[0]?.length ?? 0;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pData - Matrix data.\r\n     */\r\n    public constructor(pData: Array<Array<number>>) {\r\n        this.mData = pData;\r\n    }\r\n\r\n    /**\r\n     * Add value to matrix.\r\n     * @param pAddData - Matrix or scalar value.\r\n     */\r\n    public add(pAddData: Matrix | number): Matrix {\r\n        const lData: Array<Array<number>> = new Array<Array<number>>();\r\n\r\n        if (pAddData instanceof Matrix) {\r\n            // Restrict on same length.\r\n            if (this.height !== pAddData.height && this.width !== pAddData.width) {\r\n                throw new Exception('Matrices need to be the same size for calculation.', this);\r\n            }\r\n\r\n            // Iterate rows and extend data dynamicly by pushing new data rows.\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                // Add each column of row.\r\n                const lRowData: Array<number> = new Array<number>(this.width);\r\n                for (let lColumnIndex = 0; lColumnIndex < lRowData.length; lColumnIndex++) {\r\n                    lRowData[lColumnIndex] = this.mData[lRowIndex][lColumnIndex] + pAddData.data[lRowIndex][lColumnIndex];\r\n                }\r\n\r\n                lData.push(lRowData);\r\n            }\r\n        } else {\r\n            // Add scalar to each matrix component.\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                const lRowData: Array<number> = new Array<number>(this.width);\r\n                for (let lColumnIndex = 0; lColumnIndex < lRowData.length; lColumnIndex++) {\r\n                    lRowData[lColumnIndex] = this.mData[lRowIndex][lColumnIndex] + pAddData;\r\n                }\r\n\r\n                lData.push(lRowData);\r\n            }\r\n        }\r\n\r\n        return new Matrix(lData);\r\n    }\r\n\r\n    /**\r\n     * Adjoint matrix.\r\n     */\r\n    public adjoint(): Matrix {\r\n        const lMatrixData: Array<Array<number>> = new Array<Array<number>>();\r\n\r\n        // Allways use first row and iterate over columns.\r\n        for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n            const lMatrixRow: Array<number> = new Array<number>();\r\n            for (let lColumIndex = 0; lColumIndex < this.width; lColumIndex++) {\r\n                // Calculate determant of matrix with omitted column and row.\r\n                // Toggle sign on each new row or column.\r\n                let lDeterminant: number = this.omit(lRowIndex, lColumIndex).determinant();\r\n                lDeterminant *= Math.pow(-1, (lRowIndex + 1) + (lColumIndex + 1));\r\n\r\n\r\n                lMatrixRow.push(lDeterminant);\r\n            }\r\n\r\n            // Add row to matrix data.\r\n            lMatrixData.push(lMatrixRow);\r\n        }\r\n\r\n        // Calculate transpose from cofactor matrix to get adjoint. \r\n        const lCofactorMatrix = new Matrix(lMatrixData);\r\n        return lCofactorMatrix.transpose();\r\n    }\r\n\r\n    /**\r\n     * Calculate determant of matrix.\r\n     */\r\n    public determinant(): number {\r\n        // Super fast determinant calculation of a 1x1 matrix.\r\n        if (this.height === 1 && this.width === 1) {\r\n            return this.data[0][0];\r\n        }\r\n\r\n        let lDeterminant: number = 0;\r\n        for (let lIterationIndex = 0; lIterationIndex < this.width; lIterationIndex++) {\r\n            // Get number of row iteration to detect if any calculation musst be done.\r\n            let lSignedNumber: number = this.data[0][lIterationIndex];\r\n            lSignedNumber *= (lIterationIndex % 2) ? -1 : 1; // Toggle sign between iteration. Begin with plus.\r\n\r\n            // Check if any calculation needs to be done. Zero multiplicated is allways zero.\r\n            if (lSignedNumber !== 0) {\r\n                // Calculate determinant of new matrix. Allways use first row.\r\n                const lDeterminantMatrix: Matrix = this.omit(0, lIterationIndex);\r\n                lDeterminant += lSignedNumber * lDeterminantMatrix.determinant();\r\n            }\r\n        }\r\n\r\n        return lDeterminant;\r\n    }\r\n\r\n    /**\r\n     * Inverse matrix.\r\n     */\r\n    public inverse(): Matrix {\r\n        const lAdjoint: Matrix = this.adjoint();\r\n        const lDeterminant: number = this.determinant();\r\n\r\n        // Devide each adjoint matrix component by determinant.\r\n        for (let lColumIndex = 0; lColumIndex < this.width; lColumIndex++) {\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                lAdjoint.data[lRowIndex][lColumIndex] /= lDeterminant;\r\n            }\r\n        }\r\n\r\n        return lAdjoint;\r\n    }\r\n\r\n    /**\r\n     * Multiplicate matrix.\r\n     * @param pMultData - Matrix or scalar value.\r\n     */\r\n    public mult(pMultData: Matrix | number): Matrix {\r\n        const lData: Array<Array<number>> = new Array<Array<number>>();\r\n\r\n        if (pMultData instanceof Matrix) {\r\n            // Restrict on same length.\r\n            if (this.width !== pMultData.height) {\r\n                throw new Exception('Matrices A width and B height must match for multiplication.', this);\r\n            }\r\n\r\n            // Iterate rows and extend data dynamicly by pushing new data rows.\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                // Add each column of row.\r\n                const lRowData: Array<number> = new Array<number>(pMultData.width);\r\n                for (let lColumnIndex = 0; lColumnIndex < lRowData.length; lColumnIndex++) {\r\n\r\n                    // Multiplicate target row with source column components.\r\n                    // Iteration length is eighter target.height or source.width.\r\n                    let lProduct: number = 0;\r\n                    for (let lComponentIndex = 0; lComponentIndex < this.height; lComponentIndex++) {\r\n                        lProduct += this.mData[lRowIndex][lComponentIndex] * pMultData.data[lComponentIndex][lColumnIndex];\r\n                    }\r\n                    lRowData[lColumnIndex] = lProduct;\r\n                }\r\n\r\n                lData.push(lRowData);\r\n            }\r\n        } else {\r\n            // Multiplicate scalar to each matrix component.\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                const lRowData: Array<number> = new Array<number>(this.width);\r\n                for (let lColumnIndex = 0; lColumnIndex < this.width; lColumnIndex++) {\r\n                    lRowData[lColumnIndex] = this.mData[lRowIndex][lColumnIndex] * pMultData;\r\n                }\r\n\r\n                lData.push(lRowData);\r\n            }\r\n        }\r\n\r\n        return new Matrix(lData);\r\n    }\r\n\r\n    /**\r\n     * Omit row and column from matrix.\r\n     * @param pOmitRow - Omitting row.\r\n     * @param pOmitColumn - Omiting column\r\n     */\r\n    public omit(pOmitRow: number, pOmitColumn: number): Matrix {\r\n        const lMatrixData: Array<Array<number>> = new Array<Array<number>>();\r\n\r\n        // Allways use first row and iterate over columns.\r\n        for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n            if (lRowIndex !== pOmitRow) {\r\n                const lMatrixRow: Array<number> = new Array<number>();\r\n                for (let lColumIndex = 0; lColumIndex < this.width; lColumIndex++) {\r\n                    // Skip column of\r\n                    if (lColumIndex !== pOmitColumn) {\r\n                        lMatrixRow.push(this.data[lRowIndex][lColumIndex]);\r\n                    }\r\n                }\r\n\r\n                // Add row to matrix data.\r\n                lMatrixData.push(lMatrixRow);\r\n            }\r\n        }\r\n\r\n        return new Matrix(lMatrixData);\r\n    }\r\n\r\n    /**\r\n     * Substract value to matrix.\r\n     * @param pAddData - Matrix or scalar value.\r\n     */\r\n    public sub(pAddData: Matrix | number): Matrix {\r\n        const lData: Array<Array<number>> = new Array<Array<number>>();\r\n\r\n        if (pAddData instanceof Matrix) {\r\n            // Restrict on same length.\r\n            if (this.height !== pAddData.height && this.width !== pAddData.width) {\r\n                throw new Exception('Matrices need to be the same size for calculation.', this);\r\n            }\r\n\r\n            // Iterate rows and extend data dynamicly by pushing new data rows.\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                // Add each column of row.\r\n                const lRowData: Array<number> = new Array<number>(this.width);\r\n                for (let lColumnIndex = 0; lColumnIndex < lRowData.length; lColumnIndex++) {\r\n                    lRowData[lColumnIndex] = this.mData[lRowIndex][lColumnIndex] - pAddData.data[lRowIndex][lColumnIndex];\r\n                }\r\n\r\n                lData.push(lRowData);\r\n            }\r\n        } else {\r\n            // Add scalar to each matrix component.\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                const lRowData: Array<number> = new Array<number>(this.width);\r\n                for (let lColumnIndex = 0; lColumnIndex < lRowData.length; lColumnIndex++) {\r\n                    lRowData[lColumnIndex] = this.mData[lRowIndex][lColumnIndex] - pAddData;\r\n                }\r\n\r\n                lData.push(lRowData);\r\n            }\r\n        }\r\n\r\n        return new Matrix(lData);\r\n    }\r\n\r\n    /**\r\n     * Transpose matrix.\r\n     */\r\n    public transpose(): Matrix {\r\n        const lMatrixData: Array<Array<number>> = new Array<Array<number>>();\r\n\r\n        // Transpose by copying column into row.\r\n        for (let lColumIndex = 0; lColumIndex < this.width; lColumIndex++) {\r\n            const lMatrixRow: Array<number> = new Array<number>();\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                lMatrixRow.push(this.data[lRowIndex][lColumIndex]);\r\n            }\r\n\r\n            // Add row to matrix data.\r\n            lMatrixData.push(lMatrixRow);\r\n        }\r\n\r\n        return new Matrix(lMatrixData);\r\n    }\r\n\r\n    /**\r\n     * Multiplicate matrix with vector.\r\n     * @param pMultData - Vector.\r\n     * @returns \r\n     */\r\n    public vectorMult(pMultData: Vector): Vector {\r\n        // Restrict on same length.\r\n        if (this.width !== pMultData.data.length) {\r\n            throw new Exception('Matrices A width and B height must match for multiplication.', this);\r\n        }\r\n\r\n        // Convert vector to matrix by creating a \r\n        const lMatrixData: Array<Array<number>> = new Array<Array<number>>();\r\n        for (const lVectorComponent of pMultData.data) {\r\n            lMatrixData.push([lVectorComponent]);\r\n        }\r\n\r\n        // Multiplicate\r\n        const lMutiplicatedMatrix = this.mult(new Matrix(lMatrixData));\r\n\r\n        const lVectorData: Array<number> = new Array<number>();\r\n        for (let lRowIndex = 0; lRowIndex < lMutiplicatedMatrix.height; lRowIndex++) {\r\n            lVectorData.push(lMutiplicatedMatrix.data[lRowIndex][0]);\r\n        }\r\n\r\n        return new Vector(lVectorData);\r\n    }\r\n}", "export class Euler {\r\n    private mX: number;\r\n    private mY: number;\r\n    private mZ: number;\r\n\r\n    /**\r\n     * X axis degree.\r\n     */\r\n    public get x(): number {\r\n        return this.mX;\r\n    } set x(pValue: number) {\r\n        this.mX = pValue;\r\n    }\r\n\r\n    /**\r\n     * Y axis degree.\r\n     */\r\n    public get y(): number {\r\n        return this.mY;\r\n    } set y(pValue: number) {\r\n        this.mY = pValue;\r\n    }\r\n\r\n    /**\r\n     * Z axis degree.\r\n     */\r\n    public get z(): number {\r\n        return this.mZ;\r\n    } set z(pValue: number) {\r\n        this.mZ = pValue;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mX = 0;\r\n        this.mY = 0;\r\n        this.mZ = 0;\r\n    }\r\n}", "import { Euler } from './euler.ts';\r\nimport { Matrix } from './matrix.ts';\r\nimport { Vector } from './vector.ts';\r\n\r\nexport class Quaternion {\r\n    /**\r\n     * Create new quaternion from degree rotation.\r\n     * Rotate order XYZ (Pitch, Yaw, Roll)\r\n     * @param pPitch - Pitch degree.\r\n     * @param pYaw - Yaw degree.\r\n     * @param pRoll - Roll degree.\r\n     */\r\n    public static fromRotation(pPitch: number, pYaw: number, pRoll: number): Quaternion {\r\n        // Conversion to radian.\r\n        const lPitchRadian: number = (pPitch % 360) * Math.PI / 180;\r\n        const lYawRadian: number = (pYaw % 360) * Math.PI / 180;\r\n        const lRollRadian: number = (pRoll % 360) * Math.PI / 180;\r\n\r\n        // Pre calculate.\r\n        const lCosPitch = Math.cos(lPitchRadian * 0.5);\r\n        const lSinPitch = Math.sin(lPitchRadian * 0.5);\r\n        const lCosYaw = Math.cos(lYawRadian * 0.5);\r\n        const lSinYaw = Math.sin(lYawRadian * 0.5);\r\n        const lCosRoll = Math.cos(lRollRadian * 0.5);\r\n        const lSinRoll = Math.sin(lRollRadian * 0.5);\r\n\r\n        // Create quaternion.\r\n        const lQuaternion = Quaternion.identity();\r\n        lQuaternion.w = lCosPitch * lCosYaw * lCosRoll + lSinPitch * lSinYaw * lSinRoll;\r\n        lQuaternion.x = lSinPitch * lCosYaw * lCosRoll - lCosPitch * lSinYaw * lSinRoll;\r\n        lQuaternion.y = lCosPitch * lSinYaw * lCosRoll + lSinPitch * lCosYaw * lSinRoll;\r\n        lQuaternion.z = lCosPitch * lCosYaw * lSinRoll - lSinPitch * lSinYaw * lCosRoll;\r\n\r\n        return lQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Create identity quaternion.\r\n     */\r\n    public static identity(): Quaternion {\r\n        return new Quaternion(1, 0, 0, 0);\r\n    }\r\n\r\n    public mW: number;\r\n    public mX: number;\r\n    public mY: number;\r\n    public mZ: number;\r\n\r\n    /**\r\n     * Rotation forward vector.\r\n     */\r\n    public get vectorForward(): Vector {\r\n        // Products.\r\n        const lSquareX: number = 2 * Math.pow(this.mX, 2);\r\n        const lSquareY: number = 2 * Math.pow(this.mY, 2);\r\n        const lProductXz: number = 2 * this.mX * this.mZ;\r\n        const lProductYw: number = 2 * this.mY * this.mW;\r\n        const lProductYz: number = 2 * this.mY * this.mZ;\r\n        const lProductXw: number = 2 * this.mX * this.mW;\r\n\r\n        const lX: number = lProductXz + lProductYw;\r\n        const lY: number = lProductYz - lProductXw;\r\n        const lZ: number = 1 - lSquareX - lSquareY;\r\n\r\n        return new Vector([lX, lY, lZ]);\r\n    }\r\n\r\n    /**\r\n     * Rotation vector right.\r\n     */\r\n    public get vectorRight(): Vector {\r\n        // Products.\r\n        const lSquareY: number = 2 * Math.pow(this.mY, 2);\r\n        const lSquareZ: number = 2 * Math.pow(this.mZ, 2);\r\n        const lProductXy: number = 2 * this.mX * this.mY;\r\n        const lProductZw: number = 2 * this.mZ * this.mW;\r\n        const lProductYz: number = 2 * this.mY * this.mZ;\r\n        const lProductXw: number = 2 * this.mX * this.mW;\r\n\r\n        const lX: number = 1 - lSquareY - lSquareZ;\r\n        const lY: number = lProductXy + lProductZw;\r\n        const lZ: number = lProductYz + lProductXw;\r\n\r\n        return new Vector([lX, lY, lZ]);\r\n    }\r\n\r\n    /**\r\n     * Rotation up vector.\r\n     */\r\n    public get vectorUp(): Vector {\r\n        // Products.\r\n        const lSquareX: number = 2 * Math.pow(this.mX, 2);\r\n        const lSquareZ: number = 2 * Math.pow(this.mZ, 2);\r\n        const lProductXy: number = 2 * this.mX * this.mY;\r\n        const lProductZw: number = 2 * this.mZ * this.mW;\r\n\r\n        const lProductYz: number = 2 * this.mY * this.mZ;\r\n        const lProductXw: number = 2 * this.mX * this.mW;\r\n\r\n        const lX: number = lProductXy - lProductZw;\r\n        const lY: number = 1 - lSquareX - lSquareZ;\r\n        const lZ: number = lProductYz + lProductXw;\r\n\r\n        return new Vector([lX, lY, lZ]);\r\n    }\r\n\r\n    /**\r\n     * Get w value.\r\n     */\r\n    public get w(): number {\r\n        return this.mW;\r\n    } set w(pValue: number) {\r\n        this.mW = pValue;\r\n    }\r\n\r\n    /**\r\n     * Get x value.\r\n     */\r\n    public get x(): number {\r\n        return this.mX;\r\n    } set x(pValue: number) {\r\n        this.mX = pValue;\r\n    }\r\n\r\n    /**\r\n     * Get y value.\r\n     */\r\n    public get y(): number {\r\n        return this.mY;\r\n    } set y(pValue: number) {\r\n        this.mY = pValue;\r\n    }\r\n\r\n    /**\r\n     * Get z value.\r\n     */\r\n    public get z(): number {\r\n        return this.mZ;\r\n    } set z(pValue: number) {\r\n        this.mZ = pValue;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pW - W.\r\n     * @param pX - X.\r\n     * @param pY - Y.\r\n     * @param pZ - Z.\r\n     */\r\n    public constructor(pW: number, pX: number, pY: number, pZ: number) {\r\n        this.mX = pX;\r\n        this.mY = pY;\r\n        this.mZ = pZ;\r\n        this.mW = pW;\r\n    }\r\n\r\n    /**\r\n     * Add angles to current euler rotation.\r\n     * @param pPitch - Pitch degree.\r\n     * @param pYaw - Yaw degree.\r\n     * @param pRoll - Roll degree.\r\n     */\r\n    public addEulerRotation(pPitch: number, pYaw: number, pRoll: number): Quaternion {\r\n        // Apply current rotation after setting new rotation to apply rotation as absolute euler rotation and not as relative quaternion.\r\n        return this.mult(Quaternion.fromRotation(pPitch, pYaw, pRoll));\r\n    }\r\n\r\n    /**\r\n     * Quaternion rotation as euler rotation\r\n     */\r\n    public asEuler(): Euler {\r\n        const lEuler: Euler = new Euler();\r\n\r\n        // Pitch (x-axis rotation)\r\n        const lSinPitchCosYaw = 2 * (this.mW * this.mX + this.mY * this.mZ);\r\n        const lCosPitchCosYaw = 1 - 2 * (this.mX * this.mX + this.mY * this.mY);\r\n        const lPitchRadian = Math.atan2(lSinPitchCosYaw, lCosPitchCosYaw);\r\n        const lPitchDegree = (lPitchRadian * 180 / Math.PI) % 360;\r\n        lEuler.x = (lPitchDegree < 0) ? lPitchDegree + 360 : lPitchDegree;\r\n\r\n        // Yaw (y-axis rotation)\r\n        const lSinYaw = Math.sqrt(1 + 2 * (this.mW * this.mY - this.mX * this.mZ));\r\n        const lCosYaw = Math.sqrt(1 - 2 * (this.mW * this.mY - this.mX * this.mZ));\r\n        const lYawRadian = 2 * Math.atan2(lSinYaw, lCosYaw) - Math.PI / 2;\r\n        const lYawDegree = (lYawRadian * 180 / Math.PI) % 360;\r\n        lEuler.y = (lYawDegree < 0) ? lYawDegree + 360 : lYawDegree;\r\n\r\n        // Roll (z-axis rotation)\r\n        const lSinRollCosYaw = 2 * (this.mW * this.mZ + this.mX * this.mY);\r\n        const lCosRollCosYaw = 1 - 2 * (this.mY * this.mY + this.mZ * this.mZ);\r\n        const lRollRadian = Math.atan2(lSinRollCosYaw, lCosRollCosYaw);\r\n        const lRollDegree = (lRollRadian * 180 / Math.PI) % 360;\r\n        lEuler.z = (lRollDegree < 0) ? lRollDegree + 360 : lRollDegree;\r\n\r\n        return lEuler;\r\n    }\r\n\r\n    /**\r\n     * Convert quaternion to a 4x4 rotation matrix.\r\n     */\r\n    public asMatrix(): Matrix {\r\n        /*\r\n            1 - 2*qy\u00B2 - 2*qz\u00B2\t2*qx*qy - 2*qz*qw\t2*qx*qz + 2*qy*qw\r\n            2*qx*qy + 2*qz*qw\t1 - 2*qx\u00B2 - 2*qz\u00B2\t2*qy*qz - 2*qx*qw\r\n            2*qx*qz - 2*qy*qw\t2*qy*qz + 2*qx*qw\t1 - 2*qx\u00B2 - 2*qy\u00B2\r\n        */\r\n        // Sqares\r\n        const lSquareX: number = 2 * Math.pow(this.mX, 2);\r\n        const lSquareY: number = 2 * Math.pow(this.mY, 2);\r\n        const lSquareZ: number = 2 * Math.pow(this.mZ, 2);\r\n\r\n        // Products.\r\n        const lProductXy: number = 2 * this.mX * this.mY;\r\n        const lProductZw: number = 2 * this.mZ * this.mW;\r\n        const lProductXz: number = 2 * this.mX * this.mZ;\r\n        const lProductYw: number = 2 * this.mY * this.mW;\r\n        const lProductYz: number = 2 * this.mY * this.mZ;\r\n        const lProductXw: number = 2 * this.mX * this.mW;\r\n\r\n        // Fill matrix\r\n        const lMatrix: Matrix = Matrix.identity(4);\r\n        lMatrix.data[0][0] = 1 - lSquareY - lSquareZ;\r\n        lMatrix.data[0][1] = lProductXy - lProductZw;\r\n        lMatrix.data[0][2] = lProductXz + lProductYw;\r\n\r\n        lMatrix.data[1][0] = lProductXy + lProductZw;\r\n        lMatrix.data[1][1] = 1 - lSquareX - lSquareZ;\r\n        lMatrix.data[1][2] = lProductYz - lProductXw;\r\n\r\n        lMatrix.data[2][0] = lProductXz - lProductYw;\r\n        lMatrix.data[2][1] = lProductYz + lProductXw;\r\n        lMatrix.data[2][2] = 1 - lSquareX - lSquareY;\r\n\r\n        return lMatrix;\r\n    }\r\n\r\n    /**\r\n     * Multiplicate with quaternion.\r\n     * @param pQuaternion - Quaterion source.\r\n     */\r\n    public mult(pQuaternion: Quaternion): Quaternion {\r\n        const lW: number = this.mW * pQuaternion.w - this.mX * pQuaternion.x - this.mY * pQuaternion.y - this.mZ * pQuaternion.z;\r\n        const lX: number = this.mW * pQuaternion.x + this.mX * pQuaternion.w + this.mY * pQuaternion.z - this.mZ * pQuaternion.y;\r\n        const lY: number = this.mW * pQuaternion.y - this.mX * pQuaternion.z + this.mY * pQuaternion.w + this.mZ * pQuaternion.x;\r\n        const lZ: number = this.mW * pQuaternion.z + this.mX * pQuaternion.y - this.mY * pQuaternion.x + this.mZ * pQuaternion.w;\r\n\r\n        return new Quaternion(lW, lX, lY, lZ);\r\n    }\r\n\r\n    /**\r\n     * Normalize quaternion.\r\n     */\r\n    public normalize(): Quaternion {\r\n        // Calculate length.\r\n        const lLength = Math.hypot(Math.pow(this.mW, 2), Math.pow(this.mX, 2), Math.pow(this.mY, 2), Math.pow(this.mZ, 2));\r\n\r\n        // Create new quaternion by dividing each dimension by length.\r\n        return new Quaternion(this.mW / lLength, this.mX / lLength, this.mY / lLength, this.mZ / lLength);\r\n    }\r\n}", "import { Matrix } from './math/matrix.ts';\r\nimport { Quaternion } from './math/quaternion.ts';\r\nimport { Vector } from './math/vector.ts';\r\n\r\nexport class Transform {\r\n    private readonly mPivot: Matrix;\r\n    private mRotation: Quaternion;\r\n    private readonly mScale: Matrix;\r\n    private readonly mTranslation: Matrix;\r\n\r\n    /**\r\n     * X pivot point.\r\n     */\r\n    public get pivotX(): number {\r\n        return this.mPivot.data[0][3];\r\n    } set pivotX(pValue: number) {\r\n        this.mPivot.data[0][3] = pValue;\r\n    }\r\n\r\n    /**\r\n     * Y pivot point.\r\n     */\r\n    public get pivotY(): number {\r\n        return this.mPivot.data[1][3];\r\n    } set pivotY(pValue: number) {\r\n        this.mPivot.data[1][3] = pValue;\r\n    }\r\n\r\n    /**\r\n     * Z pivot point.\r\n     */\r\n    public get pivotZ(): number {\r\n        return this.mPivot.data[2][3];\r\n    } set pivotZ(pValue: number) {\r\n        this.mPivot.data[2][3] = pValue;\r\n    }\r\n\r\n    /**\r\n     * Rotation on X angle.\r\n     * Pitch.\r\n     */\r\n    public get rotationPitch(): number {\r\n        return this.mRotation.asEuler().x;\r\n    }\r\n\r\n    /**\r\n     * Rotation on Z angle.\r\n     * Roll.\r\n     */\r\n    public get rotationRoll(): number {\r\n        return this.mRotation.asEuler().z;\r\n    }\r\n\r\n    /**\r\n     * Rotation on Y angle.\r\n     * Yaw.\r\n     */\r\n    public get rotationYaw(): number {\r\n        return this.mRotation.asEuler().y;\r\n    }\r\n\r\n    /**\r\n     * Depth scale.\r\n     */\r\n    public get scaleDepth(): number {\r\n        return this.mScale.data[2][2];\r\n    }\r\n\r\n    /**\r\n     * Height scale.\r\n     */\r\n    public get scaleHeight(): number {\r\n        return this.mScale.data[1][1];\r\n    }\r\n\r\n    /**\r\n     * Width scale.\r\n     */\r\n    public get scaleWidth(): number {\r\n        return this.mScale.data[0][0];\r\n    }\r\n\r\n    /**\r\n     * X translation.\r\n     */\r\n    public get translationX(): number {\r\n        return this.mTranslation.data[0][3];\r\n    }\r\n\r\n    /**\r\n     * Y translation.\r\n     */\r\n    public get translationY(): number {\r\n        return this.mTranslation.data[1][3];\r\n    }\r\n\r\n    /**\r\n     * Z translation.\r\n     */\r\n    public get translationZ(): number {\r\n        return this.mTranslation.data[2][3];\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mScale = Matrix.identity(4);\r\n        this.mTranslation = Matrix.identity(4);\r\n        this.mRotation = new Quaternion(1, 0, 0, 0);\r\n        this.mPivot = Matrix.identity(4);\r\n    }\r\n\r\n    /**\r\n     * Add angles to current euler rotation angles.\r\n     * @param pPitch - Pitch degree.\r\n     * @param pYaw - Yaw degree.\r\n     * @param pRoll - Roll degree.\r\n     */\r\n    public addEulerRotation(pPitch: number, pYaw: number, pRoll: number): void {\r\n        // Apply rotation to current rotation.\r\n        this.mRotation = this.mRotation.addEulerRotation(pPitch, pYaw, pRoll);\r\n    }\r\n\r\n    /**\r\n     * Add rotation to already rotated object.\r\n     * @param pPitch - Pitch degree.\r\n     * @param pYaw - Yaw degree.\r\n     * @param pRoll - Roll degree.\r\n     */\r\n    public addRotation(pPitch: number, pYaw: number, pRoll: number): void {\r\n        // Apply rotation to current rotation.\r\n        this.mRotation = Quaternion.fromRotation(pPitch, pYaw, pRoll).mult(this.mRotation);\r\n    }\r\n\r\n    /**\r\n     * Add scale.\r\n     * @param pWidth - Width multiplier.\r\n     * @param pHeight - Height multiplier.\r\n     * @param pDepth - Depth multiplier.\r\n     */\r\n    public addScale(pWidth: number, pHeight: number, pDepth: number): void {\r\n        this.mScale.data[0][0] += pWidth;\r\n        this.mScale.data[1][1] += pHeight;\r\n        this.mScale.data[2][2] += pDepth;\r\n    }\r\n\r\n    /**\r\n     * Add translation.\r\n     * @param pX - Movement on worlds X axis.\r\n     * @param pY - Movement on worlds Y axis.\r\n     * @param pZ - Movement on worlds Z axis.\r\n     */\r\n    public addTranslation(pX: number, pY: number, pZ: number): this {\r\n        this.mTranslation.data[0][3] += pX;\r\n        this.mTranslation.data[1][3] += pY;\r\n        this.mTranslation.data[2][3] += pZ;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Get transformation matrix.\r\n     */\r\n    public getMatrix(pType: TransformMatrix): Matrix {\r\n        switch (pType) {\r\n            case TransformMatrix.Scale: {\r\n                return this.mScale;\r\n            }\r\n            case TransformMatrix.Translation: {\r\n                return this.mTranslation;\r\n            }\r\n            case TransformMatrix.Rotation: {\r\n                return this.mRotation.asMatrix();\r\n            }\r\n            case TransformMatrix.PivotRotation: {\r\n                const lRotationMatrix: Matrix = this.getMatrix(TransformMatrix.Rotation);\r\n\r\n                // Check if pivit point is used.\r\n                let lPivotRotation: Matrix;\r\n                if (this.pivotX !== 0 || this.pivotY !== 0 || this.pivotZ !== 0) {\r\n                    // Translate pivot => rotate => reverse pivate translation.\r\n                    lPivotRotation = this.mPivot.inverse().mult(lRotationMatrix).mult(this.mPivot);\r\n                } else {\r\n                    lPivotRotation = lRotationMatrix;\r\n                }\r\n\r\n                return lPivotRotation;\r\n            }\r\n            case TransformMatrix.Transformation: {\r\n                const lScale: Matrix = this.getMatrix(TransformMatrix.Scale);\r\n                const lTranslation: Matrix = this.getMatrix(TransformMatrix.Translation);\r\n                const lRotation: Matrix = this.getMatrix(TransformMatrix.PivotRotation);\r\n\r\n                // First scale, second rotate, third translate.\r\n                return lTranslation.mult(lRotation).mult(lScale);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset current rotation and set new rotation.\r\n     * @param pPitch - Pitch degree.\r\n     * @param pYaw - Yaw degree.\r\n     * @param pRoll - Roll degree.\r\n     */\r\n    public setRotation(pPitch: number | null, pYaw: number | null, pRoll: number | null): void {\r\n        const lPitch: number = pPitch ?? this.rotationPitch;\r\n        const lYaw: number = pYaw ?? this.rotationYaw;\r\n        const lRoll: number = pRoll ?? this.rotationRoll;\r\n\r\n        // Create new rotation.\r\n        this.mRotation = Quaternion.fromRotation(lPitch, lYaw, lRoll);\r\n    }\r\n\r\n    /**\r\n     * Set scale.\r\n     * @param pWidth - Width multiplier.\r\n     * @param pHeight - Height multiplier.\r\n     * @param pDepth - Depth multiplier.\r\n     */\r\n    public setScale(pWidth: number | null, pHeight: number | null, pDepth: number | null): this {\r\n        this.mScale.data[0][0] = pWidth ?? this.scaleWidth;\r\n        this.mScale.data[1][1] = pHeight ?? this.scaleHeight;\r\n        this.mScale.data[2][2] = pDepth ?? this.scaleDepth;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set translation.\r\n     * @param pX - Movement on worlds X axis.\r\n     * @param pY - Movement on worlds Y axis.\r\n     * @param pZ - Movement on worlds Z axis.\r\n     */\r\n    public setTranslation(pX: number | null, pY: number | null, pZ: number | null): this {\r\n        this.mTranslation.data[0][3] = pX ?? this.translationX;\r\n        this.mTranslation.data[1][3] = pY ?? this.translationY;\r\n        this.mTranslation.data[2][3] = pZ ?? this.translationZ;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Translate into rotation direction.\r\n     * @param pForward - Forward movement.\r\n     * @param pRight - Right movement.\r\n     * @param pUp - Up movement.\r\n     */\r\n    public translateInDirection(pForward: number, pRight: number, pUp: number): void {\r\n        const lTranslationVector: Vector = new Vector([pRight, pUp, pForward, 1]);\r\n        const lDirectionVector: Vector = this.getMatrix(TransformMatrix.Rotation).vectorMult(lTranslationVector);\r\n\r\n        // Add direction.\r\n        this.addTranslation(lDirectionVector.x, lDirectionVector.y, lDirectionVector.z);\r\n    }\r\n}\r\n\r\nexport enum TransformMatrix {\r\n    Rotation = 1,\r\n    PivotRotation = 2,\r\n    Translation = 3,\r\n    Scale = 4,\r\n    Transformation = 5\r\n}", "import { Matrix } from '../../math/matrix.ts';\r\nimport { IProjection } from './i-projection.interface.ts';\r\n\r\nexport class PerspectiveProjection implements IProjection {\r\n    private mAngleOfView: number;\r\n    private mAspectRatio: number;\r\n    private mCacheProjectionMatrix: Matrix | null;\r\n    private mFar: number;\r\n    private mNear: number;\r\n\r\n    /**\r\n     * Angle of view.\r\n     */\r\n    public get angleOfView(): number {\r\n        return this.mAngleOfView;\r\n    } set angleOfView(pValue: number) {\r\n        this.mAngleOfView = pValue;\r\n\r\n        // Reset cached matrix.\r\n        this.mCacheProjectionMatrix = null;\r\n    }\r\n\r\n    /**\r\n     * Angle of view.\r\n     */\r\n    public get aspectRatio(): number {\r\n        return this.mAspectRatio;\r\n    } set aspectRatio(pValue: number) {\r\n        this.mAspectRatio = pValue;\r\n\r\n        // Reset cached matrix.\r\n        this.mCacheProjectionMatrix = null;\r\n    }\r\n\r\n    /**\r\n     * Far plane.\r\n     */\r\n    public get far(): number {\r\n        return this.mFar;\r\n    } set far(pValue: number) {\r\n        this.mFar = pValue;\r\n\r\n        // Reset cached matrix.\r\n        this.mCacheProjectionMatrix = null;\r\n    }\r\n\r\n    /**\r\n     * Near plane.\r\n     */\r\n    public get near(): number {\r\n        return this.mNear;\r\n    } set near(pValue: number) {\r\n        this.mNear = pValue;\r\n\r\n        // Reset cached matrix.\r\n        this.mCacheProjectionMatrix = null;\r\n    }\r\n\r\n    /**\r\n     * Projection matrix.\r\n     */\r\n    public get projectionMatrix(): Matrix {\r\n        if (this.mCacheProjectionMatrix === null) {\r\n            this.mCacheProjectionMatrix = this.createMatrix();\r\n        }\r\n\r\n        return this.mCacheProjectionMatrix;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mAngleOfView = 0;\r\n        this.mNear = 0;\r\n        this.mFar = 0;\r\n        this.mAspectRatio = 0;\r\n\r\n        // Cache.\r\n        this.mCacheProjectionMatrix = null;\r\n    }\r\n\r\n    /**\r\n     * Create projection matrix.\r\n     */\r\n    private createMatrix(): Matrix {\r\n        const lMatrix: Matrix = Matrix.identity(4);\r\n\r\n        // Reset identity.\r\n        lMatrix.data[0][0] = 0;\r\n        lMatrix.data[1][1] = 0;\r\n        lMatrix.data[2][2] = 0;\r\n        lMatrix.data[3][3] = 0;\r\n\r\n        // Calculate planes with centered camera on z-plane.\r\n        const lFar: number = this.mFar;\r\n        const lNear: number = this.mNear;\r\n\r\n        // Top bottom calculated by get height from vertical angle of view.\r\n        // Half angle is from y=>0 to top plane, as the angle descripes the distance between top and bottom plane.\r\n        // Tan(angleOfView / 2) = Top / Near => Near * Tan(angleOfView / 2) = Top\r\n        const lTop: number = this.mNear * Math.tan((this.angleOfView * Math.PI / 180) / 2);\r\n        const lBottom: number = -lTop;\r\n\r\n        // Left right calculated from aspect ratio.\r\n        const lRight: number = lTop * this.aspectRatio;\r\n        const lLeft: number = -lRight;\r\n\r\n        // We need to set VectorZ to VectorW to devide VectorX and VectorY by the VectorZ.\r\n        // So planes are smaller the further ways they are.\r\n        // And scale VectorX and VectorY with the near plane to start the projection not on Z=0 but on Z=Near.\r\n        // \u250C N  0  0   0  \u2510   \u250C 1 \u2510   \u250C 1 \u2510\r\n        // | 0  N  0   0  |   | 2 |   | 2 |\r\n        // | 0  0  M1  M2 | x | 3 | = | 3 |\r\n        // \u2514 0  0  1   0  \u2518   \u2514 1 \u2518   \u2514 3 \u2518\r\n\r\n        // Problem is: The VectorZ get also divided by VectorX and VectorW.\r\n        // To fix the problem set VectorZ to VectorZ\u00B2 with only M1 and M2 available.\r\n        // As as M1 is the Scaling(M1 * Z) and M2 is Translating(M2 + Z) we get:\r\n        // M1*Z + M2 = Z\u00B2 => Quadratic means two solutions. But we need one.\r\n        // So we constrains the equation to be only valid between Near and Far. So we set Z=Near or Z=Far.\r\n        // All other Z Values are calculated quadratic ranging from Near to Far.\r\n        // So we get:\r\n        // M1*Near + M2 = Near\u00B2  => M1 = Far + Near\r\n        // M1*Far  + M2 = Far\u00B2   => M2 = -(Far * Near)\r\n        // \u250C N  0      0         0     \u2510\r\n        // | 0  N      0         0     |\r\n        // | 0  0    F + N   -(F * N)  |\r\n        // \u2514 0  0      1         0     \u2518\r\n\r\n        // Multiplicate this perspectiv matrix with the orthigraphic to center the camera.\r\n        // \u250C  2/(R-L)    0         0    -(R+L)/(R-L) \u2510   \u250C N  0      0         0     \u2510\r\n        // |     0     2/(T-B)     0    -(T+B)/(T-B) |   | 0  N      0         0     |\r\n        // |     0        0     1/(F-N)   -N/(F-N)   | x | 0  0    F + N   -(F * N)  |\r\n        // \u2514     0        0        0          1      \u2518   \u2514 0  0      1         0     \u2518\r\n\r\n        // And we get.\r\n        // \u250C  2N/(R-L)    0        -(R+L)/(R-L)           0      \u2510\r\n        // |     0     2N/(T-B)    -(T+B)/(T-B)           0      |\r\n        // |     0        0          F/(F-N)       -(F*N)/(F-N) |\r\n        // \u2514     0        0             1                0      \u2518\r\n\r\n\r\n        // Set matrix data. Row 1:\r\n        lMatrix.data[0][0] = (2 * lNear) / (lRight - lLeft);\r\n        lMatrix.data[0][2] = -(lRight + lLeft) / (lRight - lLeft);\r\n\r\n        // Set matrix data. Row 2:\r\n        lMatrix.data[1][1] = (2 * lNear) / (lTop - lBottom);\r\n        lMatrix.data[1][2] = -(lTop + lBottom) / (lTop - lBottom);\r\n\r\n        // Set matrix data. Row 3:\r\n        lMatrix.data[2][2] = lFar / (lFar - lNear);\r\n        lMatrix.data[2][3] = -(lFar * lNear) / (lFar - lNear);\r\n\r\n        // Set matrix data. Row 4:\r\n        lMatrix.data[3][2] = 1;\r\n\r\n        return lMatrix;\r\n    }\r\n}", "import { Matrix } from '../math/matrix.ts';\r\nimport { Transform, TransformMatrix } from '../transform.ts';\r\nimport { IProjection } from './projection/i-projection.interface.ts';\r\n\r\nexport class ViewProjection {\r\n    private readonly mProjection: IProjection;\r\n    private readonly mTransformation: Transform;\r\n\r\n    /**\r\n     * Camera projection.\r\n     */\r\n    public get projection(): IProjection {\r\n        return this.mProjection;\r\n    }\r\n\r\n    /**\r\n     * Camera transformation.\r\n     */\r\n    public get transformation(): Transform {\r\n        return this.mTransformation;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor(pProjection: IProjection) {\r\n        this.mProjection = pProjection;\r\n        this.mTransformation = new Transform();\r\n    }\r\n\r\n    /**\r\n     * Get camera matrix. \r\n     * @param pType - Matrix type. \r\n     */\r\n    public getMatrix(pType: CameraMatrix): Matrix {\r\n        switch (pType) {\r\n            case CameraMatrix.Translation: {\r\n                return this.mTransformation.getMatrix(TransformMatrix.Translation);\r\n            }\r\n            case CameraMatrix.Rotation: {\r\n                return this.mTransformation.getMatrix(TransformMatrix.Rotation);\r\n            }\r\n            case CameraMatrix.PivotRotation: {\r\n                return this.mTransformation.getMatrix(TransformMatrix.PivotRotation);\r\n            }\r\n            case CameraMatrix.Projection: {\r\n                return this.mProjection.projectionMatrix;\r\n            }\r\n            case CameraMatrix.View: {\r\n                const lTranslation: Matrix = this.getMatrix(CameraMatrix.Translation);\r\n                const lRotation: Matrix = this.getMatrix(CameraMatrix.Rotation);\r\n                return lTranslation.mult(lRotation).inverse();\r\n            }\r\n            case CameraMatrix.ViewProjection: {\r\n                const lView: Matrix = this.getMatrix(CameraMatrix.View);\r\n                const lProjection: Matrix = this.getMatrix(CameraMatrix.Projection);\r\n                return lProjection.mult(lView);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\nexport enum CameraMatrix {\r\n    Translation = 1,\r\n    Rotation = 2,\r\n    PivotRotation = 3,\r\n    Projection = 4,\r\n    View = 5,\r\n    ViewProjection = 6\r\n}", "// ------------------------- Object Values ---------------------- //\r\n@group(0) @binding(0) var<uniform> transformationMatrix: mat4x4<f32>;\r\n@group(0) @binding(1) var<uniform> color: vec4<f32>;\r\n// -------------------------------------------------------------- //\r\n\r\n\r\n// ------------------------- World Values ---------------------- //\r\nstruct Camera {\r\n    viewProjection: mat4x4<f32>,\r\n    view: mat4x4<f32>,\r\n    projection: mat4x4<f32>,\r\n    rotation: mat4x4<f32>,\r\n    translation: mat4x4<f32>,\r\n    position: vec3<f32>\r\n}\r\n@group(1) @binding(0) var<uniform> camera: Camera;\r\n\r\nstruct TimeData {\r\n    timestamp: f32,\r\n    delta: f32\r\n}\r\n@group(1) @binding(1) var<uniform> time: TimeData;\r\n\r\nstruct AmbientLight {\r\n    color: vec4<f32>\r\n}\r\n@group(1) @binding(2) var<uniform> ambientLight: AmbientLight;\r\n\r\nstruct PointLight {\r\n    position: vec4<f32>,\r\n    color: vec4<f32>,\r\n    range: f32\r\n}\r\n@group(1) @binding(3) var<storage, read> pointLights: array<PointLight>;\r\n\r\n@group(1) @binding(4) var<storage, read_write> debugValue: f32;\r\n// -------------------------------------------------------------- //\r\n\r\n\r\n// --------------------- Light calculations --------------------- //\r\n\r\n/**\r\n * Calculate point light output.\r\n */\r\nfn calculatePointLights(fragmentPosition: vec4<f32>, normal: vec4<f32>) -> vec4<f32> {\r\n    // Count of point lights.\r\n    let pointLightCount: u32 = arrayLength(&pointLights);\r\n\r\n    var lightResult: vec4<f32> = vec4<f32>(0, 0, 0, 1);\r\n\r\n    for (var index: u32 = 0; index < pointLightCount; index++) {\r\n        var pointLight: PointLight = pointLights[index];\r\n\r\n        // Calculate light strength based on angle of incidence.\r\n        let lightDirection: vec4<f32> = normalize(pointLight.position - fragmentPosition);\r\n        let diffuse: f32 = max(dot(normal, lightDirection), 0.0);\r\n\r\n        lightResult += pointLight.color * diffuse;\r\n    }\r\n\r\n    return lightResult;\r\n}\r\n\r\n/**\r\n * Apply lights to fragment color.\r\n */\r\nfn applyLight(colorIn: vec4<f32>, fragmentPosition: vec4<f32>, normal: vec4<f32>) -> vec4<f32> {\r\n    var lightColor: vec4<f32> = vec4<f32>(0, 0, 0, 1);\r\n\r\n    lightColor += ambientLight.color;\r\n    lightColor += calculatePointLights(fragmentPosition, normal);\r\n\r\n    return lightColor * colorIn;\r\n}\r\n// -------------------------------------------------------------- //\r\n\r\nstruct VertexOut {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) color: vec4<f32>,\r\n    @location(1) normal: vec4<f32>,\r\n    @location(2) fragmentPosition: vec4<f32>,\r\n}\r\n\r\nstruct VertexIn {\r\n    @builtin(instance_index) instanceId : u32,\r\n    @location(0) position: vec4<f32>,\r\n    @location(1) normal: vec4<f32>\r\n}\r\n\r\n@vertex\r\nfn vertex_main(vertex: VertexIn) -> VertexOut {\r\n    var worldposition: vec4<f32> = transformationMatrix * vertex.position;\r\n\r\n    var out: VertexOut;\r\n    out.position = camera.viewProjection * worldposition;\r\n    out.normal = vertex.normal;\r\n    out.fragmentPosition = worldposition;\r\n    out.color = color;\r\n\r\n    return out;\r\n}\r\n\r\nstruct FragmentIn {\r\n    @location(0) color: vec4<f32>,\r\n    @location(1) normal: vec4<f32>,\r\n    @location(2) fragmentPosition: vec4<f32>,\r\n}\r\n\r\n@fragment\r\nfn fragment_main(fragment: FragmentIn) -> @location(0) vec4<f32> {\r\n    return applyLight(fragment.color, fragment.fragmentPosition, fragment.normal);\r\n}", "// ------------------------- Object Values ---------------------- //\r\n@group(0) @binding(0) var<uniform> transformationMatrix: mat4x4<f32>;\r\n@group(0) @binding(1) var<storage, read> instancePositions: array<vec4<f32>>;\r\n// -------------------------------------------------------------- //\r\n\r\n\r\n// ------------------------- World Values ---------------------- //\r\nstruct Camera {\r\n    viewProjection: mat4x4<f32>,\r\n    view: mat4x4<f32>,\r\n    projection: mat4x4<f32>,\r\n    rotation: mat4x4<f32>,\r\n    translation: mat4x4<f32>,\r\n    position: vec3<f32>\r\n}\r\n@group(1) @binding(0) var<uniform> camera: Camera;\r\n\r\nstruct TimeData {\r\n    timestamp: f32,\r\n    delta: f32\r\n}\r\n@group(1) @binding(1) var<uniform> time: TimeData;\r\n\r\nstruct AmbientLight {\r\n    color: vec4<f32>\r\n}\r\n@group(1) @binding(2) var<uniform> ambientLight: AmbientLight;\r\n\r\nstruct PointLight {\r\n    position: vec4<f32>,\r\n    color: vec4<f32>,\r\n    range: f32\r\n}\r\n@group(1) @binding(3) var<storage, read> pointLights: array<PointLight>;\r\n\r\n@group(1) @binding(4) var<storage, read_write> debugValue: f32;\r\n// -------------------------------------------------------------- //\r\n\r\n\r\n// ------------------------- User Inputs ------------------------ //\r\n@group(2) @binding(0) var cubeTextureSampler: sampler;\r\n@group(2) @binding(1) var cubeTexture: texture_2d_array<f32>;\r\n// -------------------------------------------------------------- //\r\n\r\n\r\n// --------------------- Light calculations --------------------- //\r\n\r\n/**\r\n * Calculate point light output.\r\n */\r\nfn calculatePointLights(fragmentPosition: vec4<f32>, normal: vec4<f32>) -> vec4<f32> {\r\n    // Count of point lights.\r\n    let pointLightCount: u32 = arrayLength(&pointLights);\r\n\r\n    var lightResult: vec4<f32> = vec4<f32>(0, 0, 0, 1);\r\n\r\n    for (var index: u32 = 0; index < pointLightCount; index++) {\r\n        var pointLight: PointLight = pointLights[index];\r\n\r\n        // Calculate light strength based on angle of incidence.\r\n        let lightDirection: vec4<f32> = normalize(pointLight.position - fragmentPosition);\r\n        let diffuse: f32 = max(dot(normal, lightDirection), 0.0);\r\n\r\n        lightResult += pointLight.color * diffuse;\r\n    }\r\n\r\n    return lightResult;\r\n}\r\n\r\n/**\r\n * Apply lights to fragment color.\r\n */\r\nfn applyLight(colorIn: vec4<f32>, fragmentPosition: vec4<f32>, normal: vec4<f32>) -> vec4<f32> {\r\n    var lightColor: vec4<f32> = vec4<f32>(0, 0, 0, 1);\r\n\r\n    lightColor += ambientLight.color;\r\n    lightColor += calculatePointLights(fragmentPosition, normal);\r\n\r\n    return lightColor * colorIn;\r\n}\r\n// -------------------------------------------------------------- //\r\n\r\nfn hash(x: u32) -> u32\r\n{\r\n    var result: u32 = x;\r\n    result ^= result >> 16;\r\n    result *= 0x7feb352du;\r\n    result ^= result >> 15;\r\n    result *= 0x846ca68bu;\r\n    result ^= result >> 16;\r\n    return result;\r\n}\r\n\r\nstruct VertexOut {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) uv: vec2<f32>,\r\n    @location(1) normal: vec4<f32>,\r\n    @location(2) fragmentPosition: vec4<f32>,\r\n    @interpolate(flat) @location(3) textureLayer: u32\r\n}\r\n\r\nstruct VertexIn {\r\n    @builtin(instance_index) instanceId : u32,\r\n    @location(0) position: vec4<f32>,\r\n    @location(1) uv: vec2<f32>,\r\n    @location(2) normal: vec4<f32>\r\n}\r\n\r\noverride animationSeconds: f32 = 3; \r\n\r\n@vertex\r\nfn vertex_main(vertex: VertexIn) -> VertexOut {\r\n    let textureLayers: f32 = f32(textureNumLayers(cubeTexture));\r\n\r\n    var instancePosition: vec4<f32> = instancePositions[vertex.instanceId];\r\n\r\n    // Generate 4 random numbers.\r\n    var hash1: u32 = hash(vertex.instanceId + 1);\r\n    var hash2: u32 = hash(hash1);\r\n    var hash3: u32 = hash(hash2);\r\n    var hash4: u32 = hash(hash3);\r\n\r\n    // Convert into normals.\r\n    var hashStartDisplacement: f32 = (f32(hash1) - pow(2, 31)) * 2 / pow(2, 32);\r\n    var randomNormalPosition: vec4<f32> = vec4<f32>(\r\n        (f32(hash2) - pow(2, 31)) * 2 / pow(2, 32),\r\n        (f32(hash3) - pow(2, 31)) * 2 / pow(2, 32),\r\n        (f32(hash4) - pow(2, 31)) * 2 / pow(2, 32),\r\n        1\r\n    );\r\n\r\n    // Calculate random position and animate a 100m spread. \r\n    var randPosition: vec4<f32> = randomNormalPosition * 1000; // Randomise start spreading 1000m in all directsions.\r\n    randPosition += randomNormalPosition * sin((time.timestamp / animationSeconds) + (hashStartDisplacement * 100)) * 100;\r\n    randPosition.w = 1; // Reset w coord.\r\n\r\n    let randomPositionMatrix: mat4x4<f32> = mat4x4<f32>(\r\n        1, 0, 0, 0,\r\n        0, 1, 0, 0,\r\n        0, 0, 1, 0,\r\n        randPosition.x, randPosition.y, randPosition.z, 1\r\n    );\r\n\r\n    let instancePositionMatrix: mat4x4<f32> = mat4x4<f32>(\r\n        1, 0, 0, 0,\r\n        0, 1, 0, 0,\r\n        0, 0, 1, 0,\r\n        instancePosition.x, instancePosition.y, instancePosition.z, 1\r\n    );\r\n\r\n    var textureLayer: u32 = u32(floor(f32(vertex.instanceId) % textureLayers));\r\n\r\n    var worldposition: vec4<f32> = randomPositionMatrix * instancePositionMatrix * transformationMatrix * vertex.position;\r\n\r\n    var out: VertexOut;\r\n    out.position = camera.viewProjection * worldposition;\r\n    out.uv = vertex.uv;\r\n    out.normal = vertex.normal;\r\n    out.fragmentPosition = worldposition;\r\n    out.textureLayer = textureLayer;\r\n\r\n    return out;\r\n}\r\n\r\nstruct FragmentIn {\r\n    @location(0) uv: vec2<f32>,\r\n    @location(1) normal: vec4<f32>,\r\n    @location(2) fragmentPosition: vec4<f32>,\r\n    @interpolate(flat) @location(3) textureLayer: u32\r\n}\r\n\r\n@fragment\r\nfn fragment_main(fragment: FragmentIn) -> @location(0) vec4<f32> {\r\n    return applyLight(textureSample(cubeTexture, cubeTextureSampler, fragment.uv, fragment.textureLayer), fragment.fragmentPosition, fragment.normal);\r\n}", "// ------------------------- Object Values ---------------------- //\r\nstruct Particle {\r\n    position: vec3<f32>,\r\n    rotation: vec3<f32>,\r\n    velocity: vec3<f32>,\r\n    lifetime: f32\r\n}\r\n@group(0) @binding(0) var<storage, read_write> particles: array<Particle>;\r\n@group(0) @binding(1) var<storage, read_write> indirect: array<atomic<u32>, 4>;\r\n// -------------------------------------------------------------- //\r\n\r\n\r\n// ------------------------- World Values ---------------------- //\r\nstruct CameraTransformation {\r\n    rotation: mat4x4<f32>,\r\n    translation: mat4x4<f32>\r\n}\r\nstruct Camera {\r\n    viewProjection: mat4x4<f32>,\r\n    view: mat4x4<f32>,\r\n    projection: mat4x4<f32>,\r\n    translation: CameraTransformation,\r\n    invertedTranslation: CameraTransformation,\r\n    position: vec3<f32>\r\n}\r\n@group(1) @binding(0) var<uniform> camera: Camera;\r\n\r\nstruct TimeData {\r\n    timestamp: f32,\r\n    delta: f32\r\n}\r\n@group(1) @binding(1) var<uniform> time: TimeData;\r\n\r\nstruct AmbientLight {\r\n    color: vec4<f32>\r\n}\r\n@group(1) @binding(2) var<uniform> ambientLight: AmbientLight;\r\n\r\nstruct PointLight {\r\n    position: vec4<f32>,\r\n    color: vec4<f32>,\r\n    range: f32\r\n}\r\n@group(1) @binding(3) var<storage, read> pointLights: array<PointLight>;\r\n\r\n@group(1) @binding(4) var<storage, read_write> debugValue: f32;\r\n// -------------------------------------------------------------- //\r\n\r\n/**\r\n * PCG-Hash\r\n */\r\nfn hash(input: u32) -> u32\r\n{\r\n    let state: u32 = input * 747796405u + 2891336453u;\r\n    let word: u32 = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\r\n    return (word >> 22u) ^ word;\r\n}\r\n\r\noverride animationSeconds: f32 = 3; \r\n\r\nstruct ComputeParams {\r\n    @builtin(global_invocation_id) globalInvocationId : vec3u\r\n}\r\n@compute @workgroup_size(64)\r\nfn compute_main(params: ComputeParams) {\r\n    const MAX_DISTANCE: f32 = 3;\r\n    const MAX_LIFETIME: f32 = 9999;\r\n\r\n    let id = params.globalInvocationId.x;\r\n    if(id >= arrayLength(&particles)) {\r\n        return;\r\n    }\r\n\r\n    var particle: Particle = particles[id];\r\n\r\n    // Atomic just in case\r\n    atomicStore(&indirect[1], 600);\r\n\r\n    // Update time\r\n    particle.lifetime -= time.delta;\r\n\r\n    // Mark particle to kill.\r\n    let cameraDistance: f32 = distance(particle.position, camera.position);\r\n    if(cameraDistance > MAX_DISTANCE && particle.lifetime > 1) {\r\n        particle.lifetime = 0;\r\n    }\r\n\r\n    // Recreate particle.\r\n    if(particle.lifetime <= 0) {\r\n        var hash1: u32 = hash(id * 10000  + u32(time.timestamp * 1000));\r\n        var hash2: u32 = hash(hash1);\r\n        var hash3: u32 = hash(hash2);\r\n        var hash4: u32 = hash(hash3);\r\n\r\n        let radi: f32 = (f32(hash1) - pow(2, 31)) * 2 / pow(2, 32);\r\n        let posX: f32 = (f32(hash2) - pow(2, 31)) * 2 / pow(2, 32);\r\n        let posY: f32 = (f32(hash3) - pow(2, 31)) * 2 / pow(2, 32);\r\n        let posZ: f32 = (f32(hash4) - pow(2, 31)) * 2 / pow(2, 32);\r\n\r\n        // Random normalized vector.\r\n        var randomPosition: vec3<f32> =vec3<f32>(posX, posY, posZ);\r\n        randomPosition = normalize(randomPosition);\r\n\r\n        // Flip Y when it is negative.\r\n        randomPosition.y = abs(randomPosition.y);\r\n\r\n        // Scale ball by 10m\r\n        randomPosition *= MAX_DISTANCE * 0.75;\r\n\r\n        particle.position = randomPosition + camera.position;\r\n        particle.rotation = randomPosition;\r\n        particle.lifetime = MAX_LIFETIME;\r\n        particle.velocity = vec3<f32>(0.1, -0.2, 0);\r\n    }\r\n\r\n    // Move by velocity.\r\n    particle.position += particle.velocity * time.delta;\r\n    particle.rotation += particle.velocity * time.delta * 8;\r\n\r\n    _ = animationSeconds;\r\n\r\n    particles[id] = particle;\r\n}", "// ------------------------- Object Values ---------------------- //\r\n@group(0) @binding(0) var<uniform> transformationMatrix: mat4x4<f32>;\r\nstruct Particle {\r\n    position: vec3<f32>,\r\n    rotation: vec3<f32>,\r\n    velocity: vec3<f32>,\r\n    lifetime: f32\r\n}\r\n@group(0) @binding(1) var<storage, read> particles: array<Particle>;\r\n// -------------------------------------------------------------- //\r\n\r\n\r\n// ------------------------- World Values ---------------------- //\r\nstruct CameraTransformation {\r\n    rotation: mat4x4<f32>,\r\n    translation: mat4x4<f32>\r\n}\r\nstruct Camera {\r\n    viewProjection: mat4x4<f32>,\r\n    view: mat4x4<f32>,\r\n    projection: mat4x4<f32>,\r\n    translation: CameraTransformation,\r\n    invertedTranslation: CameraTransformation,\r\n    position: vec3<f32>\r\n}\r\n@group(1) @binding(0) var<uniform> camera: Camera;\r\n\r\nstruct TimeData {\r\n    timestamp: f32,\r\n    delta: f32\r\n}\r\n@group(1) @binding(1) var<uniform> time: TimeData;\r\n\r\nstruct AmbientLight {\r\n    color: vec4<f32>\r\n}\r\n@group(1) @binding(2) var<uniform> ambientLight: AmbientLight;\r\n\r\nstruct PointLight {\r\n    position: vec4<f32>,\r\n    color: vec4<f32>,\r\n    range: f32\r\n}\r\n@group(1) @binding(3) var<storage, read> pointLights: array<PointLight>;\r\n\r\n@group(1) @binding(4) var<storage, read_write> debugValue: f32;\r\n// -------------------------------------------------------------- //\r\n\r\n\r\n// ------------------------- User Inputs ------------------------ //\r\n@group(2) @binding(0) var textureSampler: sampler;\r\n@group(2) @binding(1) var texture: texture_2d<f32>;\r\n// -------------------------------------------------------------- //\r\n\r\nstruct VertexOut {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) uv: vec2<f32>,\r\n    @location(1) fragmentPosition: vec4<f32>,\r\n    @location(2) alpha: f32\r\n}\r\n\r\nstruct VertexIn {\r\n    @builtin(instance_index) instanceId : u32,\r\n    @location(0) position: vec4<f32>,\r\n    @location(1) uv: vec2<f32>\r\n}\r\n\r\n@vertex\r\nfn vertex_main(vertex: VertexIn) -> VertexOut {\r\n    const MAX_DISTANCE: f32 = 3;\r\n    const MAX_LIFETIME: f32 = 9999;\r\n\r\n    var particle: Particle = particles[vertex.instanceId];\r\n\r\n    let positionMatrix: mat4x4<f32> = mat4x4<f32>(\r\n        1, 0, 0, 0,\r\n        0, 1, 0, 0,\r\n        0, 0, 1, 0,\r\n        particle.position.x, particle.position.y, particle.position.z, 1,\r\n    );\r\n\r\n    let rotationMatrixX: mat4x4<f32> = mat4x4<f32>(\r\n        1, 0, 0, 0,\r\n        0, cos(particle.rotation.x), -sin(particle.rotation.x), 0,\r\n        0, sin(particle.rotation.x), cos(particle.rotation.x), 0,\r\n        0, 0, 0, 1\r\n    );\r\n\r\n    let rotationMatrixY: mat4x4<f32> = mat4x4<f32>(\r\n        cos(particle.rotation.y), 0, sin(particle.rotation.y), 0,\r\n        0, 1, 0, 0,\r\n        -sin(particle.rotation.y), 0, cos(particle.rotation.y), 0,\r\n        0, 0, 0, 1\r\n    );\r\n\r\n    let rotationMatrixZ: mat4x4<f32> = mat4x4<f32>(\r\n        cos(particle.rotation.z), -sin(particle.rotation.z), 0, 0,\r\n        sin(particle.rotation.z), cos(particle.rotation.z), 0, 0,\r\n        0, 0, 1, 0,\r\n        0, 0, 0, 1\r\n    );\r\n\r\n    let rotationMatrix: mat4x4<f32> = rotationMatrixX * rotationMatrixY * rotationMatrixZ;\r\n\r\n    let distanceScale: f32 = (MAX_DISTANCE - distance(particle.position, camera.position)) / MAX_DISTANCE;\r\n    let scalingMatrix: mat4x4<f32> = mat4x4<f32>(\r\n        distanceScale, 0, 0, 0,\r\n        0, distanceScale, 0, 0,\r\n        0, 0, distanceScale, 0,\r\n        0, 0, 0, 1,\r\n    );\r\n\r\n    let worldPosition: vec4<f32> = positionMatrix * scalingMatrix * transformationMatrix * rotationMatrix * vertex.position;\r\n\r\n    var out: VertexOut;\r\n    out.position = camera.viewProjection * worldPosition;\r\n    out.uv = vertex.uv;\r\n    out.fragmentPosition = worldPosition;\r\n    out.alpha = clamp(particle.lifetime, 0, 1);\r\n\r\n    return out;\r\n}\r\n\r\nstruct FragmentIn {\r\n    @location(0) uv: vec2<f32>,\r\n    @location(1) fragmentPosition: vec4<f32>,\r\n    @location(2) alpha: f32\r\n}\r\n\r\n@fragment\r\nfn fragment_main(fragment: FragmentIn) -> @location(0) vec4<f32> {\r\n    var color = textureSample(texture, textureSampler, fragment.uv);\r\n    color.a *= fragment.alpha;\r\n\r\n    if(color.a == 0) {\r\n        discard;\r\n    }\r\n\r\n    return color;\r\n}", "// ------------------------- Object Values ---------------------- //\r\n@group(0) @binding(0) var<uniform> transformationMatrix: mat4x4<f32>;\r\n// -------------------------------------------------------------- //\r\n\r\n\r\n// ------------------------- World Values ---------------------- //\r\nstruct CameraTransformation {\r\n    rotation: mat4x4<f32>,\r\n    translation: mat4x4<f32>\r\n}\r\nstruct Camera {\r\n    viewProjection: mat4x4<f32>,\r\n    view: mat4x4<f32>,\r\n    projection: mat4x4<f32>,\r\n    translation: CameraTransformation,\r\n    invertedTranslation: CameraTransformation,\r\n    position: vec3<f32>\r\n}\r\n@group(1) @binding(0) var<uniform> camera: Camera;\r\n\r\nstruct TimeData {\r\n    timestamp: f32,\r\n    delta: f32\r\n}\r\n@group(1) @binding(1) var<uniform> time: TimeData;\r\n\r\nstruct AmbientLight {\r\n    color: vec4<f32>\r\n}\r\n@group(1) @binding(2) var<uniform> ambientLight: AmbientLight;\r\n\r\nstruct PointLight {\r\n    position: vec4<f32>,\r\n    color: vec4<f32>,\r\n    range: f32\r\n}\r\n@group(1) @binding(3) var<storage, read> pointLights: array<PointLight>;\r\n\r\n@group(1) @binding(4) var<storage, read_write> debugValue: f32;\r\n// -------------------------------------------------------------- //\r\n\r\nstruct VertexOut {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) color: vec4<f32>,\r\n}\r\n\r\nstruct VertexIn {\r\n    @builtin(instance_index) instanceId : u32,\r\n    @location(0) position: vec4<f32>,\r\n    @location(1) uv: vec2<f32>,\r\n    @location(2) normal: vec4<f32>\r\n}\r\n\r\n@vertex\r\nfn vertex_main(vertex: VertexIn) -> VertexOut {\r\n    var instanceLight: PointLight = pointLights[vertex.instanceId];\r\n\r\n    var out: VertexOut;\r\n    out.position = camera.viewProjection * (instanceLight.position + vertex.position) * transformationMatrix;\r\n    out.color = instanceLight.color;\r\n\r\n    return out;\r\n}\r\n\r\nstruct FragmentIn {\r\n    @location(0) color: vec4<f32>,\r\n}\r\n\r\n@fragment\r\nfn fragment_main(fragment: FragmentIn) -> @location(0) vec4<f32> {\r\n    return fragment.color;\r\n}", "// ------------------------- Object Values ---------------------- //\r\n@group(0) @binding(0) var cubeTextureSampler: sampler;\r\n@group(0) @binding(1) var cubeMap: texture_cube<f32>;\r\n// -------------------------------------------------------------- //\r\n\r\n\r\n// ------------------------- World Values ---------------------- //\r\nstruct CameraTransformation {\r\n    rotation: mat4x4<f32>,\r\n    translation: mat4x4<f32>\r\n}\r\nstruct Camera {\r\n    viewProjection: mat4x4<f32>,\r\n    view: mat4x4<f32>,\r\n    projection: mat4x4<f32>,\r\n    translation: CameraTransformation,\r\n    invertedTranslation: CameraTransformation,\r\n    position: vec3<f32>\r\n}\r\n@group(1) @binding(0) var<uniform> camera: Camera;\r\n\r\nstruct TimeData {\r\n    timestamp: f32,\r\n    delta: f32\r\n}\r\n@group(1) @binding(1) var<uniform> time: TimeData;\r\n\r\nstruct AmbientLight {\r\n    color: vec4<f32>\r\n}\r\n@group(1) @binding(2) var<uniform> ambientLight: AmbientLight;\r\n\r\nstruct PointLight {\r\n    position: vec4<f32>,\r\n    color: vec4<f32>,\r\n    range: f32\r\n}\r\n@group(1) @binding(3) var<storage, read> pointLights: array<PointLight>;\r\n\r\n@group(1) @binding(4) var<storage, read_write> debugValue: f32;\r\n// -------------------------------------------------------------- //\r\n\r\nstruct VertexOut {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(1) fragmentPosition: vec4<f32>,\r\n}\r\n\r\nstruct VertexIn {\r\n    @location(0) position: vec4<f32>,\r\n}\r\n\r\n@vertex\r\nfn vertex_main(vertex: VertexIn) -> VertexOut {\r\n    var out: VertexOut;\r\n    out.position = camera.projection * camera.invertedTranslation.rotation  * vertex.position;\r\n    out.fragmentPosition = vertex.position;\r\n\r\n    return out;\r\n}\r\n\r\nstruct FragmentIn {\r\n    @location(1) fragmentPosition: vec4<f32>,\r\n}\r\n\r\n@fragment\r\nfn fragment_main(fragment: FragmentIn) -> @location(0) vec4<f32> {\r\n  return textureSample(cubeMap, cubeTextureSampler, fragment.fragmentPosition.xyz);\r\n}", "// ------------------------- Object Values ---------------------- //\r\n@group(0) @binding(0) var<uniform> transformationMatrix: mat4x4<f32>;\r\n// -------------------------------------------------------------- //\r\n\r\n\r\n// ------------------------- World Values ---------------------- //\r\nstruct CameraTransformation {\r\n    rotation: mat4x4<f32>,\r\n    translation: mat4x4<f32>\r\n}\r\nstruct Camera {\r\n    viewProjection: mat4x4<f32>,\r\n    view: mat4x4<f32>,\r\n    projection: mat4x4<f32>,\r\n    translation: CameraTransformation,\r\n    invertedTranslation: CameraTransformation,\r\n    position: vec3<f32>\r\n}\r\n@group(1) @binding(0) var<uniform> camera: Camera;\r\n\r\nstruct TimeData {\r\n    timestamp: f32,\r\n    delta: f32\r\n}\r\n@group(1) @binding(1) var<uniform> time: TimeData;\r\n\r\nstruct AmbientLight {\r\n    color: vec4<f32>\r\n}\r\n@group(1) @binding(2) var<uniform> ambientLight: AmbientLight;\r\n\r\nstruct PointLight {\r\n    position: vec4<f32>,\r\n    color: vec4<f32>,\r\n    range: f32\r\n}\r\n@group(1) @binding(3) var<storage, read> pointLights: array<PointLight>;\r\n\r\n@group(1) @binding(4) var<storage, read_write> debugValue: f32;\r\n// -------------------------------------------------------------- //\r\n\r\n\r\n// ------------------------- User Inputs ------------------------ //\r\n@group(2) @binding(0) var videoTextureSampler: sampler;\r\n@group(2) @binding(1) var videoTexture: texture_2d<f32>;\r\n// -------------------------------------------------------------- //\r\n\r\n\r\n// --------------------- Light calculations --------------------- //\r\n\r\n/**\r\n * Calculate point light output.\r\n */\r\nfn calculatePointLights(fragmentPosition: vec4<f32>, normal: vec4<f32>) -> vec4<f32> {\r\n    // Count of point lights.\r\n    let pointLightCount: u32 = arrayLength(&pointLights);\r\n\r\n    var lightResult: vec4<f32> = vec4<f32>(0, 0, 0, 1);\r\n\r\n    for (var index: u32 = 0; index < pointLightCount; index++) {\r\n        var pointLight: PointLight = pointLights[index];\r\n\r\n        // Calculate light strength based on angle of incidence.\r\n        let lightDirection: vec4<f32> = normalize(pointLight.position - fragmentPosition);\r\n        let diffuse: f32 = max(dot(normal, lightDirection), 0.0);\r\n\r\n        lightResult += pointLight.color * diffuse;\r\n    }\r\n\r\n    return lightResult;\r\n}\r\n\r\n/**\r\n * Apply lights to fragment color.\r\n */\r\nfn applyLight(colorIn: vec4<f32>, fragmentPosition: vec4<f32>, normal: vec4<f32>) -> vec4<f32> {\r\n    var lightColor: vec4<f32> = vec4<f32>(0, 0, 0, 1);\r\n\r\n    lightColor += ambientLight.color;\r\n    lightColor += calculatePointLights(fragmentPosition, normal);\r\n\r\n    return lightColor * colorIn;\r\n}\r\n// -------------------------------------------------------------- //\r\nstruct VertexOut {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) uv: vec2<f32>,\r\n    @location(1) normal: vec4<f32>,\r\n    @location(2) fragmentPosition: vec4<f32>,\r\n}\r\n\r\nstruct VertexIn {\r\n    @builtin(instance_index) instanceId : u32,\r\n    @location(0) position: vec4<f32>,\r\n    @location(1) uv: vec2<f32>,\r\n    @location(2) normal: vec4<f32>\r\n}\r\n\r\n@vertex\r\nfn vertex_main(vertex: VertexIn) -> VertexOut {\r\n    let translation: mat4x4<f32> = mat4x4(\r\n        vec4<f32>(1, 0, 0, 0),\r\n        vec4<f32>(0, 1, 0, 0),\r\n        vec4<f32>(0, 0, 1, 0),\r\n        transformationMatrix[3]\r\n    );\r\n\r\n    let scaling: mat4x4<f32> = mat4x4(\r\n        vec4<f32>(length(transformationMatrix[0].xyz), 0, 0, 0),\r\n        vec4<f32>(0, length(transformationMatrix[1].xyz), 0, 0),\r\n        vec4<f32>(0, 0, length(transformationMatrix[2].xyz), 0),\r\n        vec4<f32>(0, 0, 0, 1),\r\n    );\r\n\r\n    var transformedPosition: vec4<f32> = translation * camera.translation.rotation * scaling  * vertex.position;\r\n\r\n    var out: VertexOut;\r\n    out.position = camera.viewProjection * transformedPosition;\r\n    out.uv = vertex.uv;\r\n    out.normal = camera.translation.rotation * vertex.normal;\r\n    out.fragmentPosition = transformedPosition;\r\n\r\n    return out;\r\n}\r\n\r\nstruct FragmentIn {\r\n    @location(0) uv: vec2<f32>,\r\n    @location(1) normal: vec4<f32>,\r\n    @location(2) fragmentPosition: vec4<f32>,\r\n}\r\n\r\n@fragment\r\nfn fragment_main(fragment: FragmentIn) -> @location(0) vec4<f32> {\r\n    let videoColor: vec4<f32> = textureSample(videoTexture, videoTextureSampler, fragment.uv);\r\n\r\n    const red: f32 = 53;\r\n    const green: f32 = 214;\r\n    const blue: f32 = 19;\r\n\r\n    const redGreenRatio: f32 = red / green;\r\n    const blueGreenRatio: f32 = blue / green;\r\n\r\n    const ratioTolerance: f32 = 0.5;\r\n\r\n    let curredRedGreenRatio: f32 = videoColor.r / videoColor.g;\r\n    let curredBlueGreenRatio: f32 = videoColor.b / videoColor.g;\r\n\r\n    let compareRed: f32 = abs(curredRedGreenRatio - redGreenRatio);\r\n    let compareBlue: f32 = abs(curredBlueGreenRatio - blueGreenRatio);\r\n    \r\n\r\n    if(compareRed < ratioTolerance && compareBlue < ratioTolerance) {\r\n        return vec4<f32>(videoColor.rgb, 0.0);\r\n    }\r\n\r\n    return vec4<f32>(applyLight(videoColor, fragment.fragmentPosition, fragment.normal).rgb, (sin(fragment.uv.y * 750 + time.timestamp * 20) * 0.5 + 1) * 0.7);\r\n}", "// Create attributes data.\r\nexport const CanvasVertexPositionData: Array<number> = [ // 4x Position\r\n    -1.0, 1.0, 0.0, 1.0,\r\n    1.0, 1.0, 0.0, 1.0,\r\n    1.0, -1.0, 0.0, 1.0,\r\n    -1.0, -1.0, 0.0, 1.0,\r\n];\r\n\r\nexport const CanvasVertexUvData: Array<number> = [ // 4x Position\r\n    //  0, 1, 3\r\n    0.0, 0.0,\r\n    1.0, 0.0,\r\n    0.0, 1.0,\r\n    // 1, 2, 3\r\n    1.0, 0.0,\r\n    1.0, 1.0,\r\n    0.0, 1.0,\r\n];\r\n\r\nexport const CanvasVertexNormalData: Array<number> = [ // 4x Position\r\n    // Back 1,0,3\r\n    0, 0, -1, 0,\r\n    0, 0, -1, 0,\r\n    0, 0, -1, 0,\r\n\r\n    0, 0, -1, 0,\r\n    0, 0, -1, 0,\r\n    0, 0, -1, 0,\r\n];\r\n\r\n// Create mesh.\r\nexport const CanvasVertexIndices = [\r\n    0, 1, 3,\r\n    1, 2, 3,\r\n];", "// Create attributes data.\r\nexport const CubeVertexPositionData: Array<number> = [ // 4x Position\r\n    // Back\r\n    -1.0, 1.0, 1.0, 1.0,\r\n    1.0, 1.0, 1.0, 1.0,\r\n    1.0, -1.0, 1.0, 1.0,\r\n    -1.0, -1.0, 1.0, 1.0,\r\n\r\n    // Front\r\n    -1.0, 1.0, -1.0, 1.0,\r\n    1.0, 1.0, -1.0, 1.0,\r\n    1.0, -1.0, -1.0, 1.0,\r\n    -1.0, -1.0, -1.0, 1.0\r\n];\r\n\r\nexport const CubeVertexUvData: Array<number> = [ // 4x Position\r\n    // Front 4,5,6\r\n    0.33333, 0.25,\r\n    0.66666, 0.25,\r\n    0.66666, 0.50,\r\n    // Front 4,6,7\r\n    0.33333, 0.25,\r\n    0.66666, 0.50,\r\n    0.33333, 0.50,\r\n\r\n    // Back 1,0,3\r\n    0.66666, 1,\r\n    0.33333, 1,\r\n    0.33333, 0.75,\r\n    // Back 1,3,2\r\n    0.66666, 1,\r\n    0.33333, 0.75,\r\n    0.66666, 0.75,\r\n\r\n    // Left 0,4,7\r\n    0, 0.25,\r\n    0.33333, 0.25,\r\n    0.33333, 0.50,\r\n    // Left 0,7,3\r\n    0, 0.25,\r\n    0.33333, 0.50,\r\n    0, 0.50,\r\n\r\n    // Right 5,1,2\r\n    0.66666, 0.25,\r\n    1, 0.25,\r\n    1, 0.50,\r\n    // Right 5,2,6\r\n    0.66666, 0.25,\r\n    1, 0.50,\r\n    0.66666, 0.50,\r\n\r\n    // Top 0,1,5\r\n    0.33333, 0,\r\n    0.66666, 0,\r\n    0.66666, 0.25,\r\n    // Top 0,5,4\r\n    0.33333, 0,\r\n    0.66666, 0.25,\r\n    0.33333, 0.25,\r\n\r\n    // Bottom 7,6,2\r\n    0.33333, 0.50,\r\n    0.66666, 0.50,\r\n    0.66666, 0.75,\r\n    // Bottom 7,2,3\r\n    0.33333, 0.50,\r\n    0.66666, 0.75,\r\n    0.33333, 0.75,\r\n];\r\n\r\nexport const CubeVertexNormalData: Array<number> = [ // 4x Position\r\n    // Front\r\n    0, 0, -1, 0,\r\n    0, 0, -1, 0,\r\n    0, 0, -1, 0,\r\n    0, 0, -1, 0,\r\n    0, 0, -1, 0,\r\n    0, 0, -1, 0,\r\n\r\n    // Back 1,0,3\r\n    0, 0, 1, 0,\r\n    0, 0, 1, 0,\r\n    0, 0, 1, 0,\r\n    0, 0, 1, 0,\r\n    0, 0, 1, 0,\r\n    0, 0, 1, 0,\r\n\r\n    // Left 0,4,7\r\n    -1, 0, 0, 0,\r\n    -1, 0, 0, 0,\r\n    -1, 0, 0, 0,\r\n    -1, 0, 0, 0,\r\n    -1, 0, 0, 0,\r\n    -1, 0, 0, 0,\r\n\r\n    // Right 5,1,2\r\n    1, 0, 0, 0,\r\n    1, 0, 0, 0,\r\n    1, 0, 0, 0,\r\n    1, 0, 0, 0,\r\n    1, 0, 0, 0,\r\n    1, 0, 0, 0,\r\n\r\n    // Top 0,1,5\r\n    0, 1, 0, 0,\r\n    0, 1, 0, 0,\r\n    0, 1, 0, 0,\r\n    0, 1, 0, 0,\r\n    0, 1, 0, 0,\r\n    0, 1, 0, 0,\r\n\r\n    // Bottom 7,6,2\r\n    0, -1, 0, 0,\r\n    0, -1, 0, 0,\r\n    0, -1, 0, 0,\r\n    0, -1, 0, 0,\r\n    0, -1, 0, 0,\r\n    0, -1, 0, 0,\r\n];\r\n\r\n// Create mesh.\r\nexport const CubeVertexIndices = [\r\n    // Front\r\n    4, 5, 6,\r\n    4, 6, 7,\r\n    // Back\r\n    1, 0, 3,\r\n    1, 3, 2,\r\n    // Left\r\n    0, 4, 7,\r\n    0, 7, 3,\r\n    // Right\r\n    5, 1, 2,\r\n    5, 2, 6,\r\n    // Top\r\n    0, 1, 5,\r\n    0, 5, 4,\r\n    // Bottom\r\n    7, 6, 2,\r\n    7, 2, 3\r\n];", "// Create attributes data.\r\nexport const ParticleVertexPositionUvData: Array<number> = [ // 4x Position, 2x uv\r\n    // 1\r\n    -1.0, 0.5, 0.0, 1.0,/* UV */ 0.0, 0.0,\r\n    0.0, -0.5, 0.0, 1.0,/* UV */ 0.5, 1.0,\r\n    - 1.0, -0.5, -0.6, 1.0,/* UV */ 0.0, 1.0,\r\n\r\n    // 2\r\n    - 1.0, 0.5, 0.0, 1.0,/* UV */ 0.0, 0.0,\r\n    0.0, 0.5, 0.0, 1.0,/* UV */ 0.5, 0.0,\r\n    0.0, -0.5, 0.0, 1.0,/* UV */ 0.5, 1.0,\r\n\r\n    // 3\r\n    0.0, 0.5, 0.0, 1.0,/* UV */ 0.5, 0.0,\r\n    1.0, -0.5, -0.6, 1.0,/* UV */ 1.0, 1.0,\r\n    0.0, -0.5, 0.0, 1.0,/* UV */ 0.5, 1.0,\r\n\r\n    // 4\r\n    0.0, 0.5, 0.0, 1.0,/* UV */ 0.5, 0.0,\r\n    1.0, 0.5, -1.2, 1.0,/* UV */ 1.0, 0.0,\r\n    1.0, -0.5, -0.6, 1.0,/* UV */ 1.0, 1.0,\r\n];\r\n\r\n// Create mesh.\r\nexport const ParticleVertexIndices = [\r\n    0, 1, 2,\r\n    3, 4, 5,\r\n    6, 7, 8,\r\n    9, 10, 11\r\n];", "import { Dictionary } from '@kartoffelgames/core';\r\nimport { GpuBufferView } from '../../source/buffer/gpu-buffer-view.ts';\r\nimport { CameraMatrix, ViewProjection } from './camera/view_projection/view-projection.ts';\r\n\r\nexport const InitCameraControls = (pCanvas: HTMLCanvasElement, pCamera: ViewProjection, pCameraBuffer: GpuBufferView<Float32Array>): void => {\r\n\r\n    const lCurrentActionValue: Dictionary<string, number> = new Dictionary<string, number>();\r\n\r\n    // Initialize all action values to 0\r\n    lCurrentActionValue.set('Forward', 0);\r\n    lCurrentActionValue.set('Back', 0);\r\n    lCurrentActionValue.set('Left', 0);\r\n    lCurrentActionValue.set('Right', 0);\r\n    lCurrentActionValue.set('Up', 0);\r\n    lCurrentActionValue.set('Down', 0);\r\n    lCurrentActionValue.set('RotateLeft', 0);\r\n    lCurrentActionValue.set('RotateRight', 0);\r\n    lCurrentActionValue.set('Yaw', 0);\r\n    lCurrentActionValue.set('Pitch', 0);\r\n\r\n    // Keyboard event handlers\r\n    window.addEventListener('keydown', (pEvent) => {\r\n        switch (pEvent.code) {\r\n            case 'KeyW':\r\n                lCurrentActionValue.set('Forward', 1);\r\n                break;\r\n            case 'KeyS':\r\n                lCurrentActionValue.set('Back', 1);\r\n                break;\r\n            case 'KeyA':\r\n                lCurrentActionValue.set('Left', 1);\r\n                break;\r\n            case 'KeyD':\r\n                lCurrentActionValue.set('Right', 1);\r\n                break;\r\n            case 'ShiftLeft':\r\n                lCurrentActionValue.set('Up', 1);\r\n                break;\r\n            case 'ControlLeft':\r\n                lCurrentActionValue.set('Down', 1);\r\n                break;\r\n            case 'KeyQ':\r\n                lCurrentActionValue.set('RotateLeft', 1);\r\n                break;\r\n            case 'KeyE':\r\n                lCurrentActionValue.set('RotateRight', 1);\r\n                break;\r\n        }\r\n    });\r\n\r\n    window.addEventListener('keyup', (pEvent) => {\r\n        switch (pEvent.code) {\r\n            case 'KeyW':\r\n                lCurrentActionValue.set('Forward', 0);\r\n                break;\r\n            case 'KeyS':\r\n                lCurrentActionValue.set('Back', 0);\r\n                break;\r\n            case 'KeyA':\r\n                lCurrentActionValue.set('Left', 0);\r\n                break;\r\n            case 'KeyD':\r\n                lCurrentActionValue.set('Right', 0);\r\n                break;\r\n            case 'ShiftLeft':\r\n                lCurrentActionValue.set('Up', 0);\r\n                break;\r\n            case 'ControlLeft':\r\n                lCurrentActionValue.set('Down', 0);\r\n                break;\r\n            case 'KeyQ':\r\n                lCurrentActionValue.set('RotateLeft', 0);\r\n                break;\r\n            case 'KeyE':\r\n                lCurrentActionValue.set('RotateRight', 0);\r\n                break;\r\n        }\r\n    });\r\n\r\n    // Mouse movement for camera rotation\r\n    let lMouseMoveTimeout: number | null = null;\r\n    \r\n    window.addEventListener('mousemove', (pEvent) => {\r\n        const lDeltaX = pEvent.movementX;\r\n        const lDeltaY = pEvent.movementY;\r\n\r\n        // Normalize mouse movement to -1 to 1 range (10x faster sensitivity)\r\n        const lSensitivity = 0.5;\r\n        const lYawValue = Math.max(-1, Math.min(1, lDeltaX * lSensitivity));\r\n        const lPitchValue = Math.max(-1, Math.min(1, lDeltaY * lSensitivity));\r\n\r\n        lCurrentActionValue.set('Yaw', lYawValue);\r\n        lCurrentActionValue.set('Pitch', lPitchValue);\r\n        \r\n        // Clear existing timeout\r\n        if (lMouseMoveTimeout !== null) {\r\n            clearTimeout(lMouseMoveTimeout);\r\n        }\r\n        \r\n        // Reset mouse values after a short delay when movement stops\r\n        lMouseMoveTimeout = setTimeout(() => {\r\n            lCurrentActionValue.set('Yaw', 0);\r\n            lCurrentActionValue.set('Pitch', 0);\r\n        }, 16); // ~1 frame at 60fps\r\n    });\r\n\r\n    pCanvas.addEventListener('click', () => {\r\n        pCanvas.requestPointerLock();\r\n    });\r\n\r\n    window.setInterval(() => {\r\n        const lSpeed = 10;\r\n\r\n        // Z Axis\r\n        if (lCurrentActionValue.get('Forward')! > 0) {\r\n            pCamera.transformation.translateInDirection((lCurrentActionValue.get('Forward')! / 50) * lSpeed, 0, 0);\r\n        }\r\n        if (lCurrentActionValue.get('Back')! > 0) {\r\n            pCamera.transformation.translateInDirection(-(lCurrentActionValue.get('Back')! / 50) * lSpeed, 0, 0);\r\n        }\r\n\r\n        // X Axis\r\n        if (lCurrentActionValue.get('Right')! > 0) {\r\n            pCamera.transformation.translateInDirection(0, (lCurrentActionValue.get('Right')! / 50) * lSpeed, 0);\r\n        }\r\n        if (lCurrentActionValue.get('Left')! > 0) {\r\n            pCamera.transformation.translateInDirection(0, -(lCurrentActionValue.get('Left')! / 50) * lSpeed, 0);\r\n        }\r\n\r\n        // Y Axis\r\n        if (lCurrentActionValue.get('Up')! > 0) {\r\n            pCamera.transformation.translateInDirection(0, 0, (lCurrentActionValue.get('Up')! / 50) * lSpeed);\r\n        }\r\n        if (lCurrentActionValue.get('Down')! > 0) {\r\n            pCamera.transformation.translateInDirection(0, 0, -(lCurrentActionValue.get('Down')! / 50) * lSpeed);\r\n        }\r\n\r\n        // Rotation.\r\n        if (lCurrentActionValue.get('Yaw')! > 0 || lCurrentActionValue.get('Yaw')! < 0) {\r\n            pCamera.transformation.addEulerRotation(0, lCurrentActionValue.get('Yaw')!, 0);\r\n        }\r\n        if (lCurrentActionValue.get('Pitch')! > 0 || lCurrentActionValue.get('Pitch')! < 0) {\r\n            pCamera.transformation.addEulerRotation(lCurrentActionValue.get('Pitch')!, 0, 0);\r\n        }\r\n        if (lCurrentActionValue.get('RotateLeft')! > 0) {\r\n            pCamera.transformation.addEulerRotation(0, 0, lCurrentActionValue.get('RotateLeft')!);\r\n        }\r\n        if (lCurrentActionValue.get('RotateRight')! > 0) {\r\n            pCamera.transformation.addEulerRotation(0, 0, -lCurrentActionValue.get('RotateRight')!);\r\n        }\r\n\r\n        // Update transformation buffer.\r\n        pCameraBuffer.write(pCamera.getMatrix(CameraMatrix.ViewProjection).dataArray, ['viewProjection']);\r\n        pCameraBuffer.write(pCamera.getMatrix(CameraMatrix.View).dataArray, ['view']);\r\n        pCameraBuffer.write(pCamera.getMatrix(CameraMatrix.Projection).dataArray, ['projection']);\r\n        pCameraBuffer.write([pCamera.transformation.translationX, pCamera.transformation.translationY, pCamera.transformation.translationZ], ['position']);\r\n\r\n        pCameraBuffer.write(pCamera.getMatrix(CameraMatrix.Rotation).dataArray, ['translation', 'rotation']);\r\n        pCameraBuffer.write(pCamera.getMatrix(CameraMatrix.Translation).dataArray, ['translation', 'translation']);\r\n        pCameraBuffer.write(pCamera.getMatrix(CameraMatrix.Rotation).inverse().dataArray, ['invertedTranslation', 'rotation']);\r\n        pCameraBuffer.write(pCamera.getMatrix(CameraMatrix.Translation).inverse().dataArray, ['invertedTranslation', 'translation']);\r\n    }, 8);\r\n};\r\n\r\nexport const UpdateFpsDisplay = (() => {\r\n    let lMaxFps: number = 0;\r\n\r\n    return (pFps: number, pWidth: number): void => {\r\n        const lCanvas: HTMLCanvasElement = document.getElementById('fps-display') as HTMLCanvasElement;\r\n        const lCanvasContext: CanvasRenderingContext2D = lCanvas.getContext('2d', { willReadFrequently: true })!;\r\n\r\n        // Update canvas width.\r\n        if (pWidth !== lCanvas.width) {\r\n            lCanvas.width = pWidth;\r\n            lCanvas.height = 30;\r\n        }\r\n\r\n        if (lCanvas.width < 2) {\r\n            return;\r\n        }\r\n\r\n        // Get current fps image data except the first pixel column.\r\n        const lLastFpsData: ImageData = lCanvasContext.getImageData(1, 0, lCanvas.width - 1, lCanvas.height);\r\n\r\n        // Adjust to new fps scaling.\r\n        let lScaling: number = 1;\r\n        if (lMaxFps < pFps) {\r\n            lScaling = lMaxFps / pFps;\r\n            lMaxFps = pFps;\r\n        }\r\n\r\n        // now clear the right-most pixels:\r\n        if (lScaling === 1) {\r\n            lCanvasContext.clearRect(lCanvas.width - 1, 0, 1, lCanvas.height);\r\n        } else {\r\n            lCanvasContext.clearRect(0, 0, lCanvas.width, lCanvas.height);\r\n        }\r\n\r\n        // Put image data to left.\r\n        const lScalingSize: number = Math.floor(lCanvas.height * lScaling);\r\n        lCanvasContext.putImageData(lLastFpsData, 0, lCanvas.height - (lScalingSize), 0, 0, lCanvas.width - 1, lScalingSize);\r\n\r\n        // Calculate heigt of rect.\r\n        const lRectHeight: number = (pFps / lMaxFps) * lCanvas.height;\r\n\r\n        // Draw current fps.\r\n        lCanvasContext.fillStyle = '#87beee';\r\n        lCanvasContext.fillRect(lCanvas.width - 1, lCanvas.height - lRectHeight, 1, lRectHeight);\r\n    };\r\n})();", "import { GpuBuffer } from '../../source/buffer/gpu-buffer.ts';\r\nimport { GpuBufferView } from '../../source/buffer/gpu-buffer-view.ts';\r\nimport { BufferItemFormat } from '../../source/constant/buffer-item-format.enum.ts';\r\nimport { BufferItemMultiplier } from '../../source/constant/buffer-item-multiplier.enum.ts';\r\nimport { CompareFunction } from '../../source/constant/compare-function.enum.ts';\r\nimport { ComputeStage } from '../../source/constant/compute-stage.enum.ts';\r\nimport { GpuFeature } from '../../source/constant/gpu-feature.enum.ts';\r\nimport { PrimitiveCullMode } from '../../source/constant/primitive-cullmode.enum.ts';\r\nimport { SamplerType } from '../../source/constant/sampler-type.enum.ts';\r\nimport { StorageBindingType } from '../../source/constant/storage-binding-type.enum.ts';\r\nimport { TextureBlendFactor } from '../../source/constant/texture-blend-factor.enum.ts';\r\nimport { TextureBlendOperation } from '../../source/constant/texture-blend-operation.enum.ts';\r\nimport { TextureFormat } from '../../source/constant/texture-format.enum.ts';\r\nimport { TextureViewDimension } from '../../source/constant/texture-view-dimension.enum.ts';\r\nimport { VertexParameterStepMode } from '../../source/constant/vertex-parameter-step-mode.enum.ts';\r\nimport { GpuDevice } from '../../source/device/gpu-device.ts';\r\nimport { GpuExecution } from '../../source/execution/gpu-execution.ts';\r\nimport { ComputePass } from '../../source/execution/pass/compute-pass.ts';\r\nimport { RenderPass } from '../../source/execution/pass/render-pass.ts';\r\nimport { BindGroup } from '../../source/pipeline/bind_group/bind-group.ts';\r\nimport { BindGroupLayout } from '../../source/pipeline/bind_group_layout/bind-group-layout.ts';\r\nimport { ComputePipeline } from '../../source/pipeline/compute-pipeline.ts';\r\nimport { PipelineData } from '../../source/pipeline/pipeline_data/pipeline-data.ts';\r\nimport { RenderTargets, RenderTargetsInvalidationType } from '../../source/pipeline/render_targets/render-targets.ts';\r\nimport { VertexFragmentPipeline } from '../../source/pipeline/vertex_fragment_pipeline/vertex-fragment-pipeline.ts';\r\nimport { VertexParameter } from '../../source/pipeline/vertex_parameter/vertex-parameter.ts';\r\nimport { Shader } from '../../source/shader/shader.ts';\r\nimport { ShaderRenderModule } from '../../source/shader/shader-render-module.ts';\r\nimport { CanvasTexture } from '../../source/texture/canvas-texture.ts';\r\nimport { GpuTexture, GpuTextureCopyOptions } from '../../source/texture/gpu-texture.ts';\r\nimport { AmbientLight } from './camera/light/ambient-light.ts';\r\nimport { Transform, TransformMatrix } from './camera/transform.ts';\r\nimport { PerspectiveProjection } from './camera/view_projection/projection/perspective-projection.ts';\r\nimport { ViewProjection } from './camera/view_projection/view-projection.ts';\r\nimport colorCubeShader from './game_objects/color_cube/color-cube-shader.wgsl';\r\nimport cubeShader from './game_objects/cube/cube-shader.wgsl';\r\nimport particleComputeShader from './game_objects/leaf_particle/particle-compute-shader.wgsl';\r\nimport particleShader from './game_objects/leaf_particle/particle-shader.wgsl';\r\nimport lightBoxShader from './game_objects/light/light-box-shader.wgsl';\r\nimport skyboxShader from './game_objects/skybox/sky-box-shader.wgsl';\r\nimport videoCanvasShader from './game_objects/video_canvas/video-canvas-shader.wgsl';\r\nimport { CanvasVertexIndices, CanvasVertexNormalData, CanvasVertexPositionData, CanvasVertexUvData } from './meshes/canvas-mesh.ts';\r\nimport { CubeVertexIndices, CubeVertexNormalData, CubeVertexPositionData, CubeVertexUvData } from './meshes/cube-mesh.ts';\r\nimport { ParticleVertexIndices, ParticleVertexPositionUvData } from './meshes/particle-mesh.ts';\r\nimport { InitCameraControls, UpdateFpsDisplay } from './util.ts';\r\n\r\nconst gGenerateCubeStep = (pGpu: GpuDevice, pRenderTargets: RenderTargets, pWorldGroup: BindGroup): RenderInstruction => {\r\n    const lHeight: number = 50;\r\n    const lWidth: number = 50;\r\n    const lDepth: number = 50;\r\n\r\n    // Create shader.\r\n    const lWoodBoxShader = pGpu.shader(cubeShader).setup((pShaderSetup) => {\r\n        // Set parameter.\r\n        pShaderSetup.parameter('animationSeconds', ComputeStage.Vertex);\r\n\r\n        // Vertex entry.\r\n        pShaderSetup.vertexEntryPoint('vertex_main', (pVertexParameterSetup) => {\r\n            pVertexParameterSetup.buffer('position', VertexParameterStepMode.Index)\r\n                .withParameter('position', 0, BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n\r\n            pVertexParameterSetup.buffer('uv', VertexParameterStepMode.Vertex)\r\n                .withParameter('uv', 1, BufferItemFormat.Float32, BufferItemMultiplier.Vector2);\r\n\r\n            pVertexParameterSetup.buffer('normal', VertexParameterStepMode.Vertex)\r\n                .withParameter('normal', 2, BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n        });\r\n\r\n        // Fragment entry.\r\n        pShaderSetup.fragmentEntryPoint('fragment_main')\r\n            .addRenderTarget('main', 0, BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n\r\n        // Object bind group.\r\n        pShaderSetup.group(0, 'object', (pBindGroupSetup) => {\r\n            pBindGroupSetup.binding(0, 'transformationMatrix', ComputeStage.Vertex)\r\n                .asBuffer().withPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Matrix44);\r\n\r\n            pBindGroupSetup.binding(1, 'instancePositions', ComputeStage.Vertex, StorageBindingType.Read)\r\n                .asBuffer().withArray().withPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n        });\r\n\r\n        // World bind group.\r\n        pShaderSetup.group(1, pWorldGroup.layout);\r\n\r\n        // User bind group\r\n        pShaderSetup.group(2, 'user', (pBindGroupSetup) => {\r\n            pBindGroupSetup.binding(0, 'cubeTextureSampler', ComputeStage.Fragment)\r\n                .asSampler(SamplerType.Filter);\r\n\r\n            pBindGroupSetup.binding(1, 'cubeTexture', ComputeStage.Fragment | ComputeStage.Vertex)\r\n                .asTexture(TextureViewDimension.TwoDimensionArray, TextureFormat.Rgba8unorm);\r\n        });\r\n    });\r\n\r\n    // Create render module from shader.\r\n    const lWoodBoxRenderModule: ShaderRenderModule = lWoodBoxShader.createRenderModule('vertex_main', 'fragment_main');\r\n\r\n    // Transformation and position group. \r\n    const lWoodBoxTransformationGroup = lWoodBoxRenderModule.layout.getGroupLayout('object').create();\r\n\r\n    // Create transformation.\r\n    lWoodBoxTransformationGroup.data('transformationMatrix').createBuffer(new Transform().setScale(1, 1, 1).getMatrix(TransformMatrix.Transformation).dataArray);\r\n\r\n    // Create instance positions.\r\n    const lCubeInstanceTransformationData: Array<number> = new Array<number>();\r\n    for (let lWidthIndex: number = 0; lWidthIndex < lWidth; lWidthIndex++) {\r\n        for (let lHeightIndex: number = 0; lHeightIndex < lHeight; lHeightIndex++) {\r\n            for (let lDepthIndex: number = 0; lDepthIndex < lDepth; lDepthIndex++) {\r\n                lCubeInstanceTransformationData.push(lWidthIndex * 3, lHeightIndex * 3, lDepthIndex * 3, 1);\r\n            }\r\n        }\r\n    }\r\n    lWoodBoxTransformationGroup.data('instancePositions').createBuffer(lCubeInstanceTransformationData);\r\n\r\n    /*\r\n     * User defined group.\r\n     */\r\n    const lWoodBoxUserGroup = lWoodBoxRenderModule.layout.getGroupLayout('user').create();\r\n\r\n    // Setup cube texture.\r\n    const lImageTexture: GpuTexture = lWoodBoxUserGroup.data('cubeTexture').createTexture().texture;\r\n    lImageTexture.depth = 3;\r\n    lImageTexture.mipCount = 20;\r\n    (async () => {\r\n        const lSourceList: Array<string> = [\r\n            '/source/game_objects/cube/texture_one/cube-texture.png',\r\n            '/source/game_objects/cube/texture_two/cube-texture.png',\r\n            '/source/game_objects/cube/texture_three/cube-texture.png'\r\n        ];\r\n\r\n        let lHeight: number = 0;\r\n        let lWidth: number = 0;\r\n\r\n        // \"Random\" colors.\r\n        const lColorList: Array<string> = new Array<string>();\r\n        for (let lIndex: number = 0; lIndex < 20; lIndex++) {\r\n            lColorList.push('#' + Math.floor(Math.random() * 16777215).toString(16));\r\n        }\r\n\r\n        // Parallel load images.\r\n        const lImageLoadPromiseList: Array<Promise<Array<GpuTextureCopyOptions>>> = lSourceList.map(async (pSource, pIndex: number) => {\r\n            // Load image with html image element.\r\n            const lImage: HTMLImageElement = new Image();\r\n            lImage.src = pSource;\r\n            await lImage.decode();\r\n\r\n            // Init size.\r\n            if (lHeight === 0 || lWidth === 0) {\r\n                lWidth = lImage.naturalWidth;\r\n                lHeight = lImage.naturalHeight;\r\n            }\r\n\r\n            // Validate same image size for all layers.\r\n            if (lHeight !== lImage.naturalHeight || lWidth !== lImage.naturalWidth) {\r\n                throw new Error(`Texture image layers are not the same size. (${lImage.naturalWidth}, ${lImage.naturalHeight}) needs (${lWidth}, ${lHeight}).`);\r\n            }\r\n\r\n            const lWaiter: Array<Promise<void>> = new Array<Promise<void>>();\r\n            const lMipList: Array<GpuTextureCopyOptions> = new Array<GpuTextureCopyOptions>();\r\n\r\n            // Add level one.\r\n            lWaiter.push(createImageBitmap(lImage).then((pBitmap) => {\r\n                lMipList.push({\r\n                    data: pBitmap,\r\n                    mipLevel: 0,\r\n                    targetOrigin: { x: 0, y: 0, z: pIndex }\r\n                });\r\n            }));\r\n\r\n            // Generate all mips.\r\n            const lMaxMipCount = 1 + Math.floor(Math.log2(Math.max(lWidth, lHeight)));\r\n            for (let lMipLevel: number = 1; lMipLevel < lMaxMipCount; lMipLevel++) {\r\n                const lCanvas: OffscreenCanvas = new OffscreenCanvas(\r\n                    Math.max(1, Math.floor(lWidth / Math.pow(2, lMipLevel))),\r\n                    Math.max(1, Math.floor(lHeight / Math.pow(2, lMipLevel)))\r\n                );\r\n\r\n                // Fill canvas.\r\n                const lCanvasContext: OffscreenCanvasRenderingContext2D = lCanvas.getContext('2d')!;\r\n                lCanvasContext.globalAlpha = 1;\r\n                lCanvasContext.drawImage(lImage, 0, 0, lWidth, lHeight, 0, 0, lCanvas.width, lCanvas.height);\r\n                lCanvasContext.globalAlpha = 0.5;\r\n                lCanvasContext.fillStyle = lColorList[lMipLevel];\r\n                lCanvasContext.fillRect(0, 0, lCanvas.width, lCanvas.height);\r\n\r\n                lWaiter.push(createImageBitmap(lCanvas).then((pBitmap) => {\r\n                    lMipList.push({\r\n                        data: pBitmap,\r\n                        mipLevel: lMipLevel,\r\n                        targetOrigin: { x: 0, y: 0, z: pIndex }\r\n                    });\r\n                }));\r\n            }\r\n\r\n            // Wait for all images to resolve.\r\n            await Promise.all(lWaiter);\r\n\r\n            return lMipList;\r\n        }).flat();\r\n\r\n        // Resolve all bitmaps.\r\n        const lImageList: Array<GpuTextureCopyOptions> = (await Promise.all(lImageLoadPromiseList)).flat();\r\n\r\n        // Set new texture size.\r\n        lImageTexture.width = lWidth;\r\n        lImageTexture.height = lHeight;\r\n        lImageTexture.depth = lSourceList.length;\r\n\r\n        // Copy images into texture.\r\n        lImageTexture.copyFrom(...lImageList);\r\n\r\n        // Test for keeping information on resize.\r\n        lImageTexture.width = lImageTexture.width * 2;\r\n        lImageTexture.native;\r\n        lImageTexture.width = lImageTexture.width / 2;\r\n    })();\r\n\r\n    // Setup Sampler.\r\n    lWoodBoxUserGroup.data('cubeTextureSampler').createSampler();\r\n\r\n    // Generate render parameter from parameter layout.\r\n    const lMesh: VertexParameter = lWoodBoxRenderModule.vertexParameter.create(CubeVertexIndices);\r\n    lMesh.create('position', CubeVertexPositionData);\r\n    lMesh.create('uv', CubeVertexUvData);\r\n    lMesh.create('normal', CubeVertexNormalData);\r\n\r\n    // Create pipeline.\r\n    const lWoodBoxPipeline: VertexFragmentPipeline = lWoodBoxRenderModule.create(pRenderTargets);\r\n    lWoodBoxPipeline.primitiveCullMode = PrimitiveCullMode.Front;\r\n    lWoodBoxPipeline.setParameter('animationSeconds', 3);\r\n    (<any>window).animationSpeed = (pSeconds: number) => {\r\n        lWoodBoxPipeline.setParameter('animationSeconds', pSeconds);\r\n    };\r\n\r\n    return {\r\n        pipeline: lWoodBoxPipeline,\r\n        parameter: lMesh,\r\n        instanceCount: lWidth * lHeight * lDepth,\r\n        data: lWoodBoxPipeline.layout.withData((pSetup) => {\r\n            pSetup.addGroup(lWoodBoxTransformationGroup);\r\n            pSetup.addGroup(pWorldGroup);\r\n            pSetup.addGroup(lWoodBoxUserGroup);\r\n        })\r\n    };\r\n};\r\n\r\nconst gGenerateColorCubeStep = (pGpu: GpuDevice, pRenderTargets: RenderTargets, pWorldGroup: BindGroup): Array<RenderInstruction> => {\r\n    // Create shader.\r\n    const lColorBoxShader = pGpu.shader(colorCubeShader).setup((pShaderSetup) => {\r\n        // Vertex entry.\r\n        pShaderSetup.vertexEntryPoint('vertex_main', (pVertexParameterSetup) => {\r\n            pVertexParameterSetup.buffer('position', VertexParameterStepMode.Index)\r\n                .withParameter('position', 0, BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n\r\n            pVertexParameterSetup.buffer('normal', VertexParameterStepMode.Vertex)\r\n                .withParameter('normal', 1, BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n        });\r\n\r\n        // Fragment entry.\r\n        pShaderSetup.fragmentEntryPoint('fragment_main')\r\n            .addRenderTarget('main', 0, BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n\r\n        // Object bind group.\r\n        pShaderSetup.group(0, 'object', (pBindGroupSetup) => {\r\n            pBindGroupSetup.binding(0, 'transformationMatrix', ComputeStage.Vertex)\r\n                .asBuffer(true).withPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Matrix44);\r\n\r\n            pBindGroupSetup.binding(1, 'color', ComputeStage.Vertex)\r\n                .asBuffer(true).withPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n        });\r\n\r\n        // World bind group.\r\n        pShaderSetup.group(1, pWorldGroup.layout);\r\n    });\r\n\r\n    // Create render module from shader.\r\n    const lWoodBoxRenderModule: ShaderRenderModule = lColorBoxShader.createRenderModule('vertex_main', 'fragment_main');\r\n\r\n    // Transformation and position group. \r\n    const lColorBoxTransformationGroup = lWoodBoxRenderModule.layout.getGroupLayout('object').create();\r\n\r\n    // Create transformation.\r\n    lColorBoxTransformationGroup.data('transformationMatrix').createBuffer(3);\r\n    lColorBoxTransformationGroup.data('transformationMatrix').asBufferView(Float32Array, 0).write(new Transform().setScale(1, 1, 1).setTranslation(2, -30, 5).getMatrix(TransformMatrix.Transformation).dataArray);\r\n    lColorBoxTransformationGroup.data('transformationMatrix').asBufferView(Float32Array, 1).write(new Transform().setScale(1, 1, 1).setTranslation(0, -30, 5).getMatrix(TransformMatrix.Transformation).dataArray);\r\n    lColorBoxTransformationGroup.data('transformationMatrix').asBufferView(Float32Array, 2).write(new Transform().setScale(1, 1, 1).setTranslation(-2, -30, 5).getMatrix(TransformMatrix.Transformation).dataArray);\r\n\r\n    // Setup cube texture.\r\n    lColorBoxTransformationGroup.data('color').createBuffer([\r\n        /* Color 1*/ 0.89, 0.74, 0.00, 1,\r\n        /* Color 2*/ 0.92, 0.48, 0.14, 1\r\n    ]);\r\n\r\n    // Generate render parameter from parameter layout.\r\n    const lMesh: VertexParameter = lWoodBoxRenderModule.vertexParameter.create(CubeVertexIndices);\r\n    lMesh.create('position', CubeVertexPositionData);\r\n    lMesh.create('normal', CubeVertexNormalData);\r\n\r\n    // Create pipeline.\r\n    const lColorBoxPipeline: VertexFragmentPipeline = lWoodBoxRenderModule.create(pRenderTargets);\r\n    lColorBoxPipeline.primitiveCullMode = PrimitiveCullMode.Front;\r\n\r\n    return [{\r\n        pipeline: lColorBoxPipeline,\r\n        parameter: lMesh,\r\n        instanceCount: 1,\r\n        data: lColorBoxPipeline.layout.withData((pSetup) => {\r\n            pSetup.addGroup(lColorBoxTransformationGroup)\r\n                .withOffset('color', 0)\r\n                .withOffset('transformationMatrix', 0);\r\n            pSetup.addGroup(pWorldGroup);\r\n        })\r\n    },\r\n    {\r\n        pipeline: lColorBoxPipeline,\r\n        parameter: lMesh,\r\n        instanceCount: 1,\r\n        data: lColorBoxPipeline.layout.withData((pSetup) => {\r\n            pSetup.addGroup(lColorBoxTransformationGroup)\r\n                .withOffset('color', 1)\r\n                .withOffset('transformationMatrix', 1);\r\n            pSetup.addGroup(pWorldGroup);\r\n        })\r\n    },\r\n    {\r\n        pipeline: lColorBoxPipeline,\r\n        parameter: lMesh,\r\n        instanceCount: 1,\r\n        data: lColorBoxPipeline.layout.withData((pSetup) => {\r\n            pSetup.addGroup(lColorBoxTransformationGroup)\r\n                .withOffset('color', 0)\r\n                .withOffset('transformationMatrix', 2);\r\n            pSetup.addGroup(pWorldGroup);\r\n        })\r\n    }];\r\n};\r\n\r\nconst gGenerateLightBoxStep = (pGpu: GpuDevice, pRenderTargets: RenderTargets, pWorldGroup: BindGroup): RenderInstruction => {\r\n    // Create shader.\r\n    const lLightBoxShader: Shader = pGpu.shader(lightBoxShader).setup((pShaderSetup) => {\r\n        // Vertex entry.\r\n        pShaderSetup.vertexEntryPoint('vertex_main', (pVertexParameterSetup) => {\r\n            pVertexParameterSetup.buffer('position', VertexParameterStepMode.Index)\r\n                .withParameter('position', 0, BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n\r\n            pVertexParameterSetup.buffer('uv', VertexParameterStepMode.Vertex)\r\n                .withParameter('uv', 1, BufferItemFormat.Float32, BufferItemMultiplier.Vector2);\r\n\r\n            pVertexParameterSetup.buffer('normal', VertexParameterStepMode.Vertex)\r\n                .withParameter('normal', 2, BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n        });\r\n\r\n        // Fragment entry.\r\n        pShaderSetup.fragmentEntryPoint('fragment_main')\r\n            .addRenderTarget('main', 0, BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n\r\n        // Object bind group.\r\n        pShaderSetup.group(0, 'object', (pBindGroupSetup) => {\r\n            pBindGroupSetup.binding(0, 'transformationMatrix', ComputeStage.Vertex)\r\n                .asBuffer().withPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Matrix44);\r\n        });\r\n\r\n        // World bind group.\r\n        pShaderSetup.group(1, pWorldGroup.layout);\r\n    });\r\n\r\n    // Create render module from shader.\r\n    const lLightBoxRenderModule = lLightBoxShader.createRenderModule('vertex_main', 'fragment_main');\r\n\r\n    // Transformation and position group. \r\n    const lLightBoxTransformationGroup = lLightBoxShader.layout.getGroupLayout('object').create();\r\n\r\n    // Create transformation.\r\n    lLightBoxTransformationGroup.data('transformationMatrix').createBuffer(new Transform().setScale(1, 1, 1).getMatrix(TransformMatrix.Transformation).dataArray);\r\n\r\n    const lLightBoxPipeline: VertexFragmentPipeline = lLightBoxRenderModule.create(pRenderTargets);\r\n    lLightBoxPipeline.primitiveCullMode = PrimitiveCullMode.Front;\r\n\r\n    // Generate render parameter from parameter layout.\r\n    const lMesh: VertexParameter = lLightBoxRenderModule.vertexParameter.create(CubeVertexIndices);\r\n    lMesh.create('position', CubeVertexPositionData);\r\n    lMesh.create('uv', CubeVertexUvData);\r\n    lMesh.create('normal', CubeVertexNormalData);\r\n\r\n    // Create buffer view for pointlights.\r\n    const lPointLightsBuffer: GpuBufferView<Float32Array> = pWorldGroup.data('pointLights').asBufferView(Float32Array);\r\n\r\n    return {\r\n        pipeline: lLightBoxPipeline,\r\n        parameter: lMesh,\r\n        instanceCount: lPointLightsBuffer.length / 12,\r\n        data: lLightBoxPipeline.layout.withData((pSetup) => {\r\n            pSetup.addGroup(lLightBoxTransformationGroup);\r\n            pSetup.addGroup(pWorldGroup);\r\n        })\r\n    };\r\n};\r\n\r\nconst gGenerateSkyboxStep = (pGpu: GpuDevice, pRenderTargets: RenderTargets, pWorldGroup: BindGroup): RenderInstruction => {\r\n    const lSkyBoxShader: Shader = pGpu.shader(skyboxShader).setup((pShaderSetup) => {\r\n        // Vertex entry.\r\n        pShaderSetup.vertexEntryPoint('vertex_main', (pVertexParameterSetup) => {\r\n            pVertexParameterSetup.buffer('position', VertexParameterStepMode.Index)\r\n                .withParameter('position', 0, BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n        });\r\n\r\n        // Fragment entry.\r\n        pShaderSetup.fragmentEntryPoint('fragment_main')\r\n            .addRenderTarget('main', 0, BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n\r\n        pShaderSetup.group(0, 'object', (pBindGroupSetup) => {\r\n            pBindGroupSetup.binding(0, 'cubeTextureSampler', ComputeStage.Fragment)\r\n                .asSampler(SamplerType.Filter);\r\n\r\n            pBindGroupSetup.binding(1, 'cubeMap', ComputeStage.Fragment)\r\n                .asTexture(TextureViewDimension.Cube, TextureFormat.Rgba8unorm);\r\n        });\r\n\r\n        // World bind group.\r\n        pShaderSetup.group(1, pWorldGroup.layout);\r\n    });\r\n\r\n    // Create render module from shader.\r\n    const lSkyBoxRenderModule = lSkyBoxShader.createRenderModule('vertex_main', 'fragment_main');\r\n\r\n    // Transformation and position group. \r\n    const lSkyBoxTextureGroup = lSkyBoxShader.layout.getGroupLayout('object').create();\r\n\r\n    const lImageTexture: GpuTexture = lSkyBoxTextureGroup.data('cubeMap').createTexture().texture;\r\n    lImageTexture.depth = 6;\r\n    (async () => {\r\n        const lSourceList: Array<string> = [\r\n            '/source/game_objects/skybox/right.jpg',\r\n            '/source/game_objects/skybox/left.jpg',\r\n            '/source/game_objects/skybox/top.jpg',\r\n            '/source/game_objects/skybox/bottom.jpg',\r\n            '/source/game_objects/skybox/front.jpg',\r\n            '/source/game_objects/skybox/back.jpg'\r\n        ];\r\n\r\n        let lHeight: number = 0;\r\n        let lWidth: number = 0;\r\n\r\n        // Parallel load images.\r\n        const lImageLoadPromiseList: Array<Promise<ImageBitmap>> = lSourceList.map(async (pSource) => {\r\n            // Load image with html image element.\r\n            const lImage: HTMLImageElement = new Image();\r\n            lImage.src = pSource;\r\n            await lImage.decode();\r\n\r\n            // Init size.\r\n            if (lHeight === 0 || lWidth === 0) {\r\n                lWidth = lImage.naturalWidth;\r\n                lHeight = lImage.naturalHeight;\r\n            }\r\n\r\n            // Validate same image size for all layers.\r\n            if (lHeight !== lImage.naturalHeight || lWidth !== lImage.naturalWidth) {\r\n                throw new Error(`Texture image layers are not the same size. (${lImage.naturalWidth}, ${lImage.naturalHeight}) needs (${lWidth}, ${lHeight}).`);\r\n            }\r\n\r\n            return createImageBitmap(lImage);\r\n        });\r\n\r\n        // Resolve all bitmaps.\r\n        const lImageList: Array<ImageBitmap> = await Promise.all(lImageLoadPromiseList);\r\n\r\n        // Set new texture size.\r\n        lImageTexture.width = lWidth;\r\n        lImageTexture.height = lHeight;\r\n        lImageTexture.depth = lSourceList.length;\r\n\r\n        // Copy images into texture.\r\n        lImageTexture.copyFrom(...lImageList);\r\n    })();\r\n\r\n    // Setup Sampler.\r\n    lSkyBoxTextureGroup.data('cubeTextureSampler').createSampler();\r\n\r\n    // Generate render parameter from parameter layout.\r\n    const lMesh: VertexParameter = lSkyBoxRenderModule.vertexParameter.create(CubeVertexIndices);\r\n    lMesh.create('position', CubeVertexPositionData);\r\n\r\n    const lSkyBoxPipeline: VertexFragmentPipeline = lSkyBoxRenderModule.create(pRenderTargets);\r\n    lSkyBoxPipeline.primitiveCullMode = PrimitiveCullMode.Back;\r\n    lSkyBoxPipeline.depthConfig().enableWrite(false).compareWith(CompareFunction.Allways);\r\n\r\n    return {\r\n        pipeline: lSkyBoxPipeline,\r\n        parameter: lMesh,\r\n        instanceCount: 1,\r\n        data: lSkyBoxPipeline.layout.withData((pSetup) => {\r\n            pSetup.addGroup(lSkyBoxTextureGroup);\r\n            pSetup.addGroup(pWorldGroup);\r\n        })\r\n    };\r\n};\r\n\r\nconst gGenerateVideoCanvasStep = (pGpu: GpuDevice, pRenderTargets: RenderTargets, pWorldGroup: BindGroup): RenderInstruction => {\r\n    // Create shader.\r\n    const lWoodBoxShader = pGpu.shader(videoCanvasShader).setup((pShaderSetup) => {\r\n        // Vertex entry.\r\n        pShaderSetup.vertexEntryPoint('vertex_main', (pVertexParameterSetup) => {\r\n            pVertexParameterSetup.buffer('position', VertexParameterStepMode.Index)\r\n                .withParameter('position', 0, BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n\r\n            pVertexParameterSetup.buffer('uv', VertexParameterStepMode.Vertex)\r\n                .withParameter('uv', 1, BufferItemFormat.Float32, BufferItemMultiplier.Vector2);\r\n\r\n            pVertexParameterSetup.buffer('normal', VertexParameterStepMode.Vertex)\r\n                .withParameter('normal', 2, BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n        });\r\n\r\n        // Fragment entry.\r\n        pShaderSetup.fragmentEntryPoint('fragment_main')\r\n            .addRenderTarget('main', 0, BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n\r\n        // Object bind group.\r\n        pShaderSetup.group(0, 'object', (pBindGroupSetup) => {\r\n            pBindGroupSetup.binding(0, 'transformationMatrix', ComputeStage.Vertex)\r\n                .asBuffer().withPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Matrix44);\r\n        });\r\n\r\n        // World bind group.\r\n        pShaderSetup.group(1, pWorldGroup.layout);\r\n\r\n        // User bind group\r\n        pShaderSetup.group(2, 'user', (pBindGroupSetup) => {\r\n            pBindGroupSetup.binding(0, 'videoTextureSampler', ComputeStage.Fragment)\r\n                .asSampler(SamplerType.Filter);\r\n\r\n            pBindGroupSetup.binding(1, 'videoTexture', ComputeStage.Fragment)\r\n                .asTexture(TextureViewDimension.TwoDimension, TextureFormat.Rgba8unorm);\r\n        });\r\n    });\r\n\r\n    // Create render module from shader.\r\n    const lWoodBoxRenderModule: ShaderRenderModule = lWoodBoxShader.createRenderModule('vertex_main', 'fragment_main');\r\n\r\n    // Transformation and position group. \r\n    const lTransformationGroup = lWoodBoxRenderModule.layout.getGroupLayout('object').create();\r\n\r\n    // Create transformation.\r\n    lTransformationGroup.data('transformationMatrix').createBuffer(new Transform().addTranslation(-0.5, -0.5, 100).setScale(15, 8.4, 0).getMatrix(TransformMatrix.Transformation).dataArray);\r\n\r\n    /*\r\n     * User defined group.\r\n     */\r\n    const lUserGroup = lWoodBoxRenderModule.layout.getGroupLayout('user').create();\r\n\r\n    // Setup cube texture.\r\n    const lVideoTexture: GpuTexture = lUserGroup.data('videoTexture').createTexture().texture;\r\n\r\n    // Create video.\r\n    const lVideo = document.createElement('video');\r\n    lVideo.preload = 'auto';\r\n    lVideo.loop = true;\r\n    lVideo.muted = true; // Allways muted.\r\n    lVideo.src = '/source/game_objects/video_canvas/earth.mp4';\r\n    lVideo.addEventListener('resize', () => {\r\n        lVideoTexture.height = Math.max(lVideo.videoHeight, 1);\r\n        lVideoTexture.width = Math.max(lVideo.videoWidth, 1);\r\n    });\r\n    lVideo.play();\r\n\r\n    let lTimeStamp: number = performance.now();\r\n    pGpu.addFrameChangeListener(() => {\r\n        // Has at least one frame buffered.\r\n        if (lVideo.readyState > 1) {\r\n            const lFrameTimeStamp: number = performance.now();\r\n            createImageBitmap(lVideo).then((pImageBitmap) => {\r\n                if (lFrameTimeStamp < lTimeStamp) {\r\n                    return;\r\n                }\r\n\r\n                lTimeStamp = lFrameTimeStamp;\r\n                lVideoTexture.copyFrom(pImageBitmap);\r\n            });\r\n        }\r\n    });\r\n\r\n    // Setup Sampler.\r\n    lUserGroup.data('videoTextureSampler').createSampler();\r\n\r\n    // Generate render parameter from parameter layout.\r\n    const lMesh: VertexParameter = lWoodBoxRenderModule.vertexParameter.create(CanvasVertexIndices);\r\n    lMesh.create('position', CanvasVertexPositionData);\r\n    lMesh.create('uv', CanvasVertexUvData);\r\n    lMesh.create('normal', CanvasVertexNormalData);\r\n\r\n    // Create pipeline.\r\n    const lPipeline: VertexFragmentPipeline = lWoodBoxRenderModule.create(pRenderTargets);\r\n    lPipeline.primitiveCullMode = PrimitiveCullMode.None;\r\n    lPipeline.depthConfig().enableWrite(false);\r\n    lPipeline.targetConfig('color')\r\n        .alphaBlend(TextureBlendOperation.Add, TextureBlendFactor.One, TextureBlendFactor.OneMinusSrcAlpha)\r\n        .colorBlend(TextureBlendOperation.Add, TextureBlendFactor.SrcAlpha, TextureBlendFactor.OneMinusSrcAlpha);\r\n\r\n    return {\r\n        pipeline: lPipeline,\r\n        parameter: lMesh,\r\n        instanceCount: 1,\r\n        data: lPipeline.layout.withData((pSetup) => {\r\n            pSetup.addGroup(lTransformationGroup);\r\n            pSetup.addGroup(pWorldGroup);\r\n            pSetup.addGroup(lUserGroup);\r\n        })\r\n    };\r\n};\r\n\r\nconst gGenerateParticleStep = (pGpu: GpuDevice, pRenderTargets: RenderTargets, pWorldGroup: BindGroup): [RenderInstruction, ComputeInstruction] => {\r\n    const lMaxParticleCount: number = 18000;\r\n\r\n    const lParticleRenderShader: Shader = pGpu.shader(particleShader).setup((pShaderSetup) => {\r\n        // Set parameter.\r\n        pShaderSetup.parameter('animationSeconds', ComputeStage.Vertex);\r\n\r\n        // Vertex entry.\r\n        pShaderSetup.vertexEntryPoint('vertex_main', (pVertexParameterSetup) => {\r\n            pVertexParameterSetup.buffer('position-uv', VertexParameterStepMode.Index)\r\n                .withParameter('position', 0, BufferItemFormat.Float32, BufferItemMultiplier.Vector4)\r\n                .withParameter('uv', 1, BufferItemFormat.Float32, BufferItemMultiplier.Vector2);\r\n        });\r\n\r\n        // Fragment entry.\r\n        pShaderSetup.fragmentEntryPoint('fragment_main')\r\n            .addRenderTarget('main', 0, BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n\r\n        // Compute entry.\r\n        pShaderSetup.computeEntryPoint('compute_main').size(64);\r\n\r\n        // Object bind group.\r\n        pShaderSetup.group(0, 'object', (pBindGroupSetup) => {\r\n            pBindGroupSetup.binding(0, 'transformationMatrix', ComputeStage.Vertex)\r\n                .asBuffer().withPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Matrix44);\r\n            pBindGroupSetup.binding(1, 'particles', ComputeStage.Vertex, StorageBindingType.Read)\r\n                .asBuffer().withArray().withStruct((pStructSetup) => {\r\n                    pStructSetup.property('position').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Vector3);\r\n                    pStructSetup.property('rotation').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Vector3);\r\n                    pStructSetup.property('velocity').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Vector3);\r\n                    pStructSetup.property('lifetime').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Single);\r\n                });\r\n        });\r\n\r\n        // World bind group.\r\n        pShaderSetup.group(1, pWorldGroup.layout);\r\n\r\n        pShaderSetup.group(2, 'user', (pBindGroupSetup) => {\r\n            pBindGroupSetup.binding(0, 'textureSampler', ComputeStage.Fragment)\r\n                .asSampler(SamplerType.Filter);\r\n\r\n            pBindGroupSetup.binding(1, 'texture', ComputeStage.Fragment)\r\n                .asTexture(TextureViewDimension.TwoDimension, TextureFormat.Rgba8unorm);\r\n        });\r\n    });\r\n\r\n    // Create render module from shader.\r\n    const lParticleRenderModule = lParticleRenderShader.createRenderModule('vertex_main', 'fragment_main');\r\n\r\n    // Transformation and position group. \r\n    const lParticleInformationGroup = lParticleRenderModule.layout.getGroupLayout('object').create();\r\n    lParticleInformationGroup.data('particles').createBuffer(lMaxParticleCount);\r\n\r\n    // Create transformation.\r\n    lParticleInformationGroup.data('transformationMatrix').createBuffer(new Transform().setScale(0.02, 0.02, 0.02).getMatrix(TransformMatrix.Transformation).dataArray);\r\n\r\n    // Transformation and position group. \r\n    const lParticleTextureGroup = lParticleRenderShader.layout.getGroupLayout('user').create();\r\n\r\n    const lImageTexture: GpuTexture = lParticleTextureGroup.data('texture').createTexture().texture;\r\n    lImageTexture.depth = 6;\r\n    (async () => {\r\n        const lSourceList: Array<string> = [\r\n            '/source/game_objects/leaf_particle/leaf.png'\r\n        ];\r\n\r\n        let lHeight: number = 0;\r\n        let lWidth: number = 0;\r\n\r\n        // Parallel load images.\r\n        const lImageLoadPromiseList: Array<Promise<ImageBitmap>> = lSourceList.map(async (pSource) => {\r\n            // Load image with html image element.\r\n            const lImage: HTMLImageElement = new Image();\r\n            lImage.src = pSource;\r\n            await lImage.decode();\r\n\r\n            // Init size.\r\n            if (lHeight === 0 || lWidth === 0) {\r\n                lWidth = lImage.naturalWidth;\r\n                lHeight = lImage.naturalHeight;\r\n            }\r\n\r\n            // Validate same image size for all layers.\r\n            if (lHeight !== lImage.naturalHeight || lWidth !== lImage.naturalWidth) {\r\n                throw new Error(`Texture image layers are not the same size. (${lImage.naturalWidth}, ${lImage.naturalHeight}) needs (${lWidth}, ${lHeight}).`);\r\n            }\r\n\r\n            return createImageBitmap(lImage);\r\n        });\r\n\r\n        // Resolve all bitmaps.\r\n        const lImageList: Array<ImageBitmap> = await Promise.all(lImageLoadPromiseList);\r\n\r\n        // Set new texture size.\r\n        lImageTexture.width = lWidth;\r\n        lImageTexture.height = lHeight;\r\n        lImageTexture.depth = lSourceList.length;\r\n\r\n        // Copy images into texture.\r\n        lImageTexture.copyFrom(...lImageList);\r\n    })();\r\n\r\n    // Setup Sampler.\r\n    lParticleTextureGroup.data('textureSampler').createSampler();\r\n\r\n    // Generate render parameter from parameter layout.\r\n    const lMesh: VertexParameter = lParticleRenderModule.vertexParameter.create(ParticleVertexIndices);\r\n    lMesh.create('position-uv', ParticleVertexPositionUvData);\r\n\r\n    const lParticlePipeline: VertexFragmentPipeline = lParticleRenderModule.create(pRenderTargets);\r\n    lParticlePipeline.primitiveCullMode = PrimitiveCullMode.None;\r\n    lParticlePipeline.depthConfig().enableWrite(true).compareWith(CompareFunction.Less);\r\n    lParticlePipeline.targetConfig('color')\r\n        .alphaBlend(TextureBlendOperation.Add, TextureBlendFactor.One, TextureBlendFactor.OneMinusSrcAlpha)\r\n        .colorBlend(TextureBlendOperation.Add, TextureBlendFactor.SrcAlpha, TextureBlendFactor.OneMinusSrcAlpha);\r\n\r\n    // vertexCount: GPUSize32, instanceCount?: GPUSize32, firstVertex?: GPUSize32, firstInstance?: GPUSize32    \r\n    const lIndirectionBuffer: GpuBuffer = new GpuBuffer(pGpu, 4 * 4).initialData(new Uint32Array([ParticleVertexIndices.length, 0, 0, 0]).buffer);\r\n\r\n    const lRenderInstruction: RenderInstruction = {\r\n        pipeline: lParticlePipeline,\r\n        parameter: lMesh,\r\n        instanceCount: 0,\r\n        data: lParticlePipeline.layout.withData((pSetup) => {\r\n            pSetup.addGroup(lParticleTextureGroup);\r\n            pSetup.addGroup(pWorldGroup);\r\n            pSetup.addGroup(lParticleInformationGroup);\r\n        }),\r\n        indirectBuffer: lIndirectionBuffer\r\n    };\r\n\r\n    /*\r\n     * Compute shader.\r\n     */\r\n    const lParticleComputeShader: Shader = pGpu.shader(particleComputeShader).setup((pShaderSetup) => {\r\n        // Set parameter.\r\n        pShaderSetup.parameter('animationSeconds', ComputeStage.Vertex);\r\n\r\n        // Compute entry.\r\n        pShaderSetup.computeEntryPoint('compute_main').size(64);\r\n\r\n        // Object bind group.\r\n        pShaderSetup.group(0, 'object', (pBindGroupSetup) => {\r\n            pBindGroupSetup.binding(0, 'particles', ComputeStage.Compute, StorageBindingType.ReadWrite)\r\n                .asBuffer().withArray().withStruct((pStructSetup) => {\r\n                    pStructSetup.property('position').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Vector3);\r\n                    pStructSetup.property('rotation').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Vector3);\r\n                    pStructSetup.property('velocity').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Vector3);\r\n                    pStructSetup.property('lifetime').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Single);\r\n                });\r\n\r\n            pBindGroupSetup.binding(1, 'indirect', ComputeStage.Compute, StorageBindingType.ReadWrite)\r\n                .asBuffer().withPrimitive(BufferItemFormat.Uint32, BufferItemMultiplier.Vector4);\r\n        });\r\n\r\n        // World bind group.\r\n        pShaderSetup.group(1, pWorldGroup.layout);\r\n    });\r\n\r\n    // Create render module from shader.\r\n    const lParticleComputeModule = lParticleComputeShader.createComputeModule('compute_main');\r\n\r\n    // Create compute pipeline.\r\n    const lComputePipeline: ComputePipeline = new ComputePipeline(pGpu, lParticleComputeModule);\r\n    lComputePipeline.setParameter('animationSeconds', 30);\r\n\r\n    // Transformation and position group. \r\n    const lParticleComputeInformationGroup = lParticleComputeModule.layout.getGroupLayout('object').create();\r\n    lParticleComputeInformationGroup.data('particles').set(lParticleInformationGroup.data('particles').getRaw());\r\n    lParticleComputeInformationGroup.data('indirect').set(lIndirectionBuffer);\r\n\r\n    // Create compute instruction\r\n    const lComputeInstruction: ComputeInstruction = {\r\n        pipeline: lComputePipeline,\r\n        data: lComputePipeline.layout.withData((pSetup) => {\r\n            pSetup.addGroup(lParticleComputeInformationGroup);\r\n            pSetup.addGroup(pWorldGroup);\r\n        }),\r\n        dimensions: {\r\n            x: Math.ceil(lMaxParticleCount / (lParticleComputeModule.workGroupSizeX * lParticleComputeModule.workGroupSizeY * lParticleComputeModule.workGroupSizeZ)),\r\n            y: 1,\r\n            z: 1\r\n        }\r\n    };\r\n\r\n    return [lRenderInstruction, lComputeInstruction];\r\n};\r\n\r\nconst gGenerateWorldBindGroup = (pGpu: GpuDevice): BindGroup => {\r\n    const lWorldGroupLayout = new BindGroupLayout(pGpu, 'world').setup((pBindGroupSetup) => {\r\n        pBindGroupSetup.binding(0, 'camera', ComputeStage.Vertex | ComputeStage.Compute).asBuffer().withStruct((pStructSetup) => {\r\n            pStructSetup.property('viewProjection').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Matrix44);\r\n            pStructSetup.property('view').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Matrix44);\r\n            pStructSetup.property('projection').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Matrix44);\r\n\r\n            pStructSetup.property('translation').asStruct((pTranslationStruct) => {\r\n                pTranslationStruct.property('rotation').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Matrix44);\r\n                pTranslationStruct.property('translation').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Matrix44);\r\n            });\r\n\r\n            pStructSetup.property('invertedTranslation').asStruct((pTranslationStruct) => {\r\n                pTranslationStruct.property('rotation').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Matrix44);\r\n                pTranslationStruct.property('translation').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Matrix44);\r\n            });\r\n\r\n            pStructSetup.property('position').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Vector3);\r\n        });\r\n\r\n        pBindGroupSetup.binding(1, 'timestamp', ComputeStage.Vertex | ComputeStage.Fragment | ComputeStage.Compute).asBuffer().withStruct((pTimeStruct) => {\r\n            pTimeStruct.property('timestamp').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Single);\r\n            pTimeStruct.property('delta').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Single);\r\n        });\r\n\r\n        pBindGroupSetup.binding(2, 'ambientLight', ComputeStage.Fragment)\r\n            .asBuffer().withStruct((pStruct) => {\r\n                pStruct.property('color').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n            });\r\n\r\n        pBindGroupSetup.binding(3, 'pointLights', ComputeStage.Fragment | ComputeStage.Vertex, StorageBindingType.Read)\r\n            .asBuffer().withArray().withStruct((pStruct) => {\r\n                pStruct.property('position').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n                pStruct.property('color').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Vector4);\r\n                pStruct.property('range').asPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Single);\r\n            });\r\n\r\n        pBindGroupSetup.binding(4, 'debugValue', ComputeStage.Fragment | ComputeStage.Compute, StorageBindingType.ReadWrite)\r\n            .asBuffer().withPrimitive(BufferItemFormat.Float32, BufferItemMultiplier.Single);\r\n\r\n    });\r\n\r\n    /*\r\n     * Camera and world group. \r\n     */\r\n    const lWorldGroup: BindGroup = lWorldGroupLayout.create();\r\n    lWorldGroup.data('camera').createBuffer();\r\n\r\n    // Create ambient light.\r\n    const lAmbientLight: AmbientLight = new AmbientLight();\r\n    lAmbientLight.setColor(0.3, 0.3, 0.3);\r\n    lWorldGroup.data('ambientLight').createBuffer(lAmbientLight.data);\r\n\r\n    // Create point lights.\r\n    lWorldGroup.data('pointLights').createBuffer([\r\n        /* Position */1, 1, 1, 1, /* Color */1, 0, 0, 1,/* Range */ 200,\r\n        /* Position */10, 10, 10, 1, /* Color */0, 0, 1, 1,/* Range */ 200,\r\n        /* Position */-10, 10, 10, 1, /* Color */0, 1, 0, 1,/* Range */ 200\r\n    ]);\r\n\r\n    // Create timestamp.\r\n    lWorldGroup.data('timestamp').createBuffer();\r\n\r\n    // Create debug value.\r\n    lWorldGroup.data('debugValue').createBuffer();\r\n    const lDebugBuffer: GpuBufferView<Float32Array> = lWorldGroup.data('debugValue').asBufferView(Float32Array);\r\n    (<any>window).debugBuffer = () => {\r\n        lDebugBuffer.read().then((pResulto) => {\r\n            // eslint-disable-next-line no-console\r\n            console.log(pResulto);\r\n        });\r\n    };\r\n\r\n    return lWorldGroup;\r\n};\r\n\r\n(async () => {\r\n    const lGpu: GpuDevice = await GpuDevice.request('high-performance', {\r\n        features: [\r\n            { name: GpuFeature.TimestampQuery, required: true }\r\n        ]\r\n    });\r\n\r\n    // Create canvas.\r\n    const lCanvasTexture: CanvasTexture = lGpu.canvas(document.getElementById('canvas') as HTMLCanvasElement);\r\n\r\n    // Create and configure render targets.\r\n    const lRenderTargets: RenderTargets = lGpu.renderTargets(true).setup((pSetup) => {\r\n        // Add \"color\" target and init new texture.\r\n        pSetup.addColor('color', 0, true, { r: 0, g: 1, b: 0, a: 0 })\r\n            .new(TextureFormat.Bgra8unorm, lCanvasTexture);\r\n\r\n        // Add depth texture and init new texture.    \r\n        pSetup.addDepthStencil(true, 1)\r\n            .new(TextureFormat.Depth24plus);\r\n    });\r\n\r\n    // Resize canvas.\r\n    (() => {\r\n        const lCanvasWrapper: HTMLDivElement = document.querySelector('.canvas-wrapper') as HTMLDivElement;\r\n        new ResizeObserver(() => {\r\n            const lNewCanvasHeight: number = Math.max(0, lCanvasWrapper.clientHeight - 20);\r\n            const lNewCanvasWidth: number = Math.max(lCanvasWrapper.clientWidth - 20, 0);\r\n\r\n            // Resize displayed render targets.\r\n            lRenderTargets.resize(lNewCanvasHeight, lNewCanvasWidth);\r\n        }).observe(lCanvasWrapper);\r\n    })();\r\n\r\n    // Create camera perspective.\r\n    const lPerspectiveProjection: PerspectiveProjection = new PerspectiveProjection();\r\n    lPerspectiveProjection.aspectRatio = lRenderTargets.width / lRenderTargets.height;\r\n    lPerspectiveProjection.angleOfView = 72;\r\n    lPerspectiveProjection.near = 0.1;\r\n    lPerspectiveProjection.far = Number.MAX_SAFE_INTEGER;\r\n    lRenderTargets.addInvalidationListener(() => {\r\n        lPerspectiveProjection.aspectRatio = lRenderTargets.width / lRenderTargets.height;\r\n    }, RenderTargetsInvalidationType.Resize);\r\n\r\n    // Create camera.\r\n    const lCamera: ViewProjection = new ViewProjection(lPerspectiveProjection);\r\n    lCamera.transformation.setTranslation(0, 0, -4);\r\n\r\n    const lWorldGroup: BindGroup = gGenerateWorldBindGroup(lGpu);\r\n    const lTimestampBuffer: GpuBufferView<Float32Array> = lWorldGroup.data('timestamp').asBufferView(Float32Array);\r\n\r\n    const [lParticelRenderInstruction, lParticelComputeInstruction] = gGenerateParticleStep(lGpu, lRenderTargets, lWorldGroup);\r\n\r\n    // Create instruction.\r\n    const lRenderSteps: Array<RenderInstruction> = [\r\n        gGenerateSkyboxStep(lGpu, lRenderTargets, lWorldGroup),\r\n        gGenerateCubeStep(lGpu, lRenderTargets, lWorldGroup),\r\n        gGenerateLightBoxStep(lGpu, lRenderTargets, lWorldGroup),\r\n        gGenerateVideoCanvasStep(lGpu, lRenderTargets, lWorldGroup),\r\n        ...gGenerateColorCubeStep(lGpu, lRenderTargets, lWorldGroup),\r\n        lParticelRenderInstruction\r\n    ];\r\n    const lRenderPass: RenderPass = lGpu.renderPass(lRenderTargets, (pContext) => {\r\n        for (const lStep of lRenderSteps) {\r\n            if (lStep.indirectBuffer) {\r\n                pContext.drawIndirect(\r\n                    lStep.pipeline,\r\n                    lStep.parameter,\r\n                    lStep.data,\r\n                    lStep.indirectBuffer\r\n                );\r\n            } else {\r\n                pContext.drawDirect(\r\n                    lStep.pipeline,\r\n                    lStep.parameter,\r\n                    lStep.data,\r\n                    lStep.instanceCount\r\n                );\r\n            }\r\n        }\r\n    });\r\n\r\n    (<any>window).renderpassRuntime = () => {\r\n        lRenderPass.probeTimestamp().then(([pStart, pEnd]) => {\r\n            // eslint-disable-next-line no-console\r\n            console.log('Runtime:', Number(pEnd - pStart) / 1000000, 'ms');\r\n        });\r\n    };\r\n\r\n    // Create instruction.\r\n    const lComputeSteps: Array<ComputeInstruction> = [\r\n        lParticelComputeInstruction\r\n    ];\r\n    const lComputePass: ComputePass = lGpu.computePass((pContext) => {\r\n        for (const lStep of lComputeSteps) {\r\n            pContext.computeDirect(\r\n                lStep.pipeline,\r\n                lStep.data,\r\n                lStep.dimensions.x,\r\n                lStep.dimensions.y,\r\n                lStep.dimensions.z\r\n            );\r\n        }\r\n    });\r\n\r\n    (<any>window).computepassRuntime = () => {\r\n        lComputePass.probeTimestamp().then(([pStart, pEnd]) => {\r\n            // eslint-disable-next-line no-console\r\n            console.log('Runtime:', Number(pEnd - pStart) / 1000000, 'ms');\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Controls\r\n     */\r\n    InitCameraControls(lCanvasTexture.canvas, lCamera, lWorldGroup.data('camera').asBufferView(Float32Array));\r\n\r\n    /*\r\n     * Execution \r\n     */\r\n    const lRenderExecutor: GpuExecution = lGpu.executor((pExecutor) => {\r\n        lComputePass.execute(pExecutor);\r\n        lRenderPass.execute(pExecutor);\r\n    });\r\n\r\n    const lFpsLabel = document.getElementById('fpsCounter')!;\r\n\r\n    // Actual execute.\r\n    let lLastTime: number = 0;\r\n    let lCurrentFps: number = 0;\r\n    const lRender = (pTime: number) => {\r\n        // Start new frame.\r\n        lGpu.startNewFrame();\r\n\r\n        // Generate fps and smooth fps numbers.\r\n        const lFps: number = 1000 / (pTime - lLastTime);\r\n        lCurrentFps = (1 - 0.05) * lCurrentFps + 0.05 * lFps;\r\n\r\n        // Update time stamp data.\r\n        lTimestampBuffer.write([pTime / 1000, (pTime - lLastTime) / 1000]);\r\n\r\n        lLastTime = pTime;\r\n\r\n        // Generate encoder and add render commands.\r\n        lRenderExecutor.execute();\r\n\r\n        // Update fps display.\r\n        UpdateFpsDisplay(lFps, lRenderTargets.width);\r\n\r\n        // Update FPS counter.\r\n        lFpsLabel.textContent = lCurrentFps.toFixed(0);\r\n\r\n        // Refresh canvas\r\n        requestAnimationFrame(lRender);\r\n    };\r\n    requestAnimationFrame(lRender);\r\n})();\r\n\r\ntype RenderInstruction = {\r\n    pipeline: VertexFragmentPipeline;\r\n    parameter: VertexParameter;\r\n    instanceCount: number;\r\n    data: PipelineData;\r\n    indirectBuffer?: GpuBuffer;\r\n};\r\n\r\ntype ComputeInstruction = {\r\n    pipeline: ComputePipeline;\r\n    data: PipelineData;\r\n    dimensions: {\r\n        x: number;\r\n        y: number;\r\n        z: number;\r\n    };\r\n};", "(() => {\n    const socket = new WebSocket('ws://127.0.0.1:8088');\n    socket.addEventListener('open', () => {\n        console.log('Refresh connection established');\n    });\n    socket.addEventListener('message', (event) => {\n        console.log('Bundle finished. Start refresh');\n        if (event.data === 'REFRESH') {\n            window.location.reload();\n        }\n    });\n})();\nimport('./index.ts');\n"],
  "mappings": "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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;KCAA,IAAAG,GAAAC,GAAAC,EAAA,KAAAF,GAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;KCAA,IAAAG,GAAAC,GAAAC,EAAA,KAAAF,GAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;KCAA,IAAAG,GAAAC,GAAAC,EAAA,KAAAF,GAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;KCAA,IAAAG,GAAAC,GAAAC,EAAA,KAAAF,GAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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",
  "names": ["List", "init_list", "__esmMin", "_List", "pItemList", "lNewList", "pArray", "lIndex", "pValue", "lFoundIndex", "pOldValue", "pNewValue", "lOldValue", "Exception", "init_exception", "__esmMin", "pMessage", "pTarget", "pErrorOptions", "Dictionary", "init_dictionary", "__esmMin", "init_list", "init_exception", "_Dictionary", "pKey", "pValue", "Exception", "pItem", "pDefault", "lValue", "pFunction", "lResultList", "List", "lKeyValuePair", "lMappingResult", "init_stack", "__esmMin", "init_linked_list", "__esmMin", "EnumUtil", "init_enum_util", "__esmMin", "_EnumUtil", "pEnum", "pValue", "pKey", "lEnumValues", "lKey", "init_type_util", "__esmMin", "init_myers_diff", "__esmMin", "init_source", "__esmMin", "init_dictionary", "init_list", "init_stack", "init_exception", "init_linked_list", "init_enum_util", "init_type_util", "init_myers_diff", "BufferUsage", "init_buffer_usage_enum", "__esmMin", "GpuObjectInvalidationReasons", "init_gpu_object_invalidation_reasons", "__esmMin", "init_source", "pDeconstruct", "Exception", "pReason", "GpuObject", "init_gpu_object", "__esmMin", "init_source", "init_gpu_object_invalidation_reasons", "pDevice", "Dictionary", "GpuObjectInvalidationReasons", "pListener", "pFirstAffected", "pAffected", "Exception", "lAffectedList", "lAffectedType", "List", "pReasons", "lExecuteReasonListener", "pReason", "lListenerList", "lListener", "lReason", "_pNative", "_pReasons", "_pCurrentNative", "_pReferences", "pSetupCallback", "lSetupReferences", "lSetupObject", "lCurrentNative", "GpuResourceObject", "init_gpu_resource_object", "__esmMin", "init_gpu_object", "GpuObject", "pDevice", "pUsage", "GpuLimit", "init_gpu_limit_enum", "__esmMin", "init_storage_binding_type_enum", "__esmMin", "GpuBufferView", "init_gpu_buffer_view", "__esmMin", "init_source", "init_gpu_limit_enum", "init_storage_binding_type_enum", "pBuffer", "pLayout", "pType", "pDynamicOffsetIndex", "pStorageType", "Exception", "lOffsetAlignment", "lMinBufferSize", "pLayoutPath", "lLocation", "pData", "lDataBuffer", "GpuBuffer", "init_gpu_buffer", "__esmMin", "init_source", "init_buffer_usage_enum", "init_gpu_resource_object", "init_gpu_buffer_view", "GpuResourceObject", "pByteCount", "pLimit", "pDevice", "BufferUsage", "pInitialData", "Exception", "pOffset", "pSize", "lOffset", "lSize", "lCommandDecoder", "lBufferReadResult", "pLayout", "pType", "pDynamicOffsetIndex", "GpuBufferView", "pData", "lNative", "lStagingBuffer", "lDataArrayBuffer", "lDataByteLength", "lMappedBuffer", "pNativeObject", "lWriteBuffer", "pLastNative", "lBuffer", "init_buffer_item_format_enum", "__esmMin", "init_buffer_item_multiplier_enum", "__esmMin", "init_compare_function_enum", "__esmMin", "ComputeStage", "init_compute_stage_enum", "__esmMin", "GpuFeature", "init_gpu_feature_enum", "__esmMin", "init_primitive_cullmode_enum", "__esmMin", "init_sampler_type_enum", "__esmMin", "init_texture_blend_factor_enum", "__esmMin", "init_texture_blend_operation_enum", "__esmMin", "init_texture_format_enum", "__esmMin", "init_texture_view_dimension_enum", "__esmMin", "init_vertex_parameter_step_mode_enum", "__esmMin", "GpuExecution", "init_gpu_execution", "__esmMin", "init_gpu_object", "GpuObject", "pDevice", "pExecution", "lCommandEncoder", "ComputePassContext", "init_compute_pass_context", "__esmMin", "init_source", "init_buffer_usage_enum", "pEncoder", "pPipeline", "pPipelineData", "pX", "pY", "pZ", "Exception", "pIndirectBuffer", "BufferUsage", "lNativePipeline", "lLocalHighestBindGroupListIndex", "lPipelineDataGroupList", "lBindGroupIndex", "lPipelineDataGroup", "lCurrentPipelineDataGroup", "ComputePass", "init_compute_pass", "__esmMin", "init_gpu_buffer", "init_buffer_usage_enum", "init_gpu_feature_enum", "init_gpu_object", "init_compute_pass_context", "GpuObject", "pDevice", "pExecution", "pExecutionContext", "lComputePassDescriptor", "lComputePassEncoder", "ComputePassContext", "lTimestampQuerySet", "lTimestampBuffer", "GpuBuffer", "BufferUsage", "pData", "lTimedata", "TextureUsage", "init_texture_usage_enum", "__esmMin", "init_filter_mode_enum", "__esmMin", "init_wrapping_mode_enum", "__esmMin", "TextureSampler", "init_texture_sampler", "__esmMin", "init_source", "init_filter_mode_enum", "init_sampler_type_enum", "init_wrapping_mode_enum", "init_gpu_resource_object", "GpuResourceObject", "pValue", "pDevice", "pLayout", "lSamplerOptions", "Exception", "init_buffer_alignment_type_enum", "__esmMin", "BaseMemoryLayout", "init_base_memory_layout", "__esmMin", "init_gpu_object", "GpuObject", "pDevice", "BaseBufferMemoryLayout", "init_base_buffer_memory_layout", "__esmMin", "init_base_memory_layout", "BaseMemoryLayout", "pDevice", "pAlignmentType", "ArrayBufferMemoryLayout", "init_array_buffer_memory_layout", "__esmMin", "init_source", "init_buffer_alignment_type_enum", "init_base_buffer_memory_layout", "BaseBufferMemoryLayout", "pDevice", "pParameter", "Exception", "pPathName", "lPathName", "lItemIndexString", "lArrayItemSize", "lArrayItemOffset", "lInnerLocation", "PrimitiveBufferMemoryLayout", "init_primitive_buffer_memory_layout", "__esmMin", "init_source", "init_buffer_alignment_type_enum", "init_buffer_item_format_enum", "init_buffer_item_multiplier_enum", "init_base_buffer_memory_layout", "_PrimitiveBufferMemoryLayout", "BaseBufferMemoryLayout", "pMultiplier", "pItemFormat", "pDevice", "pParameter", "Exception", "pPathName", "GpuObjectSetup", "init_gpu_object_setup", "__esmMin", "init_source", "pSetupReference", "Exception", "GpuObjectChildSetup", "init_gpu_object_child_setup", "__esmMin", "init_source", "pSetupReference", "pDataCallback", "Exception", "pData", "StructBufferMemoryLayoutPropertySetup", "init_struct_buffer_memory_layout_property_setup", "__esmMin", "init_gpu_object_child_setup", "init_array_buffer_memory_layout", "init_primitive_buffer_memory_layout", "init_struct_buffer_memory_layout", "_StructBufferMemoryLayoutPropertySetup", "GpuObjectChildSetup", "pSetupReference", "pAlignmentType", "pDataCallback", "pSize", "pMemoryLayout", "lLayout", "ArrayBufferMemoryLayout", "pPrimitiveFormat", "pPrimitiveMultiplier", "pAlignment", "PrimitiveBufferMemoryLayout", "pSetupCall", "StructBufferMemoryLayout", "StructBufferMemoryLayoutSetup", "init_struct_buffer_memory_layout_setup", "__esmMin", "init_gpu_object_setup", "init_struct_buffer_memory_layout_property_setup", "GpuObjectSetup", "pSetupReference", "pAlignmentType", "pName", "lProperty", "StructBufferMemoryLayoutPropertySetup", "pMemoryLayout", "pDataReference", "StructBufferMemoryLayout", "init_struct_buffer_memory_layout", "__esmMin", "init_source", "init_buffer_alignment_type_enum", "init_base_buffer_memory_layout", "init_struct_buffer_memory_layout_setup", "BaseBufferMemoryLayout", "pDevice", "pAlignmentType", "pPathName", "lPathName", "lPropertyName", "Exception", "lPropertyOffset", "lFoundProperty", "lProperty", "lPropertyLocation", "pSetupCallback", "pReferences", "pA", "pB", "lRawDataSize", "lIndex", "lPropertyLayout", "StructBufferMemoryLayoutSetup", "init_texture_dimension_enum", "__esmMin", "GpuTextureView", "init_gpu_texture_view", "__esmMin", "init_texture_view_dimension_enum", "init_gpu_resource_object", "GpuResourceObject", "pArrayLayer", "pArrayLayerIndex", "pMipLevel", "pDevice", "pTexture", "pLayout", "lNativeTexture", "lMipLevelEnd", "lArrayLayerEnd", "lDimensionViewDepthCount", "TextureViewMemoryLayout", "init_texture_view_memory_layout", "__esmMin", "init_base_memory_layout", "BaseMemoryLayout", "pDevice", "pParameter", "GpuTexture", "init_gpu_texture", "__esmMin", "init_source", "init_gpu_limit_enum", "init_texture_dimension_enum", "init_texture_usage_enum", "init_texture_view_dimension_enum", "init_gpu_resource_object", "init_gpu_texture_view", "init_texture_view_memory_layout", "_GpuTexture", "GpuResourceObject", "pDepth", "pHeight", "pMipCount", "pWidth", "pDevice", "pParameter", "TextureUsage", "pTextures", "lCopyConfig", "lTextureIndex", "lCopyTexture", "lExternal", "lDestination", "lCommandDecoder", "lSourceTexture", "lDestinationMaxSize", "lClampedCopySize", "lSource", "pDimension", "lViewDimension", "lLayout", "TextureViewMemoryLayout", "GpuTextureView", "pNativeObject", "pOldTexture", "lTextureDimensions", "lDimensionLimit", "Exception", "lArrayLayerLimit", "lMaxMipCount", "lNewTexture", "lCopyMipCount", "lMipLevel", "lSourceMaxSize", "SamplerMemoryLayout", "init_sampler_memory_layout", "__esmMin", "init_base_memory_layout", "BaseMemoryLayout", "pDevice", "pType", "BindGroupDataSetup", "init_bind_group_data_setup", "__esmMin", "init_source", "init_gpu_buffer", "init_array_buffer_memory_layout", "init_base_buffer_memory_layout", "init_primitive_buffer_memory_layout", "init_struct_buffer_memory_layout", "init_buffer_item_format_enum", "init_gpu_limit_enum", "init_storage_binding_type_enum", "init_texture_dimension_enum", "init_texture_view_dimension_enum", "init_gpu_object_child_setup", "init_gpu_texture", "init_sampler_memory_layout", "init_texture_view_memory_layout", "init_texture_sampler", "GpuObjectChildSetup", "pLayout", "pCurrentData", "pSetupReference", "pDataCallback", "pValueType", "pDynamicOffsetIndex", "lData", "GpuBuffer", "Exception", "lBufferLayout", "pDataOrVariableLength", "lBuffer", "pData", "BaseBufferMemoryLayout", "lByteSize", "lItemCount", "lOffsetAlignment", "SamplerMemoryLayout", "lSampler", "TextureSampler", "TextureViewMemoryLayout", "lTextureDimension", "lTextureView", "GpuTexture", "lUnwrapedLayout", "lVariableRepetitionCount", "lDynamicOffsetAlignment", "lDynamicOffsetCount", "lBufferData", "lBufferDataView", "lDataIndex", "lByteOffset", "lWriteLayout", "pUnwrappedLayout", "pOverwrittenAlignment", "lLayoutAlignment", "lRepetitionCount", "lLayoutRepetionIndex", "lInnerFormat", "lItemIndex", "lOffsetIndex", "pVariableSizeCount", "pBufferDataView", "pByteOffset", "pFormat", "PrimitiveBufferMemoryLayout", "lParameterItemCount", "lParameterItemFormat", "ArrayBufferMemoryLayout", "lInnerFormatUnwrapped", "StructBufferMemoryLayout", "lFixedItemCount", "lVariableItemCount", "lPropertyFormats", "lProperty", "lPropertyFormatUnwrapped", "BindGroup", "init_bind_group", "__esmMin", "init_source", "init_gpu_buffer", "init_buffer_usage_enum", "init_storage_binding_type_enum", "init_texture_usage_enum", "init_texture_sampler", "init_bind_group_data_setup", "init_base_buffer_memory_layout", "init_gpu_object", "init_gpu_resource_object", "init_gpu_texture_view", "init_sampler_memory_layout", "init_texture_view_memory_layout", "GpuObject", "pDevice", "pBindGroupLayout", "Dictionary", "pBindName", "lBindLayout", "lData", "lDataSetupReferences", "BindGroupDataSetup", "pData", "GpuBuffer", "BaseBufferMemoryLayout", "Exception", "BufferUsage", "TextureSampler", "SamplerMemoryLayout", "GpuTextureView", "TextureViewMemoryLayout", "TextureUsage", "lOldData", "lBindDataInvalidationListener", "lEntryList", "lBindname", "lBindData", "lGroupEntry", "PipelineDataGroupSetup", "init_pipeline_data_group_setup", "__esmMin", "init_gpu_object_child_setup", "GpuObjectChildSetup", "pBindingName", "pOffsetIndex", "PipelineDataSetup", "init_pipeline_data_setup", "__esmMin", "init_source", "init_pipeline_data_group_setup", "init_gpu_object_setup", "GpuObjectSetup", "pBindGroup", "lBindGroup", "Dictionary", "PipelineDataGroupSetup", "pBindingOffsets", "pDataReference", "PipelineData", "init_pipeline_data", "__esmMin", "init_source", "init_gpu_limit_enum", "init_storage_binding_type_enum", "init_gpu_object", "init_bind_group", "init_pipeline_data_setup", "GpuObject", "pDevice", "pPipelineLayout", "Dictionary", "lBindGroup", "pBindGroupName", "Exception", "pSetupCallback", "pReferences", "lGroupName", "pBindGroup", "lBindGroupSetupData", "lBindGroupName", "lBindGroupIndex", "lBindGroupLayout", "lPipelineDataGroup", "lBindingName", "lBindingLayout", "lOffsetAlignment", "lBindingDynamicOffsetIndex", "lBufferMemoryLayout", "lSingleLayoutLength", "lBufferSize", "PipelineDataSetup", "init_primitive_front_face_enum", "__esmMin", "init_primitive_topology_enum", "__esmMin", "init_stencil_operation_enum", "__esmMin", "init_texture_aspect_enum", "__esmMin", "VertexFragmentPipelineDepthConfiguration", "init_vertex_fragment_pipeline_depth_configuration", "__esmMin", "pDataReference", "pCallback", "pBias", "pFunction", "pEnable", "VertexFragmentPipelineStencilConfiguration", "init_vertex_fragment_pipeline_stencil_configuration", "__esmMin", "pDataReference", "pCallback", "pCompare", "pFailOperation", "pPassOperation", "pDepthFailOperation", "pBitMask", "VertexFragmentPipelineTargetConfiguration", "init_vertex_fragment_pipeline_target_configuration", "__esmMin", "pDataReference", "pCallback", "pOperation", "pSourceFactor", "pDestinationFactor", "pAspects", "VertexFragmentPipeline", "init_vertex_fragment_pipeline", "__esmMin", "init_source", "init_compare_function_enum", "init_compute_stage_enum", "init_primitive_cullmode_enum", "init_primitive_front_face_enum", "init_primitive_topology_enum", "init_stencil_operation_enum", "init_texture_aspect_enum", "init_texture_blend_factor_enum", "init_texture_blend_operation_enum", "init_gpu_object", "init_vertex_fragment_pipeline_depth_configuration", "init_vertex_fragment_pipeline_stencil_configuration", "init_vertex_fragment_pipeline_target_configuration", "GpuObject", "pValue", "pDevice", "pShaderRenderModule", "pRenderTargets", "Dictionary", "VertexFragmentPipelineDepthConfiguration", "pParameterName", "lParameterUsage", "lUsage", "VertexFragmentPipelineStencilConfiguration", "pTargetName", "Exception", "VertexFragmentPipelineTargetConfiguration", "_pLastNative", "pInvalidationReason", "lLoadedPipeline", "lPipelineDescriptor", "ComputeStage", "lFragmentTargetList", "lRenderTargetName", "lRenderTarget", "pPipeline", "lStripIndexFormat", "lPrimitiveState", "lConfig", "lBlendState", "lWriteMask", "VertexParameter", "init_vertex_parameter", "__esmMin", "init_source", "init_gpu_buffer", "init_buffer_alignment_type_enum", "init_buffer_item_format_enum", "init_buffer_item_multiplier_enum", "init_buffer_usage_enum", "init_vertex_parameter_step_mode_enum", "init_array_buffer_memory_layout", "init_primitive_buffer_memory_layout", "init_gpu_object", "GpuObject", "pDevice", "pVertexParameterLayout", "pIndices", "Dictionary", "lIndexBufferLayout", "ArrayBufferMemoryLayout", "PrimitiveBufferMemoryLayout", "lIndexBuffer", "GpuBuffer", "BufferUsage", "pBufferName", "pData", "lParameterLayout", "lStrideParameter", "lStrideDataCount", "lBufferParameter", "lParameterItemCount", "lParameterItemFormat", "Exception", "lData", "lIndex", "lDataStart", "lDataEnd", "lStrideCount", "lBufferData", "lBufferDataView", "lSetData", "pByteOffset", "pFormat", "lDataIndex", "lByteOffset", "lStrideIndex", "lStrideItem", "lStrideItemIndex", "lParameterBuffer", "pBuffer", "RenderPassContext", "init_render_pass_context", "__esmMin", "init_source", "init_buffer_usage_enum", "pEncoder", "pRenderTargets", "pRecordResources", "Dictionary", "pPipeline", "pParameter", "pPipelineData", "pInstanceCount", "pInstanceOffset", "Exception", "pIndirectBuffer", "BufferUsage", "lNativePipeline", "lLocalHighestBindGroupListIndex", "lPipelineDataGroupList", "lBindGroupIndex", "lPipelineDataGroup", "lCurrentPipelineDataGroup", "lLocalHighestVertexParameterListIndex", "lBufferNames", "lBufferIndex", "lAttributeBufferName", "lNewAttributeBuffer", "lVertexParameterBufferIndex", "pBuffer", "RenderPass", "init_render_pass", "__esmMin", "init_gpu_buffer", "init_buffer_usage_enum", "init_gpu_feature_enum", "init_gpu_object", "init_gpu_resource_object", "init_pipeline_data", "init_vertex_fragment_pipeline", "init_vertex_parameter", "init_render_pass_context", "GpuObject", "pDevice", "pRenderTargets", "pStaticBundle", "pExecution", "pExecutionContext", "lRenderPassDescriptor", "lRenderPassEncoder", "RenderPassContext", "lTimestampQuerySet", "lTimestampBuffer", "GpuBuffer", "BufferUsage", "pData", "lTimedata", "pRenderPassEncoder", "lRenderBundleEncoderDescriptor", "pColorTargetName", "lParameter", "lBuffer", "lBindgroup", "lPipeline", "lRenderBundleEncoder", "lRenderPassContext", "lColorTargetList", "pResolveTexture", "lResolveTexture", "lSource", "lDestination", "lCopySize", "init_texture_operation_enum", "__esmMin", "RenderTargetTextureSetup", "init_render_targets_texture_setup", "__esmMin", "init_texture_dimension_enum", "init_texture_view_dimension_enum", "init_gpu_object_child_setup", "init_gpu_texture", "GpuObjectChildSetup", "pSetupReference", "pMultisampled", "pDataCallback", "pFormat", "pResolve", "lTextureView", "GpuTexture", "pTextureView", "RenderTargetsSetup", "init_render_targets_setup", "__esmMin", "init_source", "init_texture_operation_enum", "init_gpu_object_setup", "init_render_targets_texture_setup", "GpuObjectSetup", "pSetupReference", "pMultisampled", "pName", "pLocationIndex", "pKeepOnEnd", "pClearValue", "lTarget", "RenderTargetTextureSetup", "pTexture", "pDepthKeepOnEnd", "pDepthClearValue", "pStencilKeepOnEnd", "pStencilClearValue", "Exception", "pDataReference", "RenderTargets", "init_render_targets", "__esmMin", "init_source", "init_gpu_limit_enum", "init_texture_aspect_enum", "init_texture_operation_enum", "init_texture_usage_enum", "init_texture_view_dimension_enum", "init_gpu_object", "init_gpu_resource_object", "init_render_targets_setup", "GpuObject", "lColorAttachmentNameList", "lColorAttachment", "pDevice", "pMultisampled", "Dictionary", "pTargetName", "lColorTargetIndex", "Exception", "pHeight", "pWidth", "pSetupCallback", "lColorAttachments", "lStoreOperation", "lPassColorAttachment", "lDescriptor", "lDepthStencilTexture", "pReferenceData", "lMaxRenderTargets", "TextureUsage", "lFormatCapability", "lAttachment", "pReferences", "RenderTargetsSetup", "pNative", "lTargetIndex", "lCurrentAttachment", "pTexture", "pTextureIndex", "PipelineLayout", "init_pipeline_layout", "__esmMin", "init_source", "init_gpu_limit_enum", "init_gpu_object", "init_pipeline_data", "GpuObject", "pDevice", "pInitialGroups", "Dictionary", "lMaxCounter", "lMaxBindGroupCount", "lGroupIndex", "lGroup", "Exception", "pGroupName", "lBindGroupIndex", "pSetupCallback", "PipelineData", "lPipelineLayoutDescriptor", "lBindGroupLayout", "BindGroupLayoutBufferMemoryLayoutSetup", "init_bind_group_layout_buffer_memory_layout_setup", "__esmMin", "init_source", "init_array_buffer_memory_layout", "init_primitive_buffer_memory_layout", "init_struct_buffer_memory_layout", "init_buffer_item_format_enum", "init_gpu_object_child_setup", "_BindGroupLayoutBufferMemoryLayoutSetup", "GpuObjectChildSetup", "pSetupReference", "pAlignmentType", "pDataCallback", "pSize", "pMemoryLayout", "lLayout", "ArrayBufferMemoryLayout", "pPrimitiveFormat", "pPrimitiveMultiplier", "Exception", "PrimitiveBufferMemoryLayout", "pSetupCall", "StructBufferMemoryLayout", "BindGroupLayoutMemoryLayoutSetup", "init_bind_group_layout_memory_layout_setup", "__esmMin", "init_gpu_object_child_setup", "init_sampler_memory_layout", "init_texture_view_memory_layout", "init_bind_group_layout_buffer_memory_layout_setup", "GpuObjectChildSetup", "pSetupReference", "pAlignmentType", "pDataCallback", "pHasDynamicOffset", "BindGroupLayoutBufferMemoryLayoutSetup", "pMemoryLayout", "pSamplerType", "lLayout", "SamplerMemoryLayout", "pTextureDimension", "pTextureFormat", "TextureViewMemoryLayout", "BindGroupLayoutSetup", "init_bind_group_layout_setup", "__esmMin", "init_buffer_alignment_type_enum", "init_storage_binding_type_enum", "init_gpu_object_setup", "init_bind_group_layout_memory_layout_setup", "GpuObjectSetup", "pIndex", "pName", "pVisibility", "pStorageBinding", "lBind", "lAlignmentType", "BindGroupLayoutMemoryLayoutSetup", "pMemoryLayout", "pDataReference", "BindGroupLayout", "init_bind_group_layout", "__esmMin", "init_source", "init_base_buffer_memory_layout", "init_gpu_limit_enum", "init_storage_binding_type_enum", "init_gpu_object", "init_sampler_memory_layout", "init_texture_view_memory_layout", "init_bind_group", "init_bind_group_layout_setup", "GpuObject", "pDevice", "pName", "Dictionary", "BindGroup", "Exception", "pSetupCallback", "lEntryList", "lEntry", "lLayoutEntry", "BaseBufferMemoryLayout", "lBufferBindingType", "SamplerMemoryLayout", "TextureViewMemoryLayout", "lTextureFormatCapabilities", "lStorageAccess", "pReferences", "lMaxBindGroupCount", "lBindingIndices", "lBindingName", "lBinding", "BindGroupLayoutSetup", "VertexParameterBufferLayoutSetup", "init_vertex_parameter_buffer_layout_setup", "__esmMin", "init_gpu_object_child_setup", "GpuObjectChildSetup", "pName", "pLocation", "pFormat", "pMultiplier", "pAlignment", "VertexParameterLayoutSetup", "init_vertex_parameter_layout_setup", "__esmMin", "init_gpu_object_setup", "init_vertex_parameter_buffer_layout_setup", "GpuObjectSetup", "pBufferName", "pStepMode", "lBuffer", "VertexParameterBufferLayoutSetup", "pLayout", "pDataReference", "VertexParameterLayout", "init_vertex_parameter_layout", "__esmMin", "init_source", "init_primitive_buffer_memory_layout", "init_struct_buffer_memory_layout", "init_buffer_alignment_type_enum", "init_buffer_item_multiplier_enum", "init_vertex_parameter_step_mode_enum", "init_gpu_object", "init_vertex_parameter", "init_vertex_parameter_layout_setup", "GpuObject", "pDevice", "Dictionary", "pIndexData", "VertexParameter", "pName", "lLayout", "Exception", "pBufferName", "pSetupCallback", "lLayoutList", "lBuffer", "lCurrentBufferByteLength", "lVertexAttributes", "lParameter", "lPrimitiveParameterLayout", "lItemMultiplier", "PrimitiveBufferMemoryLayout", "lFormat", "lParameterLocation", "lStepmode", "pReferences", "lCanBeIndexed", "lAllowedMultiplier", "lParameterIndicies", "lBufferSetupData", "lBufferLayout", "StructBufferMemoryLayout", "pSetup", "lParameterSetupData", "VertexParameterLayoutSetup", "ShaderComputeEntryPointSetup", "init_shader_compute_entry_point_setup", "__esmMin", "init_gpu_object_child_setup", "GpuObjectChildSetup", "pX", "pY", "pZ", "ShaderFragmentEntryPointSetup", "init_shader_fragment_entry_point_setup", "__esmMin", "init_gpu_object_child_setup", "GpuObjectChildSetup", "pName", "pLocationIndex", "pDataFormat", "pDataMultiplier", "lRenderTarget", "ShaderSetup", "init_shader_setup", "__esmMin", "init_gpu_object_setup", "init_bind_group_layout", "init_vertex_parameter_layout", "init_shader_compute_entry_point_setup", "init_shader_fragment_entry_point_setup", "GpuObjectSetup", "pName", "lEntryPoint", "ShaderComputeEntryPointSetup", "pX", "pY", "pZ", "ShaderFragmentEntryPointSetup", "pRenderTarget", "pIndex", "pGroupOrName", "pSetupCall", "lBindGroupLayout", "BindGroupLayout", "pStageUsage", "pSetupCallback", "lVertexParameterLayout", "VertexParameterLayout", "pDataReference", "ComputePipeline", "init_compute_pipeline", "__esmMin", "init_source", "init_compute_stage_enum", "init_gpu_object", "GpuObject", "pDevice", "pShader", "Dictionary", "pParameterName", "pValue", "lParameterUsage", "lUsage", "_pLastNative", "pInvalidationReason", "lLoadedPipeline", "lPipelineDescriptor", "ComputeStage", "pPipeline", "ShaderComputeModule", "init_shader_compute_module", "__esmMin", "init_gpu_object", "init_compute_pipeline", "GpuObject", "pDevice", "pShader", "pEntryPointName", "pSize", "ComputePipeline", "ShaderRenderModule", "init_shader_render_module", "__esmMin", "init_gpu_object", "init_vertex_fragment_pipeline", "GpuObject", "pDevice", "pShader", "pVertexEntryPointName", "pVertexParameter", "pFragmentEntryPointName", "pRenderTargets", "VertexFragmentPipeline", "Shader", "init_shader", "__esmMin", "init_source", "init_gpu_object", "init_pipeline_layout", "init_shader_setup", "init_shader_compute_module", "init_shader_render_module", "GpuObject", "pDevice", "pSource", "pSourceMap", "Dictionary", "pEntryName", "lEntryPoint", "Exception", "ShaderComputeModule", "pVertexEntryName", "pFragmentEntryName", "lVertexEntryPoint", "ShaderRenderModule", "pParameterName", "lParameterType", "pSetupCallback", "lPipelineLayout", "lCompilationHints", "lEntryName", "pReferences", "lParameter", "lFragmentEntry", "lRenderTargetLocations", "lRenderTargets", "lRenderTarget", "lVertexEntry", "lComputeEntry", "lInitialPipelineLayout", "lGroup", "PipelineLayout", "ShaderSetup", "CanvasTexture", "init_canvas_texture", "__esmMin", "init_texture_dimension_enum", "init_texture_usage_enum", "init_gpu_object", "GpuObject", "pValue", "pDevice", "pCanvas", "_pNativeObject", "pReasons", "TextureUsage", "lTexture", "GpuDeviceCapabilities", "init_gpu_device_capabilities", "__esmMin", "init_source", "init_gpu_feature_enum", "init_gpu_limit_enum", "pDevice", "lFeature", "lGpuFeature", "EnumUtil", "GpuFeature", "Dictionary", "lLimitName", "GpuLimit", "pLimit", "pFeature", "init_texture_sample_type_enum", "__esmMin", "GpuTextureFormatCapabilities", "init_gpu_texture_format_capabilities", "__esmMin", "init_source", "init_gpu_feature_enum", "init_texture_aspect_enum", "init_texture_dimension_enum", "init_texture_format_enum", "init_texture_sample_type_enum", "init_texture_usage_enum", "pDevice", "lFloat32Filterable", "Dictionary", "lBcTextureFormatCapability", "pFormat", "pAspects", "pByteOfAspect", "pCompatible", "lFormat", "lEtc2TextureFormatCapability", "lAstcTextureFormatCapability", "pCompressionLevel", "lCapabilityDefinition", "Exception", "lTextureUsages", "TextureUsage", "lSampleTypes", "lAllSampleTypes", "GpuDevice", "init_gpu_device", "__esmMin", "init_source", "init_gpu_execution", "init_compute_pass", "init_render_pass", "init_render_targets", "init_shader", "init_canvas_texture", "init_gpu_device_capabilities", "init_gpu_texture_format_capabilities", "_GpuDevice", "pPerformance", "pOptions", "lAdapter", "Exception", "lFeatures", "lLimits", "lFeature", "lLimit", "lAdapterLimit", "lAvailableLimit", "lDevice", "pDevice", "GpuDeviceCapabilities", "GpuTextureFormatCapabilities", "List", "pListener", "pCanvas", "lCanvas", "CanvasTexture", "pExecution", "ComputePass", "pOnExecute", "GpuExecution", "pRenderTargets", "pStaticBundle", "RenderPass", "pMultisampled", "RenderTargets", "pSource", "Shader", "lListener", "Vector", "init_vector", "__esmMin", "init_source", "_Vector", "pData", "pAddData", "lData", "Exception", "lIndex", "lItem", "pVector", "lProduct", "lLength", "pSubData", "AmbientLight", "init_ambient_light", "__esmMin", "init_source", "init_vector", "Vector", "pRed", "pGreen", "pBlue", "Exception", "Matrix", "init_matrix", "__esmMin", "init_source", "init_vector", "_Matrix", "pArray", "pHeight", "pWidth", "lData", "lRowIndex", "lRowData", "lColumnIndex", "pSize", "pData", "pAddData", "Exception", "lMatrixData", "lMatrixRow", "lColumIndex", "lDeterminant", "lIterationIndex", "lSignedNumber", "lDeterminantMatrix", "lAdjoint", "pMultData", "lProduct", "lComponentIndex", "pOmitRow", "pOmitColumn", "lVectorComponent", "lMutiplicatedMatrix", "lVectorData", "Vector", "Euler", "init_euler", "__esmMin", "pValue", "Quaternion", "init_quaternion", "__esmMin", "init_euler", "init_matrix", "init_vector", "_Quaternion", "pPitch", "pYaw", "pRoll", "lPitchRadian", "lYawRadian", "lRollRadian", "lCosPitch", "lSinPitch", "lCosYaw", "lSinYaw", "lCosRoll", "lSinRoll", "lQuaternion", "lSquareX", "lSquareY", "lProductXz", "lProductYw", "lProductYz", "lProductXw", "lX", "lY", "lZ", "Vector", "lSquareZ", "lProductXy", "lProductZw", "pValue", "pW", "pX", "pY", "pZ", "lEuler", "Euler", "lSinPitchCosYaw", "lCosPitchCosYaw", "lPitchDegree", "lYawDegree", "lSinRollCosYaw", "lCosRollCosYaw", "lRollDegree", "lMatrix", "Matrix", "pQuaternion", "lW", "lLength", "Transform", "init_transform", "__esmMin", "init_matrix", "init_quaternion", "init_vector", "pValue", "Matrix", "Quaternion", "pPitch", "pYaw", "pRoll", "pWidth", "pHeight", "pDepth", "pX", "pY", "pZ", "pType", "lRotationMatrix", "lPivotRotation", "lScale", "lTranslation", "lRotation", "lPitch", "lYaw", "lRoll", "pForward", "pRight", "pUp", "lTranslationVector", "Vector", "lDirectionVector", "PerspectiveProjection", "init_perspective_projection", "__esmMin", "init_matrix", "pValue", "lMatrix", "Matrix", "lFar", "lNear", "lTop", "lBottom", "lRight", "lLeft", "ViewProjection", "init_view_projection", "__esmMin", "init_transform", "pProjection", "Transform", "pType", "lTranslation", "lRotation", "lView", "color_cube_shader_default", "init_color_cube_shader", "__esmMin", "cube_shader_default", "init_cube_shader", "__esmMin", "particle_compute_shader_default", "init_particle_compute_shader", "__esmMin", "particle_shader_default", "init_particle_shader", "__esmMin", "light_box_shader_default", "init_light_box_shader", "__esmMin", "sky_box_shader_default", "init_sky_box_shader", "__esmMin", "video_canvas_shader_default", "init_video_canvas_shader", "__esmMin", "CanvasVertexPositionData", "CanvasVertexUvData", "CanvasVertexNormalData", "CanvasVertexIndices", "init_canvas_mesh", "__esmMin", "CubeVertexPositionData", "CubeVertexUvData", "CubeVertexNormalData", "CubeVertexIndices", "init_cube_mesh", "__esmMin", "ParticleVertexPositionUvData", "ParticleVertexIndices", "init_particle_mesh", "__esmMin", "InitCameraControls", "UpdateFpsDisplay", "init_util", "__esmMin", "init_source", "init_view_projection", "pCanvas", "pCamera", "pCameraBuffer", "lCurrentActionValue", "Dictionary", "pEvent", "lMouseMoveTimeout", "lDeltaX", "lDeltaY", "lSensitivity", "lYawValue", "lPitchValue", "lMaxFps", "pFps", "pWidth", "lCanvas", "lCanvasContext", "lLastFpsData", "lScaling", "lScalingSize", "lRectHeight", "source_exports", "gGenerateCubeStep", "gGenerateColorCubeStep", "gGenerateLightBoxStep", "gGenerateSkyboxStep", "gGenerateVideoCanvasStep", "gGenerateParticleStep", "gGenerateWorldBindGroup", "init_source", "__esmMin", "init_gpu_buffer", "init_buffer_item_format_enum", "init_buffer_item_multiplier_enum", "init_compare_function_enum", "init_compute_stage_enum", "init_gpu_feature_enum", "init_primitive_cullmode_enum", "init_sampler_type_enum", "init_storage_binding_type_enum", "init_texture_blend_factor_enum", "init_texture_blend_operation_enum", "init_texture_format_enum", "init_texture_view_dimension_enum", "init_vertex_parameter_step_mode_enum", "init_gpu_device", "init_bind_group_layout", "init_compute_pipeline", "init_render_targets", "init_ambient_light", "init_transform", "init_perspective_projection", "init_view_projection", "init_color_cube_shader", "init_cube_shader", "init_particle_compute_shader", "init_particle_shader", "init_light_box_shader", "init_sky_box_shader", "init_video_canvas_shader", "init_canvas_mesh", "init_cube_mesh", "init_particle_mesh", "init_util", "pGpu", "pRenderTargets", "pWorldGroup", "lWoodBoxRenderModule", "cube_shader_default", "pShaderSetup", "ComputeStage", "pVertexParameterSetup", "pBindGroupSetup", "lWoodBoxTransformationGroup", "Transform", "lCubeInstanceTransformationData", "lWidthIndex", "lHeightIndex", "lDepthIndex", "lWoodBoxUserGroup", "lImageTexture", "lSourceList", "lHeight", "lWidth", "lColorList", "lIndex", "lImageLoadPromiseList", "pSource", "pIndex", "lImage", "lWaiter", "lMipList", "pBitmap", "lMaxMipCount", "lMipLevel", "lCanvas", "lCanvasContext", "lImageList", "lMesh", "CubeVertexIndices", "CubeVertexPositionData", "CubeVertexUvData", "CubeVertexNormalData", "lWoodBoxPipeline", "pSeconds", "pSetup", "color_cube_shader_default", "lColorBoxTransformationGroup", "lColorBoxPipeline", "lLightBoxShader", "light_box_shader_default", "lLightBoxRenderModule", "lLightBoxTransformationGroup", "lLightBoxPipeline", "lPointLightsBuffer", "lSkyBoxShader", "sky_box_shader_default", "lSkyBoxRenderModule", "lSkyBoxTextureGroup", "lSkyBoxPipeline", "video_canvas_shader_default", "lTransformationGroup", "lUserGroup", "lVideoTexture", "lVideo", "lTimeStamp", "lFrameTimeStamp", "pImageBitmap", "CanvasVertexIndices", "CanvasVertexPositionData", "CanvasVertexUvData", "CanvasVertexNormalData", "lPipeline", "lParticleRenderShader", "particle_shader_default", "pStructSetup", "lParticleRenderModule", "lParticleInformationGroup", "lParticleTextureGroup", "ParticleVertexIndices", "ParticleVertexPositionUvData", "lParticlePipeline", "lIndirectionBuffer", "GpuBuffer", "lRenderInstruction", "lParticleComputeModule", "particle_compute_shader_default", "lComputePipeline", "ComputePipeline", "lParticleComputeInformationGroup", "lComputeInstruction", "lWorldGroup", "BindGroupLayout", "pTranslationStruct", "pTimeStruct", "pStruct", "lAmbientLight", "AmbientLight", "lDebugBuffer", "pResulto", "lGpu", "GpuDevice", "lCanvasTexture", "lRenderTargets", "lCanvasWrapper", "lNewCanvasHeight", "lNewCanvasWidth", "lPerspectiveProjection", "PerspectiveProjection", "lCamera", "ViewProjection", "lTimestampBuffer", "lParticelRenderInstruction", "lParticelComputeInstruction", "lRenderSteps", "lRenderPass", "pContext", "lStep", "pStart", "pEnd", "lComputeSteps", "lComputePass", "InitCameraControls", "lRenderExecutor", "pExecutor", "lFpsLabel", "lLastTime", "lCurrentFps", "lRender", "pTime", "lFps", "UpdateFpsDisplay", "socket", "event"]
}
