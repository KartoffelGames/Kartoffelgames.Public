var ye=Object.create;var z=Object.defineProperty;var me=Object.getOwnPropertyDescriptor;var _=(a,e)=>(e=Symbol[a])?e:Symbol.for("Symbol."+a),O=a=>{throw TypeError(a)};var ee=(a,e,t)=>e in a?z(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var J=(a,e)=>z(a,"name",{value:e,configurable:!0});var Y=a=>[,,,ye(a?.[_("metadata")]??null)],te=["class","method","getter","setter","accessor","field","value","get","set"],W=a=>a!==void 0&&typeof a!="function"?O("Function expected"):a,Te=(a,e,t,n,r)=>({kind:te[a],name:e,metadata:n,addInitializer:i=>t._?O("Already initialized"):r.push(W(i||null))}),pe=(a,e)=>ee(e,_("metadata"),a[3]),g=(a,e,t,n)=>{for(var r=0,i=a[e>>1],o=i&&i.length;r<o;r++)e&1?i[r].call(t):n=i[r].call(t,n);return n},v=(a,e,t,n,r,i)=>{var o,s,u,b,d,c=e&7,p=!!(e&8),y=!!(e&16),I=c>3?a.length+1:c?p?1:2:0,D=te[c+5],R=c>3&&(a[I-1]=[]),F=a[I]||(a[I]=[]),w=c&&(!y&&!p&&(r=r.prototype),c<5&&(c>3||!y)&&me(c<4?r:{get[t](){return X(this,i)},set[t](T){return Z(this,i,T)}},t));c?y&&c<4&&J(i,(c>2?"set ":c>1?"get ":"")+t):J(r,t);for(var B=n.length-1;B>=0;B--)b=Te(c,t,u={},a[3],F),c&&(b.static=p,b.private=y,d=b.access={has:y?T=>he(r,T):T=>t in T},c^3&&(d.get=y?T=>(c^1?X:Ie)(T,r,c^4?i:w.get):T=>T[t]),c>2&&(d.set=y?(T,x)=>Z(T,r,x,c^4?i:w.set):(T,x)=>T[t]=x)),s=(0,n[B])(c?c<4?y?i:w[D]:c>4?void 0:{get:w.get,set:w.set}:r,b),u._=1,c^4||s===void 0?W(s)&&(c>4?R.unshift(s):c?y?i=s:w[D]=s:r=s):typeof s!="object"||s===null?O("Object expected"):(W(o=s.get)&&(w.get=o),W(o=s.set)&&(w.set=o),W(o=s.init)&&R.unshift(o));return c||pe(a,r),w&&z(r,t,w),y?c^4?i:w:r},L=(a,e,t)=>ee(a,typeof e!="symbol"?e+"":e,t),$=(a,e,t)=>e.has(a)||O("Cannot "+t),he=(a,e)=>Object(e)!==e?O('Cannot use the "in" operator on this value'):a.has(e),X=(a,e,t)=>($(a,e,"read from private field"),t?t.call(a):e.get(a));var Z=(a,e,t,n)=>($(a,e,"write to private field"),n?n.call(a,t):e.set(a,t),t),Ie=(a,e,t)=>($(a,e,"access private method"),t);var K=class a extends Array{static newListWith(...e){let t=new a;return t.push(...e),t}clear(){this.splice(0,this.length)}clone(){return a.newListWith(...this)}distinct(){return a.newListWith(...new Set(this))}equals(e){if(this===e)return!0;if(!e||this.length!==e.length)return!1;for(let t=0;t<this.length;++t)if(this[t]!==e[t])return!1;return!0}remove(e){let t=this.indexOf(e);if(t!==-1)return this.splice(t,1)[0]}replace(e,t){let n=this.indexOf(e);if(n!==-1){let r=this[n];return this[n]=t,r}}toString(){return`[${super.join(", ")}]`}};var l=class extends Error{mTarget;get target(){return this.mTarget}constructor(e,t,n){super(e,n),this.mTarget=t}};var m=class a extends Map{add(e,t){if(!this.has(e))this.set(e,t);else throw new l("Can't add dublicate key to dictionary.",this)}clone(){return new a(this)}getAllKeysOfValue(e){return[...this.entries()].filter(r=>r[1]===e).map(r=>r[0])}getOrDefault(e,t){let n=this.get(e);return typeof n<"u"?n:t}map(e){let t=new K;for(let n of this){let r=e(n[0],n[1]);t.push(r)}return t}};var S=class{mCustomMetadata;constructor(){this.mCustomMetadata=new m}getMetadata(e){return this.mCustomMetadata.get(e)??null}setMetadata(e,t){this.mCustomMetadata.set(e,t)}};var P=class extends S{};var q=class a extends S{static mPrivateMetadataKey=Symbol("Metadata");mDecoratorMetadataObject;mPropertyMetadata;constructor(e){super(),this.mDecoratorMetadataObject=e,this.mPropertyMetadata=new m,e[a.mPrivateMetadataKey]=this}getInheritedMetadata(e){let t=new Array,n=this.mDecoratorMetadataObject;do{if(Object.hasOwn(n,a.mPrivateMetadataKey)){let i=n[a.mPrivateMetadataKey].getMetadata(e);i!==null&&t.push(i)}n=Object.getPrototypeOf(n)}while(n!==null);return t.reverse()}getProperty(e){return this.mPropertyMetadata.has(e)||this.mPropertyMetadata.add(e,new P),this.mPropertyMetadata.get(e)}};Symbol.metadata??=Symbol("Symbol.metadata");var j=class a{static mMetadataMapping=new m;static add(e,t){return(n,r)=>{let i=a.forInternalDecorator(r.metadata);switch(r.kind){case"class":i.setMetadata(e,t);return;case"method":case"field":case"getter":case"setter":case"accessor":if(r.static)throw new Error("@Metadata.add not supported for statics.");i.getProperty(r.name).setMetadata(e,t);return}}}static forInternalDecorator(e){return a.mapMetadata(e)}static get(e){Object.hasOwn(e,Symbol.metadata)||a.polyfillMissingMetadata(e);let t=e[Symbol.metadata];return a.mapMetadata(t)}static init(){return(e,t)=>{a.forInternalDecorator(t.metadata)}}static mapMetadata(e){if(a.mMetadataMapping.has(e))return a.mMetadataMapping.get(e);let t=new q(e);return a.mMetadataMapping.set(e,t),t}static polyfillMissingMetadata(e){let t=new Array,n=e;do t.push(n),n=Object.getPrototypeOf(n);while(n!==null);for(let r=t.length-1;r>=0;r--){let i=t[r];if(!Object.hasOwn(i,Symbol.metadata)){let o=null;r<t.length-2&&(o=t[r+1][Symbol.metadata]),i[Symbol.metadata]=Object.create(o,{})}}}};var G=class a{static mCurrentInjectionContext=null;static mInjectMode=new m;static mInjectableConstructor=new m;static mInjectableReplacement=new m;static mInjectionConstructorIdentificationMetadataKey=Symbol("InjectionConstructorIdentification");static mSingletonMapping=new m;static createObject(e,t,n){let[r,i]=typeof t=="object"&&t!==null?[!1,t]:[!!t,n??new m],o=a.getInjectionIdentification(e);if(!a.mInjectableConstructor.has(o))throw new l(`Constructor "${e.name}" is not registered for injection and can not be built`,a);let s=r?"instanced":a.mInjectMode.get(o),u=new m(i.map((c,p)=>[a.getInjectionIdentification(c),p])),b=a.mCurrentInjectionContext,d=new m([...b?.localInjections.entries()??[],...u.entries()]);a.mCurrentInjectionContext={injectionMode:s,localInjections:d};try{if(!r&&s==="singleton"&&a.mSingletonMapping.has(o))return a.mSingletonMapping.get(o);let c=new e;return s==="singleton"&&!a.mSingletonMapping.has(o)&&a.mSingletonMapping.add(o,c),c}finally{a.mCurrentInjectionContext=b}}static injectable(e="instanced"){return(t,n)=>{a.registerInjectable(t,n.metadata,e)}}static registerInjectable(e,t,n){let r=a.getInjectionIdentification(e,t);a.mInjectableConstructor.add(r,e),a.mInjectMode.add(r,n)}static replaceInjectable(e,t){let n=a.getInjectionIdentification(e);if(!a.mInjectableConstructor.has(n))throw new l("Original constructor is not registered.",a);let r=a.getInjectionIdentification(t);if(!a.mInjectableConstructor.has(r))throw new l("Replacement constructor is not registered.",a);a.mInjectableReplacement.set(n,t)}static use(e){if(a.mCurrentInjectionContext===null)throw new l("Can't create object outside of an injection context.",a);let t=a.getInjectionIdentification(e);if(a.mCurrentInjectionContext.injectionMode!=="singleton"&&a.mCurrentInjectionContext.localInjections.has(t))return a.mCurrentInjectionContext.localInjections.get(t);let n=a.mInjectableReplacement.get(t);if(n||(n=a.mInjectableConstructor.get(t)),!n)throw new l(`Constructor "${e.name}" is not registered for injection and can not be built`,a);return a.createObject(n)}static getInjectionIdentification(e,t){let n=t?j.forInternalDecorator(t):j.get(e),r=n.getMetadata(a.mInjectionConstructorIdentificationMetadataKey);return r||(r=Symbol(e.name),n.setMetadata(a.mInjectionConstructorIdentificationMetadataKey,r)),r}};var f=class a{static METADATA_KEY=Symbol("WebDatabaseTableLayoutMetadataKey");static configOf(e){let t=j.get(e).getMetadata(a.METADATA_KEY);if(!t)throw new l("Table type not defined.",this);return t}mTableName;mFields;mIdentity;mIndices;get fields(){if(!this.mTableName)throw new l("Webdatabase field defined but the Table was not initialized with a name.",this);return Array.from(this.mFields.values())}get identity(){if(!this.mTableName)throw new l("Webdatabase field defined but the Table was not initialized with a name.",this);return this.mIdentity?this.mIdentity:{key:"__ID__",autoIncrement:!0}}get indices(){if(!this.mTableName)throw new l("Webdatabase field defined but the Table was not initialized with a name.",this);return Array.from(this.mIndices.keys())}constructor(){this.mTableName=null,this.mIdentity=null,this.mIndices=new Map,this.mFields=new Set}index(e){if(!this.mTableName)throw new l("Webdatabase field defined but the Table was not initialized with a name.",this);return this.mIndices.get(e)}setTableIdentity(e,t){if(this.mIdentity)throw new l("A table type can only have one identifier.",this);this.mIdentity={key:e,autoIncrement:t},this.mFields.add(e)}setTableField(e,t,n=!1,r=!1){if(this.mFields.add(e),!t)return;let i=this.mIndices.get(t);if(i||(i={name:t,keys:new Array,unique:!0,type:r?"multiEntryIndex":"index"},this.mIndices.set(t,i)),i.keys.push(e),i.keys.length>1&&i.type==="multiEntryIndex")throw new l("Multientity index can only have one key.",this);i.keys.length>1&&(i.type="compoundIndex"),n||(i.unique=!1)}setTableName(e){if(this.mTableName)throw new l("Table name can only be set once.",this);this.mTableName=e}};var V=class{mActionCallback;mDatabaseQuery;constructor(e,t){this.mActionCallback=t,this.mDatabaseQuery=e}between(e,t){let n=IDBKeyRange.bound(e,t,!1,!1);return this.mActionCallback(n),this.mDatabaseQuery}greaterThan(e){let t=IDBKeyRange.lowerBound(e,!1);return this.mActionCallback(t),this.mDatabaseQuery}is(e){let t=IDBKeyRange.only(e);return this.mActionCallback(t),this.mDatabaseQuery}lowerThan(e){let t=IDBKeyRange.upperBound(e,!1);return this.mActionCallback(t),this.mDatabaseQuery}};var Q=class{mQueryList;mTable;constructor(e){this.mTable=e,this.mQueryList=new Array}and(e){let t={indexKey:e,action:null,link:"AND"};return this.mQueryList.push(t),new V(this,n=>{t.action=n})}async execute(){if(this.mQueryList.length===0)throw new l("No queries specified.",this);let e=new Array;e.push(new Array);for(let r of this.mQueryList)r.link==="OR"&&e.push(new Array),e.at(-1).push(r);if(e.length===1&&e[0].length===1)return this.mTable.parseToType(await this.readQuery(e[0][0]));if(e.length===1){let r=await this.readQueryBlock(e[0]);return this.mTable.parseToType(r.values())}let t=new Set;for(let r of e)t.add(await this.readQueryBlock(r));let n=null;for(let r of t){if(!n){n=r;continue}n.size<r.size&&(n=r)}t.delete(n);for(let r of t)for(let i of r)n.set(...i);return this.mTable.parseToType(n.values())}or(e){let t={indexKey:e,action:null,link:"OR"};return this.mQueryList.push(t),new V(this,n=>{t.action=n})}async readQuery(e){if(!e.action)throw new l("Query has no assigned action.",this);let t=this.mTable.transaction.transaction.objectStore(this.mTable.tableType.name),n=(()=>{let o=t.indexNames;for(let s=0;s<o.length;s++){let u=o[s];if(u===e.indexKey)return u}return null})();if(n){let s=t.index(n).getAll(e.action);return new Promise((u,b)=>{s.addEventListener("error",d=>{let c=d.target;b(new l("Error fetching table."+c.error,this))}),s.addEventListener("success",d=>{let c=d.target;u(c.result)})})}let r=t.openCursor(),i=new Array;return new Promise((o,s)=>{r.addEventListener("error",u=>{let b=u.target;s(new l("Error fetching table."+b.error,this))}),r.addEventListener("success",u=>{let d=u.target.result;if(!d){o(i);return}let c=d.value[e.indexKey];e.action.includes(c)&&i.push(d.value),d.continue()})})}async readQueryBlock(e){let t=this.mTable.transaction.transaction.objectStore(this.mTable.tableType.name),n=new Array;for(let u of e)n.push(this.readQuery(u));let r=await Promise.all(n),i=t.keyPath,o=new Array;for(let u of r){let b=new m;for(let d of u)b.set(d[i],d);o.push(b)}let s=o[0];for(let u of o)u.size<s.size&&(s=u);o.splice(o.indexOf(s),1);for(let u of o)for(let b of s.keys())u.has(b)||s.delete(b);return s}};var N=class{mTableType;mTransaction;mTableLayout;get tableType(){return this.mTableType}get transaction(){return this.mTransaction}constructor(e,t){this.mTableType=e,this.mTransaction=t,this.mTableLayout=f.configOf(this.mTableType)}async clear(){let t=this.mTransaction.transaction.objectStore(this.mTableType.name).clear();return new Promise((n,r)=>{t.addEventListener("error",i=>{let o=i.target;r(new l("Error clearing table data."+o.error,this))}),t.addEventListener("success",()=>{n()})})}async count(){let t=this.mTransaction.transaction.objectStore(this.mTableType.name).count();return new Promise((n,r)=>{t.addEventListener("error",i=>{let o=i.target;r(new l("Error counting table rows."+o.error,this))}),t.addEventListener("success",i=>{let o=i.target;n(o.result)})})}async delete(e){if(!(e instanceof this.mTableType))throw new l("Invalid data type.",this);let t=this.mTableLayout.identity.key,n=e[t],i=this.mTransaction.transaction.objectStore(this.mTableType.name).delete(n);return new Promise((o,s)=>{i.addEventListener("error",u=>{let b=u.target;s(new l("Error deleting data."+b.error,this))}),i.addEventListener("success",()=>{o()})})}async getAll(e){let n=this.mTransaction.transaction.objectStore(this.mTableType.name).getAll(null,e);return new Promise((r,i)=>{n.addEventListener("error",o=>{let s=o.target;i(new l("Error fetching table."+s.error,this))}),n.addEventListener("success",o=>{let s=o.target,u=this.parseToType(s.result);r(u)})})}async put(e){if(!(e instanceof this.mTableType))throw new l("Invalid data type.",this);let n=this.mTransaction.transaction.objectStore(this.mTableType.name).put(JSON.parse(JSON.stringify(e,this.mTableLayout.fields)));return new Promise((r,i)=>{n.addEventListener("error",o=>{let s=o.target;i(new l("Error put data."+s.error,this))}),n.addEventListener("success",o=>{let s=o.target,u=this.mTableLayout.identity.key;e[u]=s.result,r()})})}where(e){return new Q(this).and(e)}parseToType(e){let t=new Array;for(let n of e){let r=new this.mTableType;for(let i of this.mTableLayout.fields)r[i]=n[i];t.push(r)}return t}};var U=class{mDatabase;mMode;mState;mTableTypes;get transaction(){if(!this.mState)throw new l("Transaction is closed. Transactions can't be used with asynchronous calls.",this);return this.mState}constructor(e,t,n){this.mDatabase=e,this.mTableTypes=new Set(t),this.mMode=n,this.mState=null}commit(){this.mState&&this.mState.commit()}async open(){if(this.mState)return;let e=await this.mDatabase.open(),t=Array.from(this.mTableTypes).map(n=>n.name);this.mState=e.transaction(t,this.mMode),this.mState.addEventListener("complete",()=>{this.mState=null})}table(e){if(!this.mTableTypes.has(e))throw new l("Table type not set for database.",this);return new N(e,this)}};var A=class a{static field(e,t=!1,n=!1){return function(r,i){if(i.static)throw new l("Index property can not be a static property.",a);if(typeof i.name!="string")throw new l("Index name must be a string.",a);let o=j.forInternalDecorator(i.metadata),s=o.getMetadata(f.METADATA_KEY);s||(s=new f),s.setTableField(i.name,e,t,n),o.setMetadata(f.METADATA_KEY,s)}}static identity(e){return(t,n)=>{if(n.static)throw new l("Identity property can not be a static property.",a);if(typeof n.name!="string")throw new l("Identity name must be a string.",a);let r=j.forInternalDecorator(n.metadata),i=r.getMetadata(f.METADATA_KEY);i||(i=new f),i.setTableIdentity(n.name,e),r.setMetadata(f.METADATA_KEY,i)}}static table(e){return function(t,n){let r=j.forInternalDecorator(n.metadata),i=r.getMetadata(f.METADATA_KEY);i||(i=new f),i.setTableName(e),r.setMetadata(f.METADATA_KEY,i)}}mDatabaseConnection;mDatabaseName;mTableTypes;constructor(e,t){this.mDatabaseName=e,this.mDatabaseConnection=null,this.mTableTypes=new m;for(let n of t)this.mTableTypes.set(n.name,n)}close(){this.mDatabaseConnection!==null&&(this.mDatabaseConnection.close(),this.mDatabaseConnection=null)}async delete(){let e=globalThis.indexedDB.deleteDatabase(this.mDatabaseName);return new Promise((t,n)=>{e.addEventListener("error",r=>{let i=r.target;n(new l("Error deleting database. "+i.error,this))}),e.onsuccess=()=>{t()}})}async open(){if(this.mDatabaseConnection)return this.mDatabaseConnection;let e=await new Promise((r,i)=>{let o={version:0,updateNeeded:!1,tableUpdates:new Array},s=globalThis.indexedDB.open(this.mDatabaseName);s.addEventListener("upgradeneeded",()=>{}),s.addEventListener("blocked",u=>{i(new l(`Database locked from another tab. Unable to update from "${u.oldVersion}" to "${u.newVersion}"`,this))}),s.addEventListener("error",u=>{let b=u.target;i(new l("Error opening database. "+b.error,this))}),s.addEventListener("success",u=>{let b=u.target.result;o.version=b.version;let d=new Set(Array.from(b.objectStoreNames)),c=new Set(Array.from(this.mTableTypes.keys()));if(d.size>0){let p=b.transaction([...d],"readonly");for(let y of d){if(!c.has(y)){o.tableUpdates.push({name:y,action:"delete",indices:[]});continue}let I=f.configOf(this.mTableTypes.get(y)),D=p.objectStore(y),R=I.identity.key,F=I.identity.autoIncrement;if(D.keyPath!==R||D.autoIncrement!==F){o.tableUpdates.push({name:y,action:"delete",indices:[]});continue}c.delete(y);let w=new Set(Array.from(D.indexNames)),B=new Set(I.indices),T=new Array;for(let x of w){if(!B.has(x)){T.push({name:x,action:"delete"});continue}let E=D.index(x),H=I.index(x),ue=Array.isArray(E.keyPath)?E.keyPath.join(","):E.keyPath,de=H.keys.join(","),be=H.type==="multiEntryIndex";if(ue!==de||E.multiEntry!==be||E.unique!==H.unique){T.push({name:x,action:"delete"});continue}B.delete(x)}for(let x of B)T.push({name:x,action:"create"});if(T.length>0){o.tableUpdates.push({name:y,action:"none",indices:T});continue}}}for(let p of c){let y=f.configOf(this.mTableTypes.get(p)),I=new Array;for(let D of y.indices)I.push({name:D,action:"create"});o.tableUpdates.push({name:p,action:"create",indices:I})}for(let p of o.tableUpdates)if(p.action!=="none"||p.indices.length>0){o.updateNeeded=!0;break}b.close(),r(o)})}),t=e.updateNeeded?e.version+1:e.version,n=globalThis.indexedDB.open(this.mDatabaseName,t);return new Promise((r,i)=>{n.addEventListener("upgradeneeded",o=>{let s=o.target,u=s.result,b=s.transaction;for(let d of e.tableUpdates){if(d.action==="delete"){u.deleteObjectStore(d.name);continue}let c=this.mTableTypes.get(d.name),p=f.configOf(c);if(d.action==="create"&&(p.identity?u.createObjectStore(d.name,{keyPath:p.identity.key,autoIncrement:p.identity.autoIncrement}):u.createObjectStore(d.name)),d.indices.length>0){let y=b.objectStore(d.name);for(let I of d.indices){if(I.action==="delete"){y.deleteIndex(I.name);continue}let D=p.index(I.name),R=D.keys.length>1?D.keys:D.keys[0];if(I.action==="create"){y.createIndex(I.name,R,{unique:D.unique,multiEntry:D.type==="multiEntryIndex"});continue}}}}}),n.addEventListener("blocked",o=>{i(new l(`Database locked from another tab. Unable to update from "${o.oldVersion}" to "${o.newVersion}"`,this))}),n.addEventListener("error",o=>{let s=o.target;i(new l("Error opening database. "+s.error,this))}),n.addEventListener("success",o=>{this.mDatabaseConnection=o.target.result,r(this.mDatabaseConnection)})})}async transaction(e,t,n){for(let i of e)if(!this.mTableTypes.has(i.name))throw new l(`Table "${i.name}" does not exists in this database.`,this);let r=new U(this,e,t);await r.open(),await n(r),r.commit()}};var ae,ne,re,ie,oe,se,h;se=[A.table("TestTableOne")],oe=[A.identity(!0)],ie=[A.field("name",!0)],re=[A.field("price")],ne=[A.field("type",!1,!0)],ae=[A.field()];var C=class{constructor(){L(this,"id",g(h,8,this)),g(h,11,this);L(this,"name",g(h,12,this)),g(h,15,this);L(this,"price",g(h,16,this)),g(h,19,this);L(this,"types",g(h,20,this)),g(h,23,this);L(this,"notIndexed",g(h,24,this)),g(h,27,this)}whatMyId(){return this.id}};h=Y(null),v(h,5,"id",oe,C),v(h,5,"name",ie,C),v(h,5,"price",re,C),v(h,5,"types",ne,C),v(h,5,"notIndexed",ae,C),C=v(h,0,"TestTableOne",se,C),g(h,1,C);var le,ce,k;ce=[A.table("TestTableTwo")],le=[A.field("nameThing",!0)];var M=class{constructor(){L(this,"nameThing",g(k,8,this)),g(k,11,this)}};k=Y(null),v(k,5,"nameThing",le,M),M=v(k,0,"TestTableTwo",ce,M),g(k,1,M);new A("MainDB",[C,M]).transaction([C,M],"readwrite",async e=>{let t=e.table(C),n=e.table(M);await t.clear(),await n.clear();for(let r=0;r<100;r++){let i=new C;i.name=Math.random().toString(16),i.price=Math.random(),i.types=[1,2,3].slice(Math.floor(Math.random()*4),Math.floor(Math.random()*4)),i.notIndexed=Math.random().toString(16),await t.put(i)}console.log(await t.count(),await t.getAll()),console.log(await t.where("types").is(2).and("price").between(0,.5).execute());for(let r=0;r<100;r++){let i=new M;i.nameThing=Math.random().toString(16),await n.put(i)}});(()=>{let a=new WebSocket("ws://127.0.0.1:8088");a.addEventListener("open",()=>{console.log("Refresh connection established")}),a.addEventListener("message",e=>{console.log("Bundle finished. Start refresh"),e.data==="REFRESH"&&window.location.reload()})})();
//# sourceMappingURL=page.js.map
