{"version":3,"file":".././page/build/page.js","mappings":"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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;;;;;;;;;ACnEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA,YAAY;AACZ;;;;;;;;;;AC/Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB,qBAAqB,mBAAO,CAAC,oHAA0B;AACvD,eAAe,mBAAO,CAAC,4FAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;;;;ACnIa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB,oBAAoB,mBAAO,CAAC,gGAAa;AACzC,eAAe,mBAAO,CAAC,4FAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;;;;ACxDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY;AACZ,oBAAoB,mBAAO,CAAC,gGAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;;;;;;;;AChBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;;;;;;;;;ACxBa;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,gBAAgB,GAAG,iBAAiB,GAAG,YAAY,GAAG,gBAAgB,GAAG,YAAY,GAAG,kBAAkB;AAC7H;AACA,mBAAmB,mBAAO,CAAC,kIAAwC;AACnE,8CAA6C,EAAE,qCAAqC,mCAAmC,EAAC;AACxH,aAAa,mBAAO,CAAC,0GAA4B;AACjD,wCAAuC,EAAE,qCAAqC,uBAAuB,EAAC;AACtG,kBAAkB,mBAAO,CAAC,oHAAiC;AAC3D,4CAA2C,EAAE,qCAAqC,gCAAgC,EAAC;AACnH,aAAa,mBAAO,CAAC,0GAA4B;AACjD,wCAAuC,EAAE,qCAAqC,uBAAuB,EAAC;AACtG,kBAAkB,mBAAO,CAAC,gGAAuB;AACjD,6CAA4C,EAAE,qCAAqC,iCAAiC,EAAC;AACrH;AACA,kBAAkB,mBAAO,CAAC,sFAAkB;AAC5C,4CAA2C,EAAE,qCAAqC,gCAAgC,EAAC;AACnH,kBAAkB,mBAAO,CAAC,sFAAkB;AAC5C,4CAA2C,EAAE,qCAAqC,gCAAgC,EAAC;AACnH;;;;;;;;;;ACpBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;;;;ACnDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;UChBA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMC,OAAO,GAAW,EAAE;AAC1B,MAAMC,MAAM,GAAW,EAAE;AACzB,MAAMC,MAAM,GAAW,EAAE;AAEzB,kBAAC,aAAW;EACR,MAAMC,IAAI,SAAoBC,sBAAS,CAAC10B,OAAO,CAAC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","sources":["webpack://Page/./page/source/cube/cube.ts","webpack://Page/./page/source/math/euler.ts","webpack://Page/./page/source/math/matrix.ts","webpack://Page/./page/source/math/quaternion.ts","webpack://Page/./page/source/math/vector.ts","webpack://Page/./page/source/something_better/light/ambient-light.ts","webpack://Page/./page/source/something_better/transform.ts","webpack://Page/./page/source/something_better/view_projection/projection/perspective-projection.ts","webpack://Page/./page/source/something_better/view_projection/view-projection.ts","webpack://Page/./source/base/base/binding/bind-data-group-layout.ts","webpack://Page/./source/base/base/binding/bind-data-group.ts","webpack://Page/./source/base/base/binding/pipeline-data-layout.ts","webpack://Page/./source/base/base/buffer/gpu-buffer.ts","webpack://Page/./source/base/base/execution/instruction-executor.ts","webpack://Page/./source/base/base/execution/instruction/compute-instruction.ts","webpack://Page/./source/base/base/execution/instruction/vertex-fragment-instruction.ts","webpack://Page/./source/base/base/generator/base-generator-factory.ts","webpack://Page/./source/base/base/generator/base-native-buffer-generator.ts","webpack://Page/./source/base/base/generator/base-native-generator.ts","webpack://Page/./source/base/base/gpu/gpu-device.ts","webpack://Page/./source/base/base/gpu/gpu-object-update-reason.ts","webpack://Page/./source/base/base/gpu/gpu-object.ts","webpack://Page/./source/base/base/implementation/web_gpu/native-generator/web-gpu-bind-data-group-generator.ts","webpack://Page/./source/base/base/implementation/web_gpu/native-generator/web-gpu-bind-data-group-layout-generator.ts","webpack://Page/./source/base/base/implementation/web_gpu/native-generator/web-gpu-canvas-texture-generator.ts","webpack://Page/./source/base/base/implementation/web_gpu/native-generator/web-gpu-frame-buffer-texture-generator.ts","webpack://Page/./source/base/base/implementation/web_gpu/native-generator/web-gpu-gpu-buffer-generator.ts","webpack://Page/./source/base/base/implementation/web_gpu/native-generator/web-gpu-image-texture-generator.ts","webpack://Page/./source/base/base/implementation/web_gpu/native-generator/web-gpu-pipeline-data-layout-generator.ts","webpack://Page/./source/base/base/implementation/web_gpu/native-generator/web-gpu-texture-sampler-generator.ts","webpack://Page/./source/base/base/implementation/web_gpu/native-generator/web-gpu-vertex-fragment-shader-generator.ts","webpack://Page/./source/base/base/implementation/web_gpu/native-generator/web-gpu-video-texture-generator.ts","webpack://Page/./source/base/base/implementation/web_gpu/web-gpu-generator-factory.ts","webpack://Page/./source/base/base/implementation/web_gpu/web-gpu-shader-interpreter.ts","webpack://Page/./source/base/base/implementation/web_gpu/wgsl_enum/wgsl-type.enum.ts","webpack://Page/./source/base/base/memory_layout/base-memory-layout.ts","webpack://Page/./source/base/base/memory_layout/buffer/array-buffer-memory-layout.ts","webpack://Page/./source/base/base/memory_layout/buffer/base-buffer-memory-layout.ts","webpack://Page/./source/base/base/memory_layout/buffer/linear-buffer-memory-layout.ts","webpack://Page/./source/base/base/memory_layout/buffer/struct-buffer-memory-layout.ts","webpack://Page/./source/base/base/memory_layout/sampler-memory-layout.ts","webpack://Page/./source/base/base/memory_layout/texture-memory-layout.ts","webpack://Page/./source/base/base/pipeline/parameter/vertex-parameter-layout.ts","webpack://Page/./source/base/base/pipeline/parameter/vertex-parameter.ts","webpack://Page/./source/base/base/pipeline/target/render-targets.ts","webpack://Page/./source/base/base/pipeline/target/texture-group.ts","webpack://Page/./source/base/base/pipeline/vertex-fragment-pipeline.ts","webpack://Page/./source/base/base/shader/base-shader.ts","webpack://Page/./source/base/base/shader/interpreter/base-shader-interpreter.ts","webpack://Page/./source/base/base/shader/interpreter/shader-interpreter-factory.ts","webpack://Page/./source/base/base/shader/vertex-fragment-shader.ts","webpack://Page/./source/base/base/texture/canvas-texture.ts","webpack://Page/./source/base/base/texture/frame-buffer-texture.ts","webpack://Page/./source/base/base/texture/image-texture.ts","webpack://Page/./source/base/base/texture/texture-sampler.ts","webpack://Page/./source/base/base/texture/video-texture.ts","webpack://Page/./source/base/constant/access-mode.enum.ts","webpack://Page/./source/base/constant/buffer-bind-type.enum.ts","webpack://Page/./source/base/constant/buffer-primitive-format.ts","webpack://Page/./source/base/constant/compare-function.enum.ts","webpack://Page/./source/base/constant/compute-stage.enum.ts","webpack://Page/./source/base/constant/filter-mode.enum.ts","webpack://Page/./source/base/constant/memory-copy-type.enum.ts","webpack://Page/./source/base/constant/primitive-cullmode.ts","webpack://Page/./source/base/constant/primitive-front-face.ts","webpack://Page/./source/base/constant/primitive-topology.ts","webpack://Page/./source/base/constant/sampler-type.enum.ts","webpack://Page/./source/base/constant/texture-bind-type.enum.ts","webpack://Page/./source/base/constant/texture-dimension.enum.ts","webpack://Page/./source/base/constant/texture-format.enum.ts","webpack://Page/./source/base/constant/texture-operation.ts","webpack://Page/./source/base/constant/texture-usage.enum.ts","webpack://Page/./source/base/constant/wrapping-mode.enum.ts","webpack://Page/./page/source/shader.wgsl","webpack://Page/../kartoffelgames.core.data/library/source/data_container/dictionary/dictionary.js","webpack://Page/../kartoffelgames.core.data/library/source/data_container/list/list.js","webpack://Page/../kartoffelgames.core.data/library/source/data_container/tree/base-tree.js","webpack://Page/../kartoffelgames.core.data/library/source/data_container/tree/list-tree.js","webpack://Page/../kartoffelgames.core.data/library/source/data_container/tree/tree.js","webpack://Page/../kartoffelgames.core.data/library/source/exception/exception.js","webpack://Page/../kartoffelgames.core.data/library/source/index.js","webpack://Page/../kartoffelgames.core.data/library/source/util/enum-util.js","webpack://Page/../kartoffelgames.core.data/library/source/util/type-util.js","webpack://Page/webpack/bootstrap","webpack://Page/webpack/runtime/define property getters","webpack://Page/webpack/runtime/hasOwnProperty shorthand","webpack://Page/webpack/runtime/make namespace object","webpack://Page/./page/source/index.ts"],"sourcesContent":["// Create attributes data.\r\nexport const CubeVertexPositionData: Array<number> = [ // 4x Position\r\n    // Back\r\n    -1.0, 1.0, 1.0, 1.0,\r\n    1.0, 1.0, 1.0, 1.0,\r\n    1.0, -1.0, 1.0, 1.0,\r\n    -1.0, -1.0, 1.0, 1.0,\r\n\r\n    // Front\r\n    -1.0, 1.0, -1.0, 1.0,\r\n    1.0, 1.0, -1.0, 1.0,\r\n    1.0, -1.0, -1.0, 1.0,\r\n    -1.0, -1.0, -1.0, 1.0\r\n];\r\n\r\nexport const CubeVertexUvData: Array<number> = [ // 4x Position\r\n    // Front 4,5,6\r\n    0.33333, 0.25,\r\n    0.66666, 0.25,\r\n    0.66666, 0.50,\r\n    // Front 4,6,7\r\n    0.33333, 0.25,\r\n    0.66666, 0.50,\r\n    0.33333, 0.50,\r\n\r\n    // Back 1,0,3\r\n    0.66666, 1,\r\n    0.33333, 1,\r\n    0.33333, 0.75,\r\n    // Back 1,3,2\r\n    0.66666, 1,\r\n    0.33333, 0.75,\r\n    0.66666, 0.75,\r\n\r\n    // Left 0,4,7\r\n    0, 0.25,\r\n    0.33333, 0.25,\r\n    0.33333, 0.50,\r\n    // Left 0,7,3\r\n    0, 0.25,\r\n    0.33333, 0.50,\r\n    0, 0.50,\r\n\r\n    // Right 5,1,2\r\n    0.66666, 0.25,\r\n    1, 0.25,\r\n    1, 0.50,\r\n    // Right 5,2,6\r\n    0.66666, 0.25,\r\n    1, 0.50,\r\n    0.66666, 0.50,\r\n\r\n    // Top 0,1,5\r\n    0.33333, 0,\r\n    0.66666, 0,\r\n    0.66666, 0.25,\r\n    // Top 0,5,4\r\n    0.33333, 0,\r\n    0.66666, 0.25,\r\n    0.33333, 0.25,\r\n\r\n    // Bottom 7,6,2\r\n    0.33333, 0.50,\r\n    0.66666, 0.50,\r\n    0.66666, 0.75,\r\n    // Bottom 7,2,3\r\n    0.33333, 0.50,\r\n    0.66666, 0.75,\r\n    0.33333, 0.75,\r\n];\r\n\r\nexport const CubeVertexNormalData: Array<number> = [ // 4x Position\r\n    // Front\r\n    0, 0, -1, 0,\r\n    0, 0, -1, 0,\r\n    0, 0, -1, 0,\r\n    0, 0, -1, 0,\r\n    0, 0, -1, 0,\r\n    0, 0, -1, 0,\r\n\r\n    // Back 1,0,3\r\n    0, 0, 1, 0,\r\n    0, 0, 1, 0,\r\n    0, 0, 1, 0,\r\n    0, 0, 1, 0,\r\n    0, 0, 1, 0,\r\n    0, 0, 1, 0,\r\n\r\n    // Left 0,4,7\r\n    -1, 0, 0, 0,\r\n    -1, 0, 0, 0,\r\n    -1, 0, 0, 0,\r\n    -1, 0, 0, 0,\r\n    -1, 0, 0, 0,\r\n    -1, 0, 0, 0,\r\n\r\n    // Right 5,1,2\r\n    1, 0, 0, 0,\r\n    1, 0, 0, 0,\r\n    1, 0, 0, 0,\r\n    1, 0, 0, 0,\r\n    1, 0, 0, 0,\r\n    1, 0, 0, 0,\r\n\r\n    // Top 0,1,5\r\n    0, 1, 0, 0,\r\n    0, 1, 0, 0,\r\n    0, 1, 0, 0,\r\n    0, 1, 0, 0,\r\n    0, 1, 0, 0,\r\n    0, 1, 0, 0,\r\n\r\n    // Bottom 7,6,2\r\n    0, -1, 0, 0,\r\n    0, -1, 0, 0,\r\n    0, -1, 0, 0,\r\n    0, -1, 0, 0,\r\n    0, -1, 0, 0,\r\n    0, -1, 0, 0,\r\n];\r\n\r\n// Create mesh.\r\nexport const CubeVertexIndices = [\r\n    // Front\r\n    4, 5, 6,\r\n    4, 6, 7,\r\n    // Back\r\n    1, 0, 3,\r\n    1, 3, 2,\r\n    // Left\r\n    0, 4, 7,\r\n    0, 7, 3,\r\n    // Right\r\n    5, 1, 2,\r\n    5, 2, 6,\r\n    // Top\r\n    0, 1, 5,\r\n    0, 5, 4,\r\n    // Bottom\r\n    7, 6, 2,\r\n    7, 2, 3\r\n];","export class Euler {\r\n    private mX: number;\r\n    private mY: number;\r\n    private mZ: number;\r\n\r\n    /**\r\n     * X axis degree.\r\n     */\r\n    public get x(): number {\r\n        return this.mX;\r\n    } set x(pValue: number) {\r\n        this.mX = pValue;\r\n    }\r\n\r\n    /**\r\n     * Y axis degree.\r\n     */\r\n    public get y(): number {\r\n        return this.mY;\r\n    } set y(pValue: number) {\r\n        this.mY = pValue;\r\n    }\r\n\r\n    /**\r\n     * Z axis degree.\r\n     */\r\n    public get z(): number {\r\n        return this.mZ;\r\n    } set z(pValue: number) {\r\n        this.mZ = pValue;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mX = 0;\r\n        this.mY = 0;\r\n        this.mZ = 0;\r\n    }\r\n}","import { Exception } from '@kartoffelgames/core.data';\r\nimport { Vector } from './vector';\r\n\r\nexport class Matrix {\r\n    /**\r\n     * Create matrix from data array.\r\n     * Direction from reading columns than rows.\r\n     * @param pArray - Array data. \r\n     * @param pHeight \r\n     * @param pWidth \r\n     * @returns \r\n     */\r\n    public static fromArray(pArray: Array<number>, pHeight: number, pWidth: number): Matrix {\r\n        const lData: Array<Array<number>> = new Array<Array<number>>();\r\n\r\n        for (let lRowIndex = 0; lRowIndex < pHeight; lRowIndex++) {\r\n            const lRowData: Array<number> = new Array<number>(pWidth);\r\n\r\n            for (let lColumnIndex = 0; lColumnIndex < pWidth; lColumnIndex++) {\r\n                lRowData[lColumnIndex] = pArray[(lColumnIndex * pHeight) + lRowIndex];\r\n            }\r\n\r\n            // Add row to data array.\r\n            lData.push(lRowData);\r\n        }\r\n\r\n        return new Matrix(lData);\r\n    }\r\n\r\n    /**\r\n     * Create identity matrix.\r\n     * @param pSize - Matix size: nxn\r\n     * @param pValue - Value of identity. \r\n     */\r\n    public static identity(pSize: number): Matrix {\r\n        const lData: Array<Array<number>> = new Array<Array<number>>();\r\n        for (let lRowIndex = 0; lRowIndex < pSize; lRowIndex++) {\r\n            // Create Array filled with zeros.\r\n            const lRowData: Array<number> = new Array<number>(pSize).fill(0);\r\n\r\n            // Set identity column to value.\r\n            lRowData[lRowIndex] = 1;\r\n\r\n            // Add row to data array.\r\n            lData.push(lRowData);\r\n        }\r\n\r\n        return new Matrix(lData);\r\n    }\r\n\r\n    private readonly mData: Array<Array<number>>;\r\n\r\n    /**\r\n     * Get matix raw data.\r\n     */\r\n    public get data(): Array<Array<number>> {\r\n        return this.mData;\r\n    }\r\n\r\n    /**\r\n     * Data as number array.\r\n     */\r\n    public get dataArray(): Array<number> {\r\n        const lData: Array<number> = new Array<number>();\r\n\r\n        // Read from columns to rows.\r\n        for (let lColumnIndex = 0; lColumnIndex < this.width; lColumnIndex++) {\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                lData.push(this.mData[lRowIndex][lColumnIndex]);\r\n            }\r\n        }\r\n\r\n        return lData;\r\n    }\r\n\r\n    /**\r\n     * Get matrix height.\r\n     */\r\n    public get height(): number {\r\n        return this.mData.length;\r\n    }\r\n\r\n    /**\r\n     * Get matrix width.\r\n     */\r\n    public get width(): number {\r\n        return this.mData[0]?.length ?? 0;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pData - Matrix data.\r\n     */\r\n    public constructor(pData: Array<Array<number>>) {\r\n        this.mData = pData;\r\n    }\r\n\r\n    /**\r\n     * Add value to matrix.\r\n     * @param pAddData - Matrix or scalar value.\r\n     */\r\n    public add(pAddData: Matrix | number): Matrix {\r\n        const lData: Array<Array<number>> = new Array<Array<number>>();\r\n\r\n        if (pAddData instanceof Matrix) {\r\n            // Restrict on same length.\r\n            if (this.height !== pAddData.height && this.width !== pAddData.width) {\r\n                throw new Exception('Matrices need to be the same size for calculation.', this);\r\n            }\r\n\r\n            // Iterate rows and extend data dynamicly by pushing new data rows.\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                // Add each column of row.\r\n                const lRowData: Array<number> = new Array<number>(this.width);\r\n                for (let lColumnIndex = 0; lColumnIndex < lRowData.length; lColumnIndex++) {\r\n                    lRowData[lColumnIndex] = this.mData[lRowIndex][lColumnIndex] + pAddData.data[lRowIndex][lColumnIndex];\r\n                }\r\n\r\n                lData.push(lRowData);\r\n            }\r\n        } else {\r\n            // Add scalar to each matrix component.\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                const lRowData: Array<number> = new Array<number>(this.width);\r\n                for (let lColumnIndex = 0; lColumnIndex < lRowData.length; lColumnIndex++) {\r\n                    lRowData[lColumnIndex] = this.mData[lRowIndex][lColumnIndex] + pAddData;\r\n                }\r\n\r\n                lData.push(lRowData);\r\n            }\r\n        }\r\n\r\n        return new Matrix(lData);\r\n    }\r\n\r\n    /**\r\n     * Adjoint matrix.\r\n     */\r\n    public adjoint(): Matrix {\r\n        const lMatrixData: Array<Array<number>> = new Array<Array<number>>();\r\n\r\n        // Allways use first row and iterate over columns.\r\n        for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n            const lMatrixRow: Array<number> = new Array<number>();\r\n            for (let lColumIndex = 0; lColumIndex < this.width; lColumIndex++) {\r\n                // Calculate determant of matrix with omitted column and row.\r\n                // Toggle sign on each new row or column.\r\n                let lDeterminant: number = this.omit(lRowIndex, lColumIndex).determinant();\r\n                lDeterminant *= Math.pow(-1, (lRowIndex + 1) + (lColumIndex + 1));\r\n\r\n\r\n                lMatrixRow.push(lDeterminant);\r\n            }\r\n\r\n            // Add row to matrix data.\r\n            lMatrixData.push(lMatrixRow);\r\n        }\r\n\r\n        // Calculate transpose from cofactor matrix to get adjoint. \r\n        const lCofactorMatrix = new Matrix(lMatrixData);\r\n        return lCofactorMatrix.transpose();\r\n    }\r\n\r\n    /**\r\n     * Calculate determant of matrix.\r\n     */\r\n    public determinant(): number {\r\n        // Super fast determinant calculation of a 1x1 matrix.\r\n        if (this.height === 1 && this.width === 1) {\r\n            return this.data[0][0];\r\n        }\r\n\r\n        let lDeterminant: number = 0;\r\n        for (let lIterationIndex = 0; lIterationIndex < this.width; lIterationIndex++) {\r\n            // Get number of row iteration to detect if any calculation musst be done.\r\n            let lSignedNumber: number = this.data[0][lIterationIndex];\r\n            lSignedNumber *= (lIterationIndex % 2) ? -1 : 1; // Toggle sign between iteration. Begin with plus.\r\n\r\n            // Check if any calculation needs to be done. Zero multiplicated is allways zero.\r\n            if (lSignedNumber !== 0) {\r\n                // Calculate determinant of new matrix. Allways use first row.\r\n                const lDeterminantMatrix: Matrix = this.omit(0, lIterationIndex);\r\n                lDeterminant += lSignedNumber * lDeterminantMatrix.determinant();\r\n            }\r\n        }\r\n\r\n        return lDeterminant;\r\n    }\r\n\r\n    /**\r\n     * Inverse matrix.\r\n     */\r\n    public inverse(): Matrix {\r\n        const lAdjoint: Matrix = this.adjoint();\r\n        const lDeterminant: number = this.determinant();\r\n\r\n        // Devide each adjoint matrix component by determinant.\r\n        for (let lColumIndex = 0; lColumIndex < this.width; lColumIndex++) {\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                lAdjoint.data[lRowIndex][lColumIndex] /= lDeterminant;\r\n            }\r\n        }\r\n\r\n        return lAdjoint;\r\n    }\r\n\r\n    /**\r\n     * Multiplicate matrix.\r\n     * @param pMultData - Matrix or scalar value.\r\n     */\r\n    public mult(pMultData: Matrix | number): Matrix {\r\n        const lData: Array<Array<number>> = new Array<Array<number>>();\r\n\r\n        if (pMultData instanceof Matrix) {\r\n            // Restrict on same length.\r\n            if (this.width !== pMultData.height) {\r\n                throw new Exception('Matrices A width and B height must match for multiplication.', this);\r\n            }\r\n\r\n            // Iterate rows and extend data dynamicly by pushing new data rows.\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                // Add each column of row.\r\n                const lRowData: Array<number> = new Array<number>(pMultData.width);\r\n                for (let lColumnIndex = 0; lColumnIndex < lRowData.length; lColumnIndex++) {\r\n\r\n                    // Multiplicate target row with source column components.\r\n                    // Iteration length is eighter target.height or source.width.\r\n                    let lProduct: number = 0;\r\n                    for (let lComponentIndex = 0; lComponentIndex < this.height; lComponentIndex++) {\r\n                        lProduct += this.mData[lRowIndex][lComponentIndex] * pMultData.data[lComponentIndex][lColumnIndex];\r\n                    }\r\n                    lRowData[lColumnIndex] = lProduct;\r\n                }\r\n\r\n                lData.push(lRowData);\r\n            }\r\n        } else {\r\n            // Multiplicate scalar to each matrix component.\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                const lRowData: Array<number> = new Array<number>(this.width);\r\n                for (let lColumnIndex = 0; lColumnIndex < this.width; lColumnIndex++) {\r\n                    lRowData[lColumnIndex] = this.mData[lRowIndex][lColumnIndex] * pMultData;\r\n                }\r\n\r\n                lData.push(lRowData);\r\n            }\r\n        }\r\n\r\n        return new Matrix(lData);\r\n    }\r\n\r\n    /**\r\n     * Omit row and column from matrix.\r\n     * @param pOmitRow - Omitting row.\r\n     * @param pOmitColumn - Omiting column\r\n     */\r\n    public omit(pOmitRow: number, pOmitColumn: number): Matrix {\r\n        const lMatrixData: Array<Array<number>> = new Array<Array<number>>();\r\n\r\n        // Allways use first row and iterate over columns.\r\n        for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n            if (lRowIndex !== pOmitRow) {\r\n                const lMatrixRow: Array<number> = new Array<number>();\r\n                for (let lColumIndex = 0; lColumIndex < this.width; lColumIndex++) {\r\n                    // Skip column of\r\n                    if (lColumIndex !== pOmitColumn) {\r\n                        lMatrixRow.push(this.data[lRowIndex][lColumIndex]);\r\n                    }\r\n                }\r\n\r\n                // Add row to matrix data.\r\n                lMatrixData.push(lMatrixRow);\r\n            }\r\n        }\r\n\r\n        return new Matrix(lMatrixData);\r\n    }\r\n\r\n    /**\r\n     * Substract value to matrix.\r\n     * @param pAddData - Matrix or scalar value.\r\n     */\r\n    public sub(pAddData: Matrix | number): Matrix {\r\n        const lData: Array<Array<number>> = new Array<Array<number>>();\r\n\r\n        if (pAddData instanceof Matrix) {\r\n            // Restrict on same length.\r\n            if (this.height !== pAddData.height && this.width !== pAddData.width) {\r\n                throw new Exception('Matrices need to be the same size for calculation.', this);\r\n            }\r\n\r\n            // Iterate rows and extend data dynamicly by pushing new data rows.\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                // Add each column of row.\r\n                const lRowData: Array<number> = new Array<number>(this.width);\r\n                for (let lColumnIndex = 0; lColumnIndex < lRowData.length; lColumnIndex++) {\r\n                    lRowData[lColumnIndex] = this.mData[lRowIndex][lColumnIndex] - pAddData.data[lRowIndex][lColumnIndex];\r\n                }\r\n\r\n                lData.push(lRowData);\r\n            }\r\n        } else {\r\n            // Add scalar to each matrix component.\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                const lRowData: Array<number> = new Array<number>(this.width);\r\n                for (let lColumnIndex = 0; lColumnIndex < lRowData.length; lColumnIndex++) {\r\n                    lRowData[lColumnIndex] = this.mData[lRowIndex][lColumnIndex] - pAddData;\r\n                }\r\n\r\n                lData.push(lRowData);\r\n            }\r\n        }\r\n\r\n        return new Matrix(lData);\r\n    }\r\n\r\n    /**\r\n     * Transpose matrix.\r\n     */\r\n    public transpose(): Matrix {\r\n        const lMatrixData: Array<Array<number>> = new Array<Array<number>>();\r\n\r\n        // Transpose by copying column into row.\r\n        for (let lColumIndex = 0; lColumIndex < this.width; lColumIndex++) {\r\n            const lMatrixRow: Array<number> = new Array<number>();\r\n            for (let lRowIndex = 0; lRowIndex < this.height; lRowIndex++) {\r\n                lMatrixRow.push(this.data[lRowIndex][lColumIndex]);\r\n            }\r\n\r\n            // Add row to matrix data.\r\n            lMatrixData.push(lMatrixRow);\r\n        }\r\n\r\n        return new Matrix(lMatrixData);\r\n    }\r\n\r\n    /**\r\n     * Multiplicate matrix with vector.\r\n     * @param pMultData - Vector.\r\n     * @returns \r\n     */\r\n    public vectorMult(pMultData: Vector): Vector {\r\n        // Restrict on same length.\r\n        if (this.width !== pMultData.data.length) {\r\n            throw new Exception('Matrices A width and B height must match for multiplication.', this);\r\n        }\r\n\r\n        // Convert vector to matrix by creating a \r\n        const lMatrixData: Array<Array<number>> = new Array<Array<number>>();\r\n        for (const lVectorComponent of pMultData.data) {\r\n            lMatrixData.push([lVectorComponent]);\r\n        }\r\n\r\n        // Multiplicate\r\n        const lMutiplicatedMatrix = this.mult(new Matrix(lMatrixData));\r\n\r\n        const lVectorData: Array<number> = new Array<number>();\r\n        for (let lRowIndex = 0; lRowIndex < lMutiplicatedMatrix.height; lRowIndex++) {\r\n            lVectorData.push(lMutiplicatedMatrix.data[lRowIndex][0]);\r\n        }\r\n\r\n        return new Vector(lVectorData);\r\n    }\r\n}","import { Euler } from './euler';\r\nimport { Matrix } from './matrix';\r\nimport { Vector } from './vector';\r\n\r\nexport class Quaternion {\r\n    /**\r\n     * Create new quaternion from degree rotation.\r\n     * Rotate order XYZ (Pitch, Yaw, Roll)\r\n     * @param pPitch - Pitch degree.\r\n     * @param pYaw - Yaw degree.\r\n     * @param pRoll - Roll degree.\r\n     */\r\n    public static fromRotation(pPitch: number, pYaw: number, pRoll: number): Quaternion {\r\n        // Conversion to radian.\r\n        const lPitchRadian: number = (pPitch % 360) * Math.PI / 180;\r\n        const lYawRadian: number = (pYaw % 360) * Math.PI / 180;\r\n        const lRollRadian: number = (pRoll % 360) * Math.PI / 180;\r\n\r\n        // Pre calculate.\r\n        const lCosPitch = Math.cos(lPitchRadian * 0.5);\r\n        const lSinPitch = Math.sin(lPitchRadian * 0.5);\r\n        const lCosYaw = Math.cos(lYawRadian * 0.5);\r\n        const lSinYaw = Math.sin(lYawRadian * 0.5);\r\n        const lCosRoll = Math.cos(lRollRadian * 0.5);\r\n        const lSinRoll = Math.sin(lRollRadian * 0.5);\r\n\r\n        // Create quaternion.\r\n        const lQuaternion = Quaternion.identity();\r\n        lQuaternion.w = lCosPitch * lCosYaw * lCosRoll + lSinPitch * lSinYaw * lSinRoll;\r\n        lQuaternion.x = lSinPitch * lCosYaw * lCosRoll - lCosPitch * lSinYaw * lSinRoll;\r\n        lQuaternion.y = lCosPitch * lSinYaw * lCosRoll + lSinPitch * lCosYaw * lSinRoll;\r\n        lQuaternion.z = lCosPitch * lCosYaw * lSinRoll - lSinPitch * lSinYaw * lCosRoll;\r\n\r\n        return lQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Create identity quaternion.\r\n     */\r\n    public static identity(): Quaternion {\r\n        return new Quaternion(1, 0, 0, 0);\r\n    }\r\n\r\n    public mW: number;\r\n    public mX: number;\r\n    public mY: number;\r\n    public mZ: number;\r\n\r\n    /**\r\n     * Rotation forward vector.\r\n     */\r\n    public get vectorForward(): Vector {\r\n        // Products.\r\n        const lSquareX: number = 2 * Math.pow(this.mX, 2);\r\n        const lSquareY: number = 2 * Math.pow(this.mY, 2);\r\n        const lProductXz: number = 2 * this.mX * this.mZ;\r\n        const lProductYw: number = 2 * this.mY * this.mW;\r\n        const lProductYz: number = 2 * this.mY * this.mZ;\r\n        const lProductXw: number = 2 * this.mX * this.mW;\r\n\r\n        const lX: number = lProductXz + lProductYw;\r\n        const lY: number = lProductYz - lProductXw;\r\n        const lZ: number = 1 - lSquareX - lSquareY;\r\n\r\n        return new Vector([lX, lY, lZ]);\r\n    }\r\n\r\n    /**\r\n     * Rotation vector right.\r\n     */\r\n    public get vectorRight(): Vector {\r\n        // Products.\r\n        const lSquareY: number = 2 * Math.pow(this.mY, 2);\r\n        const lSquareZ: number = 2 * Math.pow(this.mZ, 2);\r\n        const lProductXy: number = 2 * this.mX * this.mY;\r\n        const lProductZw: number = 2 * this.mZ * this.mW;\r\n        const lProductYz: number = 2 * this.mY * this.mZ;\r\n        const lProductXw: number = 2 * this.mX * this.mW;\r\n\r\n        const lX: number = 1 - lSquareY - lSquareZ;\r\n        const lY: number = lProductXy + lProductZw;\r\n        const lZ: number = lProductYz + lProductXw;\r\n\r\n        return new Vector([lX, lY, lZ]);\r\n    }\r\n\r\n    /**\r\n     * Rotation up vector.\r\n     */\r\n    public get vectorUp(): Vector {\r\n        // Products.\r\n        const lSquareX: number = 2 * Math.pow(this.mX, 2);\r\n        const lSquareZ: number = 2 * Math.pow(this.mZ, 2);\r\n        const lProductXy: number = 2 * this.mX * this.mY;\r\n        const lProductZw: number = 2 * this.mZ * this.mW;\r\n\r\n        const lProductYz: number = 2 * this.mY * this.mZ;\r\n        const lProductXw: number = 2 * this.mX * this.mW;\r\n\r\n        const lX: number = lProductXy - lProductZw;\r\n        const lY: number = 1 - lSquareX - lSquareZ;\r\n        const lZ: number = lProductYz + lProductXw;\r\n\r\n        return new Vector([lX, lY, lZ]);\r\n    }\r\n\r\n    /**\r\n     * Get w value.\r\n     */\r\n    public get w(): number {\r\n        return this.mW;\r\n    } set w(pValue: number) {\r\n        this.mW = pValue;\r\n    }\r\n\r\n    /**\r\n     * Get x value.\r\n     */\r\n    public get x(): number {\r\n        return this.mX;\r\n    } set x(pValue: number) {\r\n        this.mX = pValue;\r\n    }\r\n\r\n    /**\r\n     * Get y value.\r\n     */\r\n    public get y(): number {\r\n        return this.mY;\r\n    } set y(pValue: number) {\r\n        this.mY = pValue;\r\n    }\r\n\r\n    /**\r\n     * Get z value.\r\n     */\r\n    public get z(): number {\r\n        return this.mZ;\r\n    } set z(pValue: number) {\r\n        this.mZ = pValue;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pW - W.\r\n     * @param pX - X.\r\n     * @param pY - Y.\r\n     * @param pZ - Z.\r\n     */\r\n    public constructor(pW: number, pX: number, pY: number, pZ: number) {\r\n        this.mX = pX;\r\n        this.mY = pY;\r\n        this.mZ = pZ;\r\n        this.mW = pW;\r\n    }\r\n\r\n    /**\r\n     * Add angles to current euler rotation.\r\n     * @param pPitch - Pitch degree.\r\n     * @param pYaw - Yaw degree.\r\n     * @param pRoll - Roll degree.\r\n     */\r\n    public addEulerRotation(pPitch: number, pYaw: number, pRoll: number): Quaternion {\r\n        // Apply current rotation after setting new rotation to apply rotation as absolute euler rotation and not as relative quaternion.\r\n        return this.mult(Quaternion.fromRotation(pPitch, pYaw, pRoll));\r\n    }\r\n\r\n    /**\r\n     * Quaternion rotation as euler rotation\r\n     */\r\n    public asEuler(): Euler {\r\n        const lEuler: Euler = new Euler();\r\n\r\n        // Pitch (x-axis rotation)\r\n        const lSinPitchCosYaw = 2 * (this.mW * this.mX + this.mY * this.mZ);\r\n        const lCosPitchCosYaw = 1 - 2 * (this.mX * this.mX + this.mY * this.mY);\r\n        const lPitchRadian = Math.atan2(lSinPitchCosYaw, lCosPitchCosYaw);\r\n        const lPitchDegree = (lPitchRadian * 180 / Math.PI) % 360;\r\n        lEuler.x = (lPitchDegree < 0) ? lPitchDegree + 360 : lPitchDegree;\r\n\r\n        // Yaw (y-axis rotation)\r\n        const lSinYaw = Math.sqrt(1 + 2 * (this.mW * this.mY - this.mX * this.mZ));\r\n        const lCosYaw = Math.sqrt(1 - 2 * (this.mW * this.mY - this.mX * this.mZ));\r\n        const lYawRadian = 2 * Math.atan2(lSinYaw, lCosYaw) - Math.PI / 2;\r\n        const lYawDegree = (lYawRadian * 180 / Math.PI) % 360;\r\n        lEuler.y = (lYawDegree < 0) ? lYawDegree + 360 : lYawDegree;\r\n\r\n        // Roll (z-axis rotation)\r\n        const lSinRollCosYaw = 2 * (this.mW * this.mZ + this.mX * this.mY);\r\n        const lCosRollCosYaw = 1 - 2 * (this.mY * this.mY + this.mZ * this.mZ);\r\n        const lRollRadian = Math.atan2(lSinRollCosYaw, lCosRollCosYaw);\r\n        const lRollDegree = (lRollRadian * 180 / Math.PI) % 360;\r\n        lEuler.z = (lRollDegree < 0) ? lRollDegree + 360 : lRollDegree;\r\n\r\n        return lEuler;\r\n    }\r\n\r\n    /**\r\n     * Convert quaternion to a 4x4 rotation matrix.\r\n     */\r\n    public asMatrix(): Matrix {\r\n        /*\r\n            1 - 2*qy² - 2*qz²\t2*qx*qy - 2*qz*qw\t2*qx*qz + 2*qy*qw\r\n            2*qx*qy + 2*qz*qw\t1 - 2*qx² - 2*qz²\t2*qy*qz - 2*qx*qw\r\n            2*qx*qz - 2*qy*qw\t2*qy*qz + 2*qx*qw\t1 - 2*qx² - 2*qy²\r\n        */\r\n        // Sqares\r\n        const lSquareX: number = 2 * Math.pow(this.mX, 2);\r\n        const lSquareY: number = 2 * Math.pow(this.mY, 2);\r\n        const lSquareZ: number = 2 * Math.pow(this.mZ, 2);\r\n\r\n        // Products.\r\n        const lProductXy: number = 2 * this.mX * this.mY;\r\n        const lProductZw: number = 2 * this.mZ * this.mW;\r\n        const lProductXz: number = 2 * this.mX * this.mZ;\r\n        const lProductYw: number = 2 * this.mY * this.mW;\r\n        const lProductYz: number = 2 * this.mY * this.mZ;\r\n        const lProductXw: number = 2 * this.mX * this.mW;\r\n\r\n        // Fill matrix\r\n        const lMatrix: Matrix = Matrix.identity(4);\r\n        lMatrix.data[0][0] = 1 - lSquareY - lSquareZ;\r\n        lMatrix.data[0][1] = lProductXy - lProductZw;\r\n        lMatrix.data[0][2] = lProductXz + lProductYw;\r\n\r\n        lMatrix.data[1][0] = lProductXy + lProductZw;\r\n        lMatrix.data[1][1] = 1 - lSquareX - lSquareZ;\r\n        lMatrix.data[1][2] = lProductYz - lProductXw;\r\n\r\n        lMatrix.data[2][0] = lProductXz - lProductYw;\r\n        lMatrix.data[2][1] = lProductYz + lProductXw;\r\n        lMatrix.data[2][2] = 1 - lSquareX - lSquareY;\r\n\r\n        return lMatrix;\r\n    }\r\n\r\n    /**\r\n     * Multiplicate with quaternion.\r\n     * @param pQuaternion - Quaterion source.\r\n     */\r\n    public mult(pQuaternion: Quaternion): Quaternion {\r\n        const lW: number = this.mW * pQuaternion.w - this.mX * pQuaternion.x - this.mY * pQuaternion.y - this.mZ * pQuaternion.z;\r\n        const lX: number = this.mW * pQuaternion.x + this.mX * pQuaternion.w + this.mY * pQuaternion.z - this.mZ * pQuaternion.y;\r\n        const lY: number = this.mW * pQuaternion.y - this.mX * pQuaternion.z + this.mY * pQuaternion.w + this.mZ * pQuaternion.x;\r\n        const lZ: number = this.mW * pQuaternion.z + this.mX * pQuaternion.y - this.mY * pQuaternion.x + this.mZ * pQuaternion.w;\r\n\r\n        return new Quaternion(lW, lX, lY, lZ);\r\n    }\r\n\r\n    /**\r\n     * Normalize quaternion.\r\n     */\r\n    public normalize(): Quaternion {\r\n        // Calculate length.\r\n        const lLength = Math.hypot(Math.pow(this.mW, 2), Math.pow(this.mX, 2), Math.pow(this.mY, 2), Math.pow(this.mZ, 2));\r\n\r\n        // Create new quaternion by dividing each dimension by length.\r\n        return new Quaternion(this.mW / lLength, this.mX / lLength, this.mY / lLength, this.mZ / lLength);\r\n    }\r\n}","import { Exception } from '@kartoffelgames/core.data';\r\n\r\nexport class Vector {\r\n    private readonly mData: Array<number>;\r\n\r\n    /**\r\n     * Get vector data.\r\n     */\r\n    public get data(): Array<number> {\r\n        return this.mData;\r\n    }\r\n\r\n    /**\r\n     * W value quick access. \r\n     */\r\n    public get w(): number {\r\n        return this.mData[3];\r\n    }\r\n\r\n    /**\r\n     * X value quick access. \r\n     */\r\n    public get x(): number {\r\n        return this.mData[0];\r\n    }\r\n\r\n    /**\r\n     * Y value quick access. \r\n     */\r\n    public get y(): number {\r\n        return this.mData[1];\r\n    }\r\n\r\n    /**\r\n     * Z value quick access. \r\n     */\r\n    public get z(): number {\r\n        return this.mData[2];\r\n    }\r\n    \r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pData - Vector data.\r\n     */\r\n    public constructor(pData: Array<number>) {\r\n        this.mData = [...pData];\r\n    }\r\n\r\n    /**\r\n     * Add two vectors.\r\n     * @param pAddData - Vector or scalar.\r\n     */\r\n    public add(pAddData: Vector | number): Vector {\r\n        const lData: Array<number> = new Array<number>();\r\n\r\n        if (pAddData instanceof Vector) {\r\n            // Restrict on same length.\r\n            if (this.mData.length !== pAddData.data.length) {\r\n                throw new Exception('Vectors need to be the same length for calculation.', this);\r\n            }\r\n\r\n            // Add values.\r\n            for (let lIndex: number = 0; lIndex < this.mData.length; lIndex++) {\r\n                lData.push(this.mData[lIndex] + pAddData.data[lIndex]);\r\n            }\r\n        } else {\r\n            // Add scalar to each vector component.\r\n            for (const lItem of this.mData) {\r\n                lData.push(lItem + pAddData);\r\n            }\r\n        }\r\n\r\n        return new Vector(lData);\r\n    }\r\n\r\n    /**\r\n     * Get length of vector.\r\n     */\r\n    public length(): number {\r\n        // Square root sum.\r\n        return Math.hypot(...this.mData);\r\n    }\r\n\r\n    /**\r\n     * Calulate cross product of two vector3.\r\n     * @param pVector - Vector3.\r\n     */\r\n    public multCross(pVector: Vector): Vector {\r\n        // Restrict on same length.\r\n        if (this.mData.length !== pVector.data.length && this.mData.length !== 3) {\r\n            throw new Exception('Vectors need to be the length of 3 for corss product calculation.', this);\r\n        }\r\n\r\n        /*\r\n         * cx = ay*bz − az*by\r\n         * cy = az*bx − ax*bz\r\n         * cz = ax*by − ay*bx\r\n         */\r\n        return new Vector([\r\n            this.mData[1] * pVector.data[2] - this.mData[2] * pVector.data[1],\r\n            this.mData[2] * pVector.data[0] - this.mData[0] * pVector.data[2],\r\n            this.mData[0] * pVector.data[1] - this.mData[1] * pVector.data[0]\r\n        ]);\r\n    }\r\n\r\n    /**\r\n     * Multiply with dot procedure.\r\n     * @param pVector - Vector.\r\n     */\r\n    public multDot(pVector: Vector): number {\r\n        // Restrict on same length.\r\n        if (this.mData.length !== pVector.data.length) {\r\n            throw new Exception('Vectors need to be the same length for calculation.', this);\r\n        }\r\n\r\n        // Calculate dot product.\r\n        let lProduct: number = 0;\r\n        for (let lIndex: number = 0; lIndex < this.mData.length; lIndex++) {\r\n            lProduct += this.mData[lIndex] * pVector.data[lIndex];\r\n        }\r\n\r\n        return lProduct;\r\n    }\r\n\r\n    /**\r\n     * Normalize vector.\r\n     */\r\n    public normalize(): Vector {\r\n        const lLength: number = this.length();\r\n\r\n        // Devide each vector component with it vector length.\r\n        const lData: Array<number> = new Array<number>();\r\n        for (const lItem of this.mData) {\r\n            lData.push(lItem / lLength);\r\n        }\r\n\r\n        return new Vector(lData);\r\n    }\r\n\r\n    /**\r\n     * Substract two vectors.\r\n     * @param pSubData - Vector or scalar\r\n     */\r\n    public sub(pSubData: Vector | number): Vector {\r\n        const lData: Array<number> = new Array<number>();\r\n\r\n        if (pSubData instanceof Vector) {\r\n            // Restrict on same length.\r\n            if (this.mData.length !== pSubData.data.length) {\r\n                throw new Exception('Vectors need to be the same length for calculation.', this);\r\n            }\r\n\r\n            // Add values.\r\n            for (let lIndex: number = 0; lIndex < this.mData.length; lIndex++) {\r\n                lData.push(this.mData[lIndex] - pSubData.data[lIndex]);\r\n            }\r\n        } else {\r\n            // Substract scalar to each vector component.\r\n            for (const lItem of this.mData) {\r\n                lData.push(lItem - pSubData);\r\n            }\r\n        }\r\n\r\n        return new Vector(lData);\r\n    }\r\n}","import { Exception } from '@kartoffelgames/core.data';\r\nimport { Vector } from '../../math/vector';\r\n\r\nexport class AmbientLight {\r\n    private readonly mColor: Vector;\r\n\r\n    /**\r\n     * Ambient light Vector4 data.\r\n     */\r\n    public get data(): Array<number> {\r\n        return this.mColor.data;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mColor = new Vector([1, 1, 1, 1]);\r\n    }\r\n\r\n    /**\r\n     * Set ambient light color.\r\n     * @param pRed - Red.\r\n     * @param pGreen - Green.\r\n     * @param pBlue - Blue.\r\n     */\r\n    public setColor(pRed: number, pGreen: number, pBlue: number): void {\r\n        if(pRed > 1 || pRed < 0 || pGreen > 1 || pGreen < 0 || pBlue > 1 || pBlue < 0){\r\n            throw new Exception(`Color values need to be in 0 to 1 range. (R:${pRed}, G:${pGreen}, B:${pBlue})`, this);\r\n        }\r\n\r\n        this.mColor.data[0] = pRed;\r\n        this.mColor.data[1] = pGreen;\r\n        this.mColor.data[2] = pBlue;\r\n    }\r\n}","import { Matrix } from '../math/matrix';\r\nimport { Quaternion } from '../math/quaternion';\r\nimport { Vector } from '../math/vector';\r\n\r\nexport class Transform {\r\n    private readonly mPivot: Matrix;\r\n    private mRotation: Quaternion;\r\n    private readonly mScale: Matrix;\r\n    private readonly mTranslation: Matrix;\r\n\r\n    /**\r\n     * X pivot point.\r\n     */\r\n    public get pivotX(): number {\r\n        return this.mPivot.data[0][3];\r\n    } set pivotX(pValue: number) {\r\n        this.mPivot.data[0][3] = pValue;\r\n    }\r\n\r\n    /**\r\n     * Y pivot point.\r\n     */\r\n    public get pivotY(): number {\r\n        return this.mPivot.data[1][3];\r\n    } set pivotY(pValue: number) {\r\n        this.mPivot.data[1][3] = pValue;\r\n    }\r\n\r\n    /**\r\n     * Z pivot point.\r\n     */\r\n    public get pivotZ(): number {\r\n        return this.mPivot.data[2][3];\r\n    } set pivotZ(pValue: number) {\r\n        this.mPivot.data[2][3] = pValue;\r\n    }\r\n\r\n    /**\r\n     * Rotation on X angle.\r\n     * Pitch.\r\n     */\r\n    public get rotationPitch(): number {\r\n        return this.mRotation.asEuler().x;\r\n    }\r\n\r\n    /**\r\n     * Rotation on Z angle.\r\n     * Roll.\r\n     */\r\n    public get rotationRoll(): number {\r\n        return this.mRotation.asEuler().z;\r\n    }\r\n\r\n    /**\r\n     * Rotation on Y angle.\r\n     * Yaw.\r\n     */\r\n    public get rotationYaw(): number {\r\n        return this.mRotation.asEuler().y;\r\n    }\r\n\r\n    /**\r\n     * Depth scale.\r\n     */\r\n    public get scaleDepth(): number {\r\n        return this.mScale.data[2][2];\r\n    }\r\n\r\n    /**\r\n     * Height scale.\r\n     */\r\n    public get scaleHeight(): number {\r\n        return this.mScale.data[1][1];\r\n    }\r\n\r\n    /**\r\n     * Width scale.\r\n     */\r\n    public get scaleWidth(): number {\r\n        return this.mScale.data[0][0];\r\n    }\r\n\r\n    /**\r\n     * X translation.\r\n     */\r\n    public get translationX(): number {\r\n        return this.mTranslation.data[0][3];\r\n    }\r\n\r\n    /**\r\n     * Y translation.\r\n     */\r\n    public get translationY(): number {\r\n        return this.mTranslation.data[1][3];\r\n    }\r\n\r\n    /**\r\n     * Z translation.\r\n     */\r\n    public get translationZ(): number {\r\n        return this.mTranslation.data[2][3];\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mScale = Matrix.identity(4);\r\n        this.mTranslation = Matrix.identity(4);\r\n        this.mRotation = new Quaternion(1, 0, 0, 0);\r\n        this.mPivot = Matrix.identity(4);\r\n    }\r\n\r\n    /**\r\n     * Add angles to current euler rotation angles.\r\n     * @param pPitch - Pitch degree.\r\n     * @param pYaw - Yaw degree.\r\n     * @param pRoll - Roll degree.\r\n     */\r\n    public addEulerRotation(pPitch: number, pYaw: number, pRoll: number): void {\r\n        // Apply rotation to current rotation.\r\n        this.mRotation = this.mRotation.addEulerRotation(pPitch, pYaw, pRoll);\r\n    }\r\n\r\n    /**\r\n     * Add rotation to already rotated object.\r\n     * @param pPitch - Pitch degree.\r\n     * @param pYaw - Yaw degree.\r\n     * @param pRoll - Roll degree.\r\n     */\r\n    public addRotation(pPitch: number, pYaw: number, pRoll: number): void {\r\n        // Apply rotation to current rotation.\r\n        this.mRotation = Quaternion.fromRotation(pPitch, pYaw, pRoll).mult(this.mRotation);\r\n    }\r\n\r\n    /**\r\n     * Add scale.\r\n     * @param pWidth - Width multiplier.\r\n     * @param pHeight - Height multiplier.\r\n     * @param pDepth - Depth multiplier.\r\n     */\r\n    public addScale(pWidth: number, pHeight: number, pDepth: number): void {\r\n        this.mScale.data[0][0] += pWidth;\r\n        this.mScale.data[1][1] += pHeight;\r\n        this.mScale.data[2][2] += pDepth;\r\n    }\r\n\r\n    /**\r\n     * Add translation.\r\n     * @param pX - Movement on worlds X axis.\r\n     * @param pY - Movement on worlds Y axis.\r\n     * @param pZ - Movement on worlds Z axis.\r\n     */\r\n    public addTranslation(pX: number, pY: number, pZ: number): void {\r\n        this.mTranslation.data[0][3] += pX;\r\n        this.mTranslation.data[1][3] += pY;\r\n        this.mTranslation.data[2][3] += pZ;\r\n    }\r\n\r\n    /**\r\n     * Get transformation matrix.\r\n     */\r\n    public getMatrix(pType: TransformMatrix): Matrix {\r\n        switch (pType) {\r\n            case TransformMatrix.Scale: {\r\n                return this.mScale;\r\n            }\r\n            case TransformMatrix.Translation: {\r\n                return this.mTranslation;\r\n            }\r\n            case TransformMatrix.Rotation: {\r\n                return this.mRotation.asMatrix();\r\n            }\r\n            case TransformMatrix.PivotRotation: {\r\n                const lRotationMatrix: Matrix = this.getMatrix(TransformMatrix.Rotation);\r\n\r\n                // Check if pivit point is used.\r\n                let lPivotRotation: Matrix;\r\n                if (this.pivotX !== 0 || this.pivotY !== 0 || this.pivotZ !== 0) {\r\n                    // Translate pivot => rotate => reverse pivate translation.\r\n                    lPivotRotation = this.mPivot.inverse().mult(lRotationMatrix).mult(this.mPivot);\r\n                } else {\r\n                    lPivotRotation = lRotationMatrix;\r\n                }\r\n\r\n                return lPivotRotation;\r\n            }\r\n            case TransformMatrix.Transformation: {\r\n                const lScale: Matrix = this.getMatrix(TransformMatrix.Scale);\r\n                const lTranslation: Matrix = this.getMatrix(TransformMatrix.Translation);\r\n                const lRotation: Matrix = this.getMatrix(TransformMatrix.PivotRotation);\r\n\r\n                // First scale, second rotate, third translate.\r\n                return lTranslation.mult(lRotation).mult(lScale);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset current rotation and set new rotation.\r\n     * @param pPitch - Pitch degree.\r\n     * @param pYaw - Yaw degree.\r\n     * @param pRoll - Roll degree.\r\n     */\r\n    public setRotation(pPitch: number | null, pYaw: number | null, pRoll: number | null): void {\r\n        const lPitch: number = pPitch ?? this.rotationPitch;\r\n        const lYaw: number = pYaw ?? this.rotationYaw;\r\n        const lRoll: number = pRoll ?? this.rotationRoll;\r\n\r\n        // Create new rotation.\r\n        this.mRotation = Quaternion.fromRotation(lPitch, lYaw, lRoll);\r\n    }\r\n\r\n    /**\r\n     * Set scale.\r\n     * @param pWidth - Width multiplier.\r\n     * @param pHeight - Height multiplier.\r\n     * @param pDepth - Depth multiplier.\r\n     */\r\n    public setScale(pWidth: number | null, pHeight: number | null, pDepth: number | null): void {\r\n        this.mScale.data[0][0] = pWidth ?? this.scaleWidth;\r\n        this.mScale.data[1][1] = pHeight ?? this.scaleHeight;\r\n        this.mScale.data[2][2] = pDepth ?? this.scaleDepth;\r\n    }\r\n\r\n    /**\r\n     * Set translation.\r\n     * @param pX - Movement on worlds X axis.\r\n     * @param pY - Movement on worlds Y axis.\r\n     * @param pZ - Movement on worlds Z axis.\r\n     */\r\n    public setTranslation(pX: number | null, pY: number | null, pZ: number | null): void {\r\n        this.mTranslation.data[0][3] = pX ?? this.translationX;\r\n        this.mTranslation.data[1][3] = pY ?? this.translationY;\r\n        this.mTranslation.data[2][3] = pZ ?? this.translationZ;\r\n    }\r\n\r\n    /**\r\n     * Translate into rotation direction.\r\n     * @param pForward - Forward movement.\r\n     * @param pRight - Right movement.\r\n     * @param pUp - Up movement.\r\n     */\r\n    public translateInDirection(pForward: number, pRight: number, pUp: number): void {\r\n        const lTranslationVector: Vector = new Vector([pRight, pUp, pForward, 1]);\r\n        const lDirectionVector: Vector = this.getMatrix(TransformMatrix.Rotation).vectorMult(lTranslationVector);\r\n\r\n        // Add direction.\r\n        this.addTranslation(lDirectionVector.x, lDirectionVector.y, lDirectionVector.z);\r\n    }\r\n}\r\n\r\nexport enum TransformMatrix {\r\n    Rotation = 1,\r\n    PivotRotation = 2,\r\n    Translation = 3,\r\n    Scale = 4,\r\n    Transformation = 5\r\n}","import { Matrix } from '../../../math/matrix';\r\nimport { IProjection } from './i-projection.interface';\r\n\r\nexport class PerspectiveProjection implements IProjection {\r\n    private mAngleOfView: number;\r\n    private mAspectRatio: number;\r\n    private mCacheProjectionMatrix: Matrix | null;\r\n    private mFar: number;\r\n    private mNear: number;\r\n\r\n    /**\r\n     * Angle of view.\r\n     */\r\n    public get angleOfView(): number {\r\n        return this.mAngleOfView;\r\n    } set angleOfView(pValue: number) {\r\n        this.mAngleOfView = pValue;\r\n\r\n        // Reset cached matrix.\r\n        this.mCacheProjectionMatrix = null;\r\n    }\r\n\r\n    /**\r\n     * Angle of view.\r\n     */\r\n    public get aspectRatio(): number {\r\n        return this.mAspectRatio;\r\n    } set aspectRatio(pValue: number) {\r\n        this.mAspectRatio = pValue;\r\n\r\n        // Reset cached matrix.\r\n        this.mCacheProjectionMatrix = null;\r\n    }\r\n\r\n    /**\r\n     * Far plane.\r\n     */\r\n    public get far(): number {\r\n        return this.mFar;\r\n    } set far(pValue: number) {\r\n        this.mFar = pValue;\r\n\r\n        // Reset cached matrix.\r\n        this.mCacheProjectionMatrix = null;\r\n    }\r\n\r\n    /**\r\n     * Near plane.\r\n     */\r\n    public get near(): number {\r\n        return this.mNear;\r\n    } set near(pValue: number) {\r\n        this.mNear = pValue;\r\n\r\n        // Reset cached matrix.\r\n        this.mCacheProjectionMatrix = null;\r\n    }\r\n\r\n    /**\r\n     * Projection matrix.\r\n     */\r\n    public get projectionMatrix(): Matrix {\r\n        if (this.mCacheProjectionMatrix === null) {\r\n            this.mCacheProjectionMatrix = this.createMatrix();\r\n        }\r\n\r\n        return this.mCacheProjectionMatrix;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mAngleOfView = 0;\r\n        this.mNear = 0;\r\n        this.mFar = 0;\r\n        this.mAspectRatio = 0;\r\n\r\n        // Cache.\r\n        this.mCacheProjectionMatrix = null;\r\n    }\r\n\r\n    /**\r\n     * Create projection matrix.\r\n     */\r\n    private createMatrix(): Matrix {\r\n        const lMatrix: Matrix = Matrix.identity(4);\r\n\r\n        // Reset identity.\r\n        lMatrix.data[0][0] = 0;\r\n        lMatrix.data[1][1] = 0;\r\n        lMatrix.data[2][2] = 0;\r\n        lMatrix.data[3][3] = 0;\r\n\r\n        // Calculate planes with centered camera on z-plane.\r\n        const lFar: number = this.mFar;\r\n        const lNear: number = this.mNear;\r\n\r\n        // Top bottom calculated by get height from vertical angle of view.\r\n        // Half angle is from y=>0 to top plane, as the angle descripes the distance between top and bottom plane.\r\n        // Tan(angleOfView / 2) = Top / Near => Near * Tan(angleOfView / 2) = Top\r\n        const lTop: number = this.mNear * Math.tan((this.angleOfView * Math.PI / 180) / 2);\r\n        const lBottom: number = -lTop;\r\n\r\n        // Left right calculated from aspect ratio.\r\n        const lRight: number = lTop * this.aspectRatio;\r\n        const lLeft: number = -lRight;\r\n\r\n        // We need to set VectorZ to VectorW to devide VectorX and VectorY by the VectorZ.\r\n        // So planes are smaller the further ways they are.\r\n        // And scale VectorX and VectorY with the near plane to start the projection not on Z=0 but on Z=Near.\r\n        // ┌ N  0  0   0  ┐   ┌ 1 ┐   ┌ 1 ┐\r\n        // | 0  N  0   0  |   | 2 |   | 2 |\r\n        // | 0  0  M1  M2 | x | 3 | = | 3 |\r\n        // └ 0  0  1   0  ┘   └ 1 ┘   └ 3 ┘\r\n\r\n        // Problem is: The VectorZ get also divided by VectorX and VectorW.\r\n        // To fix the problem set VectorZ to VectorZ² with only M1 and M2 available.\r\n        // As as M1 is the Scaling(M1 * Z) and M2 is Translating(M2 + Z) we get:\r\n        // M1*Z + M2 = Z² => Quadratic means two solutions. But we need one.\r\n        // So we constrains the equation to be only valid between Near and Far. So we set Z=Near or Z=Far.\r\n        // All other Z Values are calculated quadratic ranging from Near to Far.\r\n        // So we get:\r\n        // M1*Near + M2 = Near²  => M1 = Far + Near\r\n        // M1*Far  + M2 = Far²   => M2 = -(Far * Near)\r\n        // ┌ N  0      0         0     ┐\r\n        // | 0  N      0         0     |\r\n        // | 0  0    F + N   -(F * N)  |\r\n        // └ 0  0      1         0     ┘\r\n\r\n        // Multiplicate this perspectiv matrix with the orthigraphic to center the camera.\r\n        // ┌  2/(R-L)    0         0    -(R+L)/(R-L) ┐   ┌ N  0      0         0     ┐\r\n        // |     0     2/(T-B)     0    -(T+B)/(T-B) |   | 0  N      0         0     |\r\n        // |     0        0     1/(F-N)   -N/(F-N)   | x | 0  0    F + N   -(F * N)  |\r\n        // └     0        0        0          1      ┘   └ 0  0      1         0     ┘\r\n\r\n        // And we get.\r\n        // ┌  2N/(R-L)    0        -(R+L)/(R-L)           0      ┐\r\n        // |     0     2N/(T-B)    -(T+B)/(T-B)           0      |\r\n        // |     0        0          F/(F-N)       -(F*N)/(F-N) |\r\n        // └     0        0             1                0      ┘\r\n\r\n\r\n        // Set matrix data. Row 1:\r\n        lMatrix.data[0][0] = (2 * lNear) / (lRight - lLeft);\r\n        lMatrix.data[0][2] = -(lRight + lLeft) / (lRight - lLeft);\r\n\r\n        // Set matrix data. Row 2:\r\n        lMatrix.data[1][1] = (2 * lNear) / (lTop - lBottom);\r\n        lMatrix.data[1][2] = -(lTop + lBottom) / (lTop - lBottom);\r\n\r\n        // Set matrix data. Row 3:\r\n        lMatrix.data[2][2] = lFar / (lFar - lNear);\r\n        lMatrix.data[2][3] = -(lFar * lNear) / (lFar - lNear);\r\n\r\n        // Set matrix data. Row 4:\r\n        lMatrix.data[3][2] = 1;\r\n\r\n        return lMatrix;\r\n    }\r\n}","import { Matrix } from '../../math/matrix';\r\nimport { Transform, TransformMatrix } from '../transform';\r\nimport { IProjection } from './projection/i-projection.interface';\r\n\r\nexport class ViewProjection {\r\n    private readonly mProjection: IProjection;\r\n    private readonly mTransformation: Transform;\r\n\r\n    /**\r\n     * Camera projection.\r\n     */\r\n    public get projection(): IProjection {\r\n        return this.mProjection;\r\n    }\r\n\r\n    /**\r\n     * Camera transformation.\r\n     */\r\n    public get transformation(): Transform {\r\n        return this.mTransformation;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor(pProjection: IProjection) {\r\n        this.mProjection = pProjection;\r\n        this.mTransformation = new Transform();\r\n    }\r\n\r\n    /**\r\n     * Get camera matrix. \r\n     * @param pType - Matrix type. \r\n     */\r\n    public getMatrix(pType: CameraMatrix): Matrix {\r\n        switch (pType) {\r\n            case CameraMatrix.Translation: {\r\n                return this.mTransformation.getMatrix(TransformMatrix.Translation);\r\n            }\r\n            case CameraMatrix.Rotation: {\r\n                return this.mTransformation.getMatrix(TransformMatrix.Rotation);\r\n            }\r\n            case CameraMatrix.PivotRotation: {\r\n                return this.mTransformation.getMatrix(TransformMatrix.PivotRotation);\r\n            }\r\n            case CameraMatrix.Projection: {\r\n                return this.mProjection.projectionMatrix;\r\n            }\r\n            case CameraMatrix.View: {\r\n                const lTranslation: Matrix = this.getMatrix(CameraMatrix.Translation);\r\n                const lRotation: Matrix = this.getMatrix(CameraMatrix.Rotation);\r\n                return lTranslation.mult(lRotation).inverse();\r\n            }\r\n            case CameraMatrix.ViewProjection: {\r\n                const lView: Matrix = this.getMatrix(CameraMatrix.View);\r\n                const lProjection: Matrix = this.getMatrix(CameraMatrix.Projection);\r\n                return lProjection.mult(lView);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\nexport enum CameraMatrix {\r\n    Translation = 1,\r\n    Rotation = 2,\r\n    PivotRotation = 3,\r\n    Projection = 4,\r\n    View = 5,\r\n    ViewProjection = 6\r\n}","import { Dictionary, Exception } from '@kartoffelgames/core.data';\r\nimport { GpuDevice } from '../gpu/gpu-device';\r\nimport { GpuObject } from '../gpu/gpu-object';\r\nimport { BaseMemoryLayout } from '../memory_layout/base-memory-layout';\r\nimport { BindDataGroup } from './bind-data-group';\r\nimport { UpdateReason } from '../gpu/gpu-object-update-reason';\r\n\r\nexport class BindDataGroupLayout extends GpuObject<'bindDataGroupLayout'> {\r\n    private readonly mBindings: Dictionary<string, BindLayout>;\r\n    private mIdentifier: string;\r\n\r\n    /**\r\n     * Get binding names.\r\n     */\r\n    public get bindingNames(): Array<string> {\r\n        return [...this.mBindings.keys()];\r\n    }\r\n\r\n    /**\r\n    * Get bindings of group.\r\n    */\r\n    public get bindings(): Array<BindLayout> {\r\n        const lBindingList: Array<BindLayout> = new Array<BindLayout>();\r\n        for (const lBinding of this.mBindings.values()) {\r\n            lBindingList[lBinding.index] = lBinding;\r\n        }\r\n\r\n        return lBindingList;\r\n    }\r\n\r\n    /**\r\n     * Get bind group identifier.\r\n     * Same configured groups has the same identifier.\r\n     */\r\n    public get identifier(): string {\r\n        return this.mIdentifier;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Gpu Device reference.\r\n     */\r\n    public constructor(pDevice: GpuDevice) {\r\n        super(pDevice);\r\n\r\n        // Init storage.\r\n        this.mBindings = new Dictionary<string, BindLayout>();\r\n\r\n        // Update identifier.\r\n        this.mIdentifier = '';\r\n        this.addUpdateListener(() => {\r\n            let lIdentifier: string = '';\r\n            for (const lBind of this.mBindings.values()) {\r\n                // Simple chain of values.\r\n                lIdentifier += lBind.index;\r\n                lIdentifier += '-' + lBind.name;\r\n                lIdentifier += '-' + lBind.layout.accessMode;\r\n                lIdentifier += '-' + lBind.layout.bindingIndex;\r\n                lIdentifier += '-' + lBind.layout.memoryType;\r\n                lIdentifier += '-' + lBind.layout.name;\r\n                lIdentifier += '-' + lBind.layout.visibility;\r\n                lIdentifier += ';';\r\n            }\r\n\r\n            this.mIdentifier = lIdentifier;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add layout to binding group.\r\n     * @param pLayout - Memory layout.\r\n     * @param pName - Binding name. For easy access only.\r\n     * @param pIndex - Index of bind inside group.\r\n     */\r\n    public addBinding(pLayout: BaseMemoryLayout, pName: string): void {\r\n        if (pLayout.bindingIndex === null) {\r\n            throw new Exception(`Layout \"${pLayout.name}\" binding needs a binding index.`, this);\r\n        }\r\n\r\n        // Set layout.\r\n        this.mBindings.set(pName, {\r\n            name: pName,\r\n            index: pLayout.bindingIndex,\r\n            layout: pLayout\r\n        });\r\n\r\n        // Register change listener for layout changes.\r\n        pLayout.addUpdateListener(() => {\r\n            this.triggerAutoUpdate(UpdateReason.ChildData);\r\n        });\r\n\r\n        // Trigger next auto update.\r\n        this.triggerAutoUpdate(UpdateReason.ChildData);\r\n    }\r\n\r\n    /**\r\n     * Create bind group from layout.\r\n     */\r\n    public createGroup(): BindDataGroup {\r\n        return new BindDataGroup(this.device, this);\r\n    }\r\n\r\n    /**\r\n     * Get full bind information.\r\n     * @param pName - Bind name.\r\n     */\r\n    public getBind(pName: string): Readonly<BindLayout> {\r\n        if (!this.mBindings.has(pName)) {\r\n            throw new Exception(`Bind ${pName} does not exist.`, this);\r\n        }\r\n\r\n        return this.mBindings.get(pName)!;\r\n    }\r\n}\r\n\r\ntype BindLayout = {\r\n    name: string,\r\n    index: number,\r\n    layout: BaseMemoryLayout;\r\n};","import { Dictionary, Exception, TypedArray } from '@kartoffelgames/core.data';\r\nimport { GpuBuffer } from '../buffer/gpu-buffer';\r\nimport { GpuDevice } from '../gpu/gpu-device';\r\nimport { GpuObject } from '../gpu/gpu-object';\r\nimport { FrameBufferTexture } from '../texture/frame-buffer-texture';\r\nimport { ImageTexture } from '../texture/image-texture';\r\nimport { TextureSampler } from '../texture/texture-sampler';\r\nimport { VideoTexture } from '../texture/video-texture';\r\nimport { BindDataGroupLayout } from './bind-data-group-layout';\r\nimport { CanvasTexture } from '../texture/canvas-texture';\r\nimport { UpdateReason } from '../gpu/gpu-object-update-reason';\r\n\r\nexport class BindDataGroup extends GpuObject<'bindDataGroup'> {\r\n    private readonly mBindData: Dictionary<string, BindData>;\r\n    private readonly mLayout: BindDataGroupLayout;\r\n\r\n    /**\r\n     * Layout of bind group.\r\n     */\r\n    public get layout(): BindDataGroupLayout {\r\n        return this.mLayout;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Gpu Device reference.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pBindGroupLayout: BindDataGroupLayout) {\r\n        super(pDevice);\r\n\r\n        this.mLayout = pBindGroupLayout;\r\n        this.mBindData = new Dictionary<string, BindData>();\r\n\r\n        // Register change listener for layout changes.\r\n        pBindGroupLayout.addUpdateListener(() => {\r\n            this.triggerAutoUpdate(UpdateReason.ChildData);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get data of layout binding.\r\n     * @param pBindName - Bind layout entry name.\r\n     */\r\n    public getData(pBindName: string): BindData {\r\n        const lData = this.mBindData.get(pBindName);\r\n        if (!lData) {\r\n            throw new Exception(`Cant get bind data \"${pBindName}\". No data set.`, this);\r\n        }\r\n\r\n        return lData;\r\n    }\r\n\r\n    /**\r\n     * Set data to layout binding.\r\n     * @param pBindName - Bind layout entry name.\r\n     * @param pData - Bind data.\r\n     */\r\n    public setData(pBindName: string, pData: BindData): void {\r\n        // TODO: Validate data type with value type.\r\n\r\n        // Set bind type to Teture for TS type check shutup.\r\n        this.mBindData.set(pBindName, pData);\r\n    }\r\n}\r\n\r\ntype BindData = GpuBuffer<TypedArray> | TextureSampler | ImageTexture | FrameBufferTexture | VideoTexture | CanvasTexture;","import { Dictionary, Exception } from '@kartoffelgames/core.data';\r\nimport { GpuDevice } from '../gpu/gpu-device';\r\nimport { GpuObject } from '../gpu/gpu-object';\r\nimport { BindDataGroupLayout } from './bind-data-group-layout';\r\nimport { UpdateReason } from '../gpu/gpu-object-update-reason';\r\n\r\nexport class PipelineDataLayout extends GpuObject<'pipelineDataLayout'> {\r\n    private readonly mBindGroups: Dictionary<number, BindDataGroupLayout>;\r\n\r\n    /**\r\n     * Bind group count.\r\n     */\r\n    public get groups(): Array<number> {\r\n        return [...this.mBindGroups.keys()];\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Gpu Device reference.\r\n     */\r\n    public constructor(pDevice: GpuDevice) {\r\n        super(pDevice);\r\n\r\n        // Init storage.\r\n        this.mBindGroups = new Dictionary<number, BindDataGroupLayout>();\r\n    }\r\n\r\n    /**\r\n     * Create bind group.\r\n     * @param pIndex - Group index.\r\n     * @param pLayout - [Optional] Bind group Layout.\r\n     */\r\n    public addGroupLayout(pIndex: number, pLayout: BindDataGroupLayout): void {\r\n        this.mBindGroups.add(pIndex, pLayout);\r\n\r\n        // Register change listener for layout changes.\r\n        pLayout.addUpdateListener(() => {\r\n            this.triggerAutoUpdate(UpdateReason.ChildData);\r\n        });\r\n\r\n        // Trigger auto update.\r\n        this.triggerAutoUpdate(UpdateReason.ChildData);\r\n    }\r\n\r\n    /**\r\n     * Get created bind group layout.\r\n     * @param pIndex - Group index.\r\n     */\r\n    public getGroupLayout(pIndex: number): BindDataGroupLayout {\r\n        // Throw on unaccessable group.\r\n        if (!this.mBindGroups.has(pIndex)) {\r\n            throw new Exception(`Bind group layout (${pIndex}) does not exists.`, this);\r\n        }\r\n\r\n        // Bind group should allways exist.\r\n        return this.mBindGroups.get(pIndex)!;\r\n    }\r\n}","import { TypedArray } from '@kartoffelgames/core.data';\r\nimport { GpuDevice } from '../gpu/gpu-device';\r\nimport { GpuObject } from '../gpu/gpu-object';\r\nimport { BaseBufferMemoryLayout } from '../memory_layout/buffer/base-buffer-memory-layout';\r\nimport { UpdateReason } from '../gpu/gpu-object-update-reason';\r\n\r\n/**\r\n * GpuBuffer. Uses local and native gpu buffers.\r\n */\r\nexport class GpuBuffer<TType extends TypedArray> extends GpuObject<'gpuBuffer'> {\r\n    private readonly mDataType: BufferDataType<TType>;\r\n    private readonly mItemCount: number;\r\n    private readonly mLayout: BaseBufferMemoryLayout;\r\n\r\n    /**\r\n     * Data type of buffer.\r\n     */\r\n    public get dataType(): BufferDataType<TType> {\r\n        return this.mDataType;\r\n    }\r\n\r\n    /**\r\n     * Get buffer item count.\r\n     */\r\n    public get length(): number {\r\n        return this.mItemCount;\r\n    }\r\n\r\n    /**\r\n     * Buffer layout.\r\n     */\r\n    public get memoryLayout(): BaseBufferMemoryLayout {\r\n        return this.mLayout;\r\n    }\r\n\r\n    /**\r\n     * Buffer size in bytes aligned to 4 bytes.\r\n     */\r\n    public get size(): number {\r\n        return ((this.mItemCount * this.mDataType.BYTES_PER_ELEMENT) + 3) & ~3;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - GPU.\r\n     * @param pLayout - Buffer layout.\r\n     * @param pInitialData  - Inital data. Can be empty. Or Buffer size. \r\n     */\r\n    public constructor(pDevice: GpuDevice, pLayout: BaseBufferMemoryLayout, pInitialData: TType | number) {\r\n        super(pDevice);\r\n        this.mLayout = pLayout;\r\n        this.mDataType = <BufferDataType<TType>>pInitialData.constructor;\r\n\r\n        // Set buffer initial data from buffer size or buffer data.\r\n        if(typeof pInitialData === 'number'){\r\n            this.mItemCount = pInitialData;\r\n        } else{\r\n            this.mItemCount =  pInitialData.length;\r\n            this.writeRaw(pInitialData, 0);\r\n        }\r\n\r\n        // Register change listener for layout changes.\r\n        pLayout.addUpdateListener(() => {\r\n            this.triggerAutoUpdate(UpdateReason.ChildData);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Read buffer on layout location.\r\n     * @param pLayoutPath - Layout path. \r\n     */\r\n    public async read(pLayoutPath: Array<string>): Promise<TType> {\r\n        const lLocation = this.mLayout.locationOf(pLayoutPath);\r\n        return this.readRaw(lLocation.offset, lLocation.size);\r\n    }\r\n\r\n    /**\r\n     * Read data raw without layout.\r\n     * @param pOffset - Data offset.\r\n     * @param pSize - Data size.\r\n     */\r\n    public async readRaw(pOffset?: number | undefined, pSize?: number | undefined): Promise<TType> {\r\n        const lOffset: number = pOffset ?? 0;\r\n        const lSize: number = pSize ?? this.size;\r\n\r\n        // Read data async\r\n        const lBufferGenerator = this.device.generator.request<'gpuBuffer'>(this);\r\n        return <TType>await lBufferGenerator.readRaw(lOffset, lSize);\r\n    }\r\n\r\n    /**\r\n     * Write data on layout location.\r\n     * @param pData - Data.\r\n     * @param pLayoutPath - Layout path.\r\n     */\r\n    public async write(pData: ArrayLike<number>, pLayoutPath: Array<string>): Promise<void> {\r\n        const lLocation = this.mLayout.locationOf(pLayoutPath);\r\n\r\n        // Skip new promise creation by returning original promise.\r\n        return this.writeRaw(pData, lLocation.offset);\r\n    }\r\n\r\n    /**\r\n     * Write data raw without layout.\r\n     * @param pData - Data.\r\n     * @param pOffset - Data offset.\r\n     */\r\n    public async writeRaw(pData: ArrayLike<number>, pOffset?: number | undefined): Promise<void> {\r\n        const lOffset: number = pOffset ?? 0;\r\n\r\n        // Write data async. Dont wait.\r\n        const lBufferGenerator = this.device.generator.request<'gpuBuffer'>(this);\r\n        lBufferGenerator.writeRaw(pData, lOffset, pData.length);\r\n    }\r\n}\r\n\r\ntype BufferDataType<T extends TypedArray> = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    BYTES_PER_ELEMENT: number;\r\n    new(pInitValues: ArrayBuffer | number | TypedArray): T;\r\n};","import { GpuDevice } from '../gpu/gpu-device';\r\nimport { GpuObject } from '../gpu/gpu-object';\r\nimport { RenderTargets } from '../pipeline/target/render-targets';\r\nimport { ComputeInstruction } from './instruction/compute-instruction';\r\nimport { IGpuInstruction } from './instruction/i-gpu-instruction.interface';\r\nimport { VertexFragmentInstruction } from './instruction/vertex-fragment-instruction';\r\n\r\nexport class InstructionExecuter extends GpuObject<'instructionExecutor'> {\r\n    private readonly mInstructionList: Array<IGpuInstruction>;\r\n\r\n    public constructor(pDevice: GpuDevice) {\r\n        super(pDevice);\r\n\r\n        this.mInstructionList = new Array<IGpuInstruction>();\r\n    }\r\n\r\n    /**\r\n     * Create and add new compute instruction\r\n     */\r\n    public createComputeInstruction(): ComputeInstruction {\r\n        // Create instruction.\r\n        const lInstruction: ComputeInstruction = new ComputeInstruction(this.device, this);\r\n\r\n        // Add instruction to instruction list.\r\n        this.mInstructionList.push(lInstruction);\r\n\r\n        return lInstruction;\r\n    }\r\n\r\n    /**\r\n     * Create and add new vertex fragment instruction\r\n     * @param pRenderTargets - Instruction render targets.\r\n     */\r\n    public createVertexFragmentInstruction(pRenderTargets: RenderTargets): VertexFragmentInstruction {\r\n        // Create instruction.\r\n        const lInstruction: VertexFragmentInstruction = new VertexFragmentInstruction(this.device, this, pRenderTargets);\r\n\r\n        // Add instruction to instruction list.\r\n        this.mInstructionList.push(lInstruction);\r\n\r\n        return lInstruction;\r\n    }\r\n\r\n    /**\r\n     * Execute all instructions on order.\r\n     */\r\n    public execute(): void {\r\n        const lInstructionExecutor = this.device.generator.request<'instructionExecutor'>(this);\r\n\r\n        // Start execution.\r\n        lInstructionExecutor.startExecution();\r\n\r\n        for (const lInstruction of this.mInstructionList) {\r\n            lInstruction.execute();\r\n        }\r\n\r\n        // End Execution.\r\n        lInstructionExecutor.endExecution();\r\n    }\r\n}","import { Exception } from '@kartoffelgames/core.data';\r\nimport { BindDataGroup } from '../../binding/bind-data-group';\r\nimport { GpuDevice } from '../../gpu/gpu-device';\r\nimport { GpuObject } from '../../gpu/gpu-object';\r\nimport { ComputePipeline } from '../../pipeline/compute-pipeline';\r\nimport { InstructionExecuter } from '../instruction-executor';\r\nimport { IGpuInstruction } from './i-gpu-instruction.interface';\r\n\r\nexport class ComputeInstruction extends GpuObject<'computeInstruction'> implements IGpuInstruction {\r\n    private readonly mExecutor: InstructionExecuter;\r\n    private readonly mStepList: Array<ComputeInstructionStep>;\r\n\r\n    /**\r\n     * Get executor.\r\n     */\r\n    public get executor(): InstructionExecuter {\r\n        return this.mExecutor;\r\n    }\r\n\r\n\r\n    /**\r\n     * Get all instruction steps.\r\n     */\r\n    public get steps(): Array<ComputeInstructionStep> {\r\n        return this.mStepList;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Device reference.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pExecutor: InstructionExecuter) {\r\n        super(pDevice);\r\n\r\n        this.mStepList = new Array<ComputeInstructionStep>();\r\n        this.mExecutor = pExecutor;\r\n    }\r\n\r\n    /**\r\n     * Add instruction step.\r\n     * @param pPipeline - Pipeline.\r\n     * @param pBindData -  Pipeline bind data.\r\n     */\r\n    public addStep(pPipeline: ComputePipeline, pBindData: Record<number, BindDataGroup>): void {\r\n        const lStep: ComputeInstructionStep = {\r\n            pipeline: pPipeline,\r\n            bindData: new Array<BindDataGroup | null>()\r\n        };\r\n\r\n        // Fill in data groups.\r\n        for (const lGroup of pPipeline.shader.pipelineLayout.groups) {\r\n            const lBindDataGroup: BindDataGroup | undefined = pBindData[lGroup];\r\n\r\n            // Validate bind data group.\r\n            if (!lBindDataGroup) {\r\n                throw new Exception('Defined bind data group not set.', this);\r\n            }\r\n\r\n            // Validate same layout bind layout.\r\n            const lBindGroupLayout = pPipeline.shader.pipelineLayout.getGroupLayout(lGroup);\r\n            if (lBindDataGroup.layout.identifier !== lBindGroupLayout.identifier) {\r\n                throw new Exception('Source bind group layout does not match target layout.', this);\r\n            }\r\n\r\n            lStep.bindData[lGroup] = pBindData[lGroup];\r\n        }\r\n\r\n        this.mStepList.push(lStep);\r\n    }\r\n\r\n    /**\r\n     * Execute instruction.\r\n     * @param pExecutor - Executor context.\r\n     */\r\n    public execute(): void {\r\n        this.device.generator.request<'computeInstruction'>(this).execute();\r\n    }\r\n}\r\n\r\ntype ComputeInstructionStep = {\r\n    pipeline: ComputePipeline;\r\n    bindData: Array<BindDataGroup | null>;\r\n};","import { Exception } from '@kartoffelgames/core.data';\r\nimport { BindDataGroup } from '../../binding/bind-data-group';\r\nimport { GpuDevice } from '../../gpu/gpu-device';\r\nimport { GpuObject } from '../../gpu/gpu-object';\r\nimport { VertexParameter } from '../../pipeline/parameter/vertex-parameter';\r\nimport { RenderTargets } from '../../pipeline/target/render-targets';\r\nimport { VertexFragmentPipeline } from '../../pipeline/vertex-fragment-pipeline';\r\nimport { InstructionExecuter } from '../instruction-executor';\r\nimport { IGpuInstruction } from './i-gpu-instruction.interface';\r\n\r\nexport class VertexFragmentInstruction extends GpuObject<'vertexFragmentInstruction'> implements IGpuInstruction {\r\n    private readonly mExecutor: InstructionExecuter;\r\n    private readonly mRenderTargets: RenderTargets;\r\n    private readonly mStepList: Array<VertexFragmentInstructionStep>;\r\n\r\n    /**\r\n     * Get executor.\r\n     */\r\n    public get executor(): InstructionExecuter {\r\n        return this.mExecutor;\r\n    }\r\n\r\n    /**\r\n     * Get instruction render target.\r\n     */\r\n    public get renderTargets(): RenderTargets {\r\n        return this.mRenderTargets;\r\n    }\r\n\r\n    /**\r\n     * Get all instruction steps.\r\n     */\r\n    public get steps(): Array<VertexFragmentInstructionStep> {\r\n        return this.mStepList;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Device reference.\r\n     * @param pRenderTargets - Render targets. \r\n     */\r\n    public constructor(pDevice: GpuDevice, pExecutor: InstructionExecuter, pRenderTargets: RenderTargets) {\r\n        super(pDevice);\r\n\r\n        this.mStepList = new Array<VertexFragmentInstructionStep>();\r\n        this.mRenderTargets = pRenderTargets;\r\n        this.mExecutor = pExecutor;\r\n    }\r\n\r\n    /**\r\n     * Add instruction step.\r\n     * @param pPipeline - Pipeline.\r\n     * @param pParameter - Pipeline parameter.\r\n     * @param pBindData - Pipline bind data groups.\r\n     * @param pInstanceCount - Instance count.\r\n     */\r\n    public addStep(pPipeline: VertexFragmentPipeline, pParameter: VertexParameter, pBindData: Record<number, BindDataGroup>, pInstanceCount: number = 1): void {\r\n        // Validate same render targets.\r\n        if (this.mRenderTargets !== pPipeline.renderTargets) {\r\n            throw new Exception('Instruction render pass not valid for instruction set.', this);\r\n        }\r\n\r\n        const lStep: VertexFragmentInstructionStep = {\r\n            pipeline: pPipeline,\r\n            parameter: pParameter,\r\n            instanceCount: pInstanceCount,\r\n            bindData: new Array<BindDataGroup | null>()\r\n        };\r\n\r\n        // Fill in data groups.\r\n        for (const lGroup of pPipeline.shader.pipelineLayout.groups) {\r\n            const lBindDataGroup: BindDataGroup | undefined = pBindData[lGroup];\r\n\r\n            // Validate bind data group.\r\n            if (!lBindDataGroup) {\r\n                throw new Exception('Defined bind data group not set.', this);\r\n            }\r\n\r\n            // Validate same layout bind layout.\r\n            const lBindGroupLayout = pPipeline.shader.pipelineLayout.getGroupLayout(lGroup);\r\n            if (lBindDataGroup.layout.identifier !== lBindGroupLayout.identifier) {\r\n                throw new Exception('Source bind group layout does not match target layout.', this);\r\n            }\r\n\r\n            lStep.bindData[lGroup] = pBindData[lGroup];\r\n        }\r\n\r\n        this.mStepList.push(lStep);\r\n    }\r\n\r\n    /**\r\n     * Execute instruction.\r\n     * @param pExecutor - Executor context.\r\n     */\r\n    public execute(): void {\r\n        this.device.generator.request<'vertexFragmentInstruction'>(this).execute();\r\n    }\r\n}\r\n\r\ntype VertexFragmentInstructionStep = {\r\n    pipeline: VertexFragmentPipeline;\r\n    parameter: VertexParameter;\r\n    instanceCount: number;\r\n    bindData: Array<BindDataGroup | null>;\r\n};","import { Dictionary, Exception, TypedArray } from '@kartoffelgames/core.data';\r\nimport { BindDataGroup } from '../binding/bind-data-group';\r\nimport { BindDataGroupLayout } from '../binding/bind-data-group-layout';\r\nimport { PipelineDataLayout } from '../binding/pipeline-data-layout';\r\nimport { GpuBuffer } from '../buffer/gpu-buffer';\r\nimport { GpuDevice } from '../gpu/gpu-device';\r\nimport { GpuObject } from '../gpu/gpu-object';\r\nimport { ComputePipeline } from '../pipeline/compute-pipeline';\r\nimport { RenderTargets } from '../pipeline/target/render-targets';\r\nimport { VertexFragmentPipeline } from '../pipeline/vertex-fragment-pipeline';\r\nimport { ComputeShader } from '../shader/compute-shader';\r\nimport { VertexFragmentShader } from '../shader/vertex-fragment-shader';\r\nimport { CanvasTexture } from '../texture/canvas-texture';\r\nimport { FrameBufferTexture } from '../texture/frame-buffer-texture';\r\nimport { ImageTexture } from '../texture/image-texture';\r\nimport { TextureSampler } from '../texture/texture-sampler';\r\nimport { VideoTexture } from '../texture/video-texture';\r\nimport { BaseNativeBufferGenerator } from './base-native-buffer-generator';\r\nimport { BaseNativeGenerator } from './base-native-generator';\r\nimport { ComputeInstruction } from '../execution/instruction/compute-instruction';\r\nimport { VertexFragmentInstruction } from '../execution/instruction/vertex-fragment-instruction';\r\nimport { BaseNativeInstructionGenerator } from './base-native-instruction-generator';\r\nimport { InstructionExecuter } from '../execution/instruction-executor';\r\nimport { BaseNativeInstructionExecutorGenerator } from './base-native-instruction-executor-generator';\r\n\r\nexport abstract class BaseGeneratorFactory<TGeneratorMap extends GeneratorNativeMap = GeneratorNativeMap> {\r\n    private mDevice: GpuDevice | null;\r\n    private readonly mGeneratorConstructors: Dictionary<ConstructorOf<GenerateableGpuObject>, ConstructorOf<NativeGenerator<TGeneratorMap>>>;\r\n    private readonly mGenerators: Dictionary<GenerateableGpuObject, NativeGenerator<TGeneratorMap>>;\r\n\r\n    public get device(): GpuDevice {\r\n        if (!this.mDevice) {\r\n            throw new Exception('Generator factory not initialized.', this);\r\n        }\r\n\r\n        return this.mDevice;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mGeneratorConstructors = new Dictionary<ConstructorOf<GenerateableGpuObject>, ConstructorOf<NativeGenerator<TGeneratorMap>>>();\r\n        this.mGenerators = new Dictionary<GenerateableGpuObject, NativeGenerator<TGeneratorMap>>();\r\n        this.mDevice = null;\r\n    }\r\n\r\n    /**\r\n     * Init factory with gpu device.\r\n     * @param pDevice - Gpu device.\r\n     */\r\n    public async init(pDevice: GpuDevice): Promise<this> {\r\n        // Set device.\r\n        this.mDevice = pDevice;\r\n\r\n        // Init internals.\r\n        await this.initInternals();\r\n\r\n        // Resolve with itself.\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Generate native.\r\n     * @param pType - Type name of base object.\r\n     * @param pBaseObject - Base gpu object.\r\n     */\r\n    public request<TKey extends GeneratorObjectKeys>(pBaseObject: GenerateableGpuObjectOf<TKey>): NativeGeneratorOf<TGeneratorMap, TKey> {\r\n        // Check for cached generator.\r\n        if (this.mGenerators.has(pBaseObject)) {\r\n            return <NativeGeneratorOf<TGeneratorMap, TKey>>this.mGenerators.get(pBaseObject)!;\r\n        }\r\n\r\n        // Get and validate generator function.\r\n        const lGeneratorConstructor = <ConstructorOf<NativeGeneratorOf<TGeneratorMap, TKey>> | undefined>this.mGeneratorConstructors.get(<any>pBaseObject.constructor);\r\n        if (!lGeneratorConstructor) {\r\n            // Currently only for 'none' Gpu objects or unset generators.\r\n            const lNullCache: null | any = null;\r\n\r\n            // Cache null.\r\n            this.mGenerators.set(pBaseObject, lNullCache);\r\n\r\n            return lNullCache;\r\n        }\r\n\r\n        // Create and cache generator.\r\n        const lGenerator: NativeGeneratorOf<TGeneratorMap, TKey> = new lGeneratorConstructor(pBaseObject);\r\n        this.mGenerators.set(pBaseObject, lGenerator);\r\n\r\n        return lGenerator;\r\n    }\r\n\r\n    /**\r\n     * Register an generatpr for this type.\r\n     * @param pType - Base gpu object type name.\r\n     * @param pGenerator - Generator for this type.\r\n     */\r\n    protected registerGenerator<TKey extends GeneratorObjectKeys>(pType: ConstructorOf<GenerateableGpuObjectOf<TKey>>, pGenerator: ConstructorOf<NativeGeneratorOf<TGeneratorMap, TKey>>): void {\r\n        if (this.mGeneratorConstructors.has(pType)) {\r\n            throw new Exception(`Generator already registed for \"${pType.name}\"`, this);\r\n        }\r\n\r\n        this.mGeneratorConstructors.set(pType, <ConstructorOf<NativeGenerator<TGeneratorMap>>>pGenerator);\r\n    }\r\n\r\n    /**\r\n     * Init factory internals.\r\n     */\r\n    protected abstract initInternals(): Promise<void>;\r\n}\r\n\r\n// Generator keys with optional 'none'\r\nexport type GeneratorObjectKeys = keyof GeneratorFactoryMap | 'none';\r\ntype GenerateableGpuObjectOf<TKey extends GeneratorObjectKeys> = TKey extends keyof GeneratorFactoryMap ? GeneratorFactoryMap[TKey]['gpuObject'] : GpuObject<'none'>;\r\ntype GenerateableGpuObject = GenerateableGpuObjectOf<GeneratorObjectKeys>;\r\ntype NativeGeneratorOf<TMap extends GeneratorNativeMap, TKey extends GeneratorObjectKeys> = TKey extends keyof GeneratorFactoryMap ? TMap['generators'][TKey]['generator'] : null;\r\ntype NativeGenerator<TMap extends GeneratorNativeMap> = NativeGeneratorOf<TMap, GeneratorObjectKeys>;\r\n\r\n// Constructor type.\r\ntype ConstructorOf<T> = new (...pArgs: Array<any>) => T;\r\n\r\n// Mapping of all base gpu objects.\r\nexport interface GeneratorFactoryMap {\r\n    // Textures.\r\n    textureSampler: {\r\n        gpuObject: TextureSampler;\r\n        generator: BaseNativeGenerator<GeneratorNativeMap, 'textureSampler'>;\r\n    };\r\n    imageTexture: {\r\n        gpuObject: ImageTexture;\r\n        generator: BaseNativeGenerator<GeneratorNativeMap, 'imageTexture'>;\r\n    };\r\n    frameBufferTexture: {\r\n        gpuObject: FrameBufferTexture;\r\n        generator: BaseNativeGenerator<GeneratorNativeMap, 'frameBufferTexture'>;\r\n    };\r\n    videoTexture: {\r\n        gpuObject: VideoTexture;\r\n        generator: BaseNativeGenerator<GeneratorNativeMap, 'videoTexture'>;\r\n    };\r\n    canvasTexture: {\r\n        gpuObject: CanvasTexture;\r\n        generator: BaseNativeGenerator<GeneratorNativeMap, 'canvasTexture'>;\r\n    };\r\n\r\n    // Things with generics. :(\r\n    gpuBuffer: {\r\n        gpuObject: GpuBuffer<TypedArray>;\r\n        generator: BaseNativeBufferGenerator<GeneratorNativeMap, 'gpuBuffer'>;\r\n    };\r\n\r\n    // Pipeline layouting.\r\n    bindDataGroupLayout: {\r\n        gpuObject: BindDataGroupLayout;\r\n        generator: BaseNativeGenerator<GeneratorNativeMap, 'bindDataGroupLayout'>;\r\n    };\r\n    bindDataGroup: {\r\n        gpuObject: BindDataGroup;\r\n        generator: BaseNativeGenerator<GeneratorNativeMap, 'bindDataGroup'>;\r\n    };\r\n    pipelineDataLayout: {\r\n        gpuObject: PipelineDataLayout;\r\n        generator: BaseNativeGenerator<GeneratorNativeMap, 'pipelineDataLayout'>;\r\n    };\r\n    renderTargets: {\r\n        gpuObject: RenderTargets;\r\n        generator: BaseNativeGenerator<GeneratorNativeMap, 'renderTargets'>;\r\n    };\r\n\r\n    // Pipelines.\r\n    vertexFragmentPipeline: {\r\n        gpuObject: VertexFragmentPipeline;\r\n        generator: BaseNativeGenerator<GeneratorNativeMap, 'vertexFragmentPipeline'>;\r\n    };\r\n    computePipeline: {\r\n        gpuObject: ComputePipeline;\r\n        generator: BaseNativeGenerator<GeneratorNativeMap, 'computePipeline'>;\r\n    };\r\n\r\n    // Shader.\r\n    vertexFragmentShader: {\r\n        gpuObject: VertexFragmentShader;\r\n        generator: BaseNativeGenerator<GeneratorNativeMap, 'vertexFragmentShader'>;\r\n    };\r\n    computeShader: {\r\n        gpuObject: ComputeShader;\r\n        generator: BaseNativeGenerator<GeneratorNativeMap, 'computeShader'>;\r\n    };\r\n\r\n    // Execution.\r\n    computeInstruction: {\r\n        gpuObject: ComputeInstruction;\r\n        generator: BaseNativeInstructionGenerator<GeneratorNativeMap, 'computeInstruction'>;\r\n    };\r\n    vertexFragmentInstruction: {\r\n        gpuObject: VertexFragmentInstruction;\r\n        generator: BaseNativeInstructionGenerator<GeneratorNativeMap, 'vertexFragmentInstruction'>;\r\n    };\r\n    instructionExecutor: {\r\n        gpuObject: InstructionExecuter;\r\n        generator: BaseNativeInstructionExecutorGenerator<GeneratorNativeMap, 'instructionExecutor'>;\r\n    }\r\n}\r\n\r\n// Same type but without undefined behavior.\r\nexport interface GeneratorNativeMap {\r\n    factory: BaseGeneratorFactory<GeneratorNativeMap>;\r\n    generators: {\r\n        [Property in keyof GeneratorFactoryMap]: {\r\n            generator: GeneratorFactoryMap[Property]['generator'];\r\n            native: any;\r\n        }\r\n    };\r\n}","import { TypedArray } from '@kartoffelgames/core.data';\r\nimport { GeneratorFactoryMap, GeneratorNativeMap } from './base-generator-factory';\r\nimport { BaseNativeGenerator } from './base-native-generator';\r\n\r\nexport abstract class BaseNativeBufferGenerator<TMap extends GeneratorNativeMap, TGeneratorKey extends keyof GeneratorFactoryMap> extends BaseNativeGenerator<TMap, TGeneratorKey> {\r\n    /**\r\n     * Read data raw from native buffer.\r\n     * @param pOffset - Read offset.\r\n     * @param pSize - Read size.\r\n     */\r\n    public abstract readRaw(pOffset: number, pSize: number): Promise<TypedArray>;\r\n\r\n    /**\r\n     * Write data raw without layout.\r\n     * @param pData - Data.\r\n     * @param pOffset - Data offset.\r\n     * @param pSize - Data size.\r\n     */\r\n    public abstract writeRaw(pData: ArrayLike<number>, pOffset: number, pSize: number | undefined): Promise<void>;\r\n}","import { GpuObjectUpdateReason, UpdateReason } from '../gpu/gpu-object-update-reason';\r\nimport { GeneratorFactoryMap, GeneratorNativeMap } from './base-generator-factory';\r\n\r\nexport abstract class BaseNativeGenerator<TMap extends GeneratorNativeMap, TGeneratorKey extends keyof GeneratorFactoryMap> {\r\n    private readonly mFactory: TMap['factory'];\r\n    private readonly mGpuObject: GeneratorFactoryMap[TGeneratorKey]['gpuObject'];\r\n    private mLastGeneratedFrame: number;\r\n    private mNative: TMap['generators'][TGeneratorKey]['native'] | null;\r\n    private readonly mUpdateReasons: GpuObjectUpdateReason;\r\n\r\n    /**\r\n     * Life time of native object.\r\n     */\r\n    protected abstract nativeLifeTime: NativeObjectLifeTime;\r\n\r\n    /**\r\n     * Generator factory.\r\n     */\r\n    protected get factory(): TMap['factory'] {\r\n        return this.mFactory;\r\n    }\r\n\r\n    /**\r\n     * Get base object of generator.\r\n     */\r\n    protected get gpuObject(): GeneratorFactoryMap[TGeneratorKey]['gpuObject'] {\r\n        return this.mGpuObject;\r\n    }\r\n\r\n    /**\r\n     * Get generator update reasons.\r\n     */\r\n    protected get updateReasons(): GpuObjectUpdateReason {\r\n        return this.mUpdateReasons;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pBaseObject - Base object containing all values.\r\n     * @param pGeneratorFactory - Generator factory.\r\n     */\r\n    public constructor(pFactory: TMap['factory'], pBaseObject: TGeneratorKey extends keyof GeneratorFactoryMap ? GeneratorFactoryMap[TGeneratorKey]['gpuObject'] : never) {\r\n        this.mFactory = pFactory;\r\n        this.mGpuObject = pBaseObject;\r\n        this.mNative = null;\r\n        this.mLastGeneratedFrame = 0;\r\n        this.mUpdateReasons = new GpuObjectUpdateReason();\r\n    }\r\n\r\n    /**\r\n     * Generate native gpu object from base.\r\n     */\r\n    public create(): TMap['generators'][TGeneratorKey]['native'] {\r\n        // Validate life time.\r\n        switch (this.nativeLifeTime) {\r\n            case NativeObjectLifeTime.Persistent: {\r\n                // Do nothing.\r\n                break;\r\n            }\r\n            case NativeObjectLifeTime.Single: {\r\n                // Invalidate every time.\r\n                this.invalidate(UpdateReason.LifeTime);\r\n                break;\r\n            }\r\n            case NativeObjectLifeTime.Frame: {\r\n                // Invalidate on different frame till last generated.\r\n                if (this.factory.device.frameCount !== this.mLastGeneratedFrame) {\r\n                    this.invalidate(UpdateReason.LifeTime);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Clear and destroy old native when any update reason exists.\r\n        if (this.mNative !== null && this.mUpdateReasons.any()) {\r\n            this.destroy(this.mNative);\r\n            this.mNative = null;\r\n        }\r\n\r\n        // Generate new native when not already generated.\r\n        if (this.mNative === null) {\r\n            this.mNative = this.generate();\r\n            this.mLastGeneratedFrame = this.factory.device.frameCount;\r\n\r\n            // Reset all update reasons.\r\n            this.mUpdateReasons.clear();\r\n        }\r\n\r\n        return this.mNative;\r\n    }\r\n\r\n    /**\r\n     * Invalidate and destroy generated native.\r\n     */\r\n    public invalidate(pDestroyReason: UpdateReason): void {\r\n        // Add update reason.\r\n        this.mUpdateReasons.add(pDestroyReason);\r\n    }\r\n\r\n    /**\r\n     * Destroy generated native.\r\n     * @param _pNative - Generated native.\r\n     * @param _pDestroyReason - Reason why the native should be destroyed.\r\n     */\r\n    protected destroy(_pNative: TMap['generators'][TGeneratorKey]['native']): void {\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Generate native gpu object.\r\n     * @param pUpdateReason - Reason why the native should be updated.\r\n     */\r\n    protected abstract generate(): TMap['generators'][TGeneratorKey]['native'];\r\n}\r\n\r\nexport enum NativeObjectLifeTime {\r\n    Persistent = 0,\r\n    Frame = 1,\r\n    Single = 2\r\n}","import { InstructionExecuter } from '../execution/instruction-executor';\r\nimport { BaseGeneratorFactory } from '../generator/base-generator-factory';\r\nimport { TextureGroup } from '../pipeline/target/texture-group';\r\nimport { ShaderInterpreterConstructor, ShaderInterpreterFactory } from '../shader/interpreter/shader-interpreter-factory';\r\nimport { VertexFragmentShader } from '../shader/vertex-fragment-shader';\r\n\r\nexport class GpuDevice {\r\n    /**\r\n     * Request new gpu device.\r\n     * @param pGenerator - Native object generator.\r\n     */\r\n    public static async request(pGenerator: BaseGeneratorFactory, pShaderInterpreter: ShaderInterpreterConstructor): Promise<GpuDevice> {\r\n        // Construct gpu device.\r\n        const lDevice: GpuDevice = new GpuDevice(pGenerator, pShaderInterpreter);\r\n\r\n        // Init generator with created device.\r\n        await pGenerator.init(lDevice);\r\n\r\n        return lDevice;\r\n    }\r\n\r\n    private mFrameCounter: number;\r\n    private readonly mGenerator: BaseGeneratorFactory;\r\n    private readonly mShaderInterpreter: ShaderInterpreterFactory;\r\n\r\n    /**\r\n     * Get frame count.\r\n     */\r\n    public get frameCount(): number {\r\n        return this.mFrameCounter;\r\n    }\r\n\r\n    /**\r\n     * Native object generator.\r\n     */\r\n    public get generator(): BaseGeneratorFactory {\r\n        return this.mGenerator;\r\n    }\r\n\r\n    /**\r\n     * Shader interpreter.\r\n     */\r\n    public get shaderInterpreter(): ShaderInterpreterFactory {\r\n        return this.mShaderInterpreter;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pGenerator - Native GPU-Object Generator.\r\n     */\r\n    private constructor(pGenerator: BaseGeneratorFactory, pShaderInterpreter: ShaderInterpreterConstructor) {\r\n        this.mFrameCounter = 0;\r\n        this.mGenerator = pGenerator;\r\n        this.mShaderInterpreter = new ShaderInterpreterFactory(this, pShaderInterpreter);\r\n    }\r\n\r\n    /**\r\n     * Create instruction executor.\r\n     */\r\n    public instructionExecutor(): InstructionExecuter {\r\n        return new InstructionExecuter(this);\r\n    }\r\n\r\n    /**\r\n     * Create shader.\r\n     * @param pSource - Shader source.\r\n     * @param pVertexEntry - Vertex entry name.\r\n     * @param pFragmentEntry - Optional fragment entry.\r\n     */\r\n    public renderShader(pSource: string, pVertexEntry: string, pFragmentEntry?: string): VertexFragmentShader {\r\n        return new VertexFragmentShader(this, pSource, pVertexEntry, pFragmentEntry);\r\n    }\r\n\r\n    /**\r\n     * Start new frame.\r\n     */\r\n    public startNewFrame(): void {\r\n        this.mFrameCounter++;\r\n    }\r\n\r\n    /**\r\n     * Create texture group that shares the same dimensions.\r\n     * @param pWidth - Texture width.\r\n     * @param pHeight - Texture height.\r\n     * @param pMultisampleLevel - Multisample level of textures.\r\n     */\r\n    public textureGroup(pWidth: number, pHeight: number, pMultisampleLevel: number = 1): TextureGroup {\r\n        return new TextureGroup(this, pWidth, pHeight, pMultisampleLevel);\r\n    }\r\n}","export class GpuObjectUpdateReason {\r\n    private readonly mReasons: Set<UpdateReason>;\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mReasons = new Set<UpdateReason>();\r\n    }\r\n\r\n    /**\r\n     * Add update reason.\r\n     * @param pReason - Update reason.\r\n     */\r\n    public add(pReason: UpdateReason): void {\r\n        this.mReasons.add(pReason);\r\n    }\r\n\r\n    /**\r\n     * If update reason has any existing reason.\r\n     */\r\n    public any(): boolean {\r\n        return this.mReasons.size > 0;\r\n    }\r\n\r\n    /**\r\n     * Clear all reasons.\r\n     */\r\n    public clear(): void {\r\n        this.mReasons.clear();\r\n    }\r\n\r\n    /**\r\n     * Check for update reason.\r\n     * @param pReason - Update reason.\r\n     */\r\n    public has(pReason: UpdateReason): boolean {\r\n        return this.mReasons.has(pReason);\r\n    }\r\n}\r\n\r\nexport enum UpdateReason {\r\n    Setting = 1,\r\n    Data = 2,\r\n    ChildData = 3,\r\n    LifeTime = 4\r\n}","import { GeneratorObjectKeys } from '../generator/base-generator-factory';\r\nimport { GpuDevice } from './gpu-device';\r\nimport { UpdateReason } from './gpu-object-update-reason';\r\n\r\nexport abstract class GpuObject<TGpuObjectKey extends GeneratorObjectKeys = 'none'> {\r\n    private mAutoUpdate: boolean;\r\n    private readonly mDevice: GpuDevice;\r\n    private readonly mUpdateListenerList: Set<GpuObjectUpdateListener>;\r\n\r\n    /**\r\n     * Enable or disable auto update.\r\n     */\r\n    public get autoUpdate(): boolean {\r\n        return this.mAutoUpdate;\r\n    } set autoUpdate(pValue: boolean) {\r\n        this.mAutoUpdate = pValue;\r\n    }\r\n\r\n    /**\r\n     * Gpu Device.\r\n     */\r\n    protected get device(): GpuDevice {\r\n        return this.mDevice;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Gpu device.\r\n     */\r\n    public constructor(pDevice: GpuDevice) {\r\n        this.mAutoUpdate = true;\r\n        this.mDevice = pDevice;\r\n        this.mUpdateListenerList = new Set<GpuObjectUpdateListener>();\r\n    }\r\n\r\n    /**\r\n     * Add update listener.\r\n     * @param pListener - Listener.\r\n     */\r\n    public addUpdateListener(pListener: GpuObjectUpdateListener): void {\r\n        this.mUpdateListenerList.add(pListener);\r\n    }\r\n\r\n    /**\r\n     * Add update listener.\r\n     * @param pListener - Listener.\r\n     */\r\n    public removeUpdateListener(pListener: GpuObjectUpdateListener): void {\r\n        this.mUpdateListenerList.delete(pListener);\r\n    }\r\n\r\n    /**\r\n     * Update gpu object.\r\n     */\r\n    public update(pUpdateReason: UpdateReason): void {\r\n        // Invalidate before calling parent listener. Only when a generator exists.\r\n        const lGenerator = this.device.generator.request<TGpuObjectKey>(<any>this);\r\n        if (lGenerator) {\r\n            lGenerator.invalidate(pUpdateReason);\r\n        }\r\n\r\n        // Call parent update listerner.\r\n        for (const lUpdateListener of this.mUpdateListenerList) {\r\n            lUpdateListener();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger auto update.\r\n     * Does nothing on disabled auto update.\r\n     */\r\n    protected triggerAutoUpdate(pUpdateReason: UpdateReason): void {\r\n        if (this.mAutoUpdate) {\r\n            this.update(pUpdateReason);\r\n        }\r\n    }\r\n}\r\n\r\nexport type GpuObjectUpdateListener = () => void;","import { Exception } from '@kartoffelgames/core.data';\r\nimport { GpuBuffer } from '../../../buffer/gpu-buffer';\r\nimport { BaseNativeGenerator, NativeObjectLifeTime } from '../../../generator/base-native-generator';\r\nimport { CanvasTexture } from '../../../texture/canvas-texture';\r\nimport { FrameBufferTexture } from '../../../texture/frame-buffer-texture';\r\nimport { ImageTexture } from '../../../texture/image-texture';\r\nimport { TextureSampler } from '../../../texture/texture-sampler';\r\nimport { VideoTexture } from '../../../texture/video-texture';\r\nimport { NativeWebGpuMap } from '../web-gpu-generator-factory';\r\n\r\nexport class WebGpuBindDataGroupGenerator extends BaseNativeGenerator<NativeWebGpuMap, 'bindDataGroup'> {\r\n    /**\r\n     * Set life time of generated native.\r\n     */\r\n    protected override get nativeLifeTime(): NativeObjectLifeTime {\r\n        return NativeObjectLifeTime.Persistent;\r\n    }\r\n\r\n    /**\r\n     * Generate native gpu bind data group.\r\n     */\r\n    protected override generate(): GPUBindGroup {\r\n        const lEntryList: Array<GPUBindGroupEntry> = new Array<GPUBindGroupEntry>();\r\n\r\n        for (const lBindname of this.gpuObject.layout.bindingNames) {\r\n            const lBindLayout = this.gpuObject.layout.getBind(lBindname);\r\n            const lBindData = this.gpuObject.getData(lBindname);\r\n\r\n            // Set resource to group entry for each \r\n            const lGroupEntry: GPUBindGroupEntry = { binding: lBindLayout.index, resource: <any>null };\r\n\r\n            // Buffer bind.\r\n            if (lBindData instanceof GpuBuffer) {\r\n                lGroupEntry.resource = { buffer: this.factory.request<'gpuBuffer'>(lBindData).create() };\r\n\r\n                lEntryList.push(lGroupEntry);\r\n                continue;\r\n            }\r\n\r\n            // External/Video texture bind\r\n            if (lBindData instanceof VideoTexture) {\r\n                lGroupEntry.resource = this.factory.request<'videoTexture'>(lBindData).create();\r\n\r\n                lEntryList.push(lGroupEntry);\r\n                continue;\r\n            }\r\n\r\n            // Sampler bind\r\n            if (lBindData instanceof TextureSampler) {\r\n                lGroupEntry.resource = this.factory.request<'textureSampler'>(lBindData).create();\r\n                lEntryList.push(lGroupEntry);\r\n                continue;\r\n            }\r\n\r\n            // Frame buffer bind.\r\n            if (lBindData instanceof FrameBufferTexture) {\r\n                lGroupEntry.resource = this.factory.request<'frameBufferTexture'>(lBindData).create();\r\n\r\n                lEntryList.push(lGroupEntry);\r\n                continue;\r\n            }\r\n\r\n            // Image texture bind.\r\n            if (lBindData instanceof ImageTexture) {\r\n                lGroupEntry.resource = this.factory.request<'imageTexture'>(lBindData).create();\r\n\r\n                lEntryList.push(lGroupEntry);\r\n                continue;\r\n            }\r\n\r\n            // Canvas texture bind.\r\n            if (lBindData instanceof CanvasTexture) {\r\n                lGroupEntry.resource = this.factory.request<'canvasTexture'>(lBindData).create();\r\n\r\n                lEntryList.push(lGroupEntry);\r\n                continue;\r\n            }\r\n\r\n            throw new Exception(`Bind type for \"${lBindData}\" not supported`, this);\r\n        }\r\n\r\n        return this.factory.gpu.createBindGroup({\r\n            label: 'Bind-Group',\r\n            layout: this.factory.request<'bindDataGroupLayout'>(this.gpuObject.layout).create(),\r\n            entries: lEntryList\r\n        });\r\n    }\r\n}","import { Exception } from '@kartoffelgames/core.data';\r\nimport { AccessMode } from '../../../../constant/access-mode.enum';\r\nimport { BufferBindType } from '../../../../constant/buffer-bind-type.enum';\r\nimport { SamplerType } from '../../../../constant/sampler-type.enum';\r\nimport { TextureBindType } from '../../../../constant/texture-bind-type.enum';\r\nimport { BaseNativeGenerator, NativeObjectLifeTime } from '../../../generator/base-native-generator';\r\nimport { BaseBufferMemoryLayout } from '../../../memory_layout/buffer/base-buffer-memory-layout';\r\nimport { SamplerMemoryLayout } from '../../../memory_layout/sampler-memory-layout';\r\nimport { TextureMemoryLayout } from '../../../memory_layout/texture-memory-layout';\r\nimport { NativeWebGpuMap } from '../web-gpu-generator-factory';\r\n\r\nexport class WebGpuBindDataGroupLayoutGenerator extends BaseNativeGenerator<NativeWebGpuMap,'bindDataGroupLayout'>  {\r\n    /**\r\n     * Set life time of generated native.\r\n     */\r\n    protected override get nativeLifeTime(): NativeObjectLifeTime {\r\n        return NativeObjectLifeTime.Persistent;\r\n    }\r\n\r\n    /**\r\n     * Generate native bind data group layout object.\r\n     */\r\n    protected override generate(): GPUBindGroupLayout {\r\n        const lEntryList: Array<GPUBindGroupLayoutEntry> = new Array<GPUBindGroupLayoutEntry>();\r\n\r\n        // Generate layout entry for each binding.\r\n        for (const lEntry of this.gpuObject.bindings) {\r\n            // Generate default properties.\r\n            const lLayoutEntry: GPUBindGroupLayoutEntry = {\r\n                visibility: lEntry.layout.visibility,\r\n                binding: lEntry.index\r\n            };\r\n\r\n            // Buffer layouts.\r\n            if (lEntry.layout instanceof BaseBufferMemoryLayout) {\r\n                let lBufferBindingType: GPUBufferBindingType;\r\n                switch (lEntry.layout.bindType) {\r\n                    case BufferBindType.Uniform: {\r\n                        lBufferBindingType = 'uniform';\r\n                        break;\r\n                    }\r\n                    case BufferBindType.Storage: {\r\n                        // Read only access. No bit compare.\r\n                        if (lEntry.layout.accessMode === AccessMode.Read) {\r\n                            lBufferBindingType = 'read-only-storage';\r\n                        } else {\r\n                            lBufferBindingType = 'storage';\r\n                        }\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        throw new Exception('Can only bind buffers of bind type storage or uniform.', this);\r\n                    }\r\n                }\r\n\r\n                // Create buffer layout with all optional values.\r\n                const lBufferLayout: Required<GPUBufferBindingLayout> = {\r\n                    type: lBufferBindingType,\r\n                    minBindingSize: 0,\r\n                    hasDynamicOffset: false\r\n                };\r\n                lLayoutEntry.buffer = lBufferLayout;\r\n\r\n                // Add buffer layout entry to bindings.\r\n                lEntryList.push(lLayoutEntry);\r\n\r\n                continue;\r\n            }\r\n\r\n            // Sampler layouts.\r\n            if (lEntry.layout instanceof SamplerMemoryLayout) {\r\n                let lSamplerBindingType: GPUSamplerBindingType;\r\n                switch (lEntry.layout.samplerType) {\r\n                    case SamplerType.Comparison: {\r\n                        lSamplerBindingType = 'comparison';\r\n                        break;\r\n                    }\r\n                    case SamplerType.Filter: {\r\n                        lSamplerBindingType = 'filtering';\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // Create sampler layout with all optional values.\r\n                const lSamplerLayout: Required<GPUSamplerBindingLayout> = {\r\n                    type: lSamplerBindingType\r\n                };\r\n                lLayoutEntry.sampler = lSamplerLayout;\r\n\r\n                // Add sampler layout entry to bindings.\r\n                lEntryList.push(lLayoutEntry);\r\n\r\n                continue;\r\n            }\r\n\r\n            // Texture layouts.\r\n            if (lEntry.layout instanceof TextureMemoryLayout) {\r\n                switch (lEntry.layout.bindType) {\r\n                    case TextureBindType.External: {\r\n                        if (lEntry.layout.accessMode !== AccessMode.Read) {\r\n                            throw new Exception('External textures must have access mode read.', this);\r\n                        }\r\n\r\n                        const lExternalTextureLayout: Required<GPUExternalTextureBindingLayout> = {};\r\n                        lLayoutEntry.externalTexture = lExternalTextureLayout;\r\n                        break;\r\n                    }\r\n                    case TextureBindType.Images: {\r\n                        if (lEntry.layout.accessMode !== AccessMode.Read) {\r\n                            throw new Exception('Image textures must have access mode read.', this);\r\n                        }\r\n\r\n                        const lTextureLayout: Required<GPUTextureBindingLayout> = {\r\n                            sampleType: this.factory.sampleTypeFromLayout(lEntry.layout),\r\n                            multisampled: lEntry.layout.multisampled,\r\n                            viewDimension: lEntry.layout.dimension\r\n                        };\r\n                        lLayoutEntry.texture = lTextureLayout;\r\n                        break;\r\n                    }\r\n                    case TextureBindType.Storage: {\r\n                        if (lEntry.layout.accessMode !== AccessMode.Write) {\r\n                            throw new Exception('Storage textures must have access mode write.', this);\r\n                        }\r\n\r\n                        const lStorageTextureLayout: Required<GPUStorageTextureBindingLayout> = {\r\n                            access: 'write-only',\r\n                            format: this.factory.formatFromLayout(lEntry.layout),\r\n                            viewDimension: lEntry.layout.dimension\r\n                        };\r\n                        lLayoutEntry.storageTexture = lStorageTextureLayout;\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        throw new Exception('Cant bind attachment textures.', this);\r\n                    }\r\n                }\r\n\r\n                lEntryList.push(lLayoutEntry);\r\n            }\r\n\r\n            lEntryList.push(lLayoutEntry);\r\n        }\r\n\r\n        // Create binding group layout.\r\n        return this.factory.gpu.createBindGroupLayout({\r\n            label: 'Bind-Group-Layout',\r\n            entries: lEntryList\r\n        });\r\n    }\r\n}","import { BaseNativeGenerator, NativeObjectLifeTime } from '../../../generator/base-native-generator';\r\nimport { UpdateReason } from '../../../gpu/gpu-object-update-reason';\r\nimport { CanvasTexture } from '../../../texture/canvas-texture';\r\nimport { NativeWebGpuMap, WebGpuGeneratorFactory } from '../web-gpu-generator-factory';\r\n\r\nexport class WebGpuCanvasTextureGenerator extends BaseNativeGenerator<NativeWebGpuMap, 'canvasTexture'> {\r\n    private mContext: GPUCanvasContext | null;\r\n\r\n    /**\r\n     * Set life time of generated native.\r\n     */\r\n    protected override get nativeLifeTime(): NativeObjectLifeTime {\r\n        return NativeObjectLifeTime.Frame;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pBaseObject - Base object containing all values.\r\n     * @param pGeneratorFactory - Generator factory.\r\n     */\r\n    public constructor(pFactory: WebGpuGeneratorFactory, pBaseObject: CanvasTexture) {\r\n        super(pFactory, pBaseObject);\r\n\r\n        this.mContext = null;\r\n    }\r\n\r\n    /**\r\n     * Destory texture object.\r\n     * @param _pNativeObject - Native canvas texture.\r\n     */\r\n    protected override destroy(_pNativeObject: GPUTextureView): void {\r\n        // Only destroy context when child data/layout has changes.\r\n        if (this.updateReasons.has(UpdateReason.ChildData)) {\r\n            // Destory context.\r\n            this.mContext?.unconfigure();\r\n            this.mContext = null;\r\n        }\r\n\r\n        // Nothing else to destroy.\r\n    }\r\n\r\n    /**\r\n     * Generate native canvas texture view.\r\n     */\r\n    protected override generate(): GPUTextureView {\r\n        // Configure context.\r\n        if (!this.mContext) {\r\n            // Create and configure canvas context.\r\n            this.mContext = this.gpuObject.canvas.getContext('webgpu')!;\r\n            this.mContext.configure({\r\n                device: this.factory.gpu,\r\n                format: this.factory.formatFromLayout(this.gpuObject.memoryLayout),\r\n                usage: this.factory.usageFromLayout(this.gpuObject.memoryLayout),\r\n                alphaMode: 'opaque'\r\n            });\r\n        }\r\n\r\n        // Create texture and save it for destorying later.\r\n        const lTexture: GPUTexture = this.mContext.getCurrentTexture();\r\n\r\n        // TODO: View descriptor.\r\n        return lTexture.createView();\r\n    }\r\n}","import { BaseNativeGenerator, NativeObjectLifeTime } from '../../../generator/base-native-generator';\r\nimport { FrameBufferTexture } from '../../../texture/frame-buffer-texture';\r\nimport { NativeWebGpuMap, WebGpuGeneratorFactory } from '../web-gpu-generator-factory';\r\n\r\nexport class WebGpuFramebufferTextureGenerator extends BaseNativeGenerator<NativeWebGpuMap, 'frameBufferTexture'> {\r\n    private mTexture: GPUTexture | null;\r\n\r\n    /**\r\n     * Set life time of generated native.\r\n     */\r\n    protected override get nativeLifeTime(): NativeObjectLifeTime {\r\n        return NativeObjectLifeTime.Frame;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pBaseObject - Base object containing all values.\r\n     * @param pGeneratorFactory - Generator factory.\r\n     */\r\n    public constructor(pFactory: WebGpuGeneratorFactory, pBaseObject: FrameBufferTexture) {\r\n        super(pFactory, pBaseObject);\r\n\r\n        this.mTexture = null;\r\n    }\r\n\r\n    /**\r\n     * Destory texture object.\r\n     * @param _pNativeObject - Native canvas texture.\r\n     */\r\n    protected override destroy(_pNativeObject: GPUTextureView): void {\r\n        this.mTexture?.destroy();\r\n        this.mTexture = null;\r\n    }\r\n\r\n    /**\r\n     * Generate native canvas texture view.\r\n     */\r\n    protected override generate(): GPUTextureView {\r\n        // Configure context.\r\n        if (!this.mTexture) {\r\n            // Create and configure canvas context.\r\n            this.mTexture = this.factory.gpu.createTexture({\r\n                label: 'Frame-Buffer-Texture',\r\n                size: [this.gpuObject.width, this.gpuObject.height, this.gpuObject.depth],\r\n                format: this.factory.formatFromLayout(this.gpuObject.memoryLayout),\r\n                usage: this.factory.usageFromLayout(this.gpuObject.memoryLayout),\r\n                dimension: this.factory.dimensionFromLayout(this.gpuObject.memoryLayout),\r\n                sampleCount: this.gpuObject.multiSampleLevel\r\n            });\r\n        }\r\n\r\n        // TODO: View descriptor.\r\n        return this.mTexture.createView();\r\n    }\r\n}","import { TypedArray } from '@kartoffelgames/core.data';\r\nimport { BaseNativeBufferGenerator } from '../../../generator/base-native-buffer-generator';\r\nimport { NativeObjectLifeTime } from '../../../generator/base-native-generator';\r\nimport { NativeWebGpuMap, WebGpuGeneratorFactory } from '../web-gpu-generator-factory';\r\nimport { GpuBuffer } from '../../../buffer/gpu-buffer';\r\nimport { BufferBindType } from '../../../../constant/buffer-bind-type.enum';\r\nimport { MemoryCopyType } from '../../../../constant/memory-copy-type.enum';\r\n\r\nexport class WebGpuGpuBufferGenerator extends BaseNativeBufferGenerator<NativeWebGpuMap, 'gpuBuffer'> {\r\n    private readonly mReadyBufferList: Array<GPUBuffer>;\r\n    private readonly mWavingBufferList: Array<GPUBuffer>;\r\n\r\n    /**\r\n     * Set life time of generated native.\r\n     */\r\n    protected override get nativeLifeTime(): NativeObjectLifeTime {\r\n        return NativeObjectLifeTime.Persistent;\r\n    }\r\n\r\n    public constructor(pFactory: WebGpuGeneratorFactory, pBaseObject: GpuBuffer<TypedArray>) {\r\n        super(pFactory, pBaseObject);\r\n\r\n        // Waving buffer list.\r\n        this.mReadyBufferList = new Array<GPUBuffer>();\r\n        this.mWavingBufferList = new Array<GPUBuffer>();\r\n    }\r\n\r\n    /**\r\n     * Read raw buffer data.\r\n     * @param pOffset - Data read offset.\r\n     * @param pSize - Data read size.\r\n     */\r\n    public override async readRaw(pOffset: number, pSize: number): Promise<TypedArray> {\r\n        // Get buffer and map data.\r\n        const lBuffer: GPUBuffer = this.create();\r\n        await lBuffer.mapAsync(GPUMapMode.READ, pOffset, pSize);\r\n\r\n        // Get mapped data and force it into typed array.\r\n        const lData = new this.gpuObject.dataType(lBuffer.getMappedRange());\r\n        return lData;\r\n    }\r\n\r\n    /**\r\n     * Write data raw.\r\n     * @param pData - Data.\r\n     * @param pOffset - Data offset.\r\n     * @param pSize - Data size.\r\n     */\r\n    public override async writeRaw(pData: ArrayLike<number>, pOffset: number, pSize: number): Promise<void> {\r\n        // Create new buffer when no mapped buffer is available. \r\n        let lStagingBuffer: GPUBuffer;\r\n        if (this.mReadyBufferList.length === 0) {\r\n            lStagingBuffer = this.factory.gpu.createBuffer({\r\n                label: `RingBuffer-WaveBuffer-${this.mWavingBufferList.length}`,\r\n                size: this.gpuObject.size,\r\n                usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,\r\n                mappedAtCreation: true,\r\n            });\r\n\r\n            // Add new buffer to complete list.\r\n            this.mWavingBufferList.push(lStagingBuffer);\r\n        } else {\r\n            lStagingBuffer = this.mReadyBufferList.pop()!;\r\n        }\r\n\r\n        // Execute write operations.\r\n        const lBufferArray: TypedArray = new this.gpuObject.dataType(lStagingBuffer.getMappedRange(pOffset, pSize));\r\n        lBufferArray.set(pData);\r\n\r\n        // Unmap for copying data.\r\n        lStagingBuffer.unmap();\r\n\r\n        // Copy buffer data from staging into wavig buffer.\r\n        const lCommandDecoder: GPUCommandEncoder = this.factory.gpu.createCommandEncoder();\r\n        lCommandDecoder.copyBufferToBuffer(lStagingBuffer, 0, this.create(), 0, this.gpuObject.size);\r\n        this.factory.gpu.queue.submit([lCommandDecoder.finish()]);\r\n\r\n        // Shedule staging buffer remaping.\r\n        lStagingBuffer.mapAsync(GPUMapMode.WRITE).then(() => {\r\n            this.mReadyBufferList.push(lStagingBuffer);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Destroy wave and ready buffer.\r\n     */\r\n    protected override destroy(pNativeObject: GPUBuffer): void {\r\n        pNativeObject.destroy();\r\n\r\n        // Destroy all wave buffer and clear list.\r\n        for (let lCount: number = 0; this.mWavingBufferList.length < lCount; lCount++) {\r\n            this.mWavingBufferList.pop()?.destroy();\r\n        }\r\n\r\n        // Clear ready buffer list.\r\n        for (let lCount: number = 0; this.mReadyBufferList.length < lCount; lCount++) {\r\n            // No need to destroy. All buffers have already destroyed.\r\n            this.mReadyBufferList.pop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate buffer. Write local gpu object data as initial native buffer data.\r\n     */\r\n    protected override generate(): GPUBuffer {\r\n        let lUsage: number = 0;\r\n\r\n        // Append usage type from abstract bind type.\r\n        switch (this.gpuObject.memoryLayout.bindType) {\r\n            case BufferBindType.Undefined: {\r\n                // Just an layout indicator. Does nothing to usage type.\r\n                break;\r\n            }\r\n            case BufferBindType.Index: {\r\n                lUsage |= GPUBufferUsage.INDEX;\r\n                break;\r\n            }\r\n            case BufferBindType.Storage: {\r\n                lUsage |= GPUBufferUsage.STORAGE;\r\n                break;\r\n            }\r\n            case BufferBindType.Uniform: {\r\n                lUsage |= GPUBufferUsage.UNIFORM;\r\n                break;\r\n            }\r\n            case BufferBindType.Vertex: {\r\n                lUsage |= GPUBufferUsage.VERTEX;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Append usage type from abstract usage type.\r\n        if ((this.gpuObject.memoryLayout.memoryType & MemoryCopyType.CopyDestination) !== 0) {\r\n            lUsage |= GPUBufferUsage.COPY_DST;\r\n        }\r\n        if ((this.gpuObject.memoryLayout.memoryType & MemoryCopyType.CopySource) !== 0) {\r\n            lUsage |= GPUBufferUsage.COPY_SRC;\r\n        }\r\n\r\n        // Create gpu buffer mapped\r\n        const lBuffer: GPUBuffer = this.factory.gpu.createBuffer({\r\n            label: 'Ring-Buffer-Static-Buffer',\r\n            size: this.gpuObject.size,\r\n            usage: lUsage,\r\n            mappedAtCreation: true // Map data when buffer would receive initial data.\r\n        });\r\n\r\n        // unmap buffer.\r\n        lBuffer.unmap();\r\n\r\n        return lBuffer;\r\n    }\r\n}","import { BaseNativeGenerator, NativeObjectLifeTime } from '../../../generator/base-native-generator';\r\nimport { ImageTexture } from '../../../texture/image-texture';\r\nimport { NativeWebGpuMap, WebGpuGeneratorFactory } from '../web-gpu-generator-factory';\r\n\r\nexport class WebGpuImageTextureGenerator extends BaseNativeGenerator<NativeWebGpuMap, 'imageTexture'> {\r\n    private mTexture: GPUTexture | null;\r\n\r\n    /**\r\n     * Set life time of generated native.\r\n     */\r\n    protected override get nativeLifeTime(): NativeObjectLifeTime {\r\n        return NativeObjectLifeTime.Persistent;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pBaseObject - Base object containing all values.\r\n     * @param pGeneratorFactory - Generator factory.\r\n     */\r\n    public constructor(pFactory: WebGpuGeneratorFactory, pBaseObject: ImageTexture) {\r\n        super(pFactory, pBaseObject);\r\n\r\n        this.mTexture = null;\r\n    }\r\n\r\n    /**\r\n     * Destory texture object.\r\n     * @param _pNativeObject - Native canvas texture.\r\n     */\r\n    protected override destroy(_pNativeObject: GPUTextureView): void {\r\n        this.mTexture?.destroy();\r\n        this.mTexture = null;\r\n    }\r\n\r\n    /**\r\n     * Generate native canvas texture view.\r\n     */\r\n    protected override generate(): GPUTextureView {\r\n        // Create texture with set size, format and usage. Save it for destorying later.\r\n        this.mTexture = this.factory.gpu.createTexture({\r\n            label: 'Frame-Buffer-Texture',\r\n            size: [this.gpuObject.width, this.gpuObject.height, this.gpuObject.depth],\r\n            format: this.factory.formatFromLayout(this.gpuObject.memoryLayout),\r\n            usage: this.factory.usageFromLayout(this.gpuObject.memoryLayout),\r\n            dimension: this.factory.dimensionFromLayout(this.gpuObject.memoryLayout),\r\n        });\r\n\r\n        // Load images into texture.\r\n        for (let lImageIndex: number = 0; lImageIndex < this.gpuObject.images.length; lImageIndex++) {\r\n            const lBitmap: ImageBitmap = this.gpuObject.images[lImageIndex];\r\n\r\n            // Copy image into depth layer.\r\n            this.factory.gpu.queue.copyExternalImageToTexture(\r\n                { source: lBitmap },\r\n                { texture: this.mTexture, origin: [0, 0, lImageIndex] },\r\n                [lBitmap.width, lBitmap.height]\r\n            );\r\n        }\r\n\r\n        // TODO: View descriptor.\r\n        return this.mTexture.createView();\r\n    }\r\n}","import { Exception } from '@kartoffelgames/core.data';\r\nimport { BaseNativeGenerator, NativeObjectLifeTime } from '../../../generator/base-native-generator';\r\nimport { NativeWebGpuMap } from '../web-gpu-generator-factory';\r\n\r\nexport class WebGpuPipelineDataLayoutGenerator extends BaseNativeGenerator<NativeWebGpuMap, 'pipelineDataLayout'> {\r\n    /**\r\n     * Set life time of generated native.\r\n     */\r\n    protected override get nativeLifeTime(): NativeObjectLifeTime {\r\n        return NativeObjectLifeTime.Persistent;\r\n    }\r\n\r\n    /**\r\n     * Generate native gpu pipeline data layout.\r\n     */\r\n    protected override generate(): GPUPipelineLayout  {\r\n        const lBindGoupIndices: Array<number> = this.gpuObject.groups;\r\n\r\n        // Generate pipeline layout from bind group layouts.\r\n        const lPipelineLayoutDescriptor = { bindGroupLayouts: new Array<GPUBindGroupLayout>() };\r\n        for (const lIndex of lBindGoupIndices) {\r\n            const lBindGroupLayout = this.gpuObject.getGroupLayout(lIndex);\r\n\r\n            lPipelineLayoutDescriptor.bindGroupLayouts[lIndex] = this.factory.request<'bindDataGroupLayout'>(lBindGroupLayout).create();\r\n        }\r\n\r\n        // Validate continunity.\r\n        if (lBindGoupIndices.length !== lPipelineLayoutDescriptor.bindGroupLayouts.length) {\r\n            throw new Exception(`Bind group gap detected. Group not set.`, this);\r\n        }\r\n\r\n        // Generate pipeline layout from descriptor.\r\n        return this.factory.gpu.createPipelineLayout(lPipelineLayoutDescriptor) ;\r\n    }\r\n}","import { FilterMode } from '../../../../constant/filter-mode.enum';\r\nimport { WrappingMode } from '../../../../constant/wrapping-mode.enum';\r\nimport { BaseNativeGenerator, NativeObjectLifeTime } from '../../../generator/base-native-generator';\r\nimport { NativeWebGpuMap } from '../web-gpu-generator-factory';\r\n\r\nexport class WebGpuTextureSamplerGenerator extends BaseNativeGenerator<NativeWebGpuMap, 'textureSampler'>  {\r\n    /**\r\n     * Set life time of generated native.\r\n     */\r\n    protected override get nativeLifeTime(): NativeObjectLifeTime {\r\n        return NativeObjectLifeTime.Persistent;\r\n    }\r\n\r\n    /**\r\n     * Generate native bind data group layout object.\r\n     */\r\n    protected override generate(): GPUSampler {\r\n        // Convert compare function to native compare function.\r\n        const lNativeCompareFunction: GPUCompareFunction | null = this.factory.compareFunctionToNative(this.gpuObject.compare);\r\n        \r\n        // Convert wrap mode to native address mode.\r\n        let lAddressMode: GPUAddressMode = 'clamp-to-edge';\r\n        switch (this.gpuObject.wrapMode) {\r\n            case WrappingMode.ClampToEdge: {\r\n                lAddressMode = 'clamp-to-edge';\r\n                break;\r\n            }\r\n            case WrappingMode.MirrorRepeat: {\r\n                lAddressMode = 'mirror-repeat';\r\n                break;\r\n            }\r\n            case WrappingMode.Repeat: {\r\n                lAddressMode = 'repeat';\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Convert filter to native mipmap filter.\r\n        let lMipMapFilter: GPUMipmapFilterMode = 'linear';\r\n        switch (this.gpuObject.mipmapFilter) {\r\n            case FilterMode.Linear: {\r\n                lMipMapFilter = 'linear';\r\n                break;\r\n            }\r\n            case FilterMode.Nearest: {\r\n                lMipMapFilter = 'nearest';\r\n                break;\r\n            }\r\n        }\r\n\r\n        const lSamplerOptions: GPUSamplerDescriptor = {\r\n            label: 'Texture-Sampler',\r\n            addressModeU: lAddressMode,\r\n            addressModeV: lAddressMode,\r\n            addressModeW: lAddressMode,\r\n            magFilter: this.toNativeFilterMode(this.gpuObject.magFilter),\r\n            minFilter: this.toNativeFilterMode(this.gpuObject.minFilter),\r\n            mipmapFilter: lMipMapFilter,\r\n            lodMaxClamp: this.gpuObject.lodMaxClamp,\r\n            lodMinClamp: this.gpuObject.lodMinClamp,\r\n            maxAnisotropy: this.gpuObject.maxAnisotropy\r\n        };\r\n\r\n        if (lNativeCompareFunction) {\r\n            lSamplerOptions.compare = lNativeCompareFunction;\r\n        }\r\n\r\n        return this.factory.gpu.createSampler(lSamplerOptions);\r\n    }\r\n\r\n    /**\r\n     * Convert filter to native filter.\r\n     * @param pFilerMode - Filter mode.\r\n     */\r\n    private toNativeFilterMode(pFilerMode: FilterMode): GPUFilterMode {\r\n        switch (pFilerMode) {\r\n            case FilterMode.Linear: {\r\n                return 'linear';\r\n            }\r\n            case FilterMode.Nearest: {\r\n                return 'nearest';\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { BaseNativeGenerator, NativeObjectLifeTime } from '../../../generator/base-native-generator';\r\nimport { NativeWebGpuMap } from '../web-gpu-generator-factory';\r\n\r\nexport class WebGpuVertexFragmentShaderGenerator extends BaseNativeGenerator<NativeWebGpuMap, 'vertexFragmentShader'> {\r\n    /**\r\n     * Set life time of generated native.\r\n     */\r\n    protected override get nativeLifeTime(): NativeObjectLifeTime {\r\n        return NativeObjectLifeTime.Persistent;\r\n    }\r\n\r\n    /**\r\n     * Generate native gpu pipeline data layout.\r\n     */\r\n    protected override generate(): GPUShaderModule {\r\n        return this.factory.gpu.createShaderModule({ code: this.gpuObject.information.source });\r\n    }\r\n}","import { BaseNativeGenerator, NativeObjectLifeTime } from '../../../generator/base-native-generator';\r\nimport { NativeWebGpuMap } from '../web-gpu-generator-factory';\r\n\r\nexport class WebGpuVideoTextureGenerator extends BaseNativeGenerator<NativeWebGpuMap, 'videoTexture'> {\r\n    /**\r\n     * Set life time of generated native.\r\n     */\r\n    protected override get nativeLifeTime(): NativeObjectLifeTime {\r\n        return NativeObjectLifeTime.Persistent;\r\n    }\r\n\r\n    /**\r\n     * Generate native canvas texture view.\r\n     */\r\n    protected override generate(): GPUExternalTexture {\r\n        return this.factory.gpu.importExternalTexture({\r\n            label: 'External-Texture',\r\n            source: this.gpuObject.video,\r\n            colorSpace: 'srgb'\r\n        });\r\n    }\r\n}","import { Dictionary, Exception } from '@kartoffelgames/core.data';\r\nimport { MemoryCopyType } from '../../../constant/memory-copy-type.enum';\r\nimport { TextureDimension } from '../../../constant/texture-dimension.enum';\r\nimport { TextureFormat } from '../../../constant/texture-format.enum';\r\nimport { TextureUsage } from '../../../constant/texture-usage.enum';\r\nimport { BindDataGroup } from '../../binding/bind-data-group';\r\nimport { BindDataGroupLayout } from '../../binding/bind-data-group-layout';\r\nimport { PipelineDataLayout } from '../../binding/pipeline-data-layout';\r\nimport { GpuBuffer } from '../../buffer/gpu-buffer';\r\nimport { BaseGeneratorFactory, GeneratorNativeMap } from '../../generator/base-generator-factory';\r\nimport { TextureMemoryLayout } from '../../memory_layout/texture-memory-layout';\r\nimport { VertexFragmentShader } from '../../shader/vertex-fragment-shader';\r\nimport { CanvasTexture } from '../../texture/canvas-texture';\r\nimport { FrameBufferTexture } from '../../texture/frame-buffer-texture';\r\nimport { ImageTexture } from '../../texture/image-texture';\r\nimport { TextureSampler } from '../../texture/texture-sampler';\r\nimport { VideoTexture } from '../../texture/video-texture';\r\nimport { WebGpuBindDataGroupGenerator } from './native-generator/web-gpu-bind-data-group-generator';\r\nimport { WebGpuBindDataGroupLayoutGenerator } from './native-generator/web-gpu-bind-data-group-layout-generator';\r\nimport { WebGpuCanvasTextureGenerator } from './native-generator/web-gpu-canvas-texture-generator';\r\nimport { WebGpuFramebufferTextureGenerator } from './native-generator/web-gpu-frame-buffer-texture-generator';\r\nimport { WebGpuGpuBufferGenerator } from './native-generator/web-gpu-gpu-buffer-generator';\r\nimport { WebGpuImageTextureGenerator } from './native-generator/web-gpu-image-texture-generator';\r\nimport { WebGpuPipelineDataLayoutGenerator } from './native-generator/web-gpu-pipeline-data-layout-generator';\r\nimport { WebGpuVertexFragmentShaderGenerator } from './native-generator/web-gpu-vertex-fragment-shader-generator';\r\nimport { WebGpuTextureSamplerGenerator } from './native-generator/web-gpu-texture-sampler-generator';\r\nimport { WebGpuVideoTextureGenerator } from './native-generator/web-gpu-video-texture-generator';\r\nimport { WebGpuRenderTargetsGenerator } from './native-generator/web-gpu-render-targets-generator';\r\nimport { WebGpuComputeShaderGenerator } from './native-generator/web-gpu-compute-shader-generator';\r\nimport { WebGpuVertexFragmentPipelineGenerator } from './native-generator/web-gpu-vertex-fragment-pipeline-generator';\r\nimport { CompareFunction } from '../../../constant/compare-function.enum';\r\nimport { BufferPrimitiveFormat } from '../../../constant/buffer-primitive-format';\r\nimport { WebGpuComputeInstructionGenerator } from './native-generator/web-gpu-compute-instruction-generator';\r\nimport { WebGpuVertexFragmentInstructionGenerator } from './native-generator/web-gpu-vertex-fragment-instruction-generator';\r\nimport { WebGpuComputePipelineGenerator } from './native-generator/web-gpu-compute-pipeline-generator';\r\nimport { WebGpuInstructionExecutorGenerator } from './native-generator/web-gpu-instruction-executor-generator';\r\n\r\nexport class WebGpuGeneratorFactory extends BaseGeneratorFactory<NativeWebGpuMap> {\r\n    private static readonly mAdapters: Dictionary<GPUPowerPreference, GPUAdapter> = new Dictionary<GPUPowerPreference, GPUAdapter>();\r\n    private static readonly mDevices: Dictionary<GPUAdapter, GPUDevice> = new Dictionary<GPUAdapter, GPUDevice>();\r\n\r\n    private mGpuAdapter: GPUAdapter | null;\r\n    private mGpuDevice: GPUDevice | null;\r\n    private readonly mPerformance: GPUPowerPreference;\r\n\r\n    /**\r\n     * GPU device.\r\n     */\r\n    public get gpu(): GPUDevice {\r\n        if (this.mGpuDevice === null) {\r\n            throw new Exception('Web GPU device not initialized.', this);\r\n        }\r\n\r\n        return this.mGpuDevice;\r\n    }\r\n\r\n    /**\r\n     * Preferred texture format.\r\n     */\r\n    public get preferredFormat(): GPUTextureFormat {\r\n        return window.navigator.gpu.getPreferredCanvasFormat();\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor(pMode: GPUPowerPreference) {\r\n        super();\r\n\r\n        this.mPerformance = pMode;\r\n        this.mGpuAdapter = null;\r\n        this.mGpuDevice = null;\r\n\r\n        // Data.\r\n        this.registerGenerator<'gpuBuffer'>(GpuBuffer, WebGpuGpuBufferGenerator);\r\n\r\n        // Data binding.\r\n        this.registerGenerator<'bindDataGroupLayout'>(BindDataGroupLayout, WebGpuBindDataGroupLayoutGenerator);\r\n        this.registerGenerator<'bindDataGroup'>(BindDataGroup, WebGpuBindDataGroupGenerator);\r\n        this.registerGenerator<'pipelineDataLayout'>(PipelineDataLayout, WebGpuPipelineDataLayoutGenerator);\r\n\r\n        // Textures.\r\n        this.registerGenerator<'canvasTexture'>(CanvasTexture, WebGpuCanvasTextureGenerator);\r\n        this.registerGenerator<'frameBufferTexture'>(FrameBufferTexture, WebGpuFramebufferTextureGenerator);\r\n        this.registerGenerator<'videoTexture'>(VideoTexture, WebGpuVideoTextureGenerator);\r\n        this.registerGenerator<'imageTexture'>(ImageTexture, WebGpuImageTextureGenerator);\r\n        this.registerGenerator<'textureSampler'>(TextureSampler, WebGpuTextureSamplerGenerator);\r\n\r\n        // Shader.\r\n        this.registerGenerator<'vertexFragmentShader'>(VertexFragmentShader, WebGpuVertexFragmentShaderGenerator);\r\n    }\r\n\r\n    /**\r\n     * Parse primitive vertex format into native vertex format.\r\n     * @param pPrimitiveFormat - Primitive buffer format.\r\n     */\r\n    public byteCountOfVertexFormat(pPrimitiveFormat: BufferPrimitiveFormat): number {\r\n        switch (pPrimitiveFormat) {\r\n            case BufferPrimitiveFormat.Float:\r\n            case BufferPrimitiveFormat.Int:\r\n            case BufferPrimitiveFormat.Uint: {\r\n                return 4;\r\n            }\r\n            case BufferPrimitiveFormat.Vec2Float:\r\n            case BufferPrimitiveFormat.Vec2Uint:\r\n            case BufferPrimitiveFormat.Vec2Int: {\r\n                return 4 * 2;\r\n            }\r\n            case BufferPrimitiveFormat.Vec3Int:\r\n            case BufferPrimitiveFormat.Vec3Float:\r\n            case BufferPrimitiveFormat.Vec3Uint: {\r\n                return 4 * 3;\r\n            }\r\n            case BufferPrimitiveFormat.Vec4Int:\r\n            case BufferPrimitiveFormat.Vec4Float:\r\n            case BufferPrimitiveFormat.Vec4Uint: {\r\n                return 4 * 4;\r\n            }\r\n            case BufferPrimitiveFormat.Unsupported: {\r\n                throw new Exception('Vertex format not supported', this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert constant to native GPUCompareFunction.\r\n     * @param pCompareFunction - Constant compare value.\r\n     */\r\n    public compareFunctionToNative<T extends CompareFunction | null>(pCompareFunction: T): T extends CompareFunction ? GPUCompareFunction : null {\r\n        let lNativeCompareFunction: GPUCompareFunction | null = null;\r\n        switch (pCompareFunction) {\r\n            case CompareFunction.Allways: {\r\n                lNativeCompareFunction = 'always';\r\n                break;\r\n            }\r\n            case CompareFunction.Greater: {\r\n                lNativeCompareFunction = 'greater';\r\n                break;\r\n            }\r\n            case CompareFunction.Equal: {\r\n                lNativeCompareFunction = 'equal';\r\n                break;\r\n            }\r\n            case CompareFunction.GreaterEqual: {\r\n                lNativeCompareFunction = 'greater-equal';\r\n                break;\r\n            }\r\n            case CompareFunction.LessEqual: {\r\n                lNativeCompareFunction = 'less-equal';\r\n                break;\r\n            }\r\n            case CompareFunction.Less: {\r\n                lNativeCompareFunction = 'less';\r\n                break;\r\n            }\r\n            case CompareFunction.Never: {\r\n                lNativeCompareFunction = 'never';\r\n                break;\r\n            }\r\n            case CompareFunction.NotEqual: {\r\n                lNativeCompareFunction = 'not-equal';\r\n                break;\r\n            }\r\n        }\r\n\r\n        return <any>lNativeCompareFunction;\r\n    }\r\n\r\n    /**\r\n     * GPU Dimension from layout texture dimension.\r\n     */\r\n    public dimensionFromLayout(pLayout: TextureMemoryLayout): GPUTextureDimension {\r\n        // \"Calculate\" texture dimension from texture size.\r\n        switch (pLayout.dimension) {\r\n            case TextureDimension.OneDimension: {\r\n                return '1d';\r\n            }\r\n\r\n            case TextureDimension.TwoDimension: {\r\n                return '2d';\r\n            }\r\n\r\n            case TextureDimension.Cube:\r\n            case TextureDimension.CubeArray:\r\n            case TextureDimension.ThreeDimension:\r\n            case TextureDimension.TwoDimensionArray: {\r\n                return '3d';\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Format from layout.\r\n     */\r\n    public formatFromLayout(pLayout: TextureMemoryLayout): GPUTextureFormat {\r\n        // Convert base to web gpu texture format.\r\n        switch (pLayout.format) {\r\n            case TextureFormat.BlueRedGreenAlpha: {\r\n                return 'bgra8unorm';\r\n            }\r\n            case TextureFormat.Depth: {\r\n                return 'depth24plus';\r\n            }\r\n            case TextureFormat.DepthStencil: {\r\n                return 'depth24plus-stencil8';\r\n            }\r\n            case TextureFormat.Red: {\r\n                return 'r8unorm';\r\n            }\r\n            case TextureFormat.RedGreen: {\r\n                return 'rg8unorm';\r\n            }\r\n            case TextureFormat.RedGreenBlueAlpha: {\r\n                return 'rgba8unorm';\r\n            }\r\n            case TextureFormat.RedGreenBlueAlphaInteger: {\r\n                return 'rgba8uint';\r\n            }\r\n            case TextureFormat.RedGreenInteger: {\r\n                return 'rg8uint';\r\n            }\r\n            case TextureFormat.RedInteger: {\r\n                return 'r8uint';\r\n            }\r\n            case TextureFormat.Stencil: {\r\n                return 'stencil8';\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Init devices.\r\n     */\r\n    public override async initInternals(): Promise<void> {\r\n        // Try to load cached adapter. When not cached, request new one.\r\n        const lAdapter: GPUAdapter | null = WebGpuGeneratorFactory.mAdapters.get(this.mPerformance) ?? await window.navigator.gpu.requestAdapter({ powerPreference: this.mPerformance });\r\n        if (!lAdapter) {\r\n            throw new Exception('Error requesting GPU adapter', WebGpuGeneratorFactory);\r\n        }\r\n\r\n        WebGpuGeneratorFactory.mAdapters.set(this.mPerformance, lAdapter);\r\n\r\n        // Try to load cached device. When not cached, request new one.\r\n        const lDevice: GPUDevice | null = WebGpuGeneratorFactory.mDevices.get(lAdapter) ?? await lAdapter.requestDevice();\r\n        if (!lDevice) {\r\n            throw new Exception('Error requesting GPU device', WebGpuGeneratorFactory);\r\n        }\r\n\r\n        WebGpuGeneratorFactory.mDevices.set(lAdapter, lDevice);\r\n\r\n        this.mGpuAdapter = lAdapter;\r\n        this.mGpuDevice = lDevice;\r\n    }\r\n\r\n    /**\r\n     * Get sample type from texture layout.\r\n     */\r\n    public sampleTypeFromLayout(pLayout: TextureMemoryLayout): GPUTextureSampleType {\r\n        // Convert texture format to sampler values.\r\n        switch (pLayout.format) {\r\n            case TextureFormat.Depth:\r\n            case TextureFormat.DepthStencil: {\r\n                return 'depth';\r\n            }\r\n\r\n            case TextureFormat.Stencil:\r\n            case TextureFormat.BlueRedGreenAlpha:\r\n            case TextureFormat.Red:\r\n            case TextureFormat.RedGreen:\r\n            case TextureFormat.RedGreenBlueAlpha: {\r\n                return 'float';\r\n            }\r\n\r\n            case TextureFormat.RedGreenBlueAlphaInteger:\r\n            case TextureFormat.RedGreenInteger:\r\n            case TextureFormat.RedInteger: {\r\n                return 'uint';\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parse primitive vertex format into native vertex format.\r\n     * @param pPrimitiveFormat - Primitive buffer format.\r\n     */\r\n    public toNativeVertexFormat(pPrimitiveFormat: BufferPrimitiveFormat): GPUVertexFormat {\r\n        switch (pPrimitiveFormat) {\r\n            case BufferPrimitiveFormat.Float: {\r\n                return 'float32';\r\n            }\r\n            case BufferPrimitiveFormat.Int: {\r\n                return 'sint32';\r\n            }\r\n            case BufferPrimitiveFormat.Uint: {\r\n                return 'uint32';\r\n            }\r\n            case BufferPrimitiveFormat.Vec2Float: {\r\n                return 'float32x2';\r\n            }\r\n            case BufferPrimitiveFormat.Vec3Float: {\r\n                return 'float32x3';\r\n            }\r\n            case BufferPrimitiveFormat.Vec4Float: {\r\n                return 'float32x4';\r\n            }\r\n            case BufferPrimitiveFormat.Vec2Int: {\r\n                return 'sint32x2';\r\n            }\r\n            case BufferPrimitiveFormat.Vec3Int: {\r\n                return 'sint32x3';\r\n            }\r\n            case BufferPrimitiveFormat.Vec4Int: {\r\n                return 'sint32x4';\r\n            }\r\n            case BufferPrimitiveFormat.Vec2Uint: {\r\n                return 'uint32x2';\r\n            }\r\n            case BufferPrimitiveFormat.Vec3Uint: {\r\n                return 'uint32x3';\r\n            }\r\n            case BufferPrimitiveFormat.Vec4Uint: {\r\n                return 'uint32x4';\r\n            }\r\n            case BufferPrimitiveFormat.Unsupported: {\r\n                throw new Exception('Vertex format not supported', this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Usage from layout.\r\n     */\r\n    public usageFromLayout(pLayout: TextureMemoryLayout): number {\r\n        // Parse base to web gpu usage.\r\n        let lUsage: number = 0;\r\n        if ((pLayout.memoryType & MemoryCopyType.CopyDestination) !== 0) {\r\n            lUsage |= GPUTextureUsage.COPY_DST;\r\n        }\r\n        if ((pLayout.memoryType & MemoryCopyType.CopySource) !== 0) {\r\n            lUsage |= GPUTextureUsage.COPY_SRC;\r\n        }\r\n        if ((pLayout.usage & TextureUsage.RenderAttachment) !== 0) {\r\n            lUsage |= GPUTextureUsage.RENDER_ATTACHMENT;\r\n        }\r\n        if ((pLayout.usage & TextureUsage.StorageBinding) !== 0) {\r\n            lUsage |= GPUTextureUsage.STORAGE_BINDING;\r\n        }\r\n        if ((pLayout.usage & TextureUsage.TextureBinding) !== 0) {\r\n            lUsage |= GPUTextureUsage.TEXTURE_BINDING;\r\n        }\r\n\r\n        return lUsage;\r\n    }\r\n}\r\n\r\nexport interface NativeWebGpuMap extends GeneratorNativeMap {\r\n    factory: WebGpuGeneratorFactory;\r\n\r\n    generators: {\r\n        // Textures.\r\n        textureSampler: { generator: WebGpuTextureSamplerGenerator; native: GPUSampler; };\r\n        imageTexture: { generator: WebGpuImageTextureGenerator; native: GPUTextureView; };\r\n        frameBufferTexture: { generator: WebGpuFramebufferTextureGenerator; native: GPUTextureView; };\r\n        videoTexture: { generator: WebGpuVideoTextureGenerator; native: GPUExternalTexture; };\r\n        canvasTexture: { generator: WebGpuCanvasTextureGenerator; native: GPUTextureView; };\r\n\r\n        // Things with generics. :(\r\n        gpuBuffer: { generator: WebGpuGpuBufferGenerator; native: GPUBuffer; };\r\n\r\n        // Pipeline layouting.\r\n        bindDataGroupLayout: { generator: WebGpuBindDataGroupLayoutGenerator; native: GPUBindGroupLayout; };\r\n        bindDataGroup: { generator: WebGpuBindDataGroupGenerator; native: GPUBindGroup; };\r\n        pipelineDataLayout: { generator: WebGpuPipelineDataLayoutGenerator; native: GPUPipelineLayout; };\r\n        renderTargets: { generator: WebGpuRenderTargetsGenerator; native: GPURenderPassDescriptor; };\r\n\r\n        // Pipelines.\r\n        vertexFragmentPipeline: { generator: WebGpuVertexFragmentPipelineGenerator; native: GPURenderPipeline; };\r\n        computePipeline: { generator: WebGpuComputePipelineGenerator; native: GPUComputePipeline; };\r\n\r\n        // Shader.\r\n        vertexFragmentShader: { generator: WebGpuVertexFragmentShaderGenerator; native: GPUShaderModule; };\r\n        computeShader: { generator: WebGpuComputeShaderGenerator; native: GPUShaderModule; };\r\n\r\n        // Execution.\r\n        computeInstruction: { generator: WebGpuComputeInstructionGenerator; native: null; };\r\n        vertexFragmentInstruction: { generator: WebGpuVertexFragmentInstructionGenerator; native: null; };\r\n        instructionExecutor: { generator: WebGpuInstructionExecutorGenerator; native: null; };\r\n    };\r\n}","import { Exception } from '@kartoffelgames/core.data';\r\nimport { AccessMode } from '../../../constant/access-mode.enum';\r\nimport { BufferBindType } from '../../../constant/buffer-bind-type.enum';\r\nimport { ComputeStage } from '../../../constant/compute-stage.enum';\r\nimport { SamplerType } from '../../../constant/sampler-type.enum';\r\nimport { TextureBindType } from '../../../constant/texture-bind-type.enum';\r\nimport { TextureDimension } from '../../../constant/texture-dimension.enum';\r\nimport { TextureFormat } from '../../../constant/texture-format.enum';\r\nimport { BaseMemoryLayout } from '../../memory_layout/base-memory-layout';\r\nimport { ArrayBufferMemoryLayout } from '../../memory_layout/buffer/array-buffer-memory-layout';\r\nimport { BaseBufferMemoryLayout } from '../../memory_layout/buffer/base-buffer-memory-layout';\r\nimport { LinearBufferMemoryLayout } from '../../memory_layout/buffer/linear-buffer-memory-layout';\r\nimport { StructBufferMemoryLayout } from '../../memory_layout/buffer/struct-buffer-memory-layout';\r\nimport { SamplerMemoryLayout } from '../../memory_layout/sampler-memory-layout';\r\nimport { TextureMemoryLayout } from '../../memory_layout/texture-memory-layout';\r\nimport { BaseShaderInterpreter, ShaderFunction, ShaderFunctionDefinition, ShaderStructDefinition, ShaderType, ShaderTypeDefinition, ShaderValue, ShaderValueDefinition } from '../../shader/interpreter/base-shader-interpreter';\r\nimport { WgslBufferArrayTypes, WgslBufferLinearTypes, WgslSamplerTypes, WgslTextureTypes, WgslType } from './wgsl_enum/wgsl-type.enum';\r\nimport { BufferPrimitiveFormat } from '../../../constant/buffer-primitive-format';\r\n\r\nexport class WebGpuShaderInterpreter extends BaseShaderInterpreter {\r\n    /**\r\n     * Fetch al function definitions.\r\n     * @param pSourceCode - Source code.\r\n     */\r\n    protected override fetchFunctionDefinitions(pSourceCode: string): Array<ShaderFunctionDefinition> {\r\n        const lFunctionRegex: RegExp = /(?<attributes>(?:@[\\w]+(?:\\([^)]*\\))?\\s+)+)?(?:\\s)*?fn\\s+(?<name>\\w*)\\s*\\((?<parameter>(?:.|\\r?\\n)*?)\\)(?:\\s*->\\s*(?<result>[^{]+))?\\s*{/gm;\r\n\r\n        const lFunctionList: Array<ShaderFunctionDefinition> = new Array<ShaderFunctionDefinition>();\r\n        for (const lFunctionMatch of pSourceCode.matchAll(lFunctionRegex)) {\r\n            const lFunctionName: string = lFunctionMatch.groups!['name'];\r\n            const lFunctionResult: string = lFunctionMatch.groups!['result'];\r\n            const lFunctionAttributes: string | null = lFunctionMatch.groups!['attributes'];\r\n            const lFunctionParameter: string = lFunctionMatch.groups!['parameter'];\r\n\r\n            // Fetch attributes.\r\n            const lAttachments: Record<string, string> = {};\r\n            if (lFunctionAttributes) {\r\n                // Split string of multiple attributes.\r\n                for (const lAttributeMatch of lFunctionAttributes.matchAll(/@(?<name>[\\w])+\\((?<value>[^)]*)\\)/g)) {\r\n                    const lAttributeName: string = lAttributeMatch.groups!['name'];\r\n                    const lAttributeValue: string = lAttributeMatch.groups!['value'];\r\n\r\n                    // Add each attribute as value attachment.\r\n                    lAttachments[lAttributeName] = lAttributeValue;\r\n                }\r\n            }\r\n\r\n            // Cut source code after function head match. Head includes first bracket.\r\n            const lFunctionBodyStart: string = pSourceCode.slice(lFunctionMatch.index! + lFunctionMatch[0].length);\r\n\r\n            const lBracketRegex: RegExp = /(?:\".*?\"|'.*?'|\\/\\*.*?\\*\\/|\\/\\/.*?$)|(?<bracket>{|})/gms;\r\n\r\n            // Read function body. Match opening and closing brackets. Count layers and find exit bracket. \r\n            let lBracketLayer: number = 1;\r\n            let lClosingBracketIndex: number = -1;\r\n            let lBracketMatch: RegExpExecArray | null;\r\n            while ((lBracketMatch = lBracketRegex.exec(lFunctionBodyStart)) !== null) {\r\n                if (lBracketMatch.groups?.['bracket']) {\r\n                    const lBracket: string = lBracketMatch.groups['bracket'];\r\n\r\n                    // Count closing and opening layers.\r\n                    if (lBracket === '{') {\r\n                        lBracketLayer++;\r\n                    } else {\r\n                        lBracketLayer--;\r\n\r\n                        // Exit search on exiting last layer.\r\n                        if (lBracketLayer === 0) {\r\n                            lClosingBracketIndex = lBracketMatch.index;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Validate found closing bracket.\r\n            if (lClosingBracketIndex < 0) {\r\n                throw new Exception(`Error closing function \"${lFunctionName}\"`, this);\r\n            }\r\n\r\n            // Cut string on opening and exit braket.\r\n            const lFunctionBody: string = lFunctionBodyStart.slice(0, lClosingBracketIndex);\r\n\r\n            // Fetch Parameter.\r\n            const lParameterVariableList: Array<ShaderValueDefinition> = this.fetchVariableDefinitions(lFunctionParameter);\r\n\r\n            // Fetch result type.\r\n            const lReturnTypes: ShaderValueDefinition = this.fetchVariableDefinitions(lFunctionResult).at(0)!;\r\n\r\n            lFunctionList.push({\r\n                name: lFunctionName,\r\n                returnType: lReturnTypes,\r\n                parameter: lParameterVariableList,\r\n                attachments: lAttachments,\r\n                body: lFunctionBody\r\n            });\r\n        }\r\n\r\n        return lFunctionList;\r\n    }\r\n\r\n    /**\r\n     * Fetch all struct definitions of shader.\r\n     * @param pSourceCode - Shader source code.\r\n     */\r\n    protected override fetchStructDefinitions(pSourceCode: string): Array<ShaderStructDefinition> {\r\n        const lStuctRegex: RegExp = /^\\s*struct\\s+(?<name>\\w+)\\s*{(?<typeinfo>[^}]*)}$/smg;\r\n\r\n        // Fetch all found structs.\r\n        const lStructDefinitionList: Array<ShaderStructDefinition> = new Array<ShaderStructDefinition>();\r\n        for (const lStructMatch of pSourceCode.matchAll(lStuctRegex)) {\r\n            const lStructName: string = lStructMatch.groups!['name'];\r\n            const lStructBody: string = lStructMatch.groups!['typeinfo'];\r\n\r\n            lStructDefinitionList.push({\r\n                name: lStructName,\r\n                properies: this.fetchVariableDefinitions(lStructBody)\r\n            });\r\n        }\r\n\r\n        return lStructDefinitionList;\r\n    }\r\n\r\n    /**\r\n     * Fetch all global bindings.\r\n     * @param pSourceCode - Source code.\r\n     */\r\n    protected override fetchValueDefinitions(pSourceCode: string): Array<ShaderValueDefinition> {\r\n        // Get only lines with group attributes.\r\n        const lAllGroupLines: string = [...pSourceCode.matchAll(/^.*@group.*$/gm)].reduce((pCurrent, pLine) => {\r\n            return pCurrent + pLine[0];\r\n        }, '');\r\n\r\n        return this.fetchVariableDefinitions(lAllGroupLines);\r\n    }\r\n\r\n    /**\r\n     * Convert definition into function.\r\n     * @param pDefinition - Function definitions.\r\n     */\r\n    protected override functionFromDefinition(pDefinition: ShaderFunctionDefinition): ShaderFunction {\r\n        // Create memory layouts\r\n        const lParameter: Array<BaseMemoryLayout> = pDefinition.parameter.map((pParameterDefintion) => { return this.valueFromDefinition(pParameterDefintion).value; });\r\n        const lReturnType: BaseMemoryLayout = this.valueFromDefinition(pDefinition.returnType).value;\r\n\r\n        // Read tags from attachments.\r\n        let lTag: ComputeStage = ComputeStage.None;\r\n        if (pDefinition.attachments['vertex']) {\r\n            lTag |= ComputeStage.Vertex;\r\n        }\r\n        if (pDefinition.attachments['fragment']) {\r\n            lTag |= ComputeStage.Fragment;\r\n        }\r\n        if (pDefinition.attachments['compute']) {\r\n            lTag |= ComputeStage.Compute;\r\n        }\r\n\r\n        // \"Calculate\" used globals by using deep mathematic learning block chain algorithms.\r\n        const lUsedGlobals: Array<string> = new Array<string>();\r\n        for (const lGlobalValue of this.fetchValueDefinitions(this.source)) {\r\n            if (pDefinition.body.includes(lGlobalValue.name)) {\r\n                lUsedGlobals.push(lGlobalValue.name);\r\n            }\r\n        }\r\n\r\n        const lAttachmentValueRexgex: RegExp = /\".*?\"|'.*?'|[^,\"']+/g;\r\n\r\n        // Save all attachments.\r\n        const lAttachment: Record<string, Array<string>> = {};\r\n        for (const lAttachmentName in pDefinition.attachments) {\r\n            const lAttachmentValues: string = pDefinition.attachments[lAttachmentName];\r\n\r\n            // Split values by comma. Filter every empty value.\r\n            lAttachment[lAttachmentName] = [...lAttachmentValues.matchAll(lAttachmentValueRexgex)]\r\n                .map((pMatch: RegExpMatchArray) => { return pMatch[0].trim(); })\r\n                .filter((pValue: string) => { return pValue !== ''; });\r\n        }\r\n\r\n        return {\r\n            name: pDefinition.name,\r\n            entryPoints: lTag,\r\n            parameter: lParameter,\r\n            return: lReturnType,\r\n            usedGlobals: lUsedGlobals,\r\n            attachments: lAttachment\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Setup shader types.\r\n     * @param pAddType - Add type callback.\r\n     */\r\n    protected override setupShaderTypes(pAddType: (pType: ShaderTypeDefinition) => void): void {\r\n        // Scalar types.\r\n        pAddType({ name: WgslType.Boolean, variants: [{ size: 1, align: 1 }] });\r\n\r\n        pAddType({ name: WgslType.Integer32, variants: [{ size: 4, align: 4, format: BufferPrimitiveFormat.Int }] });\r\n        pAddType({ name: WgslType.UnsignedInteger32, variants: [{ size: 4, align: 4, format: BufferPrimitiveFormat.Uint }] });\r\n        pAddType({ name: WgslType.Float32, variants: [{ size: 4, align: 4, format: BufferPrimitiveFormat.Float }] });\r\n        pAddType({ name: WgslType.Float16, variants: [{ size: 2, align: 2 }] });\r\n\r\n        // Vector types.\r\n        pAddType({\r\n            name: WgslType.Vector2, variants: [\r\n                { size: 8, align: 8, generic: [WgslType.Integer32], format: BufferPrimitiveFormat.Vec2Int },\r\n                { size: 8, align: 8, generic: [WgslType.UnsignedInteger32], format: BufferPrimitiveFormat.Vec2Uint },\r\n                { size: 8, align: 8, generic: [WgslType.Float32], format: BufferPrimitiveFormat.Vec2Float },\r\n                { size: 4, align: 4, generic: [WgslType.Float16] }\r\n            ]\r\n        });\r\n        pAddType({\r\n            name: WgslType.Vector3, variants: [\r\n                { size: 12, align: 16, generic: [WgslType.Integer32], format: BufferPrimitiveFormat.Vec3Int },\r\n                { size: 12, align: 16, generic: [WgslType.UnsignedInteger32], format: BufferPrimitiveFormat.Vec3Uint },\r\n                { size: 12, align: 16, generic: [WgslType.Float32], format: BufferPrimitiveFormat.Vec3Float },\r\n                { size: 6, align: 8, generic: [WgslType.Float16] }\r\n            ]\r\n        });\r\n        pAddType({\r\n            name: WgslType.Vector4, variants: [\r\n                { size: 16, align: 16, generic: [WgslType.Integer32], format: BufferPrimitiveFormat.Vec4Int },\r\n                { size: 16, align: 16, generic: [WgslType.UnsignedInteger32], format: BufferPrimitiveFormat.Vec4Uint },\r\n                { size: 16, align: 16, generic: [WgslType.Float32], format: BufferPrimitiveFormat.Vec4Float },\r\n                { size: 8, align: 8, generic: [WgslType.Float16] }\r\n            ]\r\n        });\r\n\r\n        // Matrix types.\r\n        pAddType({\r\n            name: WgslType.Matrix22, variants: [\r\n                { size: 16, align: 8, generic: [WgslType.Integer32] },\r\n                { size: 16, align: 8, generic: [WgslType.UnsignedInteger32] },\r\n                { size: 16, align: 8, aliases: ['mat2x2f'], generic: [WgslType.Float32] },\r\n                { size: 8, align: 4, aliases: ['mat2x2h'], generic: [WgslType.Float16] }\r\n            ]\r\n        });\r\n        pAddType({\r\n            name: WgslType.Matrix23, variants: [\r\n                { size: 32, align: 16, generic: [WgslType.Integer32] },\r\n                { size: 32, align: 16, generic: [WgslType.UnsignedInteger32] },\r\n                { size: 32, align: 16, aliases: ['mat2x3f'], generic: [WgslType.Float32] },\r\n                { size: 16, align: 8, aliases: ['mat2x3h'], generic: [WgslType.Float16] }\r\n            ]\r\n        });\r\n        pAddType({\r\n            name: WgslType.Matrix24, variants: [\r\n                { size: 32, align: 16, generic: [WgslType.Integer32] },\r\n                { size: 32, align: 16, generic: [WgslType.UnsignedInteger32] },\r\n                { size: 32, align: 16, aliases: ['mat2x4f'], generic: [WgslType.Float32] },\r\n                { size: 16, align: 8, aliases: ['mat2x4h'], generic: [WgslType.Float16] }\r\n            ]\r\n        });\r\n        pAddType({\r\n            name: WgslType.Matrix32, variants: [\r\n                { size: 24, align: 8, generic: [WgslType.Integer32] },\r\n                { size: 24, align: 8, generic: [WgslType.UnsignedInteger32] },\r\n                { size: 24, align: 8, aliases: ['mat3x2f'], generic: [WgslType.Float32] },\r\n                { size: 12, align: 4, aliases: ['mat3x2h'], generic: [WgslType.Float16] }\r\n            ]\r\n        });\r\n        pAddType({\r\n            name: WgslType.Matrix33, variants: [\r\n                { size: 48, align: 16, generic: [WgslType.Integer32] },\r\n                { size: 48, align: 16, generic: [WgslType.UnsignedInteger32] },\r\n                { size: 48, align: 16, aliases: ['mat3x3f'], generic: [WgslType.Float32] },\r\n                { size: 24, align: 8, aliases: ['mat3x3h'], generic: [WgslType.Float16] }\r\n            ]\r\n        });\r\n        pAddType({\r\n            name: WgslType.Matrix34, variants: [\r\n                { size: 48, align: 16, generic: [WgslType.Integer32] },\r\n                { size: 48, align: 16, generic: [WgslType.UnsignedInteger32] },\r\n                { size: 48, align: 16, aliases: ['mat3x4f'], generic: [WgslType.Float32] },\r\n                { size: 24, align: 8, aliases: ['mat3x4h'], generic: [WgslType.Float16] }\r\n            ]\r\n        });\r\n        pAddType({\r\n            name: WgslType.Matrix42, variants: [\r\n                { size: 32, align: 8, generic: [WgslType.Integer32] },\r\n                { size: 32, align: 8, generic: [WgslType.UnsignedInteger32] },\r\n                { size: 32, align: 8, aliases: ['mat4x2f'], generic: [WgslType.Float32] },\r\n                { size: 16, align: 4, aliases: ['mat4x2h'], generic: [WgslType.Float16] }\r\n            ]\r\n        });\r\n        pAddType({\r\n            name: WgslType.Matrix43, variants: [\r\n                { size: 64, align: 16, generic: [WgslType.Integer32] },\r\n                { size: 64, align: 16, generic: [WgslType.UnsignedInteger32] },\r\n                { size: 64, align: 16, aliases: ['mat4x3f'], generic: [WgslType.Float32] },\r\n                { size: 32, align: 8, aliases: ['mat4x3h'], generic: [WgslType.Float16] }\r\n            ]\r\n        });\r\n        pAddType({\r\n            name: WgslType.Matrix44, variants: [\r\n                { size: 64, align: 16, generic: [WgslType.Integer32] },\r\n                { size: 64, align: 16, generic: [WgslType.UnsignedInteger32] },\r\n                { size: 64, align: 16, aliases: ['mat4x4f'], generic: [WgslType.Float32] },\r\n                { size: 32, align: 8, aliases: ['mat4x4h'], generic: [WgslType.Float16] }\r\n            ]\r\n        });\r\n\r\n        // Bundled types.\r\n        pAddType({\r\n            name: WgslType.Array, variants: [\r\n                { size: -1, align: -1, generic: ['*'] },\r\n                { size: -1, align: -1, generic: ['*', '*'] }\r\n            ]\r\n        });\r\n\r\n        // Specials\r\n        pAddType({\r\n            name: WgslType.Atomic, variants: [\r\n                { size: 4, align: 4, generic: [WgslType.Integer32] },\r\n                { size: 4, align: 4, generic: [WgslType.UnsignedInteger32] }\r\n            ]\r\n        });\r\n\r\n        // Image textures.\r\n        pAddType({ name: WgslType.Texture1d, variants: [{ size: -1, align: -1, generic: ['*'] }] });\r\n        pAddType({ name: WgslType.Texture2d, variants: [{ size: -1, align: -1, generic: ['*'] }] });\r\n        pAddType({ name: WgslType.Texture2dArray, variants: [{ size: -1, align: -1, generic: ['*'] }] });\r\n        pAddType({ name: WgslType.Texture3d, variants: [{ size: -1, align: -1, generic: ['*'] }] });\r\n        pAddType({ name: WgslType.TextureCube, variants: [{ size: -1, align: -1, generic: ['*'] }] });\r\n        pAddType({ name: WgslType.TextureCubeArray, variants: [{ size: -1, align: -1, generic: ['*'] }] });\r\n        pAddType({ name: WgslType.TextureMultisampled2d, variants: [{ size: -1, align: -1, generic: ['*'] }] });\r\n\r\n        // External tetures.\r\n        pAddType({ name: WgslType.TextureExternal, variants: [{ size: -1, align: -1, generic: [] }] });\r\n\r\n        // Storage textures.\r\n        pAddType({ name: WgslType.TextureStorage1d, variants: [{ size: -1, align: -1, generic: ['*', '*'] }] });\r\n        pAddType({ name: WgslType.TextureStorage2d, variants: [{ size: -1, align: -1, generic: ['*', '*'] }] });\r\n        pAddType({ name: WgslType.TextureStorage2dArray, variants: [{ size: -1, align: -1, generic: ['*', '*'] }] });\r\n        pAddType({ name: WgslType.TextureStorage3d, variants: [{ size: -1, align: -1, generic: ['*', '*'] }] });\r\n\r\n        // Depth Textures.\r\n        pAddType({ name: WgslType.TextureDepth2d, variants: [{ size: -1, align: -1, generic: [] }] });\r\n        pAddType({ name: WgslType.TextureDepth2dArray, variants: [{ size: -1, align: -1, generic: [] }] });\r\n        pAddType({ name: WgslType.TextureDepthCube, variants: [{ size: -1, align: -1, generic: [] }] });\r\n        pAddType({ name: WgslType.TextureDepthCubeArray, variants: [{ size: -1, align: -1, generic: [] }] });\r\n        pAddType({ name: WgslType.TextureDepthMultisampled2d, variants: [{ size: -1, align: -1, generic: [] }] });\r\n\r\n        // Sampler\r\n        pAddType({ name: WgslType.Sampler, variants: [{ size: -1, align: -1, generic: [] }] });\r\n        pAddType({ name: WgslType.SamplerComparison, variants: [{ size: -1, align: -1, generic: [] }] });\r\n\r\n        // Reference and Pointer Types.\r\n        pAddType({ name: WgslType.Reference, variants: [{ size: -1, align: -1, generic: ['*', '*', '*'] }] });\r\n        pAddType({ name: WgslType.Pointer, variants: [{ size: -1, align: -1, generic: ['*', '*', '*'] }] });\r\n    }\r\n\r\n    /**\r\n     * Create shader value from definition.\r\n     * @param pValueDefinition - Shader value definition.\r\n     */\r\n    protected override valueFromDefinition(pValueDefinition: ShaderValueDefinition): ShaderValue {\r\n        const lDefinitionType: ShaderType = this.typeFor(pValueDefinition.name, pValueDefinition.typeGenerics);\r\n\r\n        /*\r\n         * Read generic settings.\r\n         */\r\n\r\n        // BufferBindType\r\n        // Parameter is only an layout type that can happend when specifed as function return type of parameter.\r\n        let lBufferBindType: BufferBindType = BufferBindType.Undefined;\r\n        if (pValueDefinition.attachments['bindingType']) {\r\n            const lBindingTypeEnum: 'uniform' | 'storage' = <'uniform' | 'storage'>pValueDefinition.attachments['bindingType'];\r\n            switch (lBindingTypeEnum) {\r\n                case 'uniform': {\r\n                    lBufferBindType = BufferBindType.Uniform;\r\n                    break;\r\n                }\r\n                case 'storage': {\r\n                    lBufferBindType = BufferBindType.Storage;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // AccessMode\r\n        let lAccessMode: AccessMode = AccessMode.None;\r\n        if (pValueDefinition.attachments['accessMode']) {\r\n            const lAccessEnum: 'read' | 'write' | 'read_write' = <'read' | 'write' | 'read_write'>pValueDefinition.attachments['accessMode'];\r\n            switch (lAccessEnum) {\r\n                case 'read': {\r\n                    lAccessMode = AccessMode.Read;\r\n                    break;\r\n                }\r\n                case 'write': {\r\n                    lAccessMode = AccessMode.Write;\r\n                    break;\r\n                }\r\n                case 'read_write': {\r\n                    lAccessMode = AccessMode.Read | AccessMode.Write;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Binding Index.\r\n        const lBindingIndex: number | null = pValueDefinition.attachments['binding'] ? parseInt(pValueDefinition.attachments['binding']) : null;\r\n        const lParameterIndex: number | null = pValueDefinition.attachments['location'] ? parseInt(pValueDefinition.attachments['location']) : null;\r\n\r\n        const lCreationParameter: ShaderValueCreationParameter = {\r\n            valueDefinition: pValueDefinition,\r\n            typeDefinition: lDefinitionType,\r\n            accessMode: lAccessMode,\r\n            bufferBindType: lBufferBindType,\r\n            groupIndex: pValueDefinition.attachments['group'] ? parseInt(pValueDefinition.attachments['group']) : null,\r\n            memoryIndex: {\r\n                binding: lBindingIndex,\r\n                location: lParameterIndex,\r\n            },\r\n            visibility: this.visibilityOf(pValueDefinition.name)\r\n        };\r\n\r\n        /*\r\n         * Convert different memory layouts.\r\n         */\r\n\r\n        // Struct.\r\n        if (lDefinitionType.type === 'struct') {\r\n            return this.createStructBufferLayout(lCreationParameter);\r\n        }\r\n\r\n        // Sampler\r\n        if (WgslSamplerTypes.includes(<any>lDefinitionType.typeName)) {\r\n            return this.createSamplerLayout(lCreationParameter);\r\n        }\r\n\r\n        // Array buffer.\r\n        if (WgslBufferArrayTypes.includes(<any>lDefinitionType.typeName)) {\r\n            return this.createArrayBufferLayout(lCreationParameter);\r\n        }\r\n\r\n        // Linear buffer.\r\n        if (WgslBufferLinearTypes.includes(<any>lDefinitionType.typeName)) {\r\n            return this.createLinearBufferLayout(lCreationParameter);\r\n        }\r\n\r\n        // Textures.\r\n        if (WgslTextureTypes.includes(<any>lDefinitionType.typeName)) {\r\n            return this.createTextureLayout(lCreationParameter);\r\n        }\r\n\r\n        // Unsupported behaviour.\r\n        throw new Exception(`Shader value \"${pValueDefinition.name}\" has an unsupported type.`, this);\r\n    }\r\n\r\n    /**\r\n     * Create array buffer layout shader value.\r\n     * @param pParameter - Creation parameter.\r\n     */\r\n    private createArrayBufferLayout(pParameter: ShaderValueCreationParameter): ShaderValue {\r\n        let lArraySize: number = -1;\r\n        if (pParameter.valueDefinition.typeGenerics.length === 2) {\r\n            const lArraySizeGeneric: string = pParameter.valueDefinition.typeGenerics[1];\r\n            lArraySize = parseInt(lArraySizeGeneric);\r\n\r\n            // Validate size generic.\r\n            if (isNaN(lArraySize)) {\r\n                throw new Exception(`Wrong size generic \"${lArraySizeGeneric}\" on array type.`, this);\r\n            }\r\n        }\r\n\r\n        // Read inner type from generic.\r\n        const lInnerTypeDefinition: ShaderValueDefinition = this.fetchVariableDefinitions(pParameter.valueDefinition.typeGenerics[0])[0];\r\n        const lInnerType: ShaderValue = this.valueFromDefinition(lInnerTypeDefinition);\r\n\r\n        const lArrayMemoryLayout: ArrayBufferMemoryLayout = new ArrayBufferMemoryLayout(this.device, {\r\n            arraySize: lArraySize,\r\n            innerType: <BaseBufferMemoryLayout>lInnerType.value,\r\n            bindType: pParameter.bufferBindType,\r\n            access: pParameter.accessMode,\r\n            bindingIndex: pParameter.memoryIndex.binding,\r\n            name: pParameter.valueDefinition.name,\r\n            visibility: pParameter.visibility\r\n        });\r\n\r\n        return {\r\n            group: pParameter.groupIndex,\r\n            value: lArrayMemoryLayout\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Create linear buffer layout shader value.\r\n     * @param pParameter - Creation parameter.\r\n     */\r\n    private createLinearBufferLayout(pParameter: ShaderValueCreationParameter): ShaderValue {\r\n        if (pParameter.typeDefinition.type !== 'buildIn') {\r\n            throw new Exception('Type not supported.', this);\r\n        }\r\n\r\n        const lLinearBufferLayout = new LinearBufferMemoryLayout(this.device, {\r\n            size: pParameter.typeDefinition.size,\r\n            alignment: pParameter.typeDefinition.align,\r\n            bindType: pParameter.bufferBindType,\r\n            access: pParameter.accessMode,\r\n            bindingIndex: pParameter.memoryIndex.binding,\r\n            locationIndex: pParameter.memoryIndex.location,\r\n            name: pParameter.valueDefinition.name,\r\n            visibility: pParameter.visibility,\r\n            primitiveFormat: pParameter.typeDefinition.primitiveFormat ?? BufferPrimitiveFormat.Unsupported\r\n        });\r\n\r\n        return {\r\n            group: pParameter.groupIndex,\r\n            value: lLinearBufferLayout\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Create sampler layout shader value.\r\n     * @param pParameter - Creation parameter.\r\n     */\r\n    private createSamplerLayout(pParameter: ShaderValueCreationParameter): ShaderValue {\r\n        if (pParameter.typeDefinition.type !== 'buildIn') {\r\n            throw new Exception('Type not supported.', this);\r\n        }\r\n\r\n        const lSamplerType: SamplerType = (pParameter.typeDefinition.typeName === WgslType.Sampler) ? SamplerType.Filter : SamplerType.Comparison;\r\n\r\n        const lSamplerMemoryLayout: SamplerMemoryLayout = new SamplerMemoryLayout(this.device, {\r\n            samplerType: lSamplerType,\r\n            access: pParameter.accessMode,\r\n            bindingIndex: pParameter.memoryIndex.binding,\r\n            name: pParameter.valueDefinition.name,\r\n            visibility: pParameter.visibility\r\n        });\r\n\r\n        return {\r\n            group: pParameter.groupIndex,\r\n            value: lSamplerMemoryLayout\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Create struct buffer layout shader value.\r\n     * @param pParameter - Creation parameter.\r\n     */\r\n    private createStructBufferLayout(pParameter: ShaderValueCreationParameter): ShaderValue {\r\n        if (pParameter.typeDefinition.type !== 'struct') {\r\n            throw new Exception('Type not supported.', this);\r\n        }\r\n\r\n        const lStructMemoryLayout: StructBufferMemoryLayout = new StructBufferMemoryLayout(this.device, {\r\n            structName: pParameter.typeDefinition.struct.name,\r\n            bindType: pParameter.bufferBindType,\r\n            access: pParameter.accessMode,\r\n            bindingIndex: pParameter.memoryIndex.binding,\r\n            name: pParameter.valueDefinition.name,\r\n            visibility: pParameter.visibility\r\n        });\r\n\r\n        // Add all properties.\r\n        for (let lPropertyIndex: number = 0; lPropertyIndex < pParameter.typeDefinition.struct.properties.length; lPropertyIndex++) {\r\n            const lProperty: ShaderValue = pParameter.typeDefinition.struct.properties[lPropertyIndex];\r\n            lStructMemoryLayout.addProperty(lPropertyIndex, <BaseBufferMemoryLayout>lProperty.value);\r\n        }\r\n\r\n        return {\r\n            group: pParameter.groupIndex,\r\n            value: lStructMemoryLayout\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Create struct buffer layout shader value.\r\n     * @param pParameter - Creation parameter.\r\n     */\r\n    private createTextureLayout(pParameter: ShaderValueCreationParameter): ShaderValue {\r\n        if (pParameter.typeDefinition.type !== 'buildIn') {\r\n            throw new Exception('Type not supported.', this);\r\n        }\r\n\r\n        const lTextureWgslType: WgslTextureTypes = <any>pParameter.typeDefinition.typeName;\r\n\r\n        // Uses multisamples or not.\r\n        const lUsesMultisample: boolean = (lTextureWgslType === WgslType.TextureMultisampled2d || lTextureWgslType === WgslType.TextureDepthMultisampled2d);\r\n\r\n        const lTextureLayout = new TextureMemoryLayout(this.device, {\r\n            dimension: this.textureDimensionFromType(lTextureWgslType),\r\n            format: this.textureDefaultFormatFromType(lTextureWgslType),\r\n            bindType: this.textureBindTypeFromType(lTextureWgslType),\r\n            multisampled: lUsesMultisample,\r\n            access: pParameter.accessMode,\r\n            bindingIndex: pParameter.memoryIndex.binding,\r\n            name: pParameter.valueDefinition.name,\r\n            visibility: pParameter.visibility\r\n        });\r\n\r\n        return {\r\n            group: pParameter.groupIndex,\r\n            value: lTextureLayout\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Find all variable definitions and fetch data.\r\n     * @param pSourceSnipped - Source snipped with variables.\r\n     */\r\n    private fetchVariableDefinitions(pSourceSnipped: string): Array<ShaderValueDefinition> {\r\n        const lDefinitionRegex: RegExp = /(?<attributes>(?:@[\\w]+(?:\\([^)]*\\))?\\s+)+)?(?:var(?:<(?<access>[\\w\\s,]+)?>)?\\s+)?(?:(?<variable>\\w+)\\s*:\\s*)?(?<type>(?<typename>\\w+)(?:<(?<generics>[<>\\w\\s,]+)>)?)/gm;\r\n\r\n        const lVariableList: Array<ShaderValueDefinition> = new Array<ShaderValueDefinition>();\r\n        for (const lDefinitionMatch of pSourceSnipped.matchAll(lDefinitionRegex)) {\r\n            const lVariableTypeName: string = lDefinitionMatch.groups!['typename'];\r\n            const lVariableName: string = lDefinitionMatch.groups!['variable'] ?? '';\r\n            const lVariableAttributes: string | null = lDefinitionMatch.groups!['attributes'];\r\n            const lVariableAccess: string | null = lDefinitionMatch.groups!['access'];\r\n            const lVariableGenerics: string | null = lDefinitionMatch.groups!['generics'];\r\n\r\n            const lAttachments: Record<string, string> = {};\r\n\r\n            // Fetch attributes.\r\n            if (lVariableAttributes) {\r\n                // Split string of multiple attributes.\r\n                for (const lAttributeMatch of lVariableAttributes.matchAll(/@(?<name>[\\w])+\\((?<value>[^)]*)\\)/g)) {\r\n                    const lAttributeName: string = lAttributeMatch.groups!['name'];\r\n                    const lAttributeValue: string = lAttributeMatch.groups!['value'];\r\n\r\n                    // Add each attribute as value attachment.\r\n                    lAttachments[lAttributeName] = lAttributeValue;\r\n                }\r\n            }\r\n\r\n            // Parse optional acccess modifier.\r\n            if (lVariableAccess) {\r\n                // var<bindType|addressSpace [,accessMode]> => var<storage, read>\r\n                const lAccessList: Array<string> = lVariableAccess.split(',').map((pValue: string) => pValue.trim()).filter((pValue: string) => pValue.length);\r\n\r\n                // Add bind type attachment.\r\n                lAttachments['bindingType'] = lAccessList[0];\r\n\r\n                // Add optional accessMode attachment.\r\n                if (lAccessList[1]) {\r\n                    lAttachments['accessMode'] = lAccessList[1];\r\n                }\r\n            }\r\n\r\n            // Split generic types.\r\n            const lGenericList: Array<string> = new Array<string>();\r\n            if (lVariableGenerics) {\r\n                for (const lGenericMatch of lVariableGenerics.matchAll(/(?<generictype>(?:\\w+(?:<.+>)?))[,\\s]*/g)) {\r\n                    lGenericList.push(lGenericMatch.groups!['generictype']);\r\n                }\r\n            }\r\n\r\n            lVariableList.push({\r\n                name: lVariableName,\r\n                type: this.typeFor(lVariableTypeName, lGenericList),\r\n                typeGenerics: lGenericList,\r\n                attachments: lAttachments,\r\n            });\r\n        }\r\n\r\n        return lVariableList;\r\n    }\r\n\r\n    /**\r\n     * Read texture bind type from texture wgsl type. \r\n     * @param pTextureType - Texture wgsl type.\r\n     * @returns \r\n     */\r\n    private textureBindTypeFromType(pTextureType: WgslTextureTypes): TextureBindType {\r\n        // Map every texture type for bind type.\r\n        switch (pTextureType) {\r\n            case WgslType.TextureExternal: {\r\n                return TextureBindType.External;\r\n            }\r\n\r\n            case WgslType.TextureStorage1d:\r\n            case WgslType.TextureStorage2d:\r\n            case WgslType.TextureStorage2dArray:\r\n            case WgslType.TextureStorage3d: {\r\n                return TextureBindType.Storage;\r\n            }\r\n\r\n            case WgslType.Texture1d:\r\n            case WgslType.TextureDepth2d:\r\n            case WgslType.Texture2d:\r\n            case WgslType.TextureDepthMultisampled2d:\r\n            case WgslType.TextureMultisampled2d:\r\n            case WgslType.TextureDepth2dArray:\r\n            case WgslType.Texture2dArray:\r\n            case WgslType.Texture3d:\r\n            case WgslType.TextureCube:\r\n            case WgslType.TextureDepthCube:\r\n            case WgslType.TextureCubeArray:\r\n            case WgslType.TextureDepthCubeArray: {\r\n                return TextureBindType.Images;\r\n            }\r\n\r\n            default: {\r\n                throw new Exception(`Texture type \"${pTextureType}\" not supported for any texture bind type.`, null);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Work in process texture format from texture type.\r\n     * @param pTextureType - Texture type.\r\n     */\r\n    private textureDefaultFormatFromType(pTextureType: WgslTextureTypes): TextureFormat {\r\n        // Map every texture type for view dimension.\r\n        switch (pTextureType) {\r\n            case WgslType.Texture1d:\r\n            case WgslType.TextureStorage1d:\r\n            case WgslType.Texture2d:\r\n            case WgslType.TextureStorage2d:\r\n            case WgslType.TextureMultisampled2d:\r\n            case WgslType.TextureExternal:\r\n            case WgslType.Texture2dArray:\r\n            case WgslType.TextureStorage2dArray:\r\n            case WgslType.Texture3d:\r\n            case WgslType.TextureStorage3d:\r\n            case WgslType.TextureCube:\r\n            case WgslType.TextureCubeArray: {\r\n                return TextureFormat.BlueRedGreenAlpha;\r\n            }\r\n\r\n            case WgslType.TextureDepth2dArray:\r\n            case WgslType.TextureDepthCubeArray:\r\n            case WgslType.TextureDepthCube:\r\n            case WgslType.TextureDepthMultisampled2d:\r\n            case WgslType.TextureDepth2d: {\r\n                return TextureFormat.DepthStencil;\r\n            }\r\n\r\n            default: {\r\n                throw new Exception(`Texture type \"${pTextureType}\" not supported for any texture dimension.`, null);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Read texture dimension from texture type.\r\n     * @param pTextureType - Texture type.\r\n     */\r\n    private textureDimensionFromType(pTextureType: WgslTextureTypes): TextureDimension {\r\n        // Map every texture type for view dimension.\r\n        switch (pTextureType) {\r\n            case WgslType.Texture1d:\r\n            case WgslType.TextureStorage1d: {\r\n                return TextureDimension.OneDimension;\r\n            }\r\n\r\n            case WgslType.TextureDepth2d:\r\n            case WgslType.Texture2d:\r\n            case WgslType.TextureStorage2d:\r\n            case WgslType.TextureDepthMultisampled2d:\r\n            case WgslType.TextureMultisampled2d:\r\n            case WgslType.TextureExternal: {\r\n                return TextureDimension.TwoDimension;\r\n            }\r\n\r\n            case WgslType.TextureDepth2dArray:\r\n            case WgslType.Texture2dArray:\r\n            case WgslType.TextureStorage2dArray: {\r\n                return TextureDimension.TwoDimensionArray;\r\n            }\r\n\r\n            case WgslType.Texture3d:\r\n            case WgslType.TextureStorage3d: {\r\n                return TextureDimension.ThreeDimension;\r\n            }\r\n\r\n            case WgslType.TextureCube:\r\n            case WgslType.TextureDepthCube: {\r\n                return TextureDimension.Cube;\r\n            }\r\n\r\n            case WgslType.TextureCubeArray:\r\n            case WgslType.TextureDepthCubeArray: {\r\n                return TextureDimension.CubeArray;\r\n            }\r\n\r\n            default: {\r\n                throw new Exception(`Texture type \"${pTextureType}\" not supported for any texture dimension.`, null);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ntype ShaderValueCreationParameter = {\r\n    typeDefinition: ShaderType;\r\n    valueDefinition: ShaderValueDefinition;\r\n    bufferBindType: BufferBindType;\r\n    accessMode: AccessMode;\r\n    visibility: ComputeStage;\r\n    groupIndex: number | null;\r\n    memoryIndex: {\r\n        binding: number | null;\r\n        location: number | null;\r\n    };\r\n};","export enum WgslType {\r\n    // Scalar types.\r\n    Boolean = 'bool',\r\n    Integer32 = 'i32',\r\n    UnsignedInteger32 = 'u32',\r\n    Float32 = 'f32',\r\n    Float16 = 'f16',\r\n\r\n    // Vector types.\r\n    Vector2 = 'vec2',\r\n    Vector3 = 'vec3',\r\n    Vector4 = 'vec4',\r\n\r\n    // Matrix types.\r\n    Matrix22 = 'mat2x2',\r\n    Matrix23 = 'mat2x3',\r\n    Matrix24 = 'mat2x4',\r\n    Matrix32 = 'mat3x2',\r\n    Matrix33 = 'mat3x3',\r\n    Matrix34 = 'mat3x4',\r\n    Matrix42 = 'mat4x2',\r\n    Matrix43 = 'mat4x3',\r\n    Matrix44 = 'mat4x4',\r\n\r\n    // Container.\r\n    Array = 'array',\r\n\r\n    //Special.\r\n    Atomic = 'atomic',\r\n    Pointer = 'ptr',\r\n    Reference = 'ref',\r\n\r\n    // Textures.\r\n    Texture1d = 'texture_1d',\r\n    Texture2d = 'texture_2d',\r\n    Texture2dArray = 'texture_2d_array',\r\n    Texture3d = 'texture_3d',\r\n    TextureCube = 'texture_cube',\r\n    TextureCubeArray = 'texture_cube_array',\r\n    TextureMultisampled2d = 'texture_multisampled_2d',\r\n    TextureExternal = 'texture_external',\r\n\r\n    // Depth texture.\r\n    TextureDepth2d = 'texture_depth_2d',\r\n    TextureDepth2dArray = 'texture_depth_2d_array',\r\n    TextureDepthCube = 'texture_depth_cube',\r\n    TextureDepthCubeArray = 'texture_depth_cube_array',\r\n    TextureDepthMultisampled2d = 'texture_depth_multisampled_2d',\r\n\r\n    // Storage textures.\r\n    TextureStorage1d = 'texture_storage_1d',\r\n    TextureStorage2d = 'texture_storage_2d',\r\n    TextureStorage2dArray = 'texture_storage_2d_array',\r\n    TextureStorage3d = 'texture_storage_3d',\r\n\r\n    // Sampler.\r\n    Sampler = 'sampler',\r\n    SamplerComparison = 'sampler_comparison'\r\n}\r\n\r\nexport const WgslBufferLinearTypes = [\r\n    WgslType.Boolean, WgslType.Integer32, WgslType.UnsignedInteger32,\r\n    WgslType.Float32, WgslType.Float16, WgslType.Vector2,\r\n    WgslType.Vector3, WgslType.Vector4, WgslType.Matrix22, WgslType.Matrix23,\r\n    WgslType.Matrix24, WgslType.Matrix32, WgslType.Matrix33,\r\n    WgslType.Matrix34, WgslType.Matrix42, WgslType.Matrix43,\r\n    WgslType.Matrix44,\r\n] as const;\r\nexport type WgslBufferLinearTypes = typeof WgslBufferLinearTypes[number];\r\n\r\nexport const WgslBufferArrayTypes = [WgslType.Array] as const;\r\nexport type WgslBufferArrayTypes = typeof WgslBufferArrayTypes[number];\r\n\r\nexport const WgslTextureTypes = [\r\n    WgslType.Texture1d, WgslType.Texture2d, WgslType.Texture2dArray,\r\n    WgslType.Texture3d, WgslType.TextureCube, WgslType.TextureCubeArray,\r\n    WgslType.TextureMultisampled2d, WgslType.TextureExternal,\r\n    WgslType.TextureDepth2d, WgslType.TextureDepth2dArray,\r\n    WgslType.TextureDepthCube, WgslType.TextureDepthCubeArray,\r\n    WgslType.TextureDepthMultisampled2d, WgslType.TextureStorage1d,\r\n    WgslType.TextureStorage2d, WgslType.TextureStorage2dArray, WgslType.TextureStorage3d\r\n] as const;\r\nexport type WgslTextureTypes = typeof WgslTextureTypes[number];\r\n\r\nexport const WgslSamplerTypes = [WgslType.Sampler, WgslType.SamplerComparison] as const;\r\nexport type WgslSamplerTypes = typeof WgslSamplerTypes[number];\r\n","import { AccessMode } from '../../constant/access-mode.enum';\r\nimport { ComputeStage } from '../../constant/compute-stage.enum';\r\nimport { MemoryCopyType } from '../../constant/memory-copy-type.enum';\r\nimport { GpuDevice } from '../gpu/gpu-device';\r\nimport { GpuObject } from '../gpu/gpu-object';\r\nimport { UpdateReason } from '../gpu/gpu-object-update-reason';\r\n\r\nexport abstract class BaseMemoryLayout extends GpuObject {\r\n    private readonly mAccessMode: AccessMode;\r\n    private readonly mBindingIndex: number | null;\r\n    \r\n    private mMemoryType: MemoryCopyType;\r\n    private readonly mName: string;\r\n    private readonly mVisibility: ComputeStage;\r\n\r\n    /**\r\n     * Buffer type access mode.\r\n     */\r\n    public get accessMode(): AccessMode {\r\n        return this.mAccessMode;\r\n    }\r\n\r\n    /**\r\n     * Get binding index.\r\n     */\r\n    public get bindingIndex(): number | null {\r\n        return this.mBindingIndex;\r\n    }\r\n\r\n    /**\r\n     * Memory type.\r\n     */\r\n    public get memoryType(): MemoryCopyType {\r\n        return this.mMemoryType;\r\n    } set memoryType(pValue: MemoryCopyType) {\r\n        this.mMemoryType = pValue;\r\n\r\n        // Request update.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Variable name of buffer.\r\n     */\r\n    public get name(): string {\r\n        return this.mName;\r\n    }\r\n\r\n    /**\r\n     * Memory visibility on compute state.\r\n     */\r\n    public get visibility(): ComputeStage {\r\n        return this.mVisibility;\r\n    }\r\n\r\n    /**\r\n     * Constuctor.\r\n     * @param pParameter - Parameter.\r\n     */\r\n    public constructor(pGpu: GpuDevice, pParameter: MemoryLayoutParameter) {\r\n        super(pGpu);\r\n\r\n        this.mAccessMode = pParameter.access;\r\n        this.mName = pParameter.name;\r\n        this.mVisibility = pParameter.visibility;\r\n        this.mMemoryType = MemoryCopyType.None;\r\n\r\n        // Set optional memory indices.\r\n        this.mBindingIndex = pParameter.bindingIndex ?? null;\r\n    }\r\n}\r\n\r\nexport interface MemoryLayoutParameter {\r\n    access: AccessMode;\r\n    bindingIndex: number | null;\r\n    name: string;\r\n    visibility: ComputeStage;\r\n}","import { Exception } from '@kartoffelgames/core.data';\r\nimport { GpuDevice } from '../../gpu/gpu-device';\r\nimport { BufferLayoutLocation, BaseBufferMemoryLayout, BufferMemoryLayoutParameter } from './base-buffer-memory-layout';\r\n\r\nexport class ArrayBufferMemoryLayout extends BaseBufferMemoryLayout {\r\n    private readonly mArraySize: number;\r\n    private readonly mInnerType: BaseBufferMemoryLayout;\r\n\r\n    /**\r\n     * Alignment of type.\r\n     */\r\n    public get alignment(): number {\r\n        return this.innerType.alignment;\r\n    }\r\n\r\n    /**\r\n     * Array item count.\r\n     */\r\n    public get arraySize(): number {\r\n        return this.mArraySize;\r\n    }\r\n\r\n    /**\r\n     * Array type.\r\n     */\r\n    public get innerType(): BaseBufferMemoryLayout {\r\n        return this.mInnerType;\r\n    }\r\n\r\n    /**\r\n     * Type size in byte.\r\n     */\r\n    public get size(): number {\r\n        if (this.arraySize === -1) {\r\n            return this.arraySize;\r\n        }\r\n\r\n        return this.arraySize * (Math.ceil(this.innerType.size / this.innerType.alignment) * this.innerType.alignment);\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pParameter - Parameter.\r\n     */\r\n    public constructor(pGpu: GpuDevice, pParameter: ArrayBufferMemoryLayoutParameter) {\r\n        super(pGpu, pParameter);\r\n\r\n        // Static properties.\r\n        this.mArraySize = pParameter.arraySize;\r\n        this.mInnerType = pParameter.innerType;\r\n\r\n        // Set inner type parent.\r\n        pParameter.innerType.parent = this;\r\n    }\r\n\r\n    /**\r\n     * Get location of path.\r\n     * @param pPathName - Path name. Divided by dots.\r\n     */\r\n    public override locationOf(pPathName: Array<string>): BufferLayoutLocation {\r\n        const lPathName: Array<string> = [...pPathName];\r\n\r\n        // Complete array.\r\n        const lItemIndexString: string | undefined = lPathName.shift();\r\n        if (!lItemIndexString) {\r\n            // Only valid for ststic arrays.\r\n            if (this.mArraySize < 0) {\r\n                throw new Exception('No size can be calculated for dynamic array buffer locations.', this);\r\n            }\r\n\r\n            return { size: this.size, offset: 0 };\r\n        }\r\n\r\n        // Validate item index.\r\n        if (isNaN(<any>lItemIndexString)) {\r\n            throw new Exception('Array index must be a number.', this);\r\n        }\r\n\r\n        // Calculate size of single item.s\r\n        const lArrayItemSize: number = Math.ceil(this.innerType.size / this.innerType.alignment) * this.innerType.alignment;\r\n        const lArrayItemOffset: number = parseInt(lItemIndexString) * lArrayItemSize;\r\n\r\n        // Single item.\r\n        if (lPathName.length === 0) {\r\n            return { size: lArrayItemSize, offset: lArrayItemSize * lArrayItemOffset };\r\n        }\r\n\r\n        // Inner property.\r\n        const lInnerLocation = this.innerType.locationOf(lPathName);\r\n        return { size: lInnerLocation.size, offset: lArrayItemOffset + lInnerLocation.offset };\r\n    }\r\n}\r\n\r\nexport interface ArrayBufferMemoryLayoutParameter extends BufferMemoryLayoutParameter {\r\n    // New.\r\n    arraySize: number;\r\n    innerType: BaseBufferMemoryLayout;\r\n}","import { Exception, TypedArray } from '@kartoffelgames/core.data';\r\nimport { BufferBindType } from '../../../constant/buffer-bind-type.enum';\r\nimport { GpuBuffer } from '../../buffer/gpu-buffer';\r\nimport { GpuDevice } from '../../gpu/gpu-device';\r\nimport { BaseMemoryLayout, MemoryLayoutParameter } from '../base-memory-layout';\r\n\r\nexport abstract class BaseBufferMemoryLayout extends BaseMemoryLayout {\r\n    private readonly mBindType: BufferBindType;\r\n    private mParent: BaseBufferMemoryLayout | null;\r\n\r\n    /**\r\n     * Type byte alignment.\r\n     */\r\n    public abstract readonly alignment: number;\r\n\r\n    /**\r\n     * Buffer size in bytes.\r\n     */\r\n    public abstract readonly size: number;\r\n\r\n    /**\r\n     * Buffer bind type.\r\n     */\r\n    public get bindType(): BufferBindType {\r\n        return this.mBindType;\r\n    }\r\n\r\n    /**\r\n     * Parent type. Stuct or Array.\r\n     */\r\n    public get parent(): BaseBufferMemoryLayout | null {\r\n        return this.mParent;\r\n    } public set parent(pValue: BaseBufferMemoryLayout | null) {\r\n        this.mParent = pValue;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pParameter - Parameter.\r\n     */\r\n    public constructor(pGpu: GpuDevice, pParameter: BufferMemoryLayoutParameter) {\r\n        super(pGpu, pParameter);\r\n\r\n        // Static properties.\r\n        this.mBindType = pParameter.bindType;\r\n        this.mParent = null;\r\n    }\r\n\r\n    /**\r\n     * Create buffer from current layout.\r\n     * @param pInitialData - Inital buffer data.\r\n     */\r\n    public create<TType extends TypedArray>(pInitialData: TType): GpuBuffer<TType> {\r\n        return new GpuBuffer<TType>(this.device, this, pInitialData);\r\n    }\r\n\r\n    /**\r\n     * Get location of path.\r\n     * @param pPathName - Path name. Divided by dots.\r\n     */\r\n    public locationOf(pPathName: Array<string>): BufferLayoutLocation {\r\n        // Only validate name.\r\n        if (pPathName.length !== 0) {\r\n            throw new Exception(`Simple buffer layout has no properties.`, this);\r\n        }\r\n\r\n        return { size: this.size, offset: 0 };\r\n    }\r\n}\r\n\r\nexport interface BufferMemoryLayoutParameter extends MemoryLayoutParameter {\r\n    bindType: BufferBindType;\r\n}\r\n\r\nexport type BufferLayoutLocation = {\r\n    offset: number;\r\n    size: number;\r\n};","import { BufferPrimitiveFormat } from '../../../constant/buffer-primitive-format';\r\nimport { GpuDevice } from '../../gpu/gpu-device';\r\nimport { BaseBufferMemoryLayout, BufferMemoryLayoutParameter } from './base-buffer-memory-layout';\r\n\r\nexport class LinearBufferMemoryLayout extends BaseBufferMemoryLayout {\r\n    private readonly mAlignment: number;\r\n    private readonly mFormat: BufferPrimitiveFormat;\r\n    private readonly mLocationIndex: number | null;\r\n    private readonly mSize: number;\r\n\r\n    /**\r\n     * Type byte alignment.\r\n     */\r\n    public get alignment(): number {\r\n        return this.mAlignment;\r\n    }\r\n\r\n    /**\r\n     * Primitive format\r\n     */\r\n    public get format(): BufferPrimitiveFormat {\r\n        return this.mFormat;\r\n    }\r\n\r\n    /**\r\n     * Get parameter index.\r\n     */\r\n    public get locationIndex(): number | null {\r\n        return this.mLocationIndex;\r\n    }\r\n\r\n    /**\r\n     * Buffer size in bytes.\r\n     */\r\n    public get size(): number {\r\n        return this.mSize;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pParameter - Parameter.\r\n     */\r\n    public constructor(pGpu: GpuDevice, pParameter: LinearBufferMemoryLayoutParameter) {\r\n        super(pGpu, pParameter);\r\n\r\n        // Static properties.\r\n        this.mAlignment = pParameter.alignment;\r\n        this.mSize = pParameter.size;\r\n        this.mFormat = pParameter.primitiveFormat;\r\n        this.mLocationIndex = pParameter.locationIndex ?? null;\r\n    }\r\n}\r\n\r\nexport interface LinearBufferMemoryLayoutParameter extends BufferMemoryLayoutParameter {\r\n    size: number;\r\n    alignment: number;\r\n    primitiveFormat: BufferPrimitiveFormat;\r\n    locationIndex: number | null;\r\n}","import { Exception } from '@kartoffelgames/core.data';\r\nimport { GpuDevice } from '../../gpu/gpu-device';\r\nimport { BaseBufferMemoryLayout, BufferLayoutLocation, BufferMemoryLayoutParameter } from './base-buffer-memory-layout';\r\nimport { LinearBufferMemoryLayout } from './linear-buffer-memory-layout';\r\n\r\nexport class StructBufferMemoryLayout extends BaseBufferMemoryLayout {\r\n    private mAlignment: number;\r\n    private mInnerProperties: Array<[number, BaseBufferMemoryLayout]>;\r\n    private mSize: number;\r\n    private readonly mStructName: string;\r\n\r\n    /**\r\n     * Alignment of type.\r\n     */\r\n    public get alignment(): number {\r\n        return this.mAlignment;\r\n    }\r\n\r\n    /**\r\n     * Ordered inner properties.\r\n     */\r\n    public get properties(): Array<BaseBufferMemoryLayout> {\r\n        return this.mInnerProperties.map((pProperty) => pProperty[1]);\r\n    }\r\n\r\n    /**\r\n     * Type size in byte.\r\n     */\r\n    public get size(): number {\r\n        return this.mSize;\r\n    }\r\n\r\n    /**\r\n     * Struct name.\r\n     */\r\n    public get structName(): string {\r\n        return this.mStructName;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pParameter - Parameter.\r\n     */\r\n    public constructor(pGpu: GpuDevice, pParameter: StructBufferMemoryLayoutParameter) {\r\n        super(pGpu, pParameter);\r\n\r\n        // Calculated properties.\r\n        this.mAlignment = 0;\r\n        this.mSize = 0;\r\n\r\n        // Static properties.\r\n        this.mStructName = pParameter.structName;\r\n        this.mInnerProperties = new Array<[number, BaseBufferMemoryLayout]>();\r\n    }\r\n\r\n    /**\r\n     * Add property to struct.\r\n     * @param pName - Property name.\r\n     * @param pOrder - Index of property.\r\n     * @param pType - Property type.\r\n     */\r\n    public addProperty(pOrder: number, pType: BaseBufferMemoryLayout): void {\r\n        this.mInnerProperties.push([pOrder, pType]);\r\n        pType.parent = this;\r\n\r\n        // Order properties.\r\n        this.mInnerProperties = this.mInnerProperties.sort((pA, pB) => {\r\n            return pA[0] - pB[0];\r\n        });\r\n\r\n        // Call recalculation. Or other usefull things.\r\n        this.recalculateAlignment();\r\n    }\r\n\r\n    /**\r\n     * Get types of properties with a set memory index.\r\n     */\r\n    public bindingLayouts(): Array<BaseBufferMemoryLayout> {\r\n        const lLocationTypes: Array<BaseBufferMemoryLayout> = new Array<BaseBufferMemoryLayout>();\r\n\r\n        // Include itself.\r\n        if (this.bindingIndex !== null) {\r\n            lLocationTypes.push(this);\r\n        }\r\n\r\n        // Check all properties.\r\n        for (const [, lPropertyType] of this.mInnerProperties.values()) {\r\n            // Get all inner locations when property is a struct type.\r\n            if (lPropertyType instanceof StructBufferMemoryLayout) {\r\n                // Result does include itself \r\n                lLocationTypes.push(...lPropertyType.bindingLayouts());\r\n            } else if (lPropertyType.bindingIndex !== null) {\r\n                lLocationTypes.push(lPropertyType);\r\n            }\r\n        }\r\n\r\n        return lLocationTypes;\r\n    }\r\n\r\n    /**\r\n     * Get types of properties with a set memory index.\r\n     */\r\n    public locationLayouts(): Array<LinearBufferMemoryLayout> {\r\n        const lLocationTypes: Array<LinearBufferMemoryLayout> = new Array<LinearBufferMemoryLayout>();\r\n\r\n        // Check all properties.\r\n        for (const [, lPropertyType] of this.mInnerProperties.values()) {\r\n            // Get all inner locations when property is a struct type.\r\n            if (lPropertyType instanceof StructBufferMemoryLayout) {\r\n                // Result does include itself \r\n                lLocationTypes.push(...lPropertyType.locationLayouts());\r\n            } else if (lPropertyType instanceof LinearBufferMemoryLayout && lPropertyType.locationIndex !== null) {\r\n                lLocationTypes.push(lPropertyType);\r\n            }\r\n        }\r\n\r\n        return lLocationTypes;\r\n    }\r\n\r\n    /**\r\n     * Get location of path.\r\n     * @param pPathName - Path name. Divided by dots.\r\n     */\r\n    public override locationOf(pPathName: Array<string>): BufferLayoutLocation {\r\n        const lPathName: Array<string> = [...pPathName];\r\n\r\n        // Complete array.\r\n        const lPropertyName: string | undefined = lPathName.shift();\r\n        if (!lPropertyName) {\r\n            return { size: this.size, offset: 0 };\r\n        }\r\n\r\n        // Get ordered types.\r\n        const lOrderedTypeList: Array<BaseBufferMemoryLayout> = this.mInnerProperties.sort(([pOrderA], [pOrderB]) => {\r\n            return pOrderA - pOrderB;\r\n        }).map(([, pType]) => pType);\r\n\r\n        // Recalculate size.\r\n        let lPropertyOffset: number = 0;\r\n        let lPropertyLayout: BaseBufferMemoryLayout | null = null;\r\n        for (const lProperty of lOrderedTypeList) {\r\n            // Increase offset to needed alignment.\r\n            lPropertyOffset = Math.ceil(lPropertyOffset / lProperty.alignment) * lProperty.alignment;\r\n\r\n            // Inner property is found. Skip searching.\r\n            // Alignment just applied so it can be skipped later.\r\n            if (lProperty.name === lPropertyName) {\r\n                lPropertyLayout = lProperty;\r\n                break;\r\n            }\r\n\r\n            // Increase offset for complete property.\r\n            lPropertyOffset += lProperty.size;\r\n        }\r\n\r\n        // Validate property.\r\n        if (!lPropertyLayout) {\r\n            throw new Exception(`Struct buffer layout property \"${lPropertyName}\" not found.`, this);\r\n        }\r\n\r\n        const lPropertyLocation = lPropertyLayout.locationOf(lPathName);\r\n        return {\r\n            size: lPropertyLocation.size,\r\n            offset: lPropertyOffset + lPropertyLocation.offset\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Recalculate size and alignment.\r\n     */\r\n    private recalculateAlignment(): void {\r\n        // Recalculate size.\r\n        let lRawDataSize: number = 0;\r\n        for (const lType of this.properties) {\r\n            // Increase offset to needed alignment.\r\n            lRawDataSize = Math.ceil(lRawDataSize / lType.alignment) * lType.alignment;\r\n\r\n            // Increase offset for type.\r\n            lRawDataSize += lType.size;\r\n\r\n            if (lType.alignment > this.mAlignment) {\r\n                this.mAlignment = lType.alignment;\r\n            }\r\n        }\r\n\r\n        // Apply struct alignment to raw data size.\r\n        this.mSize = Math.ceil(lRawDataSize / this.mAlignment) * this.mAlignment;\r\n    }\r\n}\r\n\r\nexport interface StructBufferMemoryLayoutParameter extends BufferMemoryLayoutParameter {\r\n    structName: string;\r\n}","import { SamplerType } from '../../constant/sampler-type.enum';\r\nimport { GpuDevice } from '../gpu/gpu-device';\r\nimport { TextureSampler } from '../texture/texture-sampler';\r\nimport { BaseMemoryLayout, MemoryLayoutParameter } from './base-memory-layout';\r\n\r\nexport class SamplerMemoryLayout extends BaseMemoryLayout {\r\n    private readonly mSamplerType: SamplerType;\r\n\r\n    /**\r\n     * Sampler type.\r\n     */\r\n    public get samplerType(): SamplerType {\r\n        return this.mSamplerType;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pParameter - Parameter.\r\n     */\r\n    public constructor(pGpu: GpuDevice, pParameter: SamplerMemoryLayoutParameter) {\r\n        super(pGpu, pParameter);\r\n\r\n        this.mSamplerType = pParameter.samplerType;\r\n    }\r\n\r\n    /**\r\n     * Create texture sampler.\r\n     */\r\n    public create(): TextureSampler {\r\n        return new TextureSampler(this.device, this);\r\n    }\r\n}\r\n\r\nexport interface SamplerMemoryLayoutParameter extends MemoryLayoutParameter {\r\n    samplerType: SamplerType;\r\n}","import { TextureBindType } from '../../constant/texture-bind-type.enum';\r\nimport { TextureDimension } from '../../constant/texture-dimension.enum';\r\nimport { TextureFormat } from '../../constant/texture-format.enum';\r\nimport { TextureUsage } from '../../constant/texture-usage.enum';\r\nimport { GpuDevice } from '../gpu/gpu-device';\r\nimport { UpdateReason } from '../gpu/gpu-object-update-reason';\r\nimport { CanvasTexture } from '../texture/canvas-texture';\r\nimport { FrameBufferTexture } from '../texture/frame-buffer-texture';\r\nimport { ImageTexture } from '../texture/image-texture';\r\nimport { VideoTexture } from '../texture/video-texture';\r\nimport { BaseMemoryLayout, MemoryLayoutParameter } from './base-memory-layout';\r\n\r\nexport class TextureMemoryLayout extends BaseMemoryLayout {\r\n    private readonly mBindType: TextureBindType;\r\n    private readonly mDimension: TextureDimension;\r\n    private readonly mFormat: TextureFormat;\r\n    private readonly mMultisampled: boolean;\r\n    private mUsage: TextureUsage;\r\n\r\n    /**\r\n     * Texture dimension.\r\n     */\r\n    public get bindType(): TextureBindType {\r\n        return this.mBindType;\r\n    }\r\n\r\n    /**\r\n     * Texture dimension.\r\n     */\r\n    public get dimension(): TextureDimension {\r\n        return this.mDimension;\r\n    }\r\n\r\n    /**\r\n     * Texture format.\r\n     */\r\n    public get format(): TextureFormat {\r\n        return this.mFormat;\r\n    }\r\n\r\n    /**\r\n     * Texture uses multisample.\r\n     */\r\n    public get multisampled(): boolean {\r\n        return this.mMultisampled;\r\n    }\r\n\r\n    /**\r\n     * Texture usage. // TODO: Move into creation.\r\n     */\r\n    public get usage(): TextureUsage {\r\n        return this.mUsage;\r\n    } set usage(pValue: TextureUsage) {\r\n        this.mUsage = pValue;\r\n\r\n        // Request update.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pParameter - Parameter.\r\n     */\r\n    public constructor(pGpu: GpuDevice, pParameter: TextureMemoryLayoutParameter) {\r\n        super(pGpu, pParameter);\r\n\r\n        this.mBindType = pParameter.bindType;\r\n        this.mDimension = pParameter.dimension;\r\n        this.mFormat = pParameter.format;\r\n        this.mUsage = TextureUsage.None;\r\n        this.mMultisampled = pParameter.multisampled;\r\n    }\r\n\r\n    /**\r\n     * Create canvas texture.\r\n     * @param pWidth - Texture width.\r\n     * @param pHeight - Texture height.\r\n     */\r\n    public createCanvasTexture(pWidth: number, pHeight: number): CanvasTexture {\r\n        // Create and set canvas sizes.\r\n        const lCanvasTexture: CanvasTexture = new CanvasTexture(this.device, this);\r\n        lCanvasTexture.width = pWidth;\r\n        lCanvasTexture.height = pHeight;\r\n\r\n        return lCanvasTexture;\r\n    }\r\n\r\n    /**\r\n     * Create frame buffer texture.\r\n     * @param pWidth - Texture width.\r\n     * @param pHeight - Texture height.\r\n     * @param pDepth - Texture depth.\r\n     */\r\n    public createFrameBufferTexture(pWidth: number, pHeight: number, pDepth: number): FrameBufferTexture {\r\n        // Create and set frame buffer sizes.\r\n        const lFrameBufferTexture: FrameBufferTexture = new FrameBufferTexture(this.device, this);\r\n        lFrameBufferTexture.width = pWidth;\r\n        lFrameBufferTexture.height = pHeight;\r\n        lFrameBufferTexture.depth = pDepth;\r\n\r\n        return lFrameBufferTexture;\r\n    }\r\n\r\n    /**\r\n     * Create texture from images.\r\n     * @param pSourceList - Image source list.\r\n     */\r\n    public async createImageTexture(...pSourceList: Array<string>): Promise<ImageTexture> {\r\n        // Create and load images async.\r\n        const lImageTexture: ImageTexture = new ImageTexture(this.device, this);\r\n        await lImageTexture.load(...pSourceList);\r\n\r\n        return lImageTexture;\r\n    }\r\n\r\n    /**\r\n     * Create texture from a video source.\r\n     * @param pSource - Video source.\r\n     */\r\n    public createVideoTexture(pSource: string): VideoTexture {\r\n        // Create and set video source.\r\n        const lVideoTexture: VideoTexture = new VideoTexture(this.device, this);\r\n        lVideoTexture.source = pSource;\r\n\r\n        return lVideoTexture;\r\n    }\r\n}\r\n\r\nexport interface TextureMemoryLayoutParameter extends MemoryLayoutParameter {\r\n    dimension: TextureDimension;\r\n    format: TextureFormat;\r\n    bindType: TextureBindType;\r\n    multisampled: boolean;\r\n}","import { Dictionary, Exception } from '@kartoffelgames/core.data';\r\nimport { GpuDevice } from '../../gpu/gpu-device';\r\nimport { GpuObject } from '../../gpu/gpu-object';\r\nimport { BaseBufferMemoryLayout } from '../../memory_layout/buffer/base-buffer-memory-layout';\r\nimport { StructBufferMemoryLayout } from '../../memory_layout/buffer/struct-buffer-memory-layout';\r\nimport { UpdateReason } from '../../gpu/gpu-object-update-reason';\r\nimport { LinearBufferMemoryLayout } from '../../memory_layout/buffer/linear-buffer-memory-layout';\r\nimport { VertexParameter } from './vertex-parameter';\r\n\r\nexport class VertexParameterLayout extends GpuObject {\r\n    private readonly mParameter: Dictionary<number, LinearBufferMemoryLayout>;\r\n    private readonly mParameterNames: Dictionary<string, number>;\r\n\r\n    /**\r\n     * Parameter count.\r\n     */\r\n    public get count(): number {\r\n        // Highest index plus one.\r\n        return Math.max(...this.mParameter.keys()) + 1;\r\n    }\r\n\r\n    /**\r\n     * Get all parameter names.\r\n     */\r\n    public get parameter(): Array<string> {\r\n        return [...this.mParameterNames.keys()];\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param pDevice - Device reference.\r\n     * @param pLayout - Buffer layout of parameter.\r\n     */\r\n    public constructor(pDevice: GpuDevice) {\r\n        super(pDevice);\r\n        this.mParameter = new Dictionary<number, LinearBufferMemoryLayout>();\r\n        this.mParameterNames = new Dictionary<string, number>();\r\n    }\r\n\r\n    /**\r\n     * Add parameter layout.\r\n     * @param pName - Parameter name.\r\n     * @param pLayout - Parameter layout.\r\n     */\r\n    public add(pLayout: StructBufferMemoryLayout | LinearBufferMemoryLayout): void {\r\n        // Find all childs of layout with locations.\r\n        const lLocationLayoutList: Array<LinearBufferMemoryLayout> = new Array<LinearBufferMemoryLayout>();\r\n        if (pLayout instanceof StructBufferMemoryLayout) {\r\n            lLocationLayoutList.push(...pLayout.locationLayouts());\r\n        } else if (pLayout instanceof LinearBufferMemoryLayout) {\r\n            lLocationLayoutList.push(pLayout);\r\n        }\r\n\r\n        // Validate existing parameter layout.\r\n        if (lLocationLayoutList.length === 0) {\r\n            throw new Exception('Pipeline parameter layout needs a parameter index.', this);\r\n        }\r\n\r\n        // Add each location as seperate parameter.\r\n        for (const lLocationLayout of lLocationLayoutList) {\r\n            // Validate existing parameter index.\r\n            if (lLocationLayout.locationIndex === null) {\r\n                throw new Exception('Pipeline parameter layout needs a parameter index.', this);\r\n            }\r\n\r\n            // Do not override existing parameter.\r\n            if (this.mParameter.has(lLocationLayout.locationIndex)) {\r\n                throw new Exception('Parameter does already exist.', this);\r\n            }\r\n\r\n            // Generate name by iterating its parents.\r\n            let lName: string = lLocationLayout.name;\r\n            let lParentLayout: BaseBufferMemoryLayout | null = lLocationLayout;\r\n            while ((lParentLayout = lParentLayout.parent) !== null) {\r\n                // Extend current name by its parent name.\r\n                lName = `${lParentLayout.name}.${lName}`;\r\n            }\r\n\r\n            // Link name with index and index with layout.\r\n            this.mParameterNames.set(lName, lLocationLayout.locationIndex);\r\n            this.mParameter.set(lLocationLayout.locationIndex, lLocationLayout);\r\n\r\n            // Register change listener for layout changes.\r\n            lLocationLayout.addUpdateListener(() => {\r\n                this.triggerAutoUpdate(UpdateReason.ChildData);\r\n            });\r\n        }\r\n\r\n        // Trigger update.\r\n        this.triggerAutoUpdate(UpdateReason.ChildData);\r\n    }\r\n\r\n    /**\r\n     * Create vertex parameters from layout.\r\n     * @param pIndexData - Index data.\r\n     */\r\n    public createData(pIndexData: Array<number>): VertexParameter {\r\n        return new VertexParameter(this.device, this, pIndexData);\r\n    }\r\n\r\n    /**\r\n     * Get index of parameter.\r\n     * @param pName - Parameter name.\r\n     */\r\n    public getIndexOf(pName: string): number {\r\n        // Validate name.\r\n        if (!this.mParameterNames.has(pName)) {\r\n            throw new Exception(`Parameter name \"${pName}\" does not exist`, this);\r\n        }\r\n\r\n        return this.mParameterNames.get(pName)!;\r\n    }\r\n\r\n    /**\r\n     * Get layout of name.\r\n     * @param pName - Parameter name.\r\n     */\r\n    public getLayoutOf(pName: string): LinearBufferMemoryLayout {\r\n        const lIndex: number = this.getIndexOf(pName);\r\n\r\n        // Layout should exist when it name exists.\r\n        return this.mParameter.get(lIndex)!;\r\n    }\r\n}\r\n\r\n","import { Dictionary, Exception } from '@kartoffelgames/core.data';\r\nimport { AccessMode } from '../../../constant/access-mode.enum';\r\nimport { BufferBindType } from '../../../constant/buffer-bind-type.enum';\r\nimport { BufferPrimitiveFormat } from '../../../constant/buffer-primitive-format';\r\nimport { ComputeStage } from '../../../constant/compute-stage.enum';\r\nimport { GpuBuffer } from '../../buffer/gpu-buffer';\r\nimport { GpuDevice } from '../../gpu/gpu-device';\r\nimport { GpuObject } from '../../gpu/gpu-object';\r\nimport { ArrayBufferMemoryLayout } from '../../memory_layout/buffer/array-buffer-memory-layout';\r\nimport { LinearBufferMemoryLayout } from '../../memory_layout/buffer/linear-buffer-memory-layout';\r\nimport { VertexParameterLayout } from './vertex-parameter-layout';\r\n\r\nexport class VertexParameter extends GpuObject {\r\n    private readonly mData: Dictionary<string, GpuBuffer<Float32Array>>;\r\n    private readonly mIndexBuffer: GpuBuffer<Uint32Array>;\r\n    private readonly mLayout: VertexParameterLayout;\r\n\r\n    /**\r\n     * Get index buffer.\r\n     */\r\n    public get indexBuffer(): GpuBuffer<Uint32Array> {\r\n        return this.mIndexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Get parameter layout.\r\n     */\r\n    public get layout(): VertexParameterLayout {\r\n        return this.mLayout;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Device reference.\r\n     * @param pVertexParameterLayout - Parameter layout.\r\n     * @param pIndices - Index buffer data.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pVertexParameterLayout: VertexParameterLayout, pIndices: Array<number>) {\r\n        super(pDevice);\r\n\r\n        // Set vertex parameter layout.\r\n        this.mLayout = pVertexParameterLayout;\r\n        this.mData = new Dictionary<string, GpuBuffer<Float32Array>>();\r\n\r\n        // Create index layout.\r\n        const lIndexLayout: LinearBufferMemoryLayout = new LinearBufferMemoryLayout(pDevice, {\r\n            primitiveFormat: BufferPrimitiveFormat.Uint,\r\n            bindType: BufferBindType.Index,\r\n            size: 4,\r\n            alignment: 4,\r\n            locationIndex: null,\r\n            access: AccessMode.Read,\r\n            bindingIndex: null,\r\n            name: '',\r\n            visibility: ComputeStage.Vertex\r\n        });\r\n\r\n        // Create index buffer layout.\r\n        const lIndexBufferLayout: ArrayBufferMemoryLayout = new ArrayBufferMemoryLayout(pDevice, {\r\n            innerType: lIndexLayout,\r\n            arraySize: pIndices.length,\r\n            bindType: BufferBindType.Index,\r\n            access: AccessMode.Read,\r\n            bindingIndex: null,\r\n            name: '',\r\n            visibility: ComputeStage.Vertex\r\n        });\r\n\r\n        // Create index buffer.\r\n        this.mIndexBuffer = lIndexBufferLayout.create(new Uint32Array(pIndices));\r\n    }\r\n\r\n    /**\r\n     * Get parameter buffer.\r\n     * @param pName - Parameter name.\r\n     */\r\n    public get(pName: string): GpuBuffer<Float32Array> {\r\n        // Validate.\r\n        if(!this.mData.has(pName)){\r\n            throw new Exception(`Vertex parameter \"${pName}\" not found.`, this);\r\n        }\r\n\r\n        return this.mData.get(pName)!;\r\n    }\r\n\r\n    /**\r\n     * Set parameter data.\r\n     * @param pName - Parameter name.\r\n     * @param pData - Parameter data.\r\n     */\r\n    public set(pName: string, pData: Array<number>): void {\r\n        const lBufferLayout: LinearBufferMemoryLayout = this.mLayout.getLayoutOf(pName);\r\n\r\n        // TODO: Load typed array from layout format.\r\n        const lParameterBuffer: GpuBuffer<Float32Array> = lBufferLayout.create(new Float32Array(pData));\r\n\r\n        // Save gpu buffer in correct index.\r\n        this.mData.set(pName, lParameterBuffer);\r\n    }\r\n}","import { Exception } from '@kartoffelgames/core.data';\r\nimport { TextureGroup } from './texture-group';\r\nimport { GpuObject } from '../../gpu/gpu-object';\r\nimport { GpuDevice } from '../../gpu/gpu-device';\r\nimport { FrameBufferTexture } from '../../texture/frame-buffer-texture';\r\nimport { CanvasTexture } from '../../texture/canvas-texture';\r\nimport { UpdateReason } from '../../gpu/gpu-object-update-reason';\r\nimport { TextureOperation } from '../../../constant/texture-operation';\r\nimport { TextureFormat } from '../../../constant/texture-format.enum';\r\n\r\n\r\nexport class RenderTargets extends GpuObject<'renderTargets'> {\r\n    private readonly mColorBuffer: Array<RenderTargetColorTexture>;\r\n    private mDepthBuffer: RenderTargetDepthStencilTexture | null;\r\n    private readonly mTextureGroup: TextureGroup;\r\n\r\n    /**\r\n     * Get all color buffer.\r\n     */\r\n    public get colorBuffer(): Array<RenderTargetColorTexture> {\r\n        return this.mColorBuffer;\r\n    }\r\n\r\n    /**\r\n     * Get depth stencil buffer.\r\n     */\r\n    public get depthStencilBuffer(): RenderTargetDepthStencilTexture | null {\r\n        return this.mDepthBuffer;\r\n    }\r\n\r\n    /**\r\n     * Render targets multisamples count.\r\n     */\r\n    public get multisampleCount(): number {\r\n        return this.mTextureGroup.multiSampleLevel;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Device.\r\n     * @param pTextureGroup - Texture group.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pTextureGroup: TextureGroup) {\r\n        super(pDevice);\r\n\r\n        this.mTextureGroup = pTextureGroup;\r\n        this.mColorBuffer = new Array<RenderTargetColorTexture>();\r\n\r\n        this.mDepthBuffer = null;\r\n    }\r\n\r\n    public addColorBuffer(pBufferName: string, pClearValue: number, pLoadOp: TextureOperation, pStoreOp: TextureOperation, pTargetName?: string): void {\r\n        // Read texture buffer from texture group.\r\n        const lColorBuffer: FrameBufferTexture = this.mTextureGroup.getBufferTextureOf(pBufferName);\r\n\r\n        // Read potential target buffer.\r\n        let lTargetBuffer: CanvasTexture | null = null;\r\n        if (pTargetName) {\r\n            lTargetBuffer = this.mTextureGroup.getTargetTextureOf(pTargetName);\r\n\r\n            // Add update listener.\r\n            lTargetBuffer.addUpdateListener(() => {\r\n                this.triggerAutoUpdate(UpdateReason.ChildData);\r\n            });\r\n        }\r\n\r\n        // Add update listener.\r\n        lColorBuffer.addUpdateListener(() => {\r\n            this.triggerAutoUpdate(UpdateReason.ChildData);\r\n        });\r\n\r\n        this.mColorBuffer.push({\r\n            texture: lColorBuffer,\r\n            clearValue: pClearValue,\r\n            loadOperation: pLoadOp,\r\n            storeOperation: pStoreOp,\r\n            resolveTarget: lTargetBuffer\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set depth and or stencil buffer.\r\n     * @param pBufferName - Buffer Texture name.\r\n     * @param pClearValue - Clear value in hex 0xffffff.\r\n     * @param pLoadOp - Operation on load.\r\n     * @param pStoreOp - Operation on store.\r\n     */\r\n    public setDepthStencilBuffer(pBufferName: string, pClearValue: number, pLoadOp: TextureOperation, pStoreOp: TextureOperation): void {\r\n        // Read texture buffer from texture group.\r\n        const lDepthBuffer: FrameBufferTexture = this.mTextureGroup.getBufferTextureOf(pBufferName);\r\n\r\n        // Validate depth or stencil format.\r\n        switch (lDepthBuffer.memoryLayout.format) {\r\n            case TextureFormat.Depth:\r\n            case TextureFormat.DepthStencil:\r\n            case TextureFormat.Stencil: {\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Exception('Depth and or stencil buffer needs to have depth or stencil texture formats.', this);\r\n            }\r\n        }\r\n\r\n        // Update depth buffer update listener.\r\n        if (this.mDepthBuffer) {\r\n            this.mDepthBuffer.texture.removeUpdateListener(this.onDepthBufferUpdate);\r\n        }\r\n        lDepthBuffer.addUpdateListener(this.onDepthBufferUpdate);\r\n\r\n        // Set new buffer.\r\n        this.mDepthBuffer = {\r\n            texture: lDepthBuffer,\r\n            depthClearValue: pClearValue,\r\n            depthLoadOperation: pLoadOp,\r\n            depthStoreOperation: pStoreOp,\r\n            stencilClearValue: pClearValue,\r\n            stencilLoadOperation: pLoadOp,\r\n            stencilStoreOperation: pStoreOp,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Call auto update onbuffer data update.\r\n     */\r\n    private onDepthBufferUpdate(): void {\r\n        this.triggerAutoUpdate(UpdateReason.ChildData);\r\n    }\r\n}\r\n\r\ntype RenderTargetColorTexture = {\r\n    texture: FrameBufferTexture,\r\n    clearValue: number;\r\n    loadOperation: TextureOperation;\r\n    storeOperation: TextureOperation;\r\n    resolveTarget: CanvasTexture | null;\r\n};\r\n\r\ntype RenderTargetDepthStencilTexture = {\r\n    texture: FrameBufferTexture,\r\n    depthClearValue: number;\r\n    depthLoadOperation: TextureOperation;\r\n    depthStoreOperation: TextureOperation;\r\n    stencilClearValue: number;\r\n    stencilLoadOperation: TextureOperation;\r\n    stencilStoreOperation: TextureOperation;\r\n};","import { Dictionary, Exception } from '@kartoffelgames/core.data';\r\nimport { AccessMode } from '../../../constant/access-mode.enum';\r\nimport { ComputeStage } from '../../../constant/compute-stage.enum';\r\nimport { TextureBindType } from '../../../constant/texture-bind-type.enum';\r\nimport { TextureDimension } from '../../../constant/texture-dimension.enum';\r\nimport { TextureFormat } from '../../../constant/texture-format.enum';\r\nimport { GpuDevice } from '../../gpu/gpu-device';\r\nimport { GpuObject } from '../../gpu/gpu-object';\r\nimport { TextureMemoryLayout } from '../../memory_layout/texture-memory-layout';\r\nimport { CanvasTexture } from '../../texture/canvas-texture';\r\nimport { FrameBufferTexture } from '../../texture/frame-buffer-texture';\r\nimport { RenderTargets } from './render-targets';\r\n\r\nexport class TextureGroup extends GpuObject {\r\n    private readonly mBufferTextures: Dictionary<string, FrameBufferTexture>;\r\n    private readonly mMultisampleLevel: number;\r\n    private readonly mSize: TextureSize;\r\n    private readonly mTargetTextures: Dictionary<string, CanvasTexture>;\r\n\r\n    /**\r\n     * Render target height.\r\n     */\r\n    public get height(): number {\r\n        return this.mSize.height;\r\n    } set height(pValue: number) {\r\n        this.resize(this.mSize.width, pValue);\r\n    }\r\n\r\n    /**\r\n     * Render target multisample level.\r\n     */\r\n    public get multiSampleLevel(): number {\r\n        return this.mMultisampleLevel;\r\n    }\r\n\r\n    /**\r\n     * Render target height.\r\n     */\r\n    public get width(): number {\r\n        return this.mSize.width;\r\n    } set width(pValue: number) {\r\n        this.resize(pValue, this.mSize.height);\r\n    }\r\n\r\n    /**\r\n     * Constuctor.\r\n     * @param pDevice - Gpu device reference.\r\n     * @param pWidth - Textures width.\r\n     * @param pHeight - Textures height.\r\n     * @param pMultisampleLevel - Multisample level of all buffer textures.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pWidth: number, pHeight: number, pMultisampleLevel: number) {\r\n        super(pDevice);\r\n\r\n        // Set \"fixed\" \r\n        this.mSize = { width: pWidth, height: pHeight };\r\n        this.mMultisampleLevel = pMultisampleLevel;\r\n\r\n        // Saved.\r\n        this.mBufferTextures = new Dictionary<string, FrameBufferTexture>();\r\n        this.mTargetTextures = new Dictionary<string, CanvasTexture>();\r\n    }\r\n\r\n    /**\r\n     * Add buffer texture to group.\r\n     * Uses multisample values.\r\n     * @param pName - Texture name.\r\n     * @param pType - Texture type.\r\n     */\r\n    public addBuffer(pName: string, pType: RenderBufferType): FrameBufferTexture {\r\n        // Validate existing buffer textures.\r\n        if (this.mBufferTextures.has(pName)) {\r\n            throw new Exception(`Buffer texture \"${pName}\" already exists.`, this);\r\n        }\r\n\r\n        // Create correct memory layout for texture type.\r\n        let lMemoryLayout: TextureMemoryLayout;\r\n        switch (pType) {\r\n            case 'Color': {\r\n                lMemoryLayout = this.createColorMemoryLayout(this.mMultisampleLevel > 1);\r\n                break;\r\n            }\r\n            case 'Depth': {\r\n                lMemoryLayout = this.createDepthMemoryLayout(this.mMultisampleLevel > 1);\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Create new texture and assign multisample level.\r\n        const lTexture: FrameBufferTexture = lMemoryLayout.createFrameBufferTexture(this.mSize.height, this.mSize.width, 1);\r\n        lTexture.multiSampleLevel = this.mMultisampleLevel;\r\n\r\n        // Set buffer texture.\r\n        this.mBufferTextures.set(pName, lTexture);\r\n\r\n        return lTexture;\r\n    }\r\n\r\n    /**\r\n     * Add target texture to group.\r\n     * Ignores multisample values.\r\n     * @param pName - Texture name.\r\n     * @param pType - Texture type.\r\n     */\r\n    public addTarget(pName: string): CanvasTexture {\r\n        // Validate existing target textures.\r\n        if (this.mTargetTextures.has(pName)) {\r\n            throw new Exception(`Target texture \"${pName}\" already exists.`, this);\r\n        }\r\n\r\n        // Create correct memory layout for texture type.\r\n        const lMemoryLayout: TextureMemoryLayout = this.createCanvasMemoryLayout();\r\n        const lTexture: CanvasTexture = lMemoryLayout.createCanvasTexture(this.mSize.height, this.mSize.width);\r\n\r\n        // Set target texture.\r\n        this.mTargetTextures.set(pName, lTexture);\r\n\r\n        return lTexture;\r\n    }\r\n\r\n    /**\r\n     * Create render targets.\r\n     */\r\n    public create(): RenderTargets {\r\n        return new RenderTargets(this.device, this);\r\n    }\r\n\r\n    /**\r\n     * Get buffer texture.\r\n     * @param pName - texture name.\r\n     */\r\n    public getBufferTextureOf(pName: string): FrameBufferTexture {\r\n        // Validate existing canvas.\r\n        if (this.mBufferTextures.has(pName)) {\r\n            throw new Exception(`Buffer texture \"${pName}\" not found.`, this);\r\n        }\r\n\r\n        return this.mBufferTextures.get(pName)!;\r\n    }\r\n\r\n    /**\r\n     * Get target texture.\r\n     * @param pName - texture name.\r\n     */\r\n    public getTargetTextureOf(pName: string): CanvasTexture {\r\n        // Validate existing canvas.\r\n        if (this.mTargetTextures.has(pName)) {\r\n            throw new Exception(`Target texture \"${pName}\" not found.`, this);\r\n        }\r\n\r\n        return this.mTargetTextures.get(pName)!;\r\n    }\r\n\r\n    /**\r\n     * Create layout for a canvas texture.\r\n     */\r\n    private createCanvasMemoryLayout(): TextureMemoryLayout {\r\n        return new TextureMemoryLayout(this.device, {\r\n            dimension: TextureDimension.TwoDimension,\r\n            format: TextureFormat.RedGreenBlueAlpha,\r\n            bindType: TextureBindType.RenderTarget,\r\n            multisampled: false,\r\n            access: AccessMode.Write | AccessMode.Read,\r\n            bindingIndex: null,\r\n            name: '',\r\n            visibility: ComputeStage.Fragment\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create layout for a color texture.\r\n     */\r\n    private createColorMemoryLayout(pMultisampled: boolean): TextureMemoryLayout {\r\n        return new TextureMemoryLayout(this.device, {\r\n            dimension: TextureDimension.TwoDimension,\r\n            format: TextureFormat.RedGreenBlueAlpha,\r\n            bindType: TextureBindType.RenderTarget,\r\n            multisampled: pMultisampled,\r\n            access: AccessMode.Write | AccessMode.Read,\r\n            bindingIndex: null,\r\n            name: '',\r\n            visibility: ComputeStage.Fragment\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create layout for a depth texture.\r\n     */\r\n    private createDepthMemoryLayout(pMultisampled: boolean): TextureMemoryLayout {\r\n        return new TextureMemoryLayout(this.device, {\r\n            dimension: TextureDimension.TwoDimension,\r\n            format: TextureFormat.Depth,\r\n            bindType: TextureBindType.RenderTarget,\r\n            multisampled: pMultisampled,\r\n            access: AccessMode.Write | AccessMode.Read,\r\n            bindingIndex: null,\r\n            name: '',\r\n            visibility: ComputeStage.Fragment\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Resize all textures.\r\n     * @param pWidth - Textures width.\r\n     * @param pHeight - Textures height.\r\n     */\r\n    private resize(pWidth: number, pHeight: number): void {\r\n        // Update size.\r\n        this.mSize.width = pWidth;\r\n        this.mSize.width = pHeight;\r\n\r\n        // Update buffer texture sizes.\r\n        for (const lTexture of this.mBufferTextures.values()) {\r\n            lTexture.height = pHeight;\r\n            lTexture.height = pWidth;\r\n        }\r\n\r\n        // Update target texture sizes.\r\n        for (const lTexture of this.mTargetTextures.values()) {\r\n            lTexture.height = pHeight;\r\n            lTexture.height = pWidth;\r\n        }\r\n    }\r\n}\r\n\r\ntype TextureSize = { width: number; height: number; };\r\n\r\ntype RenderBufferType = 'Color' | 'Depth';","import { CompareFunction } from '../../constant/compare-function.enum';\r\nimport { PrimitiveCullMode } from '../../constant/primitive-cullmode';\r\nimport { PrimitiveFrontFace } from '../../constant/primitive-front-face';\r\nimport { PrimitiveTopology } from '../../constant/primitive-topology';\r\nimport { GpuDevice } from '../gpu/gpu-device';\r\nimport { GpuObject } from '../gpu/gpu-object';\r\nimport { UpdateReason } from '../gpu/gpu-object-update-reason';\r\nimport { VertexFragmentShader } from '../shader/vertex-fragment-shader';\r\nimport { RenderTargets } from './target/render-targets';\r\n\r\nexport class VertexFragmentPipeline extends GpuObject<'vertexFragmentPipeline'> {\r\n    private mDepthCompare: CompareFunction;\r\n    private mDepthWriteEnabled: boolean;\r\n    private mPrimitiveCullMode: PrimitiveCullMode;\r\n    private mPrimitiveFrontFace: PrimitiveFrontFace;\r\n    private mPrimitiveTopology: PrimitiveTopology;\r\n    private readonly mRenderTargets: RenderTargets;\r\n    private readonly mShader: VertexFragmentShader;\r\n\r\n    /**\r\n     * Set depth compare function.\r\n     */\r\n    public get depthCompare(): CompareFunction {\r\n        return this.mDepthCompare;\r\n    } set depthCompare(pValue: CompareFunction) {\r\n        this.mDepthCompare = pValue;\r\n\r\n        // Set data changed flag.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Defines which polygon orientation will be culled.\r\n     */\r\n    public get primitiveCullMode(): PrimitiveCullMode {\r\n        return this.mPrimitiveCullMode;\r\n    } set primitiveCullMode(pValue: PrimitiveCullMode) {\r\n        this.mPrimitiveCullMode = pValue;\r\n\r\n        // Set data changed flag.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Defines which polygons are considered front-facing.\r\n     */\r\n    public get primitiveFrontFace(): PrimitiveFrontFace {\r\n        return this.mPrimitiveFrontFace;\r\n    } set primitiveFrontFace(pValue: PrimitiveFrontFace) {\r\n        this.mPrimitiveFrontFace = pValue;\r\n\r\n        // Set data changed flag.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * The type of primitive to be constructed from the vertex inputs.\r\n     */\r\n    public get primitiveTopology(): PrimitiveTopology {\r\n        return this.mPrimitiveTopology;\r\n    } set primitiveTopology(pValue: PrimitiveTopology) {\r\n        this.mPrimitiveTopology = pValue;\r\n\r\n        // Set data changed flag.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Render targets.\r\n     */\r\n    public get renderTargets(): RenderTargets {\r\n        return this.mRenderTargets;\r\n    }\r\n\r\n    /**\r\n     * Pipeline shader.\r\n     */\r\n    public get shader(): VertexFragmentShader {\r\n        return this.mShader;\r\n    }\r\n\r\n    /**\r\n     * Set depth write enabled / disabled.\r\n     */\r\n    public get writeDepth(): boolean {\r\n        return this.mDepthWriteEnabled;\r\n    } set writeDepth(pValue: boolean) {\r\n        this.mDepthWriteEnabled = pValue;\r\n\r\n        // Set data changed flag.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * Set default data.\r\n     * @param pDevice - Device.\r\n     * @param pShader - Pipeline shader.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pShader: VertexFragmentShader, pRenderTargets: RenderTargets) {\r\n        super(pDevice);\r\n        this.mShader = pShader;\r\n        this.mRenderTargets = pRenderTargets;\r\n\r\n        // Listen for render target and shader changes.\r\n        pShader.addUpdateListener(() => {\r\n            this.triggerAutoUpdate(UpdateReason.ChildData);\r\n        });\r\n        pRenderTargets.addUpdateListener(() => {\r\n            this.triggerAutoUpdate(UpdateReason.ChildData);\r\n        });\r\n\r\n        // Depth default settings.\r\n        this.mDepthCompare = CompareFunction.Less;\r\n        this.mDepthWriteEnabled = true;\r\n\r\n        // Primitive default settings.\r\n        this.mPrimitiveTopology = PrimitiveTopology.TriangleList;\r\n        this.mPrimitiveCullMode = PrimitiveCullMode.Back;\r\n        this.mPrimitiveFrontFace = PrimitiveFrontFace.ClockWise;\r\n    }\r\n}","import { Dictionary } from '@kartoffelgames/core.data';\r\nimport { ComputeStage } from '../../constant/compute-stage.enum';\r\nimport { BindDataGroupLayout } from '../binding/bind-data-group-layout';\r\nimport { PipelineDataLayout } from '../binding/pipeline-data-layout';\r\nimport { GeneratorFactoryMap } from '../generator/base-generator-factory';\r\nimport { GpuDevice } from '../gpu/gpu-device';\r\nimport { GpuObject } from '../gpu/gpu-object';\r\nimport { BaseShaderInterpreter, ShaderFunction } from './interpreter/base-shader-interpreter';\r\n\r\n// TODO: Split into Compute- and RenderShader AND ModuleShader(Block any entry point.)\r\n// TODO: Add ShaderModules. With own PreCompile command. (import/if/define ....)\r\n// TODO: Maybe own language??? \r\n\r\nexport abstract class BaseShader<TGpuObjectKey extends keyof GeneratorFactoryMap> extends GpuObject<TGpuObjectKey> {\r\n    private static readonly mBindGroupLayoutCache: Dictionary<string, BindDataGroupLayout> = new Dictionary<string, BindDataGroupLayout>();\r\n\r\n    private readonly mPipelineLayout: PipelineDataLayout;\r\n    private readonly mShaderInformation: BaseShaderInterpreter;\r\n\r\n    /**\r\n     * Shader information.\r\n     */\r\n    public get information(): BaseShaderInterpreter {\r\n        return this.mShaderInformation;\r\n    }\r\n\r\n    /**\r\n     * Shader pipeline layout.\r\n     */\r\n    public get pipelineLayout(): PipelineDataLayout {\r\n        return this.mPipelineLayout;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Gpu Device reference.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pSource: string) {\r\n        super(pDevice);\r\n\r\n        // Create shader information for source.\r\n        this.mShaderInformation = this.device.shaderInterpreter.interpret(pSource);\r\n\r\n        // Generate layout.\r\n        this.mPipelineLayout = new PipelineDataLayout(this.device);\r\n        for (const [lGroupIndex, lBindingList] of this.mShaderInformation.bindings) {\r\n            // Create group layout and add each binding.\r\n            let lGroupLayout: BindDataGroupLayout = new BindDataGroupLayout(this.device);\r\n            for (const lBinding of lBindingList) {\r\n                lGroupLayout.addBinding(lBinding, lBinding.name);\r\n            }\r\n\r\n            // Read from cache.\r\n            if (BaseShader.mBindGroupLayoutCache.has(lGroupLayout.identifier)) {\r\n                lGroupLayout = BaseShader.mBindGroupLayoutCache.get(lGroupLayout.identifier)!;\r\n            }\r\n\r\n            // Cache group layout.\r\n            BaseShader.mBindGroupLayoutCache.set(lGroupLayout.identifier, lGroupLayout);\r\n\r\n            // Add group to pipeline.\r\n            this.mPipelineLayout.addGroupLayout(lGroupIndex, lGroupLayout);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get entry point name of compute stage.\r\n     * @param pStage - Compute stage of entry point.\r\n     */\r\n    public getEntryPoints(pStage: ComputeStage): Array<string> {\r\n        // Ignore shader function generic. Does not matter for this function. Use only function names.\r\n        const lEntryPointFunctions: Array<ShaderFunction> = this.mShaderInformation.entryPoints.get(pStage) ?? new Array<ShaderFunction>();\r\n        return lEntryPointFunctions.map((pFunction: ShaderFunction) => { return pFunction.name; });\r\n    }\r\n}\r\n\r\n","import { Dictionary, Exception } from '@kartoffelgames/core.data';\r\nimport { ComputeStage } from '../../../constant/compute-stage.enum';\r\nimport { GpuDevice } from '../../gpu/gpu-device';\r\nimport { BaseMemoryLayout } from '../../memory_layout/base-memory-layout';\r\nimport { BufferPrimitiveFormat } from '../../../constant/buffer-primitive-format';\r\n\r\nexport abstract class BaseShaderInterpreter {\r\n    private readonly mBindings: Dictionary<number, Array<BaseMemoryLayout>>;\r\n    private readonly mDevice: GpuDevice;\r\n    private readonly mEntryPoints: Dictionary<ComputeStage, Array<ShaderFunction>>;\r\n    private readonly mShaderFunctions: Dictionary<string, ShaderFunction>;\r\n    private readonly mShaderStructDefinitions: Dictionary<string, ShaderStructDefinition>;\r\n    private readonly mShaderTypeAliases: Dictionary<string, ShaderTypeAlias>;\r\n    private readonly mShaderTypes: Dictionary<string, ShaderTypeDefinition>;\r\n    private readonly mShaderValue: Dictionary<string, ShaderValue>;\r\n    private readonly mSourceCode: string;\r\n\r\n    /**\r\n     * Shader bindings. Grouped by group.\r\n     */\r\n    public get bindings(): Map<number, Array<BaseMemoryLayout>> {\r\n        return this.mBindings;\r\n    }\r\n\r\n    /**\r\n     * Shader entry points.\r\n     */\r\n    public get entryPoints(): Map<ComputeStage, Array<ShaderFunction>> {\r\n        return this.mEntryPoints;\r\n    }\r\n\r\n    /**\r\n     * Shader source code.\r\n     */\r\n    public get source(): string {\r\n        return this.mSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gpu device.\r\n     */\r\n    protected get device(): GpuDevice {\r\n        return this.mDevice;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Device.\r\n     * @param pSourceCode - Shader source code.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pSourceCode: string) {\r\n        this.mDevice = pDevice;\r\n        this.mSourceCode = pSourceCode;\r\n\r\n        // Setup all shader types.\r\n        this.mShaderTypes = new Dictionary<string, ShaderTypeDefinition>();\r\n        this.mShaderTypeAliases = new Dictionary<string, ShaderTypeAlias>();\r\n        this.setupShaderTypes((pType: ShaderTypeDefinition) => {\r\n            this.mShaderTypes.set(pType.name, pType);\r\n\r\n            // Map all aliases of type.\r\n            for (const lVariant of pType.variants) {\r\n                // No aliases specified.\r\n                if (!lVariant.aliases) {\r\n                    continue;\r\n                }\r\n\r\n                // Map each alias with its generics.\r\n                for (const lAlias of lVariant.aliases) {\r\n                    this.mShaderTypeAliases.set(lAlias, {\r\n                        type: pType.name,\r\n                        generics: lVariant.generic ?? []\r\n                    });\r\n                }\r\n            }\r\n        });\r\n\r\n        // Read defintions.\r\n        const lShaderFunctionDefinitionList: Array<ShaderFunctionDefinition> = this.fetchFunctionDefinitions(pSourceCode);\r\n        const lShaderValueDefinitionList: Array<ShaderValueDefinition> = this.fetchValueDefinitions(pSourceCode);\r\n        const lShaderStructDefinitionList: Array<ShaderStructDefinition> = this.fetchStructDefinitions(pSourceCode);\r\n\r\n        // Map shader structs.\r\n        this.mShaderStructDefinitions = new Dictionary<string, ShaderStructDefinition>();\r\n        for (const lStructDefinition of lShaderStructDefinitionList) {\r\n            this.mShaderStructDefinitions.set(lStructDefinition.name, lStructDefinition);\r\n        }\r\n\r\n        // Meta data storages placeholders.\r\n        this.mShaderFunctions = this.convertFunctions(lShaderFunctionDefinitionList);\r\n        this.mShaderValue = this.convertValues(lShaderValueDefinitionList);\r\n\r\n        // Set entry point and bindings.\r\n        this.mEntryPoints = this.readEntryPoints();\r\n        this.mBindings = this.readBindings();\r\n    }\r\n\r\n    /**\r\n     * Get shader function.\r\n     * @param pName - Function name.\r\n     */\r\n    public getFunction(pName: string): ShaderFunction | null {\r\n        return this.mShaderFunctions.get(pName) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Create struct from value definition.\r\n     * @param pValueDefinition - value definition.\r\n     */\r\n    protected structFromDefinition(pStructDefinition: ShaderStructDefinition): ShaderStruct {\r\n        const lShaderStruct: ShaderStruct = {\r\n            name: pStructDefinition.name,\r\n            properties: new Array<ShaderValue>()\r\n        };\r\n\r\n        // Convert all properties to struct values.\r\n        for (const lProperty of pStructDefinition.properies) {\r\n            lShaderStruct.properties.push(this.valueFromDefinition(lProperty));\r\n        }\r\n\r\n        return lShaderStruct;\r\n    }\r\n\r\n    /**\r\n     * Get type of type, alias or struct name\r\n     * @param pTypeName - Type, alias or struct name.\r\n     * @param pGenericNames - Generics of type. Only valid on type names.\r\n     */\r\n    protected typeFor(pTypeName: string, pGenericNames: Array<string> = []): ShaderType {\r\n        // Search for regular type.\r\n        if (this.mShaderTypes.has(pTypeName)) {\r\n            const lRegularType: ShaderTypeDefinition = this.mShaderTypes.get(pTypeName)!;\r\n            for (const lVariant of lRegularType.variants) {\r\n                const lVariantGenerics: Array<string> = lVariant.generic ?? [];\r\n\r\n                // Validate generics.\r\n                if (lVariantGenerics.length !== pGenericNames.length) {\r\n                    continue;\r\n                }\r\n\r\n                // Validate each generic value.\r\n                let lGenericsMatches: boolean = true;\r\n                for (let lIndex: number = 0; lIndex < lVariantGenerics.length; lIndex++) {\r\n                    const lTargetGeneric: string = lVariantGenerics[lIndex];\r\n                    const lSourceGeneric: string = pGenericNames[lIndex];\r\n\r\n                    // Matches any on wildcard or strict match otherwise.\r\n                    if (lTargetGeneric !== '*' && lTargetGeneric !== lSourceGeneric) {\r\n                        lGenericsMatches = false;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // Generics does not match. Search next variant.\r\n                if (!lGenericsMatches) {\r\n                    continue;\r\n                }\r\n\r\n                return {\r\n                    typeName: lRegularType.name,\r\n                    type: 'buildIn',\r\n                    size: lVariant.size,\r\n                    align: lVariant.align,\r\n                    primitiveFormat: lVariant.format ?? BufferPrimitiveFormat.Unsupported\r\n                };\r\n            }\r\n        }\r\n\r\n        // No gernics allows after this point.\r\n        if (pGenericNames.length > 0) {\r\n            throw new Exception(`No generics allowed for struct or alias types. Regular type \"${pTypeName}<${pGenericNames.toString()}>\" not found.`, this);\r\n        }\r\n\r\n        // Search alias type.\r\n        if (this.mShaderTypeAliases.has(pTypeName)) {\r\n            const lAliasType: ShaderTypeAlias = this.mShaderTypeAliases.get(pTypeName)!;\r\n            return this.typeFor(lAliasType.type, lAliasType.generics);\r\n        }\r\n\r\n        // Search for struct.\r\n        if (this.mShaderStructDefinitions.has(pTypeName)) {\r\n            const lStructDefinition: ShaderStructDefinition = this.mShaderStructDefinitions.get(pTypeName)!;\r\n            return {\r\n                type: 'struct',\r\n                struct: this.structFromDefinition(lStructDefinition)\r\n            };\r\n        }\r\n\r\n        // Nothing found.\r\n        throw new Exception(`Type \"${pTypeName}\" not found.`, this);\r\n    }\r\n\r\n    /**\r\n     * Get visibility of global name.\r\n     * @param pName - Name of a global. \r\n     */\r\n    protected visibilityOf(pName: string): ComputeStage {\r\n        let lComputeStage: ComputeStage = <ComputeStage>0;\r\n\r\n        for (const lShaderFunction of this.searchEntryPointsOf(pName, new Set<string>())) {\r\n            lComputeStage |= lShaderFunction.entryPoints;\r\n        }\r\n\r\n        return lComputeStage;\r\n    }\r\n\r\n    /**\r\n     * Get all functions.\r\n     * @param pSourceCode - Source code of shader.\r\n     */\r\n    private convertFunctions(pFunctionDefinitions: Array<ShaderFunctionDefinition>): Dictionary<string, ShaderFunction> {\r\n        const lShaderFunctions: Dictionary<string, ShaderFunction> = new Dictionary<string, ShaderFunction>();\r\n        for (const lDefnition of pFunctionDefinitions) {\r\n            const lShaderFunction: ShaderFunction = this.functionFromDefinition(lDefnition);\r\n            lShaderFunctions.set(lShaderFunction.name, lShaderFunction);\r\n        }\r\n\r\n        return lShaderFunctions;\r\n    }\r\n\r\n    /**\r\n     * Get all global values.\r\n     * @param pSourceCode - Source code of shader.\r\n     */\r\n    private convertValues(pValueDefinitions: Array<ShaderValueDefinition>): Dictionary<string, ShaderValue> {\r\n        const lShaderValues: Dictionary<string, ShaderValue> = new Dictionary<string, ShaderValue>();\r\n        for (const lDefnition of pValueDefinitions) {\r\n            const lShaderValue: ShaderValue = this.valueFromDefinition(lDefnition);\r\n            lShaderValues.set(lShaderValue.value.name, lShaderValue);\r\n        }\r\n\r\n        return lShaderValues;\r\n    }\r\n\r\n    /**\r\n     * Fetch shader binds.\r\n     * @param pSourceCode - Shader source code.\r\n     */\r\n    private readBindings(): Dictionary<number, Array<BaseMemoryLayout>> {\r\n        const lBindings: Dictionary<number, Array<BaseMemoryLayout>> = new Dictionary<number, Array<BaseMemoryLayout>>();\r\n\r\n        for (const lShaderValue of this.mShaderValue.values()) {\r\n            // Skip all values without binding group.\r\n            if (lShaderValue.group === null) {\r\n                continue;\r\n            }\r\n\r\n            // Init new bind group.\r\n            if (!lBindings.has(lShaderValue.group)) {\r\n                lBindings.set(lShaderValue.group, new Array<BaseMemoryLayout>());\r\n            }\r\n\r\n            lBindings.get(lShaderValue.group)!.push(lShaderValue.value);\r\n        }\r\n\r\n        return lBindings;\r\n    }\r\n\r\n    /**\r\n     * Read entry points from crawled shader functions.\r\n     */\r\n    private readEntryPoints(): Dictionary<ComputeStage, Array<ShaderFunction>> {\r\n        const lEntryPoints: Dictionary<ComputeStage, Array<ShaderFunction>> = new Dictionary<ComputeStage, Array<ShaderFunction>>();\r\n\r\n        // Map shader function to entry point by function tags.\r\n        for (const lShaderFunction of this.mShaderFunctions.values()) {\r\n            if ((lShaderFunction.entryPoints & ComputeStage.Compute) === ComputeStage.Compute) {\r\n                // Init shader stage container.\r\n                if (!lEntryPoints.has(ComputeStage.Compute)) {\r\n                    lEntryPoints.set(ComputeStage.Compute, new Array<ShaderFunction>());\r\n                }\r\n\r\n                lEntryPoints.get(ComputeStage.Compute)!.push(lShaderFunction);\r\n            }\r\n\r\n            if ((lShaderFunction.entryPoints & ComputeStage.Vertex) === ComputeStage.Vertex) {\r\n                // Init shader stage container.\r\n                if (!lEntryPoints.has(ComputeStage.Vertex)) {\r\n                    lEntryPoints.set(ComputeStage.Vertex, new Array<ShaderFunction>());\r\n                }\r\n\r\n                lEntryPoints.get(ComputeStage.Vertex)!.push(lShaderFunction);\r\n            }\r\n\r\n            if ((lShaderFunction.entryPoints & ComputeStage.Fragment) === ComputeStage.Fragment) {\r\n                // Init shader stage container.\r\n                if (!lEntryPoints.has(ComputeStage.Fragment)) {\r\n                    lEntryPoints.set(ComputeStage.Fragment, new Array<ShaderFunction>());\r\n                }\r\n\r\n                lEntryPoints.get(ComputeStage.Fragment)!.push(lShaderFunction);\r\n            }\r\n        }\r\n\r\n        return lEntryPoints;\r\n    }\r\n\r\n    /**\r\n     * Search for all functions hat uses the global name.\r\n     * @param pName - variable or function name.\r\n     * @param pScannedNames - All already scanned names. Prevents recursion.\r\n     */\r\n    private searchEntryPointsOf(pName: string, pScannedNames: Set<string>): Array<ShaderFunction> {\r\n        // Add current searched name to already scanned names.\r\n        pScannedNames.add(pName);\r\n\r\n        const lUsedFunctionList: Array<ShaderFunction> = new Array<ShaderFunction>();\r\n\r\n        // Search all global names of all functions.\r\n        for (const lShaderFunction of this.mShaderFunctions.values()) {\r\n            for (const lGlobal of lShaderFunction.usedGlobals) {\r\n                // Prevent endless recursion.\r\n                if (pScannedNames.has(lGlobal)) {\r\n                    continue;\r\n                }\r\n\r\n                // Further down the rabbithole. Search for \r\n                if (this.mShaderFunctions.has(lGlobal)) {\r\n                    // Add found function to used function list.\r\n                    lUsedFunctionList.push(this.mShaderFunctions.get(lGlobal)!);\r\n\r\n                    // Recursive search for all functions that use this function.\r\n                    lUsedFunctionList.push(...this.searchEntryPointsOf(lGlobal, pScannedNames));\r\n                }\r\n            }\r\n        }\r\n\r\n        return [...new Set<ShaderFunction>(lUsedFunctionList)];\r\n    }\r\n\r\n    /**\r\n     * Read all function definitions.\r\n     * @param pSourceCode - Source code of shader.\r\n     */\r\n    protected abstract fetchFunctionDefinitions(pSourceCode: string): Array<ShaderFunctionDefinition>;\r\n\r\n    /**\r\n     * Read all global shader values.\r\n     * @param pSourceCode - Source code of shader.\r\n     */\r\n    protected abstract fetchStructDefinitions(pSourceCode: string): Array<ShaderStructDefinition>;\r\n\r\n    /**\r\n     * Read all global shader values.\r\n     * @param pSourceCode - Source code of shader.\r\n     */\r\n    protected abstract fetchValueDefinitions(pSourceCode: string): Array<ShaderValueDefinition>;\r\n\r\n    /**\r\n     * Convert function definition.\r\n     * @param pDefinition - Function definition.\r\n     */\r\n    protected abstract functionFromDefinition(pDefinition: ShaderFunctionDefinition): ShaderFunction;\r\n\r\n    /**\r\n     * Setup all shader types.\r\n     * @param pAddType - Add shader type callback.\r\n     */\r\n    protected abstract setupShaderTypes(pAddType: (pType: ShaderTypeDefinition) => void): void;\r\n\r\n    /**\r\n     * Create memory layout from value definition.\r\n     * @param pValueDefinition - value definition.\r\n     */\r\n    protected abstract valueFromDefinition(pValueDefinition: ShaderValueDefinition): ShaderValue;\r\n}\r\n\r\n/*\r\n * Definitions.\r\n */\r\n\r\nexport type ShaderValueDefinition = {\r\n    name: string;\r\n    type: ShaderType;\r\n    typeGenerics: Array<string>;\r\n    attachments: Record<string, string>;\r\n};\r\n\r\nexport type ShaderFunctionDefinition = {\r\n    attachments: Record<string, string>;\r\n    name: string;\r\n    returnType: ShaderValueDefinition;\r\n    parameter: Array<ShaderValueDefinition>;\r\n    body: string;\r\n};\r\n\r\nexport type ShaderStructDefinition = {\r\n    name: string,\r\n    properies: Array<ShaderValueDefinition>;\r\n};\r\n\r\nexport type ShaderTypeDefinition = {\r\n    name: string,\r\n    variants: Array<{\r\n        aliases?: Array<string>;\r\n        size: number;\r\n        align: number;\r\n        generic?: Array<string>;\r\n        format?: BufferPrimitiveFormat;\r\n    }>;\r\n};\r\n\r\n/*\r\n * Values.\r\n */\r\n\r\nexport type ShaderValue = {\r\n    value: BaseMemoryLayout;\r\n    group: number | null;\r\n};\r\n\r\nexport type ShaderFunction = {\r\n    entryPoints: ComputeStage;\r\n    usedGlobals: Array<string>;\r\n    name: string;\r\n    parameter: Array<BaseMemoryLayout>;\r\n    return: BaseMemoryLayout | null;\r\n    attachments: Record<string, Array<string>>;\r\n};\r\n\r\nexport type ShaderStruct = {\r\n    name: string;\r\n    properties: Array<ShaderValue>;\r\n};\r\n\r\n/*\r\n * Types.\r\n */\r\n\r\nexport type ShaderType = {\r\n    type: 'buildIn';\r\n    typeName: string;\r\n    size: number;\r\n    align: number;\r\n    primitiveFormat: BufferPrimitiveFormat;\r\n} | {\r\n    type: 'struct';\r\n    struct: ShaderStruct;\r\n};\r\n\r\ntype ShaderTypeAlias = {\r\n    type: string;\r\n    generics: Array<string>;\r\n};","import { GpuDevice } from '../../gpu/gpu-device';\r\nimport { BaseShaderInterpreter } from './base-shader-interpreter';\r\n\r\n\r\nexport class ShaderInterpreterFactory {\r\n    private readonly mDevice: GpuDevice;\r\n    private readonly mInterpreterConstructor: ShaderInterpreterConstructor;\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Gpu device.\r\n     * @param pInterpreter - Shader Interpreter \r\n     */\r\n    public constructor(pDevice: GpuDevice, pInterpreter: ShaderInterpreterConstructor) {\r\n        this.mDevice = pDevice;\r\n        this.mInterpreterConstructor = pInterpreter;\r\n    }\r\n\r\n    /**\r\n     * Interpret source code.\r\n     * Executes precompile commands.\r\n     * @param pSource - Source.\r\n     */\r\n    public interpret(pSource: string): BaseShaderInterpreter {\r\n        // TODO: Process precompile commands.\r\n\r\n        return new this.mInterpreterConstructor(this.mDevice, pSource);\r\n    }\r\n}\r\n\r\nexport type ShaderInterpreterConstructor = new (pDevice: GpuDevice, pSource: string) => BaseShaderInterpreter;","import { Exception } from '@kartoffelgames/core.data';\r\nimport { ComputeStage } from '../../constant/compute-stage.enum';\r\nimport { GpuDevice } from '../gpu/gpu-device';\r\nimport { BaseBufferMemoryLayout } from '../memory_layout/buffer/base-buffer-memory-layout';\r\nimport { StructBufferMemoryLayout } from '../memory_layout/buffer/struct-buffer-memory-layout';\r\nimport { VertexParameterLayout } from '../pipeline/parameter/vertex-parameter-layout';\r\nimport { BaseShader } from './base-shader';\r\nimport { ShaderFunction } from './interpreter/base-shader-interpreter';\r\nimport { LinearBufferMemoryLayout } from '../memory_layout/buffer/linear-buffer-memory-layout';\r\nimport { RenderTargets } from '../pipeline/target/render-targets';\r\nimport { VertexFragmentPipeline } from '../pipeline/vertex-fragment-pipeline';\r\n\r\nexport class VertexFragmentShader extends BaseShader<'vertexFragmentShader'> {\r\n    private readonly mAttachmentCount: number;\r\n    private readonly mFragmentEntry: string | null;\r\n    private readonly mParameterLayout: VertexParameterLayout;\r\n    private readonly mVertexEntry: string;\r\n\r\n    /**\r\n     * Fragment entry point name.\r\n     */\r\n    public get fragmentEntry(): string | null {\r\n        return this.mFragmentEntry;\r\n    }\r\n\r\n    /**\r\n     * Render parameter layout.\r\n     */\r\n    public get parameterLayout(): VertexParameterLayout {\r\n        return this.mParameterLayout;\r\n    }\r\n\r\n    /**\r\n     * Shader attachment count.\r\n     */\r\n    public get renderTargetCount(): number {\r\n        return this.mAttachmentCount;\r\n    }\r\n\r\n    /**\r\n     * Vertex entry point name.\r\n     */\r\n    public get vertexEntry(): string {\r\n        return this.mVertexEntry;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Gpu Device reference.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pSource: string, pVertexEntry: string, pFragmentEntry?: string) {\r\n        super(pDevice, pSource);\r\n\r\n        // Set entry points.\r\n        this.mVertexEntry = pVertexEntry;\r\n        this.mFragmentEntry = pFragmentEntry ?? null;\r\n\r\n        // Validate vertex entry point.\r\n        const lVertexEntryFunction: ShaderFunction | null = this.information.getFunction(this.mVertexEntry);\r\n        if (!lVertexEntryFunction) {\r\n            throw new Exception(`Vertex entry \"${this.mVertexEntry}\" not defined.`, this);\r\n        } else if ((lVertexEntryFunction.entryPoints & ComputeStage.Vertex) !== ComputeStage.Vertex) {\r\n            throw new Exception(`Vertex entry \"${this.mVertexEntry}\" not an defined vertex entry.`, this);\r\n        }\r\n\r\n        // Validate fragment entry point.\r\n        const lFragmentEntryFunction: ShaderFunction | null = (this.mFragmentEntry) ? this.information.getFunction(this.mFragmentEntry) : null;\r\n        if (this.mFragmentEntry) {\r\n            // Validate entry points existance.\r\n            if (!lFragmentEntryFunction) {\r\n                throw new Exception(`Fragment entry \"${this.mFragmentEntry}\" not defined.`, this);\r\n            } else if ((lFragmentEntryFunction.entryPoints & ComputeStage.Fragment) !== ComputeStage.Fragment) {\r\n                throw new Exception(`Fragment entry \"${this.mFragmentEntry}\" not an defined fragment entry.`, this);\r\n            }\r\n        }\r\n\r\n        // Create parameter layout and append every parameter.\r\n        this.mParameterLayout = new VertexParameterLayout(this.device);\r\n        for (const lParameter of lVertexEntryFunction.parameter) {\r\n            // Validate buffer type.\r\n            if (!(lParameter instanceof LinearBufferMemoryLayout)) {\r\n                throw new Exception('Only simple data types are allowed for vertex attributes.', this);\r\n            }\r\n\r\n            this.mParameterLayout.add(lParameter);\r\n        }\r\n\r\n        // Get attachment count based on fragment function return values with an memory index.\r\n        this.mAttachmentCount = 0;\r\n        if (this.mFragmentEntry) {\r\n            // Fragment has only buffer return types.\r\n            const lFragmentReturn: BaseBufferMemoryLayout = <BaseBufferMemoryLayout>lFragmentEntryFunction!.return;\r\n            if (lFragmentReturn instanceof StructBufferMemoryLayout) {\r\n                this.mAttachmentCount = lFragmentReturn.locationLayouts().length;\r\n            } else {\r\n                this.mAttachmentCount = 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create pipeline from shader.\r\n     * @param pRenderTargets - Render targets.\r\n     */\r\n    public createPipeline(pRenderTargets: RenderTargets): VertexFragmentPipeline {\r\n        return new VertexFragmentPipeline(this.device, this, pRenderTargets);\r\n    }\r\n}","import { GpuDevice } from '../gpu/gpu-device';\r\nimport { GpuObject } from '../gpu/gpu-object';\r\nimport { UpdateReason } from '../gpu/gpu-object-update-reason';\r\nimport { TextureMemoryLayout } from '../memory_layout/texture-memory-layout';\r\n\r\nexport class CanvasTexture extends GpuObject<'canvasTexture'> {\r\n    private readonly mCanvas: HTMLCanvasElement;\r\n    private readonly mMemoryLayout: TextureMemoryLayout;\r\n\r\n    /**\r\n     * HTML canvas element.\r\n     */\r\n    public get canvas(): HTMLCanvasElement {\r\n        return this.mCanvas;\r\n    }\r\n\r\n    /**\r\n     * Texture height.\r\n     */\r\n    public get height(): number {\r\n        return this.mCanvas.height;\r\n    } set height(pValue: number) {\r\n        this.mCanvas.height = pValue;\r\n\r\n        // Trigger auto update.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Textures memory layout.\r\n     */\r\n    public get memoryLayout(): TextureMemoryLayout {\r\n        return this.mMemoryLayout;\r\n    }\r\n\r\n    /**\r\n     * Texture width.\r\n     */\r\n    public get width(): number {\r\n        return this.mCanvas.width;\r\n    } set width(pValue: number) {\r\n        this.mCanvas.width = pValue;\r\n\r\n        // Trigger auto update.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Device.\r\n     * @param pCanvas - Canvas of texture.\r\n     * @param pLayout - Texture layout.\r\n     * @param pDepth - Depth of texture. Can only be set to one.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pLayout: TextureMemoryLayout) {\r\n        super(pDevice);\r\n\r\n        // Set canvas reference.\r\n        this.mCanvas = document.createElement('canvas');\r\n        this.mMemoryLayout = pLayout;\r\n\r\n        // Set defaults.\r\n        this.height = 1;\r\n        this.width = 1;\r\n\r\n        // Register change listener for layout changes.\r\n        pLayout.addUpdateListener(() => {\r\n            this.triggerAutoUpdate(UpdateReason.ChildData);\r\n        });\r\n    }\r\n}","import { GpuDevice } from '../gpu/gpu-device';\r\nimport { GpuObject } from '../gpu/gpu-object';\r\nimport { UpdateReason } from '../gpu/gpu-object-update-reason';\r\nimport { TextureMemoryLayout } from '../memory_layout/texture-memory-layout';\r\n\r\nexport class FrameBufferTexture extends GpuObject<'frameBufferTexture'> {\r\n    private mDepth: number;\r\n    private mHeight: number;\r\n    private readonly mMemoryLayout: TextureMemoryLayout;\r\n    private mMultiSampleLevel: number;\r\n    private mWidth: number;\r\n\r\n    /**\r\n     * Texture depth.\r\n     */\r\n    public get depth(): number {\r\n        return this.mDepth;\r\n    } set depth(pValue: number) {\r\n        this.mDepth = pValue;\r\n\r\n        // Trigger auto update.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Texture height.\r\n     */\r\n    public get height(): number {\r\n        return this.mHeight;\r\n    } set height(pValue: number) {\r\n        this.mHeight = pValue;\r\n\r\n        // Trigger auto update.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Textures memory layout.\r\n     */\r\n    public get memoryLayout(): TextureMemoryLayout {\r\n        return this.mMemoryLayout;\r\n    }\r\n\r\n    /**\r\n     * Texture multi sample level.\r\n     */\r\n    public get multiSampleLevel(): number {\r\n        return this.mMultiSampleLevel;\r\n    } set multiSampleLevel(pValue: number) {\r\n        this.mMultiSampleLevel = pValue;\r\n\r\n        // Trigger auto update.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Texture width.\r\n     */\r\n    public get width(): number {\r\n        return this.mWidth;\r\n    } set width(pValue: number) {\r\n        this.mWidth = pValue;\r\n\r\n        // Trigger auto update.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Device.\r\n     * @param pLayout - Texture memory layout.\r\n     * @param pDepth - Texture depth.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pLayout: TextureMemoryLayout) {\r\n        super(pDevice);\r\n\r\n        // Fixed values.\r\n\r\n        this.mMemoryLayout = pLayout;\r\n\r\n        // Set defaults.\r\n        this.mDepth = 1;\r\n        this.mHeight = 1;\r\n        this.mWidth = 1;\r\n        this.mMultiSampleLevel = 1;\r\n\r\n        // Register change listener for layout changes.\r\n        pLayout.addUpdateListener(() => {\r\n            this.triggerAutoUpdate(UpdateReason.ChildData);\r\n        });\r\n    }\r\n}","import { Exception } from '@kartoffelgames/core.data';\r\nimport { GpuDevice } from '../gpu/gpu-device';\r\nimport { GpuObject } from '../gpu/gpu-object';\r\nimport { TextureMemoryLayout } from '../memory_layout/texture-memory-layout';\r\nimport { UpdateReason } from '../gpu/gpu-object-update-reason';\r\n\r\nexport class ImageTexture extends GpuObject<'imageTexture'> {\r\n    private mDepth: number;\r\n    private mHeight: number;\r\n    private mImageList: Array<ImageBitmap>;\r\n    private readonly mMemoryLayout: TextureMemoryLayout;\r\n    private mWidth: number;\r\n\r\n    /**\r\n     * Texture depth.\r\n     */\r\n    public get depth(): number {\r\n        return this.mDepth;\r\n    }\r\n\r\n    /**\r\n     * Texture height.\r\n     */\r\n    public get height(): number {\r\n        return this.mHeight;\r\n    }\r\n\r\n    /**\r\n     * Loaded html image list.\r\n     */\r\n    public get images(): Array<ImageBitmap> {\r\n        return this.mImageList;\r\n    }\r\n\r\n    /**\r\n     * Textures memory layout.\r\n     */\r\n    public get memoryLayout(): TextureMemoryLayout {\r\n        return this.mMemoryLayout;\r\n    }\r\n\r\n    /**\r\n     * Texture width.\r\n     */\r\n    public get width(): number {\r\n        return this.mWidth;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Device.\r\n     * @param pLayout - Texture memory layout.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pLayout: TextureMemoryLayout) {\r\n        super(pDevice);\r\n\r\n        // Fixed values.\r\n        this.mMemoryLayout = pLayout;\r\n\r\n        // Set defaults.\r\n        this.mDepth = 1;\r\n        this.mHeight = 1;\r\n        this.mWidth = 1;\r\n        this.mImageList = new Array<ImageBitmap>();\r\n\r\n        // Register change listener for layout changes.\r\n        pLayout.addUpdateListener(() => {\r\n            this.triggerAutoUpdate(UpdateReason.ChildData);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load image into texture.\r\n     * Images needs to have the same dimensions.\r\n     * @param pSorceList - Source for each depth layer.\r\n     */\r\n    public async load(...pSourceList: Array<string>): Promise<void> {\r\n        let lHeight: number = 0;\r\n        let lWidth: number = 0;\r\n\r\n        // Parallel load images.\r\n        const lImageLoadPromiseList: Array<Promise<ImageBitmap>> = pSourceList.map(async (pSource) => {\r\n            // Load image with html image element.\r\n            const lImage: HTMLImageElement = new Image();\r\n            lImage.src = pSource;\r\n            await lImage.decode();\r\n\r\n            // Init size.\r\n            if (lHeight === 0 || lWidth === 0) {\r\n                lWidth = lImage.naturalWidth;\r\n                lHeight = lImage.naturalHeight;\r\n            }\r\n\r\n            // Validate same image size for all layers.\r\n            if (lHeight !== lImage.naturalHeight || lWidth !== lImage.naturalWidth) {\r\n                throw new Exception(`Texture image layers are not the same size. (${lImage.naturalWidth}, ${lImage.naturalHeight}) needs (${lWidth}, ${lHeight}).`, this);\r\n            }\r\n\r\n            return createImageBitmap(lImage);\r\n        });\r\n\r\n        // Resolve all bitmaps.\r\n        this.mImageList = await Promise.all(lImageLoadPromiseList);\r\n\r\n        // Set new texture size.\r\n        this.mWidth = lWidth;\r\n        this.mHeight = lHeight;\r\n        this.mDepth = pSourceList.length;\r\n\r\n        // Trigger change.\r\n        this.triggerAutoUpdate(UpdateReason.Data);\r\n    }\r\n}","import { CompareFunction } from '../../constant/compare-function.enum';\r\nimport { FilterMode } from '../../constant/filter-mode.enum';\r\nimport { WrappingMode } from '../../constant/wrapping-mode.enum';\r\nimport { GpuDevice } from '../gpu/gpu-device';\r\nimport { GpuObject } from '../gpu/gpu-object';\r\nimport { UpdateReason } from '../gpu/gpu-object-update-reason';\r\nimport { SamplerMemoryLayout } from '../memory_layout/sampler-memory-layout';\r\n\r\nexport class TextureSampler extends GpuObject<'textureSampler'> {\r\n    private mCompare: CompareFunction | null;\r\n    private mLodMaxClamp: number;\r\n    private mLodMinClamp: number;\r\n    private mMagFilter: FilterMode;\r\n    private mMaxAnisotropy: number;\r\n    private readonly mMemoryLayout: SamplerMemoryLayout;\r\n    private mMinFilter: FilterMode;\r\n    private mMipmapFilter: FilterMode;\r\n    private mWrapMode: WrappingMode;\r\n\r\n    /**\r\n     * When provided the sampler will be a comparison sampler with the specified compare function.\r\n     */\r\n    public get compare(): CompareFunction | null {\r\n        return this.mCompare;\r\n    } set compare(pValue: CompareFunction | null) {\r\n        this.mCompare = pValue;\r\n\r\n        // Trigger auto update.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Specifies the maximum levels of detail, respectively, used internally when sampling a texture.\r\n     */\r\n    public get lodMaxClamp(): number {\r\n        return this.mLodMaxClamp;\r\n    } set lodMaxClamp(pValue: number) {\r\n        this.mLodMaxClamp = pValue;\r\n\r\n        // Trigger auto update.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Specifies the minimum levels of detail, respectively, used internally when sampling a texture.\r\n     */\r\n    public get lodMinClamp(): number {\r\n        return this.mLodMinClamp;\r\n    } set lodMinClamp(pValue: number) {\r\n        this.mLodMinClamp = pValue;\r\n\r\n        // Trigger auto update.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * How the texture is sampled when a texel covers more than one pixel.\r\n     */\r\n    public get magFilter(): FilterMode {\r\n        return this.mMagFilter;\r\n    } set magFilter(pValue: FilterMode) {\r\n        this.mMagFilter = pValue;\r\n\r\n        // Trigger auto update.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Specifies the maximum anisotropy value clamp used by the sampler.\r\n     */\r\n    public get maxAnisotropy(): number {\r\n        return this.mMaxAnisotropy;\r\n    } set maxAnisotropy(pValue: number) {\r\n        this.mMaxAnisotropy = pValue;\r\n\r\n        // Trigger auto update.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Sampler memory layout.\r\n     */\r\n    public get memoryLayout(): SamplerMemoryLayout {\r\n        return this.mMemoryLayout;\r\n    }\r\n\r\n    /**\r\n     * How the texture is sampled when a texel covers less than one pixel.\r\n     */\r\n    public get minFilter(): FilterMode {\r\n        return this.mMinFilter;\r\n    } set minFilter(pValue: FilterMode) {\r\n        this.mMinFilter = pValue;\r\n\r\n        // Trigger auto update.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Specifies behavior for sampling between mipmap levels.\r\n     */\r\n    public get mipmapFilter(): FilterMode {\r\n        return this.mMipmapFilter;\r\n    } set mipmapFilter(pValue: FilterMode) {\r\n        this.mMipmapFilter = pValue;\r\n\r\n        // Trigger auto update.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Texture sampler edge wrap mode.\r\n     */\r\n    public get wrapMode(): WrappingMode {\r\n        return this.mWrapMode;\r\n    } set wrapMode(pValue: WrappingMode) {\r\n        this.mWrapMode = pValue;\r\n\r\n        // Trigger auto update.\r\n        this.triggerAutoUpdate(UpdateReason.Setting);\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Device.\r\n     * @param pLayout - Sampler memory layout.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pLayout: SamplerMemoryLayout) {\r\n        super(pDevice);\r\n\r\n        this.mMemoryLayout = pLayout;\r\n\r\n        // Set defaults.\r\n        this.mCompare = null;\r\n        this.mWrapMode = WrappingMode.ClampToEdge;\r\n        this.mMagFilter = FilterMode.Nearest;\r\n        this.mMinFilter = FilterMode.Nearest;\r\n        this.mMipmapFilter = FilterMode.Nearest;\r\n        this.mLodMinClamp = 0;\r\n        this.mLodMaxClamp = 32;\r\n        this.mMaxAnisotropy = 1;\r\n\r\n        // Register change listener for layout changes.\r\n        pLayout.addUpdateListener(() => {\r\n            this.triggerAutoUpdate(UpdateReason.ChildData);\r\n        });\r\n    }\r\n}","import { GpuDevice } from '../gpu/gpu-device';\r\nimport { GpuObject } from '../gpu/gpu-object';\r\nimport { UpdateReason } from '../gpu/gpu-object-update-reason';\r\nimport { TextureMemoryLayout } from '../memory_layout/texture-memory-layout';\r\n\r\nexport class VideoTexture extends GpuObject<'videoTexture'> {\r\n    private readonly mMemoryLayout: TextureMemoryLayout;\r\n    private readonly mVideo: HTMLVideoElement;\r\n\r\n    /**\r\n     * Texture height.\r\n     */\r\n    public get height(): number {\r\n        return this.mVideo.videoHeight;\r\n    }\r\n\r\n    /**\r\n     * If video should be looped.\r\n     */\r\n    public get loop(): boolean {\r\n        return this.mVideo.loop;\r\n    } set loop(pValue: boolean) {\r\n        this.mVideo.loop = pValue;\r\n    }\r\n\r\n    /**\r\n     * Textures memory layout.\r\n     */\r\n    public get memoryLayout(): TextureMemoryLayout {\r\n        return this.mMemoryLayout;\r\n    }\r\n\r\n    /**\r\n     * Video source.\r\n     */\r\n    public get source(): string {\r\n        return this.mVideo.src;\r\n    } set source(pValue: string) {\r\n        this.mVideo.src = pValue;\r\n    }\r\n\r\n    /**\r\n     * Video element.\r\n     */\r\n    public get video(): HTMLVideoElement {\r\n        return this.mVideo;\r\n    }\r\n\r\n    /**\r\n     * Video width.\r\n     */\r\n    public get width(): number {\r\n        return this.mVideo.videoWidth;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pDevice - Device.\r\n     * @param pLayout - Texture memory layout.\r\n     * @param pDepth - Texture depth.\r\n     */\r\n    public constructor(pDevice: GpuDevice, pLayout: TextureMemoryLayout) {\r\n        super(pDevice);\r\n\r\n        // Fixed values.\r\n        this.mMemoryLayout = pLayout;\r\n\r\n        // Create video.\r\n        this.mVideo = new HTMLVideoElement();\r\n        this.mVideo.loop = false;\r\n        this.mVideo.muted = true; // Allways muted.\r\n\r\n        // Register change listener for layout changes.\r\n        pLayout.addUpdateListener(() => {\r\n            this.triggerAutoUpdate(UpdateReason.ChildData);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Pause video.\r\n     */\r\n    public pause(): void {\r\n        this.mVideo.pause();\r\n    }\r\n\r\n    /**\r\n     * Play video.\r\n     */\r\n    public play(): void {\r\n        this.mVideo.play();\r\n    }\r\n}","export enum AccessMode {\r\n    None = 0,\r\n    Read = 1,\r\n    Write = 2\r\n}","export enum BufferBindType {\r\n    Undefined = 'Undefined',\r\n    Index = 'Index',\r\n    Vertex = 'Vertex',\r\n    Uniform = 'Uniform',\r\n    Storage = 'Storage'\r\n}","export enum BufferPrimitiveFormat {\r\n    Unsupported = 'Unsupported primitive format',\r\n    Float = 'float',\r\n    Vec2Float = 'vector-2-float',\r\n    Vec3Float = 'vector-3-float',\r\n    Vec4Float = 'vector-4-float',\r\n    Uint = 'unsigned-integer',\r\n    Vec2Uint = 'vector-2-unsigned-integer',\r\n    Vec3Uint = 'vector-3-unsigned-integer',\r\n    Vec4Uint = 'vector-4-unsigned-integer',\r\n    Int = 'integer',\r\n    Vec2Int = 'vector-2-integer',\r\n    Vec3Int = 'vector-3-integer',\r\n    Vec4Int = 'vector-4-integer'\r\n}","export enum CompareFunction {\r\n    Never = 'never',\r\n    Less = 'less',\r\n    Equal = 'equal',\r\n    LessEqual = 'less-equal',\r\n    Greater = 'greater',\r\n    NotEqual = 'not-equal',\r\n    GreaterEqual = 'greater-equal',\r\n    Allways = 'always'\r\n}","export enum ComputeStage {\r\n    None = 0,\r\n    Fragment = 1,\r\n    Vertex = 2,\r\n    Compute = 4\r\n}\r\n","export enum FilterMode {\r\n    Nearest = 'nearest',\r\n    Linear = 'linear'\r\n}","export enum MemoryCopyType {\r\n    None = 0,\r\n    CopySource = 1,\r\n    CopyDestination = 2,\r\n}","export enum PrimitiveCullMode {\r\n    None = 'none',\r\n    Front = 'front',\r\n    Back = 'back'\r\n}","export enum PrimitiveFrontFace {\r\n    CounterClockWise = 'counter-clockwise',\r\n    ClockWise = 'clockwise'\r\n}","export enum PrimitiveTopology {\r\n    PointList = 'point-list',\r\n    LineList = 'line-list',\r\n    LineStrip = 'line-strip',\r\n    TriangleList = 'triangle-list',\r\n    TriangleStrip = 'triangle-strip'\r\n}","export enum SamplerType {\r\n    Filter = 'Filter',\r\n    Comparison = 'Comparison',\r\n}","export enum TextureBindType {\r\n    Images = 'Image-Texture',\r\n    External = 'External-Texture',\r\n    Storage = 'Storage-Texture',\r\n    RenderTarget = 'Render-Texture'\r\n}","export enum TextureDimension {\r\n    OneDimension = '1d',\r\n    TwoDimension = '2d',\r\n    TwoDimensionArray = '2d-array',\r\n    Cube = 'cube',\r\n    CubeArray = 'cube-array',\r\n    ThreeDimension = '3d'\r\n}","export enum TextureFormat {\r\n    Red = 'r8unorm',\r\n    RedInteger = 'r8uint',\r\n    RedGreen = 'rg8unorm',\r\n    RedGreenInteger = 'rg8uint',\r\n    RedGreenBlueAlpha = 'rgba8unorm',\r\n    RedGreenBlueAlphaInteger = 'rgba8uint',\r\n    BlueRedGreenAlpha = 'bgra8unorm',\r\n    Depth = 'depth24plus',\r\n    Stencil = 'stencil8',\r\n    DepthStencil = 'depth24plus-stencil8',\r\n}","export enum TextureOperation {\r\n    Keep = 'keep',\r\n    Clear = 'clear'\r\n}","export enum TextureUsage {\r\n    None = 0,\r\n    TextureBinding = 1,\r\n    StorageBinding = 2,\r\n    RenderAttachment = 4\r\n}","export enum WrappingMode {\r\n    ClampToEdge = 'clamp-to-edge',\r\n    Repeat = 'repeat',\r\n    MirrorRepeat = 'mirror-repeat'\r\n}","export default \"// ------------------------- Object Values ---------------------- //\\r\\n@group(0) @binding(0) var<uniform> transformationMatrix: mat4x4<f32>;\\r\\n@group(0) @binding(1) var<storage, read> instancePositions: array<vec4<f32>>;\\r\\n// -------------------------------------------------------------- //\\r\\n\\r\\n\\r\\n// ------------------------- World Values ---------------------- //\\r\\n@group(1) @binding(0) var<uniform> viewProjectionMatrix: mat4x4<f32>;\\r\\n// -------------------------------------------------------------- //\\r\\n\\r\\n\\r\\n// ------------------------- User Inputs ------------------------ //\\r\\n@group(2) @binding(0) var cubeTextureSampler: sampler;\\r\\n@group(2) @binding(1) var cubeTexture: texture_2d<f32>;\\r\\n// -------------------------------------------------------------- //\\r\\n\\r\\n\\r\\n// --------------------- Light calculations --------------------- //\\r\\nstruct AmbientLight {\\r\\n    color: vec4<f32>\\r\\n}\\r\\n@group(1) @binding(1) var<uniform> ambientLight: AmbientLight;\\r\\n\\r\\nstruct PointLight {\\r\\n    position: vec4<f32>,\\r\\n    color: vec4<f32>,\\r\\n    range: f32\\r\\n}\\r\\n@group(1) @binding(2) var<storage, read> pointLights: array<PointLight>;\\r\\n\\r\\n/**\\r\\n * Calculate point light output.\\r\\n */\\r\\nfn calculatePointLights(fragmentPosition: vec4<f32>, normal: vec4<f32>) -> vec4<f32> {\\r\\n    // Count of point lights.\\r\\n    let pointLightCount: u32 = arrayLength(&pointLights);\\r\\n\\r\\n    var lightResult: vec4<f32> = vec4<f32>(0, 0, 0, 1);\\r\\n\\r\\n    for (var index: u32 = 0; index < pointLightCount; index++) {\\r\\n        var pointLight: PointLight = pointLights[index];\\r\\n\\r\\n        // Calculate light strength based on angle of incidence.\\r\\n        let lightDirection: vec4<f32> = normalize(pointLight.position - fragmentPosition);\\r\\n        let diffuse: f32 = max(dot(normal, lightDirection), 0.0);\\r\\n\\r\\n        lightResult += pointLight.color * diffuse;\\r\\n    }\\r\\n\\r\\n    return lightResult;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Apply lights to fragment color.\\r\\n */\\r\\nfn applyLight(colorIn: vec4<f32>, fragmentPosition: vec4<f32>, normal: vec4<f32>) -> vec4<f32> {\\r\\n    var lightColor: vec4<f32> = vec4<f32>(0, 0, 0, 1);\\r\\n\\r\\n    lightColor += ambientLight.color;\\r\\n    lightColor += calculatePointLights(fragmentPosition, normal);\\r\\n\\r\\n    return lightColor * colorIn;\\r\\n}\\r\\n// -------------------------------------------------------------- //\\r\\n\\r\\nstruct VertexOut {\\r\\n    @builtin(position) position: vec4<f32>,\\r\\n    @location(0) uv: vec2<f32>,\\r\\n    @location(1) normal: vec4<f32>,\\r\\n    @location(2) fragmentPosition: vec4<f32>\\r\\n}\\r\\n\\r\\nstruct VertexIn {\\r\\n    @builtin(instance_index) instanceId : u32,\\r\\n    @location(0) position: vec4<f32>,\\r\\n    @location(1) uv: vec2<f32>,\\r\\n    @location(2) normal: vec4<f32>\\r\\n}\\r\\n\\r\\n@vertex\\r\\nfn vertex_main(vertex: VertexIn) -> VertexOut {\\r\\n    var instancePosition: vec4<f32> = instancePositions[vertex.instanceId];\\r\\n    var instancePositionMatrix: mat4x4<f32> = mat4x4<f32>(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, instancePosition.x * 5, instancePosition.y * 5, instancePosition.z * 5, 1);\\r\\n\\r\\n    var out: VertexOut;\\r\\n    out.position = viewProjectionMatrix * transformationMatrix * instancePositionMatrix * vertex.position;\\r\\n    out.uv = vertex.uv;\\r\\n    out.normal = vertex.normal;\\r\\n    out.fragmentPosition = transformationMatrix * instancePositionMatrix * vertex.position;\\r\\n\\r\\n    return out;\\r\\n}\\r\\n\\r\\nstruct FragmentIn {\\r\\n    @location(0) uv: vec2<f32>,\\r\\n    @location(1) normal: vec4<f32>,\\r\\n    @location(2) fragmentPosition: vec4<f32>\\r\\n}\\r\\n\\r\\n@fragment\\r\\nfn fragment_main(fragment: FragmentIn) -> @location(0) vec4<f32> {\\r\\n    return applyLight(textureSample(cubeTexture, cubeTextureSampler, fragment.uv), fragment.fragmentPosition, fragment.normal);\\r\\n}\";","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Dictionary = void 0;\nconst list_1 = require(\"../list/list\");\nconst exception_1 = require(\"../../exception/exception\");\n/**\n * Default dictionary.\n */\nclass Dictionary extends Map {\n    /**\n     * Add value and key to dictionary.\n     * @param pKey - Key of item.\n     * @param pValue - value of item.\n     */\n    add(pKey, pValue) {\n        // Add value and key to containers.\n        if (!this.has(pKey)) {\n            this.set(pKey, pValue);\n        }\n        else {\n            throw new exception_1.Exception(\"Can't add dublicate key to dictionary.\", this);\n        }\n    }\n    /**\n     * Get all keys that have the set value.\n     * @param pValue - Value.\n     */\n    getAllKeysOfValue(pValue) {\n        // Add entires iterator to list and filter for pValue = Value\n        const lKeyValuesWithValue = list_1.List.newListWith(...this.entries()).filter((pItem) => {\n            return pItem[1] === pValue;\n        });\n        // Get only keys of key values.\n        const lKeysOfKeyValue = lKeyValuesWithValue.map((pItem) => {\n            return pItem[0];\n        });\n        return lKeysOfKeyValue;\n    }\n    /**\n     * Get item of dictionary. If key does not exists the default value gets returned.\n     * @param pKey - key of item.\n     * @param pDefault - Default value if key was not found.\n     */\n    getOrDefault(pKey, pDefault) {\n        const lValue = this.get(pKey);\n        if (typeof lValue !== 'undefined') {\n            return lValue;\n        }\n        else {\n            return pDefault;\n        }\n    }\n    /**\n     * Maps information into new list.\n     * @param pFunction - Mapping funktion.\n     */\n    map(pFunction) {\n        const lResultList = new list_1.List();\n        for (const lKeyValuePair of this) {\n            // Execute callback and add result to list.\n            const lMappingResult = pFunction(lKeyValuePair[0], lKeyValuePair[1]);\n            lResultList.push(lMappingResult);\n        }\n        return lResultList;\n    }\n}\nexports.Dictionary = Dictionary;\n//# sourceMappingURL=dictionary.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.List = void 0;\n/**\n * Extended array functionality.\n */\nclass List extends Array {\n    /**\n     * Create list and add items.\n     * @param pItemList - Items.\n     */\n    static newListWith(...pItemList) {\n        const lNewList = new List();\n        lNewList.push(...pItemList);\n        return lNewList;\n    }\n    /**\n     * Clear list.\n     */\n    clear() {\n        this.splice(0, this.length);\n    }\n    /**\n     * Copy first layer of object.\n     */\n    clone() {\n        return List.newListWith(...this);\n    }\n    /**\n     * Distinct values inside list.\n     */\n    distinct() {\n        const lSelf = this;\n        // Get all values where index is same index as first index of first appearance.\n        const lDistinctArray = this.filter((pValue, pIndex) => {\n            return lSelf.indexOf(pValue) === pIndex;\n        });\n        return List.newListWith(...lDistinctArray);\n    }\n    /**\n     * Check if arrays are the same.\n     * @param pArray - Array.\n     */\n    equals(pArray) {\n        // Check if array are same, dont null and have same length.\n        if (this === pArray) {\n            return true;\n        }\n        else if (!pArray || this.length !== pArray.length) {\n            return false;\n        }\n        // Check each item.\n        for (let lIndex = 0; lIndex < this.length; ++lIndex) {\n            if (this[lIndex] !== pArray[lIndex]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Removes the first appearence of value.\n     * @param pValue - value requested for removement.\n     */\n    remove(pValue) {\n        const lFoundIndex = this.indexOf(pValue);\n        // Only remove if found.\n        if (lFoundIndex !== -1) {\n            return this.splice(lFoundIndex, 1)[0];\n        }\n        return undefined;\n    }\n    /**\n     * Replace first appearence of value.\n     * @param pOldValue - Target value to replace.\n     * @param pNewValue - Replacement value.\n     */\n    replace(pOldValue, pNewValue) {\n        const lFoundIndex = this.indexOf(pOldValue);\n        // Only replace if found.\n        if (lFoundIndex !== -1) {\n            // Save old value and replace it with new value.\n            const lOldValue = this[lFoundIndex];\n            this[lFoundIndex] = pNewValue;\n            return lOldValue;\n        }\n        return undefined;\n    }\n    /**\n     * List to string.\n     */\n    toString() {\n        return `[${super.join(', ')}]`;\n    }\n}\nexports.List = List;\n//# sourceMappingURL=list.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseTree = void 0;\nconst dictionary_1 = require(\"../dictionary/dictionary\");\nconst list_1 = require(\"../list/list\");\n/**\n * BaseTree with generic path.\n */\nclass BaseTree {\n    /**\n     * Get all child branches of branch.\n     */\n    get branchList() {\n        return list_1.List.newListWith(...this.mBranches.values());\n    }\n    /**\n     * Get parent branch.\n     */\n    get parent() {\n        return this.mParent;\n    }\n    /**\n     * Constructor.\n     * Basic initialization.\n     */\n    constructor() {\n        this.mBranches = new dictionary_1.Dictionary();\n        this.mParent = null;\n    }\n    /**\n     * Adds new branch to tree.\n     * Does nothing if branch already exists.\n     * Returns last added branch.\n     * @param pBranchPath -  Branch to add.\n     */\n    addBranch(...pBranchPath) {\n        // If new branch can be added.\n        if (pBranchPath.length !== 0) {\n            const lCurrentBranchKey = pBranchPath.splice(0, 1)[0];\n            // Create new branch if not created.\n            if (!this.mBranches.has(lCurrentBranchKey)) {\n                // Set this as new branch parent.\n                const lNewBranch = this.createNewBranch(lCurrentBranchKey);\n                lNewBranch.mParent = this;\n                this.mBranches.add(lCurrentBranchKey, lNewBranch);\n            }\n            // Add next branch path.\n            const lCurrentBranch = this.mBranches.get(lCurrentBranchKey);\n            return lCurrentBranch.addBranch(...pBranchPath);\n        }\n        return this;\n    }\n    /**\n     * Get all paths of tree.\n     * @param pPath - Additional paths.\n     */\n    getAllPaths() {\n        return this.extendPath(new list_1.List());\n    }\n    /**\n     * Get Tree by branch path. Return undefined if no branch was found.\n     * @param pBranchPath - Branch path.\n     */\n    getBranch(...pBranchPath) {\n        // If no path was specified. Return this tree.\n        if (pBranchPath.length === 0) {\n            return this;\n        }\n        // Check if this tree has branch\n        if (this.mBranches.has(pBranchPath[0])) {\n            // remove first item in branch and safe.\n            const lCurrentLocationBranchValue = pBranchPath.splice(0, 1)[0];\n            const lCurrentLocationBranch = this.mBranches.get(lCurrentLocationBranchValue);\n            // Seach branch in next tree with modified path.\n            return lCurrentLocationBranch.getBranch(...pBranchPath);\n        }\n        // No branch found.\n        return undefined;\n    }\n    /**\n     * Check if path exists.\n     * Path specifed path doesn't need to have values.\n     * @param pBranchPath - Path to branch.\n     */\n    hasPath(...pBranchPath) {\n        return !!this.getBranch(...pBranchPath);\n    }\n    /**\n     * Removes branch by path.\n     * Returns undefined if branch does not exist.\n     * @param pBranchPath - Path to branch.\n     */\n    removeBranch(...pBranchPath) {\n        const lFoundBranch = this.getBranch(...pBranchPath);\n        // Check if parameter or branch exists.\n        if (pBranchPath.length === 0 || !lFoundBranch) {\n            return undefined;\n        }\n        else if (pBranchPath.length === 1) {\n            const lFirstBranchPathValue = pBranchPath[0];\n            // Remove branch if path has only one level.\n            // Does not throw if no element was found.\n            const lRemovedBranch = this.mBranches.get(lFirstBranchPathValue);\n            this.mBranches.delete(lFirstBranchPathValue);\n            // Remove parent and return.\n            lRemovedBranch.mParent = null;\n            return lRemovedBranch;\n        }\n        // Get parent and remove branch last path element. Parent of child is always set.\n        const lParentBranch = lFoundBranch.parent;\n        return lParentBranch.removeBranch(pBranchPath.pop());\n    }\n    /**\n     * Extends specified path with all possible paths of current tree branches.\n     * @param pStartingPath - Staring path.\n     */\n    extendPath(pStartingPath) {\n        const lExtendedPaths = new Array();\n        // Get extended path of all branches.\n        for (const lBranchKey of this.mBranches.keys()) {\n            const lBranchPath = list_1.List.newListWith(...pStartingPath, lBranchKey);\n            // Add path to current branch.\n            lExtendedPaths.push(lBranchPath);\n            // Get all paths of branch.\n            const lBranch = this.mBranches.get(lBranchKey);\n            lExtendedPaths.push(...lBranch.extendPath(lBranchPath));\n        }\n        return lExtendedPaths;\n    }\n}\nexports.BaseTree = BaseTree;\n//# sourceMappingURL=base-tree.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListTree = void 0;\nconst base_tree_1 = require(\"./base-tree\");\nconst list_1 = require(\"../list/list\");\n/**\n * Tree with additional item list.\n */\nclass ListTree extends base_tree_1.BaseTree {\n    /**\n     * Get all items of this branch and all of its childs.\n     */\n    get deepItemList() {\n        return this.getDeepItemList();\n    }\n    /**\n     * Get item of this branch\n     */\n    get itemList() {\n        return this.mItemList.clone();\n    }\n    /**\n     * Initialise list.\n     */\n    constructor() {\n        super();\n        this.mItemList = new list_1.List();\n    }\n    /**\n     * Add items to branch.\n     * @param pItemList - Item list.\n     */\n    addItem(...pItemList) {\n        this.mItemList.push(...pItemList);\n        return this;\n    }\n    /**\n     * Creates new branch.\n     * @param pBranchKey - Branch key for new branch.\n     */\n    createNewBranch(_pBranchKey) {\n        return new ListTree();\n    }\n    /**\n     * Get all listed items on branch and its childs.\n     */\n    getDeepItemList() {\n        const lFoundItems = list_1.List.newListWith(...this.mItemList);\n        // Find all items recurive.\n        for (const lBranch of this.branchList) {\n            lFoundItems.push(...lBranch.getDeepItemList());\n        }\n        return lFoundItems;\n    }\n}\nexports.ListTree = ListTree;\n//# sourceMappingURL=list-tree.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Tree = void 0;\nconst base_tree_1 = require(\"./base-tree\");\n/**\n * Tree with generic path.\n */\nclass Tree extends base_tree_1.BaseTree {\n    /**\n     * Create new emtpy branch.\n     */\n    createNewBranch(_pBranchKey) {\n        return new Tree();\n    }\n}\nexports.Tree = Tree;\n//# sourceMappingURL=tree.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Exception = void 0;\n/**\n * Basic exception.\n */\nclass Exception extends Error {\n    /**\n     * Target exception throws.\n     */\n    get target() {\n        return this.mTarget;\n    }\n    /**\n     * Constructor. Create exception.\n     * @param pMessage - Messsage of exception.\n     * @param pTarget - Target exception throws.\n     */\n    constructor(pMessage, pTarget) {\n        super(pMessage);\n        this.mTarget = pTarget;\n    }\n}\nexports.Exception = Exception;\n//# sourceMappingURL=exception.js.map","\"use strict\";\n/* istanbul ignore file */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeUtil = exports.EnumUtil = exports.Exception = exports.Tree = exports.ListTree = exports.List = exports.Dictionary = void 0;\n// Container.\nvar dictionary_1 = require(\"./data_container/dictionary/dictionary\");\nObject.defineProperty(exports, \"Dictionary\", { enumerable: true, get: function () { return dictionary_1.Dictionary; } });\nvar list_1 = require(\"./data_container/list/list\");\nObject.defineProperty(exports, \"List\", { enumerable: true, get: function () { return list_1.List; } });\nvar list_tree_1 = require(\"./data_container/tree/list-tree\");\nObject.defineProperty(exports, \"ListTree\", { enumerable: true, get: function () { return list_tree_1.ListTree; } });\nvar tree_1 = require(\"./data_container/tree/tree\");\nObject.defineProperty(exports, \"Tree\", { enumerable: true, get: function () { return tree_1.Tree; } });\nvar exception_1 = require(\"./exception/exception\");\nObject.defineProperty(exports, \"Exception\", { enumerable: true, get: function () { return exception_1.Exception; } });\n// Handler.\nvar enum_util_1 = require(\"./util/enum-util\");\nObject.defineProperty(exports, \"EnumUtil\", { enumerable: true, get: function () { return enum_util_1.EnumUtil; } });\nvar type_util_1 = require(\"./util/type-util\");\nObject.defineProperty(exports, \"TypeUtil\", { enumerable: true, get: function () { return type_util_1.TypeUtil; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EnumUtil = void 0;\n/**\n * Enumaration helper.\n */\nclass EnumUtil {\n    /**\n     * Return enum of enum value.\n     * @param pEnum - typeof Enum object.\n     * @param pValue - Value of enum.\n     */\n    static enumKeyByValue(pEnum, pValue) {\n        // Thats it... :)\n        if (EnumUtil.enumValueExists(pEnum, pValue)) {\n            return pValue;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Return all keys of an enum as array.\n     * @param pEnum - typeof Enum object.\n     */\n    static enumNamesToArray(pEnum) {\n        // Convert enum to key array.\n        return Object.keys(pEnum).filter((pKey) => isNaN(Number(pKey)));\n    }\n    /**\n     * Check if value exists in enum object.\n     * @param pEnum - typeof Enum object.\n     * @param pValue - Value of enum.\n     */\n    static enumValueExists(pEnum, pValue) {\n        return EnumUtil.enumValuesToArray(pEnum).includes(pValue);\n    }\n    /**\n     * Return all values of an enum as array.\n     * @param pEnum - typeof Enum object.\n     */\n    static enumValuesToArray(pEnum) {\n        const lEnumValues = new Array();\n        // Convert enum to vaue array by iterating over all keys.\n        for (const lKey of EnumUtil.enumNamesToArray(pEnum)) {\n            lEnumValues.push(pEnum[lKey]);\n        }\n        return lEnumValues;\n    }\n}\nexports.EnumUtil = EnumUtil;\n//# sourceMappingURL=enum-util.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeUtil = void 0;\n/**\n * Type helper.\n */\nclass TypeUtil {\n    /**\n     * Check existence of a member name and return that name.\n     * @param pName - Property name.\n     */\n    static nameOf(pName) {\n        return pName;\n    }\n}\nexports.TypeUtil = TypeUtil;\n//# sourceMappingURL=type-util.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { InstructionExecuter } from '../../source/base/base/execution/instruction-executor';\r\nimport { GpuDevice } from '../../source/base/base/gpu/gpu-device';\r\nimport { WebGpuGeneratorFactory } from '../../source/base/base/implementation/web_gpu/web-gpu-generator-factory';\r\nimport { WebGpuShaderInterpreter } from '../../source/base/base/implementation/web_gpu/web-gpu-shader-interpreter';\r\nimport { ArrayBufferMemoryLayout } from '../../source/base/base/memory_layout/buffer/array-buffer-memory-layout';\r\nimport { LinearBufferMemoryLayout } from '../../source/base/base/memory_layout/buffer/linear-buffer-memory-layout';\r\nimport { StructBufferMemoryLayout } from '../../source/base/base/memory_layout/buffer/struct-buffer-memory-layout';\r\nimport { SamplerMemoryLayout } from '../../source/base/base/memory_layout/sampler-memory-layout';\r\nimport { TextureMemoryLayout } from '../../source/base/base/memory_layout/texture-memory-layout';\r\nimport { VertexParameter } from '../../source/base/base/pipeline/parameter/vertex-parameter';\r\nimport { RenderTargets } from '../../source/base/base/pipeline/target/render-targets';\r\nimport { TextureGroup } from '../../source/base/base/pipeline/target/texture-group';\r\nimport { VertexFragmentPipeline } from '../../source/base/base/pipeline/vertex-fragment-pipeline';\r\nimport { PrimitiveCullMode } from '../../source/base/constant/primitive-cullmode';\r\nimport { TextureOperation } from '../../source/base/constant/texture-operation';\r\nimport { CubeVertexIndices, CubeVertexNormalData, CubeVertexPositionData, CubeVertexUvData } from './cube/cube';\r\nimport shader from './shader.wgsl';\r\nimport { AmbientLight } from './something_better/light/ambient-light';\r\nimport { Transform, TransformMatrix } from './something_better/transform';\r\nimport { PerspectiveProjection } from './something_better/view_projection/projection/perspective-projection';\r\nimport { CameraMatrix, ViewProjection } from './something_better/view_projection/view-projection';\r\n\r\nconst gHeight: number = 10;\r\nconst gWidth: number = 10;\r\nconst gDepth: number = 10;\r\n\r\n(async () => {\r\n    const lGpu: GpuDevice = await GpuDevice.request(new WebGpuGeneratorFactory('high-performance'), WebGpuShaderInterpreter);\r\n\r\n    // Create and configure render targets.\r\n    const lTextureGroup: TextureGroup = lGpu.textureGroup(640, 640, 2);\r\n    lTextureGroup.addBuffer('color', 'Color');\r\n    lTextureGroup.addBuffer('depth', 'Depth');\r\n    lTextureGroup.addTarget('canvas');\r\n\r\n    // Create shader.\r\n    const lShader = lGpu.renderShader(shader, 'vertex_main', 'fragment_main');\r\n\r\n    /*\r\n     * Transformation and position group. \r\n     */\r\n    const lTransformationGroupLayout = lShader.pipelineLayout.getGroupLayout(0);\r\n    const lTransformationGroup = lTransformationGroupLayout.createGroup();\r\n\r\n    // Create transformation.\r\n    const lCubeTransform: Transform = new Transform();\r\n    lCubeTransform.setScale(0.1, 0.1, 0.1);\r\n    lTransformationGroup.setData('transformationMatrix', (<ArrayBufferMemoryLayout>lTransformationGroupLayout.getBind('transformationMatrix').layout).create(new Float32Array(lCubeTransform.getMatrix(TransformMatrix.Transformation).dataArray)));\r\n\r\n    // Create instance positions.\r\n    const lCubeInstanceTransformationData: Array<number> = new Array<number>();\r\n    for (let lWidthIndex: number = 0; lWidthIndex < gWidth; lWidthIndex++) {\r\n        for (let lHeightIndex: number = 0; lHeightIndex < gHeight; lHeightIndex++) {\r\n            for (let lDepthIndex: number = 0; lDepthIndex < gDepth; lDepthIndex++) {\r\n                lCubeInstanceTransformationData.push(lWidthIndex, lHeightIndex, lDepthIndex, 1);\r\n            }\r\n        }\r\n    }\r\n    lTransformationGroup.setData('transformationMatrix', (<ArrayBufferMemoryLayout>lTransformationGroupLayout.getBind('transformationMatrix').layout).create(new Float32Array(lCubeInstanceTransformationData)));\r\n\r\n    /*\r\n     * Camera and world group. \r\n     */\r\n    const lWorldGroupLayout = lShader.pipelineLayout.getGroupLayout(1);\r\n    const lWorldGroup = lWorldGroupLayout.createGroup();\r\n\r\n    // Create camera perspective.\r\n    const lPerspectiveProjection: PerspectiveProjection = new PerspectiveProjection();\r\n    lPerspectiveProjection.aspectRatio = lTextureGroup.width / lTextureGroup.height;\r\n    lPerspectiveProjection.angleOfView = 72;\r\n    lPerspectiveProjection.near = 0.1;\r\n    lPerspectiveProjection.far = 9999999;\r\n\r\n    // Create camera.\r\n    const lCamera: ViewProjection = new ViewProjection(lPerspectiveProjection);\r\n    lCamera.transformation.setTranslation(0, 0, -4);\r\n    lWorldGroup.setData('viewProjectionMatrix', (<LinearBufferMemoryLayout>lWorldGroupLayout.getBind('viewProjectionMatrix').layout).create(new Float32Array(lCamera.getMatrix(CameraMatrix.ViewProjection).dataArray)));\r\n\r\n    // Create ambient light.\r\n    const lAmbientLight: AmbientLight = new AmbientLight();\r\n    lAmbientLight.setColor(0.1, 0.1, 0.1);\r\n    lWorldGroup.setData('ambientLight', (<StructBufferMemoryLayout>lWorldGroupLayout.getBind('ambientLight').layout).create(new Float32Array(lCamera.getMatrix(CameraMatrix.ViewProjection).dataArray)));\r\n\r\n    // Create point lights.\r\n    lWorldGroup.setData('pointLights', (<StructBufferMemoryLayout>lWorldGroupLayout.getBind('pointLights').layout).create(new Float32Array([\r\n        /* Position */1, 1, 1, 1, /* Color */1, 0, 0, 1,/* Range */ 200, 0, 0, 0,\r\n        /* Position */10, 10, 10, 1, /* Color */0, 0, 1, 1,/* Range */ 200, 0, 0, 0\r\n    ])));\r\n\r\n    /*\r\n     * User defined group.\r\n     */\r\n    const lUserGroupLayout = lShader.pipelineLayout.getGroupLayout(2);\r\n    const lUserGroup = lUserGroupLayout.createGroup();\r\n\r\n    // Setup cube texture.\r\n    const lCubeTexture = await (<TextureMemoryLayout>lUserGroupLayout.getBind('cubeTexture').layout).createImageTexture('/source/cube_texture/cube-texture.png');\r\n    lUserGroup.setData('cubeTexture', lCubeTexture);\r\n\r\n    // Setup Sampler.\r\n    const lCubeSampler = (<SamplerMemoryLayout>lUserGroupLayout.getBind('cubeTextureSampler').layout).create();\r\n    lUserGroup.setData('cubeTextureSampler', lCubeSampler);\r\n\r\n    // Generate render parameter from parameter layout.\r\n    const lMesh: VertexParameter = lShader.parameterLayout.createData(CubeVertexIndices);\r\n    lMesh.set('vertex.position', CubeVertexPositionData);\r\n    lMesh.set('vertex.uv', CubeVertexUvData); // TODO: Convert to Indexbased parameter.\r\n    lMesh.set('vertex.normal', CubeVertexNormalData); // TODO: Convert to Indexbased parameter.\r\n\r\n    // Set render targets.\r\n    const lRenderTargets: RenderTargets = lTextureGroup.create();\r\n    lRenderTargets.addColorBuffer('color', 0xaaaaaa, TextureOperation.Clear, TextureOperation.Keep, 'canvas');\r\n    lRenderTargets.setDepthStencilBuffer('depth', 0xff, TextureOperation.Clear, TextureOperation.Keep);\r\n\r\n    // Create pipeline.\r\n    const lPipeline: VertexFragmentPipeline = lShader.createPipeline(lRenderTargets);\r\n    lPipeline.primitiveCullMode = PrimitiveCullMode.Back;\r\n\r\n    // Create executor.\r\n    const lInstructionExecutor: InstructionExecuter = lGpu.instructionExecutor();\r\n\r\n    // Create instruction.\r\n    const lRenderInstruction = lInstructionExecutor.createVertexFragmentInstruction(lRenderTargets);\r\n    lRenderInstruction.addStep(lPipeline, lMesh, {\r\n        0: lTransformationGroup,\r\n        1: lWorldGroup,\r\n        2: lUserGroup\r\n    });\r\n\r\n    // TODO: Instruction set execution.\r\n    let lLastTime: number = 0;\r\n    const lRender = (pTime: number) => {\r\n        // Start new frame.\r\n        lGpu.startNewFrame();\r\n\r\n        // Generate encoder and add render commands.\r\n        lInstructionExecutor.execute();\r\n\r\n        const lFps: number = 1000 / (pTime - lLastTime);\r\n        (<any>window).currentFps = lFps;\r\n        lLastTime = pTime;\r\n\r\n        // Refresh canvas\r\n        requestAnimationFrame(lRender);\r\n    };\r\n    requestAnimationFrame(lRender);\r\n})();"],"names":["exports","Euler","x","mX","pValue","y","mY","z","mZ","constructor","Matrix","fromArray","pArray","pHeight","pWidth","lData","Array","lRowIndex","lRowData","lColumnIndex","push","identity","pSize","fill","data","mData","dataArray","width","height","length","pData","add","pAddData","core_data_1","adjoint","lMatrixData","lMatrixRow","lColumIndex","lDeterminant","omit","determinant","Math","pow","lCofactorMatrix","transpose","lIterationIndex","lSignedNumber","lDeterminantMatrix","inverse","lAdjoint","mult","pMultData","lProduct","lComponentIndex","pOmitRow","pOmitColumn","sub","vectorMult","lVectorComponent","lMutiplicatedMatrix","lVectorData","vector_1","Quaternion","fromRotation","pPitch","pYaw","pRoll","lPitchRadian","PI","lYawRadian","lRollRadian","lCosPitch","cos","lSinPitch","sin","lCosYaw","lSinYaw","lCosRoll","lSinRoll","lQuaternion","w","vectorForward","lSquareX","lSquareY","lProductXz","lProductYw","mW","lProductYz","lProductXw","lX","lY","lZ","vectorRight","lSquareZ","lProductXy","lProductZw","vectorUp","pW","pX","pY","pZ","addEulerRotation","asEuler","lEuler","euler_1","lSinPitchCosYaw","lCosPitchCosYaw","atan2","lPitchDegree","sqrt","lYawDegree","lSinRollCosYaw","lCosRollCosYaw","lRollDegree","asMatrix","lMatrix","matrix_1","pQuaternion","lW","normalize","lLength","hypot","Vector","lIndex","lItem","multCross","pVector","multDot","pSubData","AmbientLight","mColor","setColor","pRed","pGreen","pBlue","Transform","pivotX","mPivot","pivotY","pivotZ","rotationPitch","mRotation","rotationRoll","rotationYaw","scaleDepth","mScale","scaleHeight","scaleWidth","translationX","mTranslation","translationY","translationZ","quaternion_1","addRotation","addScale","pDepth","addTranslation","getMatrix","pType","TransformMatrix","Scale","Translation","Rotation","PivotRotation","lRotationMatrix","lPivotRotation","Transformation","lScale","lTranslation","lRotation","setRotation","lPitch","lYaw","lRoll","setScale","setTranslation","translateInDirection","pForward","pRight","pUp","lTranslationVector","lDirectionVector","PerspectiveProjection","angleOfView","mAngleOfView","mCacheProjectionMatrix","aspectRatio","mAspectRatio","far","mFar","near","mNear","projectionMatrix","createMatrix","lFar","lNear","lTop","tan","lBottom","lRight","lLeft","ViewProjection","projection","mProjection","transformation","mTransformation","pProjection","transform_1","CameraMatrix","Projection","View","lView","lProjection","BindDataGroupLayout","gpu_object_1","bindingNames","mBindings","keys","bindings","lBindingList","lBinding","values","index","identifier","mIdentifier","pDevice","addUpdateListener","lIdentifier","lBind","name","layout","accessMode","bindingIndex","memoryType","visibility","addBinding","pLayout","pName","set","triggerAutoUpdate","gpu_object_update_reason_1","ChildData","createGroup","bind_data_group_1","device","getBind","has","get","BindDataGroup","mLayout","pBindGroupLayout","mBindData","getData","pBindName","setData","PipelineDataLayout","groups","mBindGroups","addGroupLayout","pIndex","getGroupLayout","GpuBuffer","dataType","mDataType","mItemCount","memoryLayout","size","BYTES_PER_ELEMENT","pInitialData","writeRaw","read","pLayoutPath","lLocation","locationOf","readRaw","offset","pOffset","lOffset","lSize","lBufferGenerator","generator","request","write","InstructionExecuter","mInstructionList","createComputeInstruction","lInstruction","compute_instruction_1","createVertexFragmentInstruction","pRenderTargets","vertex_fragment_instruction_1","execute","lInstructionExecutor","startExecution","endExecution","ComputeInstruction","executor","mExecutor","steps","mStepList","pExecutor","addStep","pPipeline","pBindData","lStep","pipeline","bindData","lGroup","shader","pipelineLayout","lBindDataGroup","lBindGroupLayout","VertexFragmentInstruction","renderTargets","mRenderTargets","pParameter","pInstanceCount","parameter","instanceCount","BaseGeneratorFactory","mDevice","mGeneratorConstructors","mGenerators","init","initInternals","pBaseObject","lGeneratorConstructor","lNullCache","lGenerator","registerGenerator","pGenerator","BaseNativeBufferGenerator","base_native_generator_1","BaseNativeGenerator","factory","mFactory","gpuObject","mGpuObject","updateReasons","mUpdateReasons","pFactory","mNative","mLastGeneratedFrame","create","nativeLifeTime","NativeObjectLifeTime","Persistent","Single","invalidate","LifeTime","Frame","frameCount","any","destroy","generate","clear","pDestroyReason","_pNative","GpuDevice","pShaderInterpreter","lDevice","mFrameCounter","mGenerator","shaderInterpreter","mShaderInterpreter","shader_interpreter_factory_1","instructionExecutor","instruction_executor_1","renderShader","pSource","pVertexEntry","pFragmentEntry","vertex_fragment_shader_1","startNewFrame","textureGroup","pMultisampleLevel","texture_group_1","GpuObjectUpdateReason","mReasons","Set","pReason","UpdateReason","GpuObject","autoUpdate","mAutoUpdate","mUpdateListenerList","pListener","removeUpdateListener","delete","update","pUpdateReason","lUpdateListener","WebGpuBindDataGroupGenerator","lEntryList","lBindname","lBindLayout","lBindData","lGroupEntry","binding","resource","gpu_buffer_1","buffer","video_texture_1","texture_sampler_1","frame_buffer_texture_1","image_texture_1","canvas_texture_1","gpu","createBindGroup","label","entries","WebGpuBindDataGroupLayoutGenerator","lEntry","lLayoutEntry","base_buffer_memory_layout_1","lBufferBindingType","bindType","buffer_bind_type_enum_1","Uniform","Storage","access_mode_enum_1","Read","lBufferLayout","type","minBindingSize","hasDynamicOffset","sampler_memory_layout_1","lSamplerBindingType","samplerType","sampler_type_enum_1","Comparison","Filter","lSamplerLayout","sampler","texture_memory_layout_1","texture_bind_type_enum_1","External","lExternalTextureLayout","externalTexture","Images","lTextureLayout","sampleType","sampleTypeFromLayout","multisampled","viewDimension","dimension","texture","Write","lStorageTextureLayout","access","format","formatFromLayout","storageTexture","createBindGroupLayout","WebGpuCanvasTextureGenerator","mContext","_pNativeObject","unconfigure","canvas","getContext","configure","usage","usageFromLayout","alphaMode","lTexture","getCurrentTexture","createView","WebGpuFramebufferTextureGenerator","mTexture","createTexture","depth","dimensionFromLayout","sampleCount","multiSampleLevel","WebGpuGpuBufferGenerator","base_native_buffer_generator_1","mReadyBufferList","mWavingBufferList","lBuffer","mapAsync","GPUMapMode","READ","getMappedRange","lStagingBuffer","createBuffer","GPUBufferUsage","MAP_WRITE","COPY_SRC","mappedAtCreation","pop","lBufferArray","unmap","lCommandDecoder","createCommandEncoder","copyBufferToBuffer","queue","submit","finish","WRITE","then","pNativeObject","lCount","lUsage","Undefined","Index","INDEX","STORAGE","UNIFORM","Vertex","VERTEX","memory_copy_type_enum_1","CopyDestination","COPY_DST","CopySource","WebGpuImageTextureGenerator","lImageIndex","images","lBitmap","copyExternalImageToTexture","source","origin","WebGpuPipelineDataLayoutGenerator","lBindGoupIndices","lPipelineLayoutDescriptor","bindGroupLayouts","createPipelineLayout","WebGpuTextureSamplerGenerator","lNativeCompareFunction","compareFunctionToNative","compare","lAddressMode","wrapMode","wrapping_mode_enum_1","ClampToEdge","MirrorRepeat","Repeat","lMipMapFilter","mipmapFilter","filter_mode_enum_1","Linear","Nearest","lSamplerOptions","addressModeU","addressModeV","addressModeW","magFilter","toNativeFilterMode","minFilter","lodMaxClamp","lodMinClamp","maxAnisotropy","createSampler","pFilerMode","WebGpuVertexFragmentShaderGenerator","createShaderModule","code","information","WebGpuVideoTextureGenerator","importExternalTexture","video","colorSpace","WebGpuGeneratorFactory","base_generator_factory_1","mGpuDevice","preferredFormat","window","navigator","getPreferredCanvasFormat","pMode","mPerformance","mGpuAdapter","web_gpu_gpu_buffer_generator_1","bind_data_group_layout_1","web_gpu_bind_data_group_layout_generator_1","web_gpu_bind_data_group_generator_1","pipeline_data_layout_1","web_gpu_pipeline_data_layout_generator_1","web_gpu_canvas_texture_generator_1","web_gpu_frame_buffer_texture_generator_1","web_gpu_video_texture_generator_1","web_gpu_image_texture_generator_1","web_gpu_texture_sampler_generator_1","web_gpu_vertex_fragment_shader_generator_1","byteCountOfVertexFormat","pPrimitiveFormat","buffer_primitive_format_1","Float","Int","Uint","Vec2Float","Vec2Uint","Vec2Int","Vec3Int","Vec3Float","Vec3Uint","Vec4Int","Vec4Float","Vec4Uint","Unsupported","pCompareFunction","compare_function_enum_1","Allways","Greater","Equal","GreaterEqual","LessEqual","Less","Never","NotEqual","texture_dimension_enum_1","OneDimension","TwoDimension","Cube","CubeArray","ThreeDimension","TwoDimensionArray","texture_format_enum_1","BlueRedGreenAlpha","Depth","DepthStencil","Red","RedGreen","RedGreenBlueAlpha","RedGreenBlueAlphaInteger","RedGreenInteger","RedInteger","Stencil","lAdapter","mAdapters","requestAdapter","powerPreference","mDevices","requestDevice","toNativeVertexFormat","GPUTextureUsage","texture_usage_enum_1","RenderAttachment","RENDER_ATTACHMENT","StorageBinding","STORAGE_BINDING","TextureBinding","TEXTURE_BINDING","WebGpuShaderInterpreter","base_shader_interpreter_1","fetchFunctionDefinitions","pSourceCode","lFunctionRegex","lFunctionList","lFunctionMatch","matchAll","lFunctionName","lFunctionResult","lFunctionAttributes","lFunctionParameter","lAttachments","lAttributeMatch","lAttributeName","lAttributeValue","lFunctionBodyStart","slice","lBracketRegex","lBracketLayer","lClosingBracketIndex","lBracketMatch","exec","lBracket","lFunctionBody","lParameterVariableList","fetchVariableDefinitions","lReturnTypes","at","returnType","attachments","body","fetchStructDefinitions","lStuctRegex","lStructDefinitionList","lStructMatch","lStructName","lStructBody","properies","fetchValueDefinitions","lAllGroupLines","reduce","pCurrent","pLine","functionFromDefinition","pDefinition","lParameter","map","pParameterDefintion","valueFromDefinition","value","lReturnType","lTag","compute_stage_enum_1","None","Fragment","Compute","lUsedGlobals","lGlobalValue","includes","lAttachmentValueRexgex","lAttachment","lAttachmentName","lAttachmentValues","pMatch","trim","filter","entryPoints","return","usedGlobals","setupShaderTypes","pAddType","wgsl_type_enum_1","Boolean","variants","align","Integer32","UnsignedInteger32","Float32","Float16","Vector2","generic","Vector3","Vector4","Matrix22","aliases","Matrix23","Matrix24","Matrix32","Matrix33","Matrix34","Matrix42","Matrix43","Matrix44","Atomic","Texture1d","Texture2d","Texture2dArray","Texture3d","TextureCube","TextureCubeArray","TextureMultisampled2d","TextureExternal","TextureStorage1d","TextureStorage2d","TextureStorage2dArray","TextureStorage3d","TextureDepth2d","TextureDepth2dArray","TextureDepthCube","TextureDepthCubeArray","TextureDepthMultisampled2d","Sampler","SamplerComparison","Reference","Pointer","pValueDefinition","lDefinitionType","typeFor","typeGenerics","lBufferBindType","lBindingTypeEnum","lAccessMode","lAccessEnum","lBindingIndex","parseInt","lParameterIndex","lCreationParameter","valueDefinition","typeDefinition","bufferBindType","groupIndex","memoryIndex","location","visibilityOf","createStructBufferLayout","typeName","createSamplerLayout","createArrayBufferLayout","createLinearBufferLayout","createTextureLayout","lArraySize","lArraySizeGeneric","isNaN","lInnerTypeDefinition","lInnerType","lArrayMemoryLayout","array_buffer_memory_layout_1","arraySize","innerType","group","lLinearBufferLayout","linear_buffer_memory_layout_1","alignment","locationIndex","primitiveFormat","lSamplerType","lSamplerMemoryLayout","lStructMemoryLayout","struct_buffer_memory_layout_1","structName","struct","lPropertyIndex","properties","lProperty","addProperty","lTextureWgslType","lUsesMultisample","textureDimensionFromType","textureDefaultFormatFromType","textureBindTypeFromType","pSourceSnipped","lDefinitionRegex","lVariableList","lDefinitionMatch","lVariableTypeName","lVariableName","lVariableAttributes","lVariableAccess","lVariableGenerics","lAccessList","split","lGenericList","lGenericMatch","pTextureType","WgslType","BaseMemoryLayout","mAccessMode","mBindingIndex","mMemoryType","Setting","mName","mVisibility","pGpu","ArrayBufferMemoryLayout","mArraySize","mInnerType","ceil","parent","pPathName","lPathName","lItemIndexString","shift","lArrayItemSize","lArrayItemOffset","lInnerLocation","BaseBufferMemoryLayout","base_memory_layout_1","mBindType","mParent","LinearBufferMemoryLayout","mAlignment","mFormat","mLocationIndex","mSize","StructBufferMemoryLayout","mInnerProperties","pProperty","mStructName","pOrder","sort","pA","pB","recalculateAlignment","bindingLayouts","lLocationTypes","lPropertyType","locationLayouts","lPropertyName","lOrderedTypeList","pOrderA","pOrderB","lPropertyOffset","lPropertyLayout","lPropertyLocation","lRawDataSize","lType","SamplerMemoryLayout","mSamplerType","TextureMemoryLayout","mDimension","mMultisampled","mUsage","createCanvasTexture","lCanvasTexture","createFrameBufferTexture","lFrameBufferTexture","createImageTexture","pSourceList","lImageTexture","load","createVideoTexture","lVideoTexture","VertexParameterLayout","count","max","mParameter","mParameterNames","lLocationLayoutList","lLocationLayout","lName","lParentLayout","createData","pIndexData","vertex_parameter_1","getIndexOf","getLayoutOf","VertexParameter","indexBuffer","mIndexBuffer","pVertexParameterLayout","pIndices","lIndexLayout","lIndexBufferLayout","Uint32Array","lParameterBuffer","Float32Array","RenderTargets","colorBuffer","mColorBuffer","depthStencilBuffer","mDepthBuffer","multisampleCount","mTextureGroup","pTextureGroup","addColorBuffer","pBufferName","pClearValue","pLoadOp","pStoreOp","pTargetName","lColorBuffer","getBufferTextureOf","lTargetBuffer","getTargetTextureOf","clearValue","loadOperation","storeOperation","resolveTarget","setDepthStencilBuffer","lDepthBuffer","onDepthBufferUpdate","depthClearValue","depthLoadOperation","depthStoreOperation","stencilClearValue","stencilLoadOperation","stencilStoreOperation","TextureGroup","resize","mMultisampleLevel","mBufferTextures","mTargetTextures","addBuffer","lMemoryLayout","createColorMemoryLayout","createDepthMemoryLayout","addTarget","createCanvasMemoryLayout","render_targets_1","RenderTarget","pMultisampled","VertexFragmentPipeline","depthCompare","mDepthCompare","primitiveCullMode","mPrimitiveCullMode","primitiveFrontFace","mPrimitiveFrontFace","primitiveTopology","mPrimitiveTopology","mShader","writeDepth","mDepthWriteEnabled","pShader","primitive_topology_1","TriangleList","primitive_cullmode_1","Back","primitive_front_face_1","ClockWise","BaseShader","mShaderInformation","mPipelineLayout","interpret","lGroupIndex","lGroupLayout","mBindGroupLayoutCache","getEntryPoints","pStage","lEntryPointFunctions","pFunction","BaseShaderInterpreter","mEntryPoints","mSourceCode","mShaderTypes","mShaderTypeAliases","lVariant","lAlias","generics","lShaderFunctionDefinitionList","lShaderValueDefinitionList","lShaderStructDefinitionList","mShaderStructDefinitions","lStructDefinition","mShaderFunctions","convertFunctions","mShaderValue","convertValues","readEntryPoints","readBindings","getFunction","structFromDefinition","pStructDefinition","lShaderStruct","pTypeName","pGenericNames","lRegularType","lVariantGenerics","lGenericsMatches","lTargetGeneric","lSourceGeneric","toString","lAliasType","lComputeStage","lShaderFunction","searchEntryPointsOf","pFunctionDefinitions","lShaderFunctions","lDefnition","pValueDefinitions","lShaderValues","lShaderValue","lBindings","lEntryPoints","pScannedNames","lUsedFunctionList","lGlobal","ShaderInterpreterFactory","pInterpreter","mInterpreterConstructor","VertexFragmentShader","base_shader_1","fragmentEntry","mFragmentEntry","parameterLayout","mParameterLayout","renderTargetCount","mAttachmentCount","vertexEntry","mVertexEntry","lVertexEntryFunction","lFragmentEntryFunction","vertex_parameter_layout_1","lFragmentReturn","createPipeline","vertex_fragment_pipeline_1","CanvasTexture","mCanvas","mMemoryLayout","document","createElement","FrameBufferTexture","mDepth","mHeight","mMultiSampleLevel","mWidth","ImageTexture","mImageList","lHeight","lWidth","lImageLoadPromiseList","lImage","Image","src","decode","naturalWidth","naturalHeight","createImageBitmap","Promise","all","Data","TextureSampler","mCompare","mLodMaxClamp","mLodMinClamp","mMagFilter","mMaxAnisotropy","mMinFilter","mMipmapFilter","mWrapMode","VideoTexture","mVideo","videoHeight","loop","videoWidth","HTMLVideoElement","muted","pause","play","AccessMode","BufferBindType","BufferPrimitiveFormat","CompareFunction","ComputeStage","FilterMode","MemoryCopyType","PrimitiveCullMode","PrimitiveFrontFace","PrimitiveTopology","SamplerType","TextureBindType","TextureDimension","TextureFormat","TextureOperation","TextureUsage","WrappingMode","gHeight","gWidth","gDepth","lGpu","gpu_device_1","web_gpu_generator_factory_1","web_gpu_shader_interpreter_1","lTextureGroup","lShader","shader_wgsl_1","lTransformationGroupLayout","lTransformationGroup","lCubeTransform","lCubeInstanceTransformationData","lWidthIndex","lHeightIndex","lDepthIndex","lWorldGroupLayout","lWorldGroup","lPerspectiveProjection","perspective_projection_1","lCamera","view_projection_1","lAmbientLight","ambient_light_1","lUserGroupLayout","lUserGroup","lCubeTexture","lCubeSampler","lMesh","cube_1","lRenderTargets","texture_operation_1","Clear","Keep","lPipeline","lRenderInstruction","lLastTime","lRender","pTime","lFps","currentFps","requestAnimationFrame"],"sourceRoot":""}