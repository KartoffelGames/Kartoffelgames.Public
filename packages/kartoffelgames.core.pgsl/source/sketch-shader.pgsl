// ------------------------- Object Values ---------------------- //
@group_binding(object, transformation_matrix) uniform transformationMatrix: mat4x4;
@group_binding(object, instance_positions) @accessMode(AccessMode.Read) storage instancePositions: array<vec4>;
// -------------------------------------------------------------- //


// ------------------------- World Values ---------------------- //
@group_binding(world, view_projection_matrix) uniform viewProjectionMatrix: mat4x4;
// -------------------------------------------------------------- //


// ------------------------- User Inputs ------------------------ //
@group_binding(user, cube_texture_sampler) uniform cubeTextureSampler: sampler;
@group_binding(user, cube_texture) uniform cubeTexture: texture_2d<float>;
// -------------------------------------------------------------- //

const lightStrength: int = 23;

// --------------------- Light calculations --------------------- //
struct AmbientLight {
    color: vec4
}
@group_binding(world, ambient_light) uniform ambientLight: AmbientLight;

struct PointLight {
    position: vec4,
    color: vec4,
    range: float
}
@group_binding(world, point_lights) @accessMode(AccessMode.Read) storage pointLights: array<PointLight>;

/**
 * Calculate point light output.
 */
function calculatePointLights(fragmentPosition: vec4, normal: vec4): vec4 {
    // Count of point lights.
    const pointLightCount: u32 = arrayLength(&pointLights);

    let lightResult: vec4 = vec4(0, 0, 0, 1);

    for (let index: u32 = 0; index < pointLightCount; index++) {
        const pointLight: PointLight = pointLights[index];

        // Calculate light strength based on angle of incidence.
        let lightDirection: vec4 = normalize(pointLight.position - fragmentPosition);
        let diffuse: float = max(dot(normal, lightDirection), 0.0);

        lightResult += pointLight.color * diffuse;
    }

    return lightResult;
}

/**
 * Apply lights to fragment color.
 */
function applyLight(colorIn: vec4, fragmentPosition: vec4, normal: vec4): vec4 {
    let lightColor: vec4 = vec4(0, 0, 0, 1);

    lightColor += ambientLight.color;
    lightColor += calculatePointLights(fragmentPosition, normal);

    return lightColor * colorIn;
}
// -------------------------------------------------------------- //

struct VertexOut {
    @builtin(position) position: vec4,
    @location(uv) uv: vec2,
    @location(normal) normal: vec4,
    @location(fragment_position) fragmentPosition: vec4
}

struct VertexIn {
    @builtin(instance_index) instanceId : uint,
    @location(position) position: vec4,
    @location(uv) uv: vec2,
    @location(normal) normal: vec4
}

@vertex function vertex_main(vertex: VertexIn): VertexOut {
    const instancePosition: vec4 = instancePositions[vertex.instanceId];
    const instancePositionMatrix: mat4x4 = mat4x4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, instancePosition.x * 5, instancePosition.y * 5, instancePosition.z * 5, 1);

    // Overrideable variable.
    let rewriteable: int = 1;
    rewriteable = 2;

    const out: VertexOut;
    out.position = viewProjectionMatrix * transformationMatrix * instancePositionMatrix * vertex.position;
    out.uv = vertex.uv;
    out.normal = vertex.normal;
    out.fragmentPosition = transformationMatrix * instancePositionMatrix * vertex.position;

    return out;
}

struct FragmentIn {
    @location(uv) uv: vec2,
    @location(normal) normal: vec4,
    @location(fragment_position) fragmentPosition: vec4
}

struct FragmentOut {
    @location(0) color: vec4
}

@fragment function fragment_main(fragment: FragmentIn): FragmentOut {
    const out: FragmentOut
    out.color = applyLight(textureSample(cubeTexture, cubeTextureSampler, fragment.uv), fragment.fragmentPosition, fragment.normal);
    
    return out
}