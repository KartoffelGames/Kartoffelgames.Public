{
  "version": 3,
  "sources": ["../packages/kartoffelgames.core/source/data_container/list.ts", "../packages/kartoffelgames.core/source/exception/exception.ts", "../packages/kartoffelgames.core/source/data_container/dictionary.ts", "../packages/kartoffelgames.core/source/data_container/stack.ts", "../packages/kartoffelgames.core/source/data_container/linked-list.ts", "../packages/kartoffelgames.core/source/util/enum-util.ts", "../packages/kartoffelgames.core/source/util/type-util.ts", "../packages/kartoffelgames.core/source/util/byte-util.ts", "../packages/kartoffelgames.core/source/algorithm/myers-diff.ts", "../packages/kartoffelgames.core/source/index.ts", "../packages/kartoffelgames.core.serializer/source/statefull_serialize/statefull-serializeable-classes.ts", "../packages/kartoffelgames.core.serializer/source/statefull_serialize/decorator/statefull-serializeable.decorator.ts", "../packages/kartoffelgames.core.serializer/source/statefull_serialize/statefull-deserializer.ts", "../packages/kartoffelgames.core.serializer/source/statefull_serialize/statefull-serializer.ts", "../packages/kartoffelgames.core.serializer/source/index.ts", "../packages/kartoffelgames.worker.track_player/source/generic_module/pattern/division-channel.ts", "../packages/kartoffelgames.worker.track_player/source/generic_module/pattern/division.ts", "../packages/kartoffelgames.worker.track_player/source/generic_module/pattern/pattern.ts", "../packages/kartoffelgames.worker.track_player/source/generic_module/pattern/pattern-list.ts", "../packages/kartoffelgames.worker.track_player/source/generic_module/sample/sample.ts", "../packages/kartoffelgames.worker.track_player/source/generic_module/sample/sample-list.ts", "../packages/kartoffelgames.worker.track_player/source/generic_module/generic-module.ts", "../packages/kartoffelgames.worker.track_player/source/module_parser/effect-parse-history.ts", "../packages/kartoffelgames.worker.track_player/source/module_parser/base-module-parser.ts", "../packages/kartoffelgames.worker.track_player/source/effect/effect_definition/pitch/set-finetune-effect.ts", "../packages/kartoffelgames.worker.track_player/source/enum/pitch.enum.ts", "../packages/kartoffelgames.worker.track_player/source/effect/effect_definition/pitch/set-pitch-effect.ts", "../packages/kartoffelgames.worker.track_player/source/effect/effect_definition/sample/cut-sample-effect.ts", "../packages/kartoffelgames.worker.track_player/source/effect/effect_definition/sample/delay-sample-effect.ts", "../packages/kartoffelgames.worker.track_player/source/effect/effect_definition/sample/invert-sample-loop-effect.ts", "../packages/kartoffelgames.worker.track_player/source/effect/effect_definition/sample/retrigger-sample-effect.ts", "../packages/kartoffelgames.worker.track_player/source/effect/effect_definition/sample/sample-offset-effect.ts", "../packages/kartoffelgames.worker.track_player/source/effect/effect_definition/sample/set-panning-effect.ts", "../packages/kartoffelgames.worker.track_player/source/effect/effect_definition/sample/set-sample-effect.ts", "../packages/kartoffelgames.worker.track_player/source/effect/effect_definition/speed/set-bpm-effect.ts", "../packages/kartoffelgames.worker.track_player/source/effect/effect_definition/speed/set-speed-effect.ts", "../packages/kartoffelgames.worker.track_player/source/effect/effect_definition/volume/set-volume-effect.ts", "../packages/kartoffelgames.worker.track_player/source/enum/direction.enum.ts", "../packages/kartoffelgames.worker.track_player/source/effect/effect_definition/volume/volume-slide-effect.ts", "../packages/kartoffelgames.worker.track_player/source/module_parser/effect-parse-event.ts", "../packages/kartoffelgames.worker.track_player/source/module_parser/effect-parser.ts", "../packages/kartoffelgames.worker.track_player/source/effect/effect_definition/pitch/arpeggio-effect.ts", "../packages/kartoffelgames.worker.track_player/source/effect/effect_definition/pitch/period-slide-effect.ts", "../packages/kartoffelgames.worker.track_player/source/enum/waveform-target.enum.ts", "../packages/kartoffelgames.worker.track_player/source/effect/effect_definition/waveform/waveform-effect.ts", "../packages/kartoffelgames.worker.track_player/source/effect/effect_definition/jump/position-jump-effect.ts", "../packages/kartoffelgames.worker.track_player/source/module_parser/mod_parser/mod-effect-parser.ts", "../packages/kartoffelgames.worker.track_player/source/module_parser/mod_parser/mod-parser.ts", "../packages/kartoffelgames.worker.track_player/page/source/index.ts", "../packages/kartoffelgames.worker.track_player/page/source/standard-input-file.ts"],
  "sourcesContent": ["import type { ICloneable } from '../interface/i-cloneable.ts';\r\n\r\n/**\r\n * Wrapper for {@link Array}.\r\n * \r\n * @typeParam T - Type of items of list. \r\n * \r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array}\r\n * \r\n * @public\r\n */\r\nexport class List<T> extends Array<T> implements ICloneable<List<T>> {\r\n    /**\r\n     * Create list and add items.\r\n     * Prevents spread operator with number arrays to initialize array with length instead of item.\r\n     * \r\n     * @param pItemList - Items.\r\n     * \r\n     * @example Create new list with `newListWith` and failing creation with the native `Array` constructor.\r\n     * ```TypeScript\r\n     * const newList = List.newListWith<number>(...[3]); // => [3] \r\n     * const newListWrong = new List<number>(...[3]);    // => [undefined, undefined, undefined] \r\n     * ```\r\n     */\r\n    public static newListWith<T>(...pItemList: Array<T>): List<T> {\r\n        const lNewList: List<T> = new List<T>();\r\n        lNewList.push(...pItemList);\r\n\r\n        return lNewList;\r\n    }\r\n\r\n    /**\r\n     * Remove every item.\r\n     * \r\n     * @example Clear a list.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<number>(1, 2, 3);\r\n     * list.clear(); \r\n     * \r\n     * console.log(list.length); // => 0\r\n     * ```\r\n     */\r\n    public clear(): void {\r\n        this.splice(0, this.length);\r\n    }\r\n\r\n    /**\r\n     * Create new list and add same items.\r\n     * @see {@link ICloneable.clone}\r\n     * \r\n     * @returns cloned list with shallow copied item refernces.\r\n     * \r\n     * @example Clone and compare list and list items.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<object>(new Object());\r\n     * \r\n     * const clone = list.clone();\r\n     * \r\n     * const areSame = list === clone; // => False\r\n     * const itemSame = list[0] === list[0]; // => True\r\n     * ```\r\n     */\r\n    public clone(): List<T> {\r\n        return List.newListWith(...this);\r\n    }\r\n\r\n    /**\r\n     * Copy distinct values into new list.\r\n     * \r\n     * @returns new list instance with only distinct values.\r\n     * \r\n     * @example Create a new list with dublicates and create a new distinct list out of it.\r\n     * ```TypeScript\r\n     * const listWithDublicates = List.newListWith<number>(1, 1, 2, 3, 3);\r\n     * const distinctList = listWithDublicates.distinct(); // => [1, 2, 3]\r\n     * ```\r\n     */\r\n    public distinct(): List<T> {\r\n        return List.newListWith(...new Set(this));\r\n    }\r\n\r\n    /**\r\n     * Compares this array with the specified one.\r\n     * Compares length and every item by reference and order.\r\n     * Does only shallow compare item references.\r\n     * \r\n     * @param pArray - Array to compare.\r\n     * \r\n     * @returns true for equality.\r\n     * \r\n     * @example Compare two arrays with a list.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<number>(1, 3, 2);\r\n     * \r\n     * const isEqual = list.equals([1, 3, 2]) // => True\r\n     * const isUnequal = list.equals([1, 2, 3]) // => False\r\n     * ```\r\n     */\r\n    public equals(pArray: Array<unknown>): boolean {\r\n        // Check if array are same, dont null and have same length.\r\n        if (this === pArray) {\r\n            return true;\r\n        } else if (!pArray || this.length !== pArray.length) {\r\n            return false;\r\n        }\r\n\r\n        // Check each item.\r\n        for (let lIndex = 0; lIndex < this.length; ++lIndex) {\r\n            if (this[lIndex] !== pArray[lIndex]) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Removes the first appearence of a value.\r\n     * \r\n     * @param pValue - Target value to remove.\r\n     * \r\n     * @returns removed element. When no element was removed, undefined is returned instead.\r\n     * \r\n     * @example Remove a existing and a none existing item of a list.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<number>(1, 3, 2);\r\n     * \r\n     * const removedElement = list.remove(1); // => 1\r\n     * const noneExistingElement = list.remove(4); // => undefined\r\n     * ```\r\n     */\r\n    public remove(pValue: T): T | undefined {\r\n        const lFoundIndex: number = this.indexOf(pValue);\r\n\r\n        // Only remove if found.\r\n        if (lFoundIndex !== -1) {\r\n            return this.splice(lFoundIndex, 1)[0];\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Replace first appearence of value.\r\n     * \r\n     * @param pOldValue - Target value to replace.\r\n     * @param pNewValue - Replacement value.\r\n     * \r\n     * @returns replaced element. When no element was replaced, undefined is returned instead.\r\n     * \r\n     * @example Replace a existing and a none existing item of a list.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<number>(1, 5, 3);\r\n     * \r\n     * const removedElement = list.replace(5, 2); // => 5\r\n     * const noneExistingElement = list.replace(4, 3); // => undefined\r\n     * \r\n     * console.log(list); // => [1, 2, 3]\r\n     * ```\r\n     */\r\n    public replace(pOldValue: T, pNewValue: T): T | undefined {\r\n        const lFoundIndex: number = this.indexOf(pOldValue);\r\n\r\n        // Only replace if found.\r\n        if (lFoundIndex !== -1) {\r\n            // Save old value and replace it with new value.\r\n            const lOldValue: T = this[lFoundIndex];\r\n            this[lFoundIndex] = pNewValue;\r\n\r\n            return lOldValue;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of this list.\r\n     * @override base objects {@link Array.toString}\r\n     * \r\n     * @returns string representation for this list.\r\n     * \r\n     * @example Output a string representation of a list.\r\n     * ```TypeScript\r\n     * const list = List.newListWith<number>(1, 2, 3);\r\n     * console.log(list.toString()); // => [1, 2, 3]\r\n     * ```\r\n     */\r\n    public override toString(): string {\r\n        return `[${super.join(', ')}]`;\r\n    }\r\n}", "\uFEFF/**\r\n * Extends {@link Error} by a {@link Exception.target} reference.\r\n * \r\n * @typeParam T - Exception target type.\r\n * \r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}\r\n * \r\n * @public\r\n */\r\nexport class Exception<T> extends Error {\r\n    private readonly mTarget: T;\r\n\r\n    /**\r\n     * Target of exception.\r\n     * \r\n     * @readonly\r\n     */\r\n    public get target(): T {\r\n        return this.mTarget;\r\n    }\r\n\r\n    /**\r\n     * Constructor. \r\n     * @param pMessage - Messsage of exception.\r\n     * @param pTarget - Target of exception.\r\n     * @param pErrorOptions - Optional error options.\r\n     */\r\n    public constructor(pMessage: string, pTarget: T, pErrorOptions?: ErrorOptions) {\r\n        super(pMessage, pErrorOptions);\r\n        this.mTarget = pTarget;\r\n    }\r\n}", "import { List } from './list.ts';\r\nimport { Exception } from '../exception/exception.ts';\r\nimport type { ICloneable } from '../interface/i-cloneable.ts';\r\n\r\n/**\r\n * Wrapper for {@link Map}.\r\n * Extended by {@link Dictionary.add}, {@link Dictionary.getAllKeysOfValue}, {@link Dictionary.getOrDefault} and {@link Dictionary.map}.\r\n * \r\n * @typeParam TKey - Type of objects defined for keys. \r\n * @typeParam TValue - Type of objects defined for values. \r\n * \r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map}\r\n * \r\n * @public\r\n */\r\nexport class Dictionary<TKey, TValue> extends Map<TKey, TValue> implements ICloneable<Dictionary<TKey, TValue>>{\r\n    /**\r\n     * Add value and key to dictionary. \r\n     * Throws {@link Exception}  for any added dublicate key. \r\n     * \r\n     * @param pKey - Key of item.\r\n     * @param pValue - value of item.\r\n     * \r\n     * @throws\r\n     * On any dublicate key set,\r\n     * \r\n     * @example Adding a new and existing key.\r\n     * ```TypeScript\r\n     * const dictionary = new Dictionary<string, number>();\r\n     * dictionary.add('a', 4); // => OK\r\n     * dictionary.add('a', 4); // => Fail: Dublicate key.\r\n     * ```\r\n     */\r\n    public add(pKey: TKey, pValue: TValue): void {\r\n        // Add value and key to containers.\r\n        if (!this.has(pKey)) {\r\n            this.set(pKey, pValue);\r\n        } else {\r\n            throw new Exception(\"Can't add dublicate key to dictionary.\", this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create new dicionary and add same keys and values.\r\n     * @see {@link ICloneable.clone}\r\n     * \r\n     * @returns cloned dictionary with shallow copied key and value refernces.\r\n     * \r\n     * @example Clone and compare dictionary and dictionary items.\r\n     * ```TypeScript\r\n     * const dictionary = new Dictionary<string, object>();\r\n     * dictionary.set('a', new Object());\r\n     * \r\n     * const clone = dictionary.clone();\r\n     * \r\n     * const areSame = dictionary === clone; // => False\r\n     * const itemSame = dictionary.get('a') === clone.get('a'); // => True\r\n     * ```\r\n     */\r\n    public clone(): Dictionary<TKey, TValue> {\r\n        return new Dictionary<TKey, TValue>(this);\r\n    }\r\n\r\n    /**\r\n     * Get all keys that have the set value.\r\n     * \r\n     * @param pValue - Value.\r\n     * \r\n     * @returns all keys that hold the specified value.\r\n     * \r\n     * @example Get keys of a value.\r\n     * ```TypeScript\r\n     * const dictionary = new Dictionary<string, number>();\r\n     * dictionary.set('a', 1);\r\n     * dictionary.set('b', 2);\r\n     * dictionary.set('c', 1);\r\n     * \r\n     * const keys = dictionary.getAllKeysOfValue(1); // => ['a', 'c']\r\n     * ```\r\n     */\r\n    public getAllKeysOfValue(pValue: TValue): Array<TKey> {\r\n        // Add entries iterator to list and filter for pValue = Value\r\n        const lKeyValuesWithValue: Array<[TKey, TValue]> = [...this.entries()].filter((pItem: [TKey, TValue]) => {\r\n            return pItem[1] === pValue;\r\n        });\r\n\r\n        // Get only keys of key values.\r\n        const lKeysOfKeyValue: Array<TKey> = lKeyValuesWithValue.map<TKey>((pItem: [TKey, TValue]): TKey => {\r\n            return pItem[0];\r\n        });\r\n\r\n        return lKeysOfKeyValue;\r\n    }\r\n\r\n    /**\r\n     * Get item. If the key does not exists the default value gets returned.\r\n     * @param pKey - Key of item.\r\n     * @param pDefault - Default value if key was not found.\r\n     * \r\n     * @returns value of the key. If the key does not exists the default value gets returned.\r\n     * \r\n     * @example Get value or default from a existing and none existing key. \r\n     * ```TypeScript\r\n     * const dictionary = new Dictionary<string, number>();\r\n     * dictionary.set('a', 1);\r\n     * \r\n     * const keyA = dictionary.getOrDefault('a', 22); // => 1\r\n     * const keyZ = dictionary.getOrDefault('z', 22); // => 22\r\n     * ```\r\n     */\r\n    public getOrDefault(pKey: TKey, pDefault: TValue): TValue {\r\n        const lValue: TValue | undefined = this.get(pKey);\r\n        if (typeof lValue !== 'undefined') {\r\n            return lValue;\r\n        }\r\n\r\n        return pDefault;\r\n    }\r\n\r\n    /**\r\n     * Maps information into new list.\r\n     * @param pFunction - Mapping funktion.\r\n     * \r\n     * @typeParam T - Result type of mapping resolver function.\r\n     * \r\n     * @returns mapped data for each item.\r\n     * \r\n     * @example Remap all dictionary values by adding a number to all values. \r\n     * ```TypeScript\r\n     * const dictionary = new Dictionary<string, number>();\r\n     * dictionary.set('a', 1);\r\n     * dictionary.set('b', 2);\r\n     * \r\n     * const list = dictionary.map((key, value) => value + 1); //  => [2, 3]\r\n     * ```\r\n     */\r\n    public map<T>(pFunction: (pKey: TKey, pValue: TValue) => T): Array<T> {\r\n        const lResultList: List<T> = new List<T>();\r\n\r\n        for (const lKeyValuePair of this) {\r\n            // Execute callback and add result to list.\r\n            const lMappingResult: T = pFunction(lKeyValuePair[0], lKeyValuePair[1]);\r\n            lResultList.push(lMappingResult);\r\n        }\r\n\r\n        return lResultList;\r\n    }\r\n}", "import type { ICloneable } from '../interface/i-cloneable.ts';\r\n\r\n/**\r\n * Simple and fast stack implementation based on references.\r\n * \r\n * @public\r\n */\r\nexport class Stack<T> implements ICloneable<Stack<T>> {\r\n    private mSize: number;\r\n    private mTopItem: StackItem<T> | null;\r\n\r\n    /**\r\n     * Get current stack size.\r\n     */\r\n    public get size(): number {\r\n        return this.mSize;\r\n    }\r\n\r\n    /**\r\n     * Current top item of stack.\r\n     * Returns undefined when no item is stacked.\r\n     */\r\n    public get top(): T | undefined {\r\n        // Undefined when no item is stacked.\r\n        if (!this.mTopItem) {\r\n            return undefined;\r\n        }\r\n\r\n        return this.mTopItem.value;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mTopItem = null;\r\n        this.mSize = 0;\r\n    }\r\n\r\n    /**\r\n     * Clones the references of all stack items into a new one.\r\n     * Does only shallow copy.\r\n     * \r\n     * @returns The cloned stack.\r\n     */\r\n    public clone(): Stack<T> {\r\n        const lClonedStack: Stack<T> = new Stack<T>();\r\n\r\n        // Only thing that needs to be cloned is the current reference.\r\n        lClonedStack.mTopItem = this.mTopItem;\r\n        lClonedStack.mSize = this.mSize;\r\n\r\n        return lClonedStack;\r\n    }\r\n\r\n    /**\r\n     * Iterates over each stack entry in reversed (newest...oldest) order.\r\n     * \r\n     * @returns Generator.\r\n     */\r\n    public *entries(): Generator<T> {\r\n        let lCurrentItem: StackItem<T> | null = this.mTopItem;\r\n\r\n        while (lCurrentItem !== null) {\r\n            yield lCurrentItem.value;\r\n\r\n            lCurrentItem = lCurrentItem.previous;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear stack and get all stacked items in stack order.\r\n     * \r\n     * @returns All stacked values in top to down order.\r\n     * \r\n     * @example Flush Stack\r\n     * ``` Typescript\r\n     * const stack = new Stack<number>();\r\n     * stack.push(1);\r\n     * stack.push(2);\r\n     * stack.push(3);\r\n     * \r\n     * // Flush all items. Clears stack.\r\n     * const stackValues = stack.flush(); // => [3, 2, 1];\r\n     * console.log(stack.top); // => undefined\r\n     * ``` \r\n     */\r\n    public flush(): Array<T> {\r\n        const lValueList: Array<T> = new Array<T>();\r\n\r\n        // Pop items as long as there are stack items.\r\n        // Don't check poped value as next indicator as it can contain undefined.\r\n        while (this.mTopItem) {\r\n            lValueList.push(this.pop()!);\r\n        }\r\n\r\n        return lValueList;\r\n    }\r\n\r\n    /**\r\n     * Removes the current top item of stack.\r\n     * When no item is stacked nothing happends and undefined is returned.\r\n     * \r\n     * @returns Current top item. When no item was stacked, undefined is returned instead.\r\n     * \r\n     * @example Pop current top item.\r\n     * ``` Typescript\r\n     * const stack = new Stack<number>();\r\n     * stack.push(1);\r\n     * stack.push(2);\r\n     * stack.push(3);\r\n     * \r\n     * // Check current stacked top item before and after poping.\r\n     * console.log(stack.top); // => 3\r\n     * const stackValues = stack.pop(); // => 3;\r\n     * console.log(stack.top); // => 2\r\n     * ``` \r\n     */\r\n    public pop(): T | undefined {\r\n        // Undefined when no item is stacked.\r\n        if (!this.mTopItem) {\r\n            return undefined;\r\n        }\r\n\r\n        // Buffer current top value.\r\n        const lCurrentTopValue: T = this.mTopItem.value;\r\n\r\n        // Replace current top item with previous stacked.\r\n        this.mTopItem = this.mTopItem.previous;\r\n        this.mSize--;\r\n\r\n        return lCurrentTopValue;\r\n    }\r\n\r\n    /**\r\n     * Push new value as top item of stack. Replaces the current top item.\r\n     * @param pValue - Next value placed on top.\r\n     * \r\n     * @example Push next top item.\r\n     * ``` Typescript\r\n     * const stack = new Stack<number>();\r\n     * stack.push(1);\r\n\r\n     * \r\n     * // Check current stacked top item before and after pushing.\r\n     * console.log(stack.top); // => 1\r\n     * stack.push(2);\r\n     * console.log(stack.top); // => 2\r\n     * ``` \r\n     */\r\n    public push(pValue: T): void {\r\n        // Create new stack item with the current top item as reference. \r\n        const lNextItem: StackItem<T> = {\r\n            previous: this.mTopItem,\r\n            value: pValue\r\n        };\r\n\r\n        // Replace current top item with next.\r\n        this.mTopItem = lNextItem;\r\n        this.mSize++;\r\n    }\r\n\r\n    /**\r\n     * Converts this stack into an array.\r\n     * The first item in the array is the last item pushed into the stack.\r\n     * \r\n     * @returns The current stack as array.\r\n     * \r\n     * @example Stack into array.\r\n     * ``` Typescript\r\n     * const stack = new Stack<number>();\r\n     * stack.push(1);\r\n     * stack.push(2);\r\n     * stack.push(3);\r\n     * \r\n     * // Stack to array.\r\n     * console.log(stack.toArray()); // => [3, 2, 1]\r\n     * ``` \r\n     */\r\n    public toArray(): Array<T> {\r\n        // Convert genertor into array.\r\n        return [...this.entries()];\r\n    }\r\n}\r\n\r\ntype StackItem<T> = {\r\n    previous: StackItem<T> | null;\r\n    value: T;\r\n};", "export class LinkedList<T> {\r\n    private mCurrent: LinkedListChain<T>;\r\n    private mHeadElement: LinkedListHeadElement<T>;\r\n    private mRoot: LinkedListChain<T>;\r\n\r\n\r\n    /**\r\n     * Get current item.\r\n     */\r\n    public get current(): T | null {\r\n        // If current is null revert to the last item.\r\n        if (!this.mCurrent.item) {\r\n            return null;\r\n        }\r\n\r\n        return this.mCurrent.item.value;\r\n    }\r\n\r\n    /**\r\n     * Get if the list is done\r\n     */\r\n    public get done(): boolean {\r\n        return !this.mCurrent.next;\r\n    }\r\n\r\n    /**\r\n     * Get the root item.\r\n     */\r\n    public get root(): T | null {\r\n        if (!this.mRoot.item) {\r\n            return null;\r\n        }\r\n\r\n        return this.mRoot.item.value;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        // Set root.\r\n        this.mRoot = {\r\n            next: null,\r\n            item: null,\r\n        };\r\n\r\n        // List is empty, so it is also the root.\r\n        this.mHeadElement = {\r\n            head: this.mRoot\r\n        };\r\n        this.mCurrent = this.mRoot;\r\n    }\r\n\r\n    /**\r\n     * Move to the last item in the linked list.\r\n     */\r\n    public moveEnd(): void {\r\n        this.mCurrent = this.mHeadElement.head;\r\n    }\r\n\r\n    /**\r\n     * Move to the previous item in the linked list.\r\n     */\r\n    public moveFirst(): void {\r\n        this.mCurrent = this.mRoot;\r\n    }\r\n\r\n    /**\r\n     * Move to the next item in the linked list.\r\n     * \r\n     * @returns false when the end of the list is reached.\r\n     */\r\n    public next(): boolean {\r\n        // If current is null revert to the last item.\r\n        if (!this.mCurrent.next) {\r\n            return false;\r\n        }\r\n\r\n        // Move to next item.\r\n        this.mCurrent = this.mCurrent.next;\r\n\r\n        // Return if there is an item.\r\n        return !!this.mCurrent.item;\r\n    }\r\n\r\n    /**\r\n     * Add a new item to the end.\r\n     * \r\n     * @param pValue The value to add.\r\n     */\r\n    public push(pValue: T): void {\r\n        const lNewChain: LinkedListChain<T> = {\r\n            next: null,\r\n            item: null,\r\n        };\r\n\r\n        // Set value to current head.\r\n        this.mHeadElement.head.item = {\r\n            value: pValue\r\n        };\r\n\r\n        // Chain the new item.\r\n        this.mHeadElement.head.next = lNewChain;\r\n\r\n        // Set the new head.\r\n        this.mHeadElement.head = lNewChain;\r\n    }\r\n\r\n    /**\r\n     * Creates a new linked list starting from the current node.\r\n     * The list is still linked to the original list.\r\n     * Appending to the original list will expand the new list and vice versa.\r\n     *\r\n     * @returns {LinkedList<T>} A new linked list instance starting from the current node.\r\n     */\r\n    public sliceReference(): LinkedList<T> {\r\n        const lNewList: LinkedList<T> = new LinkedList<T>();\r\n        lNewList.mRoot = lNewList.mCurrent = this.mCurrent;\r\n\r\n        // Both lists are linked to the same head element.\r\n        lNewList.mHeadElement = this.mHeadElement;\r\n\r\n        return lNewList;\r\n    }\r\n\r\n    /**\r\n     * Sync the list with another list by setting \r\n     * the current element to the current element of the other list.\r\n     * \r\n     * @param pList The list to sync with.\r\n     */\r\n    public sync(pList: LinkedList<T>): void {\r\n        this.mCurrent = pList.mCurrent;\r\n    }\r\n}\r\n\r\ntype LinkedListHeadElement<T> = {\r\n    head: LinkedListChain<T>;\r\n};\r\n\r\ntype LinkedListChain<T> = {\r\n    next: LinkedListChain<T> | null;\r\n    item: LinkedListItem<T> | null;\r\n};\r\n\r\ntype LinkedListItem<T> = {\r\n    value: T;\r\n};", "/**\r\n * Static helper type to read data from enum objects.\r\n * \r\n * @public\r\n */\r\nexport class EnumUtil {\r\n    /**\r\n     * Infers value into enum type.\r\n     * When the values can not be infered into the specified enum, undefined is returned.\r\n     * \r\n     * @param pEnum - typeof Enum object.\r\n     * @param pValue - Value of enum.\r\n     * \r\n     * @typeParam T - Enum type the value should be infered into.\r\n     * \r\n     * @returns Infered `pValue` parameter or undefined when the value does not exists as the enums value.\r\n     * \r\n     * @example Try to cast two possible enum values.\r\n     * ``` Typescript\r\n     * enum MyEnum {\r\n     *     Entry1 = 1,\r\n     *     Entry2 = 2\r\n     * }\r\n     * \r\n     * const existingValue = EnumUtil.cast<MyEnum>(MyEnum, 1); // => MyEnum.Entry1\r\n     * const noneExistingValue = EnumUtil.cast<MyEnum>(MyEnum, 5); // => undefined\r\n     * ```\r\n     */\r\n    public static cast<T>(pEnum: object, pValue: any): T | undefined {\r\n        // Thats it... :)\r\n        if (EnumUtil.exists<T>(pEnum, pValue)) {\r\n            return pValue;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check value existence on a enum object.\r\n     * Infers `pValue` parameter as enum type.\r\n     * @param pEnum - typeof Enum object.\r\n     * @param pValue - Value of enum.\r\n     * \r\n     * @typeParam T - Enum type the value should be infered into.\r\n     * \r\n     * @returns True when the value can be casted into enum.\r\n     * \r\n     * @example Check existence of one two possible enum values.\r\n     * ``` Typescript\r\n     * enum MyEnum {\r\n     *     Entry1 = 1,\r\n     *     Entry2 = 2\r\n     * }\r\n     * \r\n     * const existingValue = EnumUtil.exists(MyEnum, 1); // => True\r\n     * const noneExistingValue = EnumUtil.exists(MyEnum, 5); // => False\r\n     * ```\r\n     */\r\n    public static exists<T>(pEnum: object, pValue: any): pValue is T {\r\n        return EnumUtil.valuesOf(pEnum).includes(pValue);\r\n    }\r\n\r\n    /**\r\n     * Return all keys of an enum as array.\r\n     * \r\n     * @param pEnum - typeof Enum object.\r\n     * \r\n     * @returns All enum key as array in defined order.\r\n     * \r\n     * @remarks\r\n     * Does only work for number enums and should fail for mixed or string enums.\r\n     * \r\n     * @example Read enum names from custom enum object.\r\n     * ``` Typescript\r\n     * enum MyEnum {\r\n     *     Entry1 = 1,\r\n     *     Entry2 = 2\r\n     * }\r\n     * \r\n     * const enumNames = EnumUtil.namesOf(MyEnum); // => ['Entry1', 'Entry2']\r\n     * ```\r\n     */\r\n    public static namesOf<TEnum>(pEnum: TEnum): Array<keyof TEnum> {\r\n        // Convert enum to key array.\r\n        return Object.keys(pEnum as object).filter((pKey) => isNaN(Number(pKey))) as Array<keyof TEnum>;\r\n    }\r\n\r\n    /**\r\n     * Return all values of an enum as array.\r\n     * \r\n     * @param pEnum - typeof Enum object.\r\n     * \r\n     * @typeParam T - Enum value type.\r\n     * \r\n     * @returns All enum values as array in defined order.\r\n     * \r\n     * @example Read enum values from custom enum object.\r\n     * ``` Typescript\r\n     * enum MyEnum {\r\n     *     Entry1 = 1,\r\n     *     Entry2 = 2\r\n     * }\r\n     * \r\n     * const enumValues = EnumUtil.valuesOf(MyEnum); // => [1, 2]\r\n     * ```\r\n     */\r\n    public static valuesOf<T>(pEnum: object): Array<T> {\r\n        const lEnumValues: Array<T> = new Array<T>();\r\n\r\n        // Convert enum to vaue array by iterating over all keys.\r\n        for (const lKey of EnumUtil.namesOf(pEnum)) {\r\n            lEnumValues.push((<{ [key: string]: T; }>pEnum)[lKey]);\r\n        }\r\n\r\n        return lEnumValues;\r\n    }\r\n}", "/**\r\n * Static helper type to read data from objects.\r\n * \r\n * @public\r\n */\r\nexport class TypeUtil {\r\n    /**\r\n     * Get name of objects property.\r\n     * @param pName - Property name.\r\n     * \r\n     * @typeParam T - Object with any string key property. \r\n     * \r\n     * @returns the name of property.\r\n     * \r\n     * @remarks\r\n     * Acts more as a type safe way of accessing property names of a type.\r\n     * \r\n     * @example Read enum names from custom enum object.\r\n     * ``` Typescript\r\n     * class MyClass {\r\n     *    public myProperty: number = 1;\r\n     * }\r\n     * \r\n     * const propertyName = TypeUtil.nameOf<MyClass>('myProperty'); // => 'myProperty'\r\n     * ```\r\n     * \r\n     * @experimental @alpha\r\n     */\r\n    public static nameOf<T>(pName: Extract<keyof T, string>): string {\r\n        return pName;\r\n    }\r\n}", "export class ByteUtil {\r\n    /**\r\n     * Convert byte to byte.\r\n     * @param pByte - Byte\r\n     * @param pSigned - If result should be signed.\r\n     */\r\n    public static byteToByte(pByte: number, pSigned: boolean = false): number {\r\n        let lByte: number = pByte & 0xff;\r\n\r\n        // Sign word.\r\n        if (pSigned) {\r\n            lByte = (lByte > 127) ? (lByte - 0x100) : lByte;\r\n        }\r\n\r\n        return lByte;\r\n    }\r\n\r\n    /**\r\n     * Convert byte to thwo nibbles.\r\n     * @param pByte - Unsigned byte.\r\n     * @param pSigned - If result should be signed.\r\n     */\r\n    public static byteToNibble(pByte: number, pSigned: boolean = false): [number, number] {\r\n        let lHighNibble: number = (pByte >>> 4) & 0xf;\r\n        let lLowNibble: number = pByte & 0xf;\r\n\r\n        // Sign both nibbles.\r\n        if (pSigned) {\r\n            lHighNibble = (lHighNibble > 7) ? (lHighNibble - 0x10) : lHighNibble;\r\n            lLowNibble = (lLowNibble > 7) ? (lLowNibble - 0x10) : lLowNibble;\r\n        }\r\n\r\n        return [lHighNibble, lLowNibble];\r\n    }\r\n\r\n    /**\r\n     * Convert byte array to string.\r\n     * @param pByteArray - Unsigned Byte array.\r\n     * @param pEmptyValue - Value interpreted as empty.\r\n     */\r\n    public static byteToString(pByteArray: Uint8Array, pEmptyValue: number = 0): string {\r\n        // Filter NULL-Bytes.\r\n        const lNullFilteredArray: Uint8Array = pByteArray.filter((pByte: number) => { return pByte !== pEmptyValue; });\r\n\r\n        // Decode byte array to string.\r\n        return String.fromCharCode(...lNullFilteredArray);\r\n    }\r\n\r\n    /**\r\n     * Convert two bytes to a world.\r\n     * @param pHightByte - World unsigned hight byte.\r\n     * @param pLowByte - World unsigned low byte.\r\n     * @param pSigned - If result should be signed.\r\n     */\r\n    public static byteToWorld(pHightByte: number, pLowByte: number, pSigned: boolean = false): number {\r\n        let lWord: number = ((pHightByte << 8) + pLowByte) & 0xffff;\r\n\r\n        // Sign word.\r\n        if (pSigned) {\r\n            lWord = (lWord > 32767) ? (lWord - 0x10000) : lWord;\r\n        }\r\n\r\n        return lWord;\r\n    }\r\n\r\n    /**\r\n     * Concat byte array to a single big int value.\r\n     * @param pByteArray - Byte array.\r\n     */\r\n    public static concatBytes(pByteArray: Uint8Array): bigint {\r\n        let lConcatNumber: bigint | null = null;\r\n\r\n        // Extend bigint for each byte.\r\n        for (const lByte of pByteArray) {\r\n            if (lConcatNumber === null) {\r\n                // Initialize bigInt with first byte.\r\n                lConcatNumber = BigInt(lByte);\r\n            } else {\r\n                // Shift by 8 bit and append new byte.\r\n                lConcatNumber <<= 8n;\r\n                lConcatNumber += BigInt(lByte);\r\n            }\r\n        }\r\n\r\n        return lConcatNumber ?? 0n;\r\n    }\r\n\r\n    /**\r\n     * Pick bits and concat every picket bit into one number.\r\n     * @param pBits - Bit to pick.\r\n     * @param pBitCount - Length of data.\r\n     * @param pBitList - index of bits.\r\n     */\r\n    public static pickBits(pBits: bigint, pBitCount: number, pBitList: Array<number>): bigint {\r\n        let lPicketNumber: bigint | null = null;\r\n\r\n        // Pick each bit.\r\n        for (const lBitIndex of pBitList) {\r\n            // Create bitmask with revered index. So that lBitIndex => 0 is the first bit and not the last.\r\n            const lBitMask: bigint = BigInt(1 << (pBitCount - 1) - lBitIndex);\r\n\r\n            // Apply bitmask and get single bit.\r\n            const lPickedBit: bigint = ((pBits & lBitMask) !== 0n) ? 1n : 0n;\r\n\r\n            if (lPicketNumber === null) {\r\n                lPicketNumber = lPickedBit;\r\n            } else {\r\n                lPicketNumber <<= 1n;\r\n                lPicketNumber += lPickedBit;\r\n            }\r\n        }\r\n\r\n        return lPicketNumber ?? 0n;\r\n    }\r\n\r\n    /**\r\n     * Read part of byte array.\r\n     * @param pData - Byte array.\r\n     * @param pOffset - Offset.\r\n     * @param pLength - Length of result.\r\n     */\r\n    public static readBytes(pData: Uint8Array, pOffset: number, pLength: number): Uint8Array {\r\n        return pData.slice(pOffset, pOffset + pLength);\r\n    }\r\n}", "/**\r\n * Optimized implementation of the myers diff algorithm.\r\n */\r\nexport class MyersDiff<TA, TB> {\r\n    private readonly mCompareFunction: (itemA: TA, itemB: TB) => boolean;\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pCompareFunction - Compare function to compare two items.\r\n     */\r\n    public constructor(pCompareFunction: (itemA: TA, itemB: TB) => boolean) {\r\n        this.mCompareFunction = pCompareFunction;\r\n    }\r\n\r\n    /**\r\n     * Get differences of the two item lists.\r\n     * @param pItemListA - Item list A.\r\n     * @param pItemListB - Item list B.\r\n     */\r\n    public differencesOf(pItemListA: Array<TA>, pItemListB: Array<TB>): Array<HistoryItem<TA, TB>> {\r\n        // Save farthest-right points with it histories.\r\n        const lFrontierList: { [index: number]: Frontier<TA, TB>; } = { 1: { x: 0, history: [] } };\r\n\r\n        // \"Convert\" Zero index to One index.\r\n        const lOneIndex: (pId: number) => number = (pId: number): number => pId - 1;\r\n\r\n        const lLengthA: number = pItemListA.length;\r\n        const lLengthB: number = pItemListB.length;\r\n\r\n        let lHistoryList: Array<HistoryItem<TA, TB>>;\r\n        let lX: number;\r\n\r\n        for (let lD = 0; lD < lLengthA + lLengthB + 1; lD++) {\r\n            for (let lK = -lD; lK < lD + 1; lK += 2) {\r\n                // Check if next move goes down or right.\r\n                const lGoesDown: boolean = (lK === -lD || (lK !== lD && lFrontierList[lK - 1].x < lFrontierList[lK + 1].x));\r\n\r\n                // Get starting diagonal point.\r\n                if (lGoesDown) {\r\n                    const lNextFrontier: Frontier<TA, TB> = lFrontierList[lK + 1];\r\n                    lX = lNextFrontier.x;\r\n                    lHistoryList = lNextFrontier.history;\r\n                } else {\r\n                    const lNextFrontier: Frontier<TA, TB> = lFrontierList[lK - 1];\r\n                    lX = lNextFrontier.x + 1;\r\n                    lHistoryList = lNextFrontier.history;\r\n                }\r\n\r\n                // Copy history list.\r\n                lHistoryList = lHistoryList.slice();\r\n                let lY: number = lX - lK;\r\n\r\n                // Only start tracking history on valid track. Staring point (0,0) should not be tracked.\r\n                if (1 <= lY && lY <= lLengthB && lGoesDown) {\r\n                    lHistoryList.push({ changeState: ChangeState.Insert, item: pItemListB[lOneIndex(lY)] });\r\n                } else if (1 <= lX && lX <= lLengthA) {\r\n                    lHistoryList.push({ changeState: ChangeState.Remove, item: pItemListA[lOneIndex(lX)] });\r\n                }\r\n\r\n                // Move diagonal as long as possible.\r\n                while (lX < lLengthA && lY < lLengthB && this.mCompareFunction(pItemListA[lOneIndex(lX + 1)], pItemListB[lOneIndex(lY + 1)])) {\r\n                    lX += 1;\r\n                    lY += 1;\r\n                    lHistoryList.push({ changeState: ChangeState.Keep, item: pItemListA[lOneIndex(lX)] });\r\n                }\r\n\r\n                // Check if in the bottom right. If not save frontier.\r\n                if (lX >= lLengthA && lY >= lLengthB) {\r\n                    // Return found history.\r\n                    return lHistoryList;\r\n                } else {\r\n                    lFrontierList[lK] = { x: lX, history: lHistoryList };\r\n                }\r\n            }\r\n        }\r\n\r\n        // Empty array for typescript. This area is never reached.\r\n        // deno-coverage-ignore-next\r\n        return new Array<HistoryItem<TA, TB>>();\r\n    }\r\n}\r\n\r\nexport type HistoryItemRemove<T> = { changeState: ChangeState.Remove, item: T; };\r\nexport type HistoryItemInsert<T> = { changeState: ChangeState.Insert, item: T; };\r\nexport type HistoryItemKeep<T> = { changeState: ChangeState.Keep, item: T; };\r\nexport type HistoryItem<TA, TB> = HistoryItemRemove<TA> | HistoryItemInsert<TB> | HistoryItemKeep<TA>;\r\n\r\nexport enum ChangeState {\r\n    Remove = 1,\r\n    Insert = 2,\r\n    Keep = 3\r\n}\r\n\r\ntype Frontier<TA, TB> = { x: number, history: Array<HistoryItem<TA, TB>>; };\r\n", "/**\r\n * Library for data container and easier data access.\r\n *\r\n * @remarks \r\n * This package consists mostly of helper classes and storage types, aimed at reducing code redundance and improving clarity.\r\n * \r\n * @packageDocumentation\r\n */\r\n\r\n// Container.\r\nexport { Dictionary } from './data_container/dictionary.ts';\r\nexport { List } from './data_container/list.ts';\r\nexport { Stack } from './data_container/stack.ts';\r\nexport { Exception } from './exception/exception.ts';\r\nexport { LinkedList } from './data_container/linked-list.ts';\r\n\r\n// Handler.\r\nexport { EnumUtil } from './util/enum-util.ts';\r\nexport { TypeUtil } from './util/type-util.ts';\r\nexport { ByteUtil } from './util/byte-util.ts';\r\n\r\n// Interfaces.\r\nexport { type ICloneable } from './interface/i-cloneable.ts';\r\nexport { type IVoidParameterConstructor } from './interface/i-constructor.ts';\r\nexport { type IDeconstructable } from './interface/i-deconstructable.ts';\r\n\r\n// Support types.\r\nexport {\r\n    type Readonly, type Writeable,\r\n\r\n    // Decorator types.\r\n    type ClassDecorator,\r\n    type ClassAccessorDecorator,\r\n    type ClassMethodDecorator,\r\n    type ClassFieldDecorator,\r\n} from './types.ts';\r\n\r\n// Algorythms\r\nexport { ChangeState, MyersDiff, type HistoryItem } from './algorithm/myers-diff.ts';\r\n", "import { Dictionary, Exception } from '@kartoffelgames/core';\r\nimport type { SerializeableConstructor, SerializeableGuid } from '../type.ts';\r\n\r\n/**\r\n * Map for all registered serializable classes.\r\n * Singleton pattern.\r\n */\r\nexport class StatefullSerializeableClasses {\r\n    private static mInstance: StatefullSerializeableClasses;\r\n\r\n    private readonly mConstructionParameterRetriever!: Dictionary<SerializeableGuid, ParameterRetrieveCallback>;\r\n    private readonly mConstructorToGuidMap!: Dictionary<SerializeableConstructor, SerializeableGuid>;\r\n    private readonly mGuidToConstructorMap!: Dictionary<SerializeableGuid, SerializeableConstructor>;\r\n\r\n    /**\r\n     * Private constructor.\r\n     * Initialize lists.\r\n     */\r\n    public constructor() {\r\n        if (StatefullSerializeableClasses.mInstance) {\r\n            return StatefullSerializeableClasses.mInstance;\r\n        }\r\n\r\n        StatefullSerializeableClasses.mInstance = this;\r\n\r\n        this.mGuidToConstructorMap = new Dictionary<SerializeableGuid, SerializeableConstructor>();\r\n        this.mConstructorToGuidMap = new Dictionary<SerializeableConstructor, SerializeableGuid>();\r\n        this.mConstructionParameterRetriever = new Dictionary<SerializeableGuid, ParameterRetrieveCallback>();\r\n\r\n        // Define default classes.\r\n        this.registerClass(Object, 'e00cb495-e7ae-4b7f-8366-8bd706a326be', () => {\r\n            return {}; // Empty.\r\n        });\r\n        this.registerClass(Array, 'fada0e18-119a-4668-80b6-bff1ca22547a', () => {\r\n            return {}; // Empty\r\n        });\r\n        this.registerClass(Date, 'b1e709cb-34d3-46f2-a9f0-f1bf57c04e69', (pObject: Date) => {\r\n            return {\r\n                parameter: [pObject.toString()]\r\n            };\r\n        });\r\n        this.registerClass(Set, '70752b96-49c5-407c-a560-c4a294fb90ae', (pObject: Set<any>) => {\r\n            return {\r\n                parameter: [[...pObject]]\r\n            };\r\n        });\r\n        this.registerClass(Map, '084af2dd-573f-4bf9-bbc5-c9b627d4baf2', (pObject: Map<any, any>) => {\r\n            return {\r\n                parameter: [[...pObject.entries()]]\r\n            };\r\n        });\r\n\r\n        // Define defaults for types arrays.\r\n        const lDefaultTypedArrayRetriever = (pArray: Int8Array) => {\r\n            return { parameter: [pArray.length] };\r\n        };\r\n\r\n        // Define typed array classes.\r\n        this.registerClass(Int8Array, '63240f98-4309-479f-869c-db2cbf8a9fda', lDefaultTypedArrayRetriever);\r\n        this.registerClass(Uint8Array, 'd4fb16bb-29d8-4835-b6c4-f3f8ab10715a', lDefaultTypedArrayRetriever);\r\n        this.registerClass(Uint8ClampedArray, 'f38e3d89-5df3-41b8-b34b-c1dc2bba69bd', lDefaultTypedArrayRetriever);\r\n        this.registerClass(Int16Array, 'e7b7193a-c8d1-4d40-a19a-1d5174d431a4', lDefaultTypedArrayRetriever);\r\n        this.registerClass(Uint16Array, '6c13f6c0-5dd2-456d-bdd4-dcded1a9b815', lDefaultTypedArrayRetriever);\r\n        this.registerClass(Int32Array, 'b79a08f2-a566-4fae-b587-3ae298545556', lDefaultTypedArrayRetriever);\r\n        this.registerClass(Uint32Array, '138511cb-8584-47a8-aa3a-08bb6488bd5b', lDefaultTypedArrayRetriever);\r\n        this.registerClass(Float32Array, 'a0f6704d-42bc-4c1b-9acb-80dad04c51af', lDefaultTypedArrayRetriever);\r\n        this.registerClass(Float64Array, '30444e6c-456f-413e-b522-26c7057fd68b', lDefaultTypedArrayRetriever);\r\n        this.registerClass(BigInt64Array, '855c609e-1497-46cf-8c12-5e01346b38ae', lDefaultTypedArrayRetriever);\r\n        this.registerClass(BigUint64Array, 'a4a0d93b-36cf-422b-8323-75484c58a0ae', lDefaultTypedArrayRetriever);\r\n    }\r\n\r\n    /**\r\n     * Get registered class by id.\r\n     * @param pId - Class constructor.\r\n     */\r\n    public getClass(pId: SerializeableGuid): SerializeableConstructor {\r\n        const lGuid: SerializeableConstructor | undefined = this.mGuidToConstructorMap.get(pId);\r\n\r\n        // Catch not registered constructors.\r\n        if (!lGuid) {\r\n            throw new Exception(`ClassId \"${pId}\" is not registered.`, this);\r\n        }\r\n\r\n        return lGuid;\r\n    }\r\n\r\n    /**\r\n     * Get id of registered class.\r\n     * @param pConstructor - Class constructor.\r\n     */\r\n    public getClassId(pConstructor: SerializeableConstructor): SerializeableGuid {\r\n        const lConstructor: SerializeableGuid | undefined = this.mConstructorToGuidMap.get(pConstructor);\r\n\r\n        // Catch not registered constructors.\r\n        if (!lConstructor) {\r\n            throw new Exception(`Constructor \"${pConstructor.name}\" is not registered.`, this);\r\n        }\r\n\r\n        return lConstructor;\r\n    }\r\n\r\n    /**\r\n     * Get construction parameter of registered objects.\r\n     * @param pObject - Object.\r\n     */\r\n    public getObjectConstructionParameter(pObject: object): StatefullSerializerInitializationParameter {\r\n        const lObjectClassId: SerializeableGuid = this.getClassId(<SerializeableConstructor>pObject.constructor);\r\n\r\n        // Retriever is allways registered when an class id is found.\r\n        const lParameterRetriever: ParameterRetrieveCallback = <ParameterRetrieveCallback>this.mConstructionParameterRetriever.get(lObjectClassId);\r\n\r\n        return lParameterRetriever(pObject);\r\n    }\r\n\r\n    /**\r\n     * Register serializeable object.\r\n     * @param pConstructor - Constructor.\r\n     * @param pGuid - Guid assigned to set constructor.\r\n     */\r\n    public registerClass(pConstructor: SerializeableConstructor, pGuid: SerializeableGuid, pParameterRetrieve: ParameterRetrieveCallback): void {\r\n        this.mGuidToConstructorMap.add(pGuid, pConstructor);\r\n        this.mConstructorToGuidMap.add(pConstructor, pGuid);\r\n        this.mConstructionParameterRetriever.add(pGuid, pParameterRetrieve);\r\n    }\r\n}\r\n\r\nexport type StatefullSerializerRequiredValue = {\r\n    propertyName: string;\r\n    value: any | Array<any>;\r\n};\r\nexport type StatefullSerializerInitializationParameter = {\r\n    parameter?: Array<any>,\r\n    requiredValues?: Array<StatefullSerializerRequiredValue>;\r\n};\r\nexport type ParameterRetrieveCallback = (pObject: any) => StatefullSerializerInitializationParameter;", "import type { ClassDecorator } from '@kartoffelgames/core';\r\nimport type { SerializeableConstructor, SerializeableGuid } from '../../type.ts';\r\nimport { StatefullSerializeableClasses } from '../statefull-serializeable-classes.ts';\r\n\r\n/**\r\n * AtScript.\r\n * Marks class as serializeable. \r\n * All child types present as properties must be marked too.\r\n * @param pGuid - Global unique id.\r\n */\r\nexport function StatefullSerializeable<TClass extends SerializeableConstructor>(pGuid: SerializeableGuid): ClassDecorator<TClass, TClass> {\r\n    return function (pConstructor: TClass): TClass {\r\n        const lObjectToConstructorParameter: WeakMap<object, Array<any>> = new WeakMap<object, Array<any>>();\r\n\r\n        // Extends original constructor that maps any parameter of constructed objects.\r\n        const lParameterProxyConstructor = class extends pConstructor {\r\n            public constructor(...pParameter: Array<any>) {\r\n                super(...pParameter);\r\n\r\n                // Map constructor parameter.\r\n                lObjectToConstructorParameter.set(this, pParameter);\r\n            }\r\n        };\r\n\r\n        // Map serializable class.\r\n        new StatefullSerializeableClasses().registerClass(lParameterProxyConstructor, pGuid, (pObject: object) => {\r\n            return {\r\n                parameter: <Array<any>>lObjectToConstructorParameter.get(pObject),\r\n                requiredValues: []\r\n            };\r\n        });\r\n\r\n        // Override original constrcutor.\r\n        return lParameterProxyConstructor;\r\n    };\r\n}\r\n", "import { Dictionary, Exception } from '@kartoffelgames/core';\r\nimport type { SerializeableConstructor, SerializeableGuid } from '../type.ts';\r\nimport { StatefullSerializeableClasses } from './statefull-serializeable-classes.ts';\r\nimport type { ObjectifiedBigInt, ObjectifiedClass, ObjectifiedObject, ObjectifiedObjectType, ObjectifiedReference, ObjectifiedSymbol, ObjectifiedValue } from './types/Objectified.type.ts';\r\n\r\nexport class StatefullDeserializer {\r\n    /**\r\n     * Deobjectifiy objectified values.\r\n     * \r\n     * @param pObjectified - Objectified values.\r\n     * @param _pConstructor - Constructor of the class. Needed that the type gets imported and the constructor gets registered.\r\n     */\r\n    public deobjectify<T>(pObjectified: ObjectifiedValue, _pConstructor?: new (...pArgs: Array<any>) => T): T {\r\n        const lObjectIds: Dictionary<SerializeableGuid, any> = new Dictionary<SerializeableGuid, any>();\r\n        return <T>this.deobjectifyUnknown(pObjectified, lObjectIds);\r\n    }\r\n\r\n    /**\r\n     * Deserialize serialized string.\r\n     * \r\n     * @param pString - Serialized string.\r\n     * @param pConstructor - Constructor of the class. Needed that the type gets imported and the constructor gets registered.\r\n     */\r\n    public deserialize<T>(pString: string, pConstructor?: new (...pArgs: Array<any>) => T): T {\r\n        const lObjectifiedValue: any = JSON.parse(pString);\r\n        return this.deobjectify<T>(lObjectifiedValue, pConstructor);\r\n    }\r\n\r\n    /**\r\n     * Deserialize\r\n     * @param pObjectified - Objectified value.\r\n     * @param pObjectIds - Current serializer runs object ids.\r\n     */\r\n    private deobjectifyObject(pObjectified: ObjectifiedObject, pObjectIds: Dictionary<SerializeableGuid, any>): unknown {\r\n        // Get object type by [&type].\r\n        const lObjectType: ObjectifiedObjectType = pObjectified['&type'];\r\n        switch (lObjectType) {\r\n            case 'reference': {\r\n                // Hint object type.\r\n                const lReferenceObject: ObjectifiedReference = <ObjectifiedReference>pObjectified;\r\n\r\n                // Read object of id.\r\n                const lObjectId: SerializeableGuid = lReferenceObject['&objectId'];\r\n\r\n                // Throw not found exception. \r\n                if (!pObjectIds.has(lObjectId)) {\r\n                    throw new Exception('Referenced object not found.', this);\r\n                }\r\n\r\n                // Object can only be found. has() has been called before.\r\n                return <object>pObjectIds.get(lObjectId);\r\n            }\r\n\r\n            case 'bigint': {\r\n                // Hint object type.\r\n                const lBigIntObject: ObjectifiedBigInt = <ObjectifiedBigInt>pObjectified;\r\n\r\n                // Get bigint value and create bigint number.\r\n                const lNumberAsString: string = lBigIntObject['&number'];\r\n                return BigInt(lNumberAsString);\r\n            }\r\n\r\n            case 'symbol': {\r\n                // Hint object type.\r\n                const lSymbolObjectType: ObjectifiedSymbol = <ObjectifiedSymbol>pObjectified;\r\n\r\n                // Get symbol values.\r\n                const lObjectId: SerializeableGuid = lSymbolObjectType['&objectId'];\r\n                const lDescription: string | undefined = lSymbolObjectType['&values']['description'];\r\n\r\n                // Create symbol and register with object id.\r\n                const lSymbol: symbol = Symbol(lDescription);\r\n                pObjectIds.set(lObjectId, lSymbol);\r\n\r\n                return lSymbol;\r\n            }\r\n\r\n            case 'class': {\r\n                // Hint object type.\r\n                const lClassObject: ObjectifiedClass = <ObjectifiedClass>pObjectified;\r\n\r\n                // Read object data.\r\n                const lClassId: SerializeableGuid = lClassObject['&constructor'];\r\n                const lObjectId: SerializeableGuid = lClassObject['&objectId'];\r\n                const lConstructionParameterList = lClassObject['&initialisation']['parameter'].map(pValue => this.deobjectifyUnknown(pValue, pObjectIds));\r\n\r\n                // Get class constructor.\r\n                const lConstructor: SerializeableConstructor = new StatefullSerializeableClasses().getClass(lClassId);\r\n\r\n                // Build class and register object id.\r\n                const lClass = new lConstructor(...lConstructionParameterList);\r\n                pObjectIds.set(lObjectId, lClass);\r\n\r\n                // Add required values.\r\n                for (const lRequiredValue of lClassObject['&initialisation']['requiredValues']) {\r\n                    const lDeserializedValue: any = this.deobjectifyUnknown(lRequiredValue.value, pObjectIds);\r\n\r\n                    // Add required value.\r\n                    if (typeof lClass[lRequiredValue.propertyName] === 'function') {\r\n                        // Call function with spread operator when value is an array.\r\n                        if (Array.isArray(lDeserializedValue)) {\r\n                            lClass[lRequiredValue.propertyName](...lDeserializedValue);\r\n                        } else {\r\n                            lClass[lRequiredValue.propertyName](lDeserializedValue);\r\n                        }\r\n                    } else {\r\n                        lClass[lRequiredValue.propertyName] = lDeserializedValue;\r\n                    }\r\n                }\r\n\r\n                // Add state values in alphabetical order.\r\n                const lValues = lClassObject['&values'];\r\n                for (const lKey of Object.keys(lValues).sort()) {\r\n                    // Deserialize and add value.\r\n                    lClass[lKey] = this.deobjectifyUnknown(lValues[lKey], pObjectIds);\r\n                }\r\n\r\n                return lClass;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deserialize unknown objectified value.\r\n     * @param pObjectified - Objectfied object.\r\n     * @param pObjectIds - Object ids of current deserialize.\r\n     */\r\n    private deobjectifyUnknown(pObjectified: ObjectifiedValue, pObjectIds: Dictionary<SerializeableGuid, any>): unknown {\r\n        const lType: 'string' | 'number' | 'bigint' | 'boolean' | 'symbol' | 'undefined' | 'object' | 'function' = typeof pObjectified;\r\n\r\n        // Objectified is simple value. Simply return.\r\n        if (lType !== 'object' || pObjectified === null) {\r\n            return pObjectified;\r\n        }\r\n\r\n        // Only remaining types are object types\r\n        return this.deobjectifyObject(<ObjectifiedObject>pObjectified, pObjectIds);\r\n    }\r\n}", "import { Dictionary } from '@kartoffelgames/core';\r\nimport type { SerializeableConstructor, SerializeableGuid } from '../type.ts';\r\nimport { StatefullSerializeableClasses, type StatefullSerializerInitializationParameter } from './statefull-serializeable-classes.ts';\r\nimport type { ObjectifiedObject, ObjectifiedSimple, ObjectifiedValue } from './types/Objectified.type.ts';\r\n\r\nexport class StatefullSerializer {\r\n    /**\r\n     * Objectify value.\r\n     * @param pObject - Object.\r\n     */\r\n    public objectify(pObject: any): ObjectifiedValue {\r\n        const lObjectIds: Dictionary<any, SerializeableGuid> = new Dictionary<any, SerializeableGuid>();\r\n        return this.objectifyUnknown(pObject, lObjectIds);\r\n    }\r\n\r\n    /**\r\n     * Objectify and stringify value.\r\n     * @param pObject - Object.\r\n     */\r\n    public serialize(pObject: any): string {\r\n        return JSON.stringify(this.objectify(pObject));\r\n    }\r\n\r\n    /**\r\n     * Objectify referenceable values, any value that gets passed as reference.\r\n     * @param pObject - Reference.\r\n     * @param pObjectIds - Current serializer runs object ids.\r\n     */\r\n    private objectifyObject(pObject: object | symbol, pObjectIds: Dictionary<any, SerializeableGuid>): ObjectifiedObject {\r\n        // Load cached objectification.\r\n        if (pObjectIds.has(pObject)) {\r\n            const lObjectId: SerializeableGuid = <string>pObjectIds.get(pObject);\r\n\r\n            // Create circular reference.\r\n            return {\r\n                '&type': 'reference',\r\n                '&objectId': lObjectId,\r\n            };\r\n        }\r\n\r\n        // Create new guid and register as symbols id.\r\n        const lObjectId: SerializeableGuid = globalThis.crypto.randomUUID();\r\n        pObjectIds.set(pObject, lObjectId);\r\n\r\n        // Symbol\r\n        if (typeof pObject === 'symbol') {\r\n            return {\r\n                '&type': 'symbol',\r\n                '&objectId': lObjectId,\r\n                '&values': {\r\n                    'description': pObject.description\r\n                }\r\n            };\r\n        }\r\n\r\n        // Objects with constructors.\r\n        const lClassConstructor: SerializeableConstructor = <SerializeableConstructor>pObject.constructor;\r\n        const lStatefullSerializeableClasses = new StatefullSerializeableClasses();\r\n        const lClassId: SerializeableGuid = lStatefullSerializeableClasses.getClassId(lClassConstructor);\r\n\r\n        // Read constructor parameter.\r\n        const lInitializationObject: StatefullSerializerInitializationParameter = lStatefullSerializeableClasses.getObjectConstructionParameter(pObject);\r\n\r\n        // Build initialization parameter.\r\n        const lInitializationParameter: Array<ObjectifiedValue> | undefined = lInitializationObject.parameter?.map(pValue => {\r\n            return this.objectifyUnknown(pValue, pObjectIds);\r\n        });\r\n\r\n        // Build initialization required values.\r\n        const lInitializationRequiredValueList = lInitializationObject.requiredValues?.map(pValue => {\r\n            return {\r\n                propertyName: pValue.propertyName,\r\n                value: this.objectifyUnknown(pValue.value, pObjectIds)\r\n            };\r\n        });\r\n\r\n        // Read all property descriptors and objectify all none readonly values.\r\n        // Order property keys so an constistent reference chain can be achived.\r\n        const lValueObject: { [key: string]: ObjectifiedValue; } = {};\r\n        const lDescriptorList = Object.getOwnPropertyDescriptors(pObject);\r\n        for (const lDescriptorKey of Object.keys(lDescriptorList).sort()) {\r\n            const lPropertyDescriptor: PropertyDescriptor = lDescriptorList[lDescriptorKey];\r\n\r\n            // Only none readonly values.\r\n            if (lPropertyDescriptor.writable) {\r\n                lValueObject[lDescriptorKey] = this.objectifyUnknown(lPropertyDescriptor.value, pObjectIds);\r\n            }\r\n        }\r\n\r\n        return {\r\n            '&type': 'class',\r\n            '&constructor': lClassId,\r\n            '&objectId': lObjectId,\r\n            '&initialisation': {\r\n                'parameter': lInitializationParameter ?? [], // Default empty array.\r\n                'requiredValues': lInitializationRequiredValueList ?? [] // Default empty array.\r\n            },\r\n            '&values': lValueObject\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Objectify unknown values.\r\n     * @param pUnknown - Unknown value.\r\n     * @param pObjectIds - Object ids of current serialization.\r\n     */\r\n    private objectifyUnknown(pUnknown: unknown, pObjectIds: Dictionary<any, SerializeableGuid>): ObjectifiedValue {\r\n        const lType: 'string' | 'number' | 'bigint' | 'boolean' | 'symbol' | 'undefined' | 'object' | 'function' = typeof pUnknown;\r\n        switch (lType) {\r\n            // Native simple types.\r\n            case 'string':\r\n            case 'number':\r\n            case 'boolean':\r\n            case 'undefined': {\r\n                return <ObjectifiedSimple>pUnknown;\r\n            }\r\n\r\n            // BigInt\r\n            case 'bigint': {\r\n                const lBigInt: bigint = <bigint>pUnknown;\r\n                return {\r\n                    '&type': 'bigint',\r\n                    '&number': lBigInt.toString()\r\n                };\r\n            }\r\n\r\n            // Symbol & Object\r\n            case 'symbol':\r\n            case 'object': {\r\n                const lObject: object = <object>pUnknown;\r\n\r\n                // Null object.\r\n                if (lObject === null) {\r\n                    return null;\r\n                }\r\n\r\n                return this.objectifyObject(lObject, pObjectIds);\r\n            }\r\n\r\n            // Function: Ignore\r\n            default: {\r\n                return undefined;\r\n            }\r\n        }\r\n    }\r\n}\r\n", "/* istanbul ignore file */\r\n\r\nexport { StatefullSerializeable } from './statefull_serialize/decorator/statefull-serializeable.decorator.ts';\r\nexport { StatefullDeserializer } from './statefull_serialize/statefull-deserializer.ts';\r\nexport { StatefullSerializeableClasses } from './statefull_serialize/statefull-serializeable-classes.ts';\r\nexport { StatefullSerializer } from './statefull_serialize/statefull-serializer.ts';\r\n", "\r\nimport { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { IGenericEffect } from '../../effect/effect_definition/i-generic-effect.ts';\r\n\r\n@StatefullSerializeable('3fd4b733-df66-4499-819a-78002d25b649')\r\nexport class DivisionChannel {\r\n    private readonly mEffectList: Array<IGenericEffect>;\r\n\r\n    /**\r\n     * Set effect.\r\n     */\r\n    public get effects(): Array<IGenericEffect> {\r\n        return this.mEffectList;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * Set empty information.\r\n     */\r\n    public constructor() {\r\n        this.mEffectList = new Array<IGenericEffect>();\r\n    }\r\n\r\n    /**\r\n     * Remove a set effect. Can be the original effect or only effect of the same type.\r\n     * @param pEffect - Effect. Or only effect with the same type.\r\n     */\r\n    public removeEffect(pEffect: IGenericEffect): void {\r\n        // Find same type of effect.\r\n        const lSameEffectType: IGenericEffect | undefined = this.mEffectList.find((pAppliedEffect: IGenericEffect) => {\r\n            return pAppliedEffect.constructor === pEffect.constructor;\r\n        });\r\n\r\n        // Remove old effect of same type.\r\n        if (typeof lSameEffectType !== 'undefined') {\r\n            const lEffectIndex: number = this.mEffectList.indexOf(lSameEffectType);\r\n            if (lEffectIndex !== -1) {\r\n                this.mEffectList.splice(lEffectIndex, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set effect. Only one type of effect can be applyed at once.\r\n     * Same types are replaced.\r\n     */\r\n    public setEffect(pEffect: IGenericEffect): void {\r\n        // Find same type of effect.\r\n        const lSameEffectType: IGenericEffect | undefined = this.mEffectList.find((pAppliedEffect: IGenericEffect) => {\r\n            return pAppliedEffect.constructor === pEffect.constructor;\r\n        });\r\n\r\n        // Remove old effect of same type.\r\n        if (typeof lSameEffectType !== 'undefined') {\r\n            const lEffectIndex: number = this.mEffectList.indexOf(lSameEffectType);\r\n            if (lEffectIndex !== -1) {\r\n                this.mEffectList.splice(lEffectIndex, 1);\r\n            }\r\n        }\r\n\r\n        this.mEffectList.push(pEffect);\r\n    }\r\n}", "import { Exception } from '@kartoffelgames/core';\r\nimport { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { DivisionChannel } from './division-channel.ts';\r\n\r\n@StatefullSerializeable('dc682441-633d-496f-b8a2-6654b27389e3')\r\nexport class Division {\r\n    private readonly mChannelList: Array<DivisionChannel>;\r\n\r\n    /**\r\n     * Get channel count.\r\n     */\r\n    public get channelCount(): number {\r\n        return this.mChannelList.length;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mChannelList = new Array<DivisionChannel>();\r\n    }\r\n\r\n    /**\r\n     * Add channel data.\r\n     * @param pIndex - Channel index.\r\n     */\r\n    public addChannel(pIndex: number): DivisionChannel {\r\n        const lNewChannel: DivisionChannel = new DivisionChannel();\r\n\r\n        // Add new when no index is specified.\r\n        if (pIndex === null || pIndex === this.mChannelList.length) {\r\n            this.mChannelList.push(lNewChannel);\r\n        } else {\r\n            // Check if index would produce gaps.\r\n            if (pIndex > this.mChannelList.length) {\r\n                throw new Exception(`Channel index would produce gaps with missing channels.`, this);\r\n            }\r\n\r\n            // Set channel to index.\r\n            this.mChannelList[pIndex] = lNewChannel;\r\n        }\r\n\r\n        return lNewChannel;\r\n    }\r\n\r\n    /**\r\n     * Get channel data.\r\n     * @param pChannelIndex - Channel index.\r\n     */\r\n    public getChannel(pChannelIndex: number): DivisionChannel {\r\n        return this.mChannelList[pChannelIndex] ?? new DivisionChannel();\r\n    }\r\n\r\n    /**\r\n     * Remove sample by index.\r\n     * @param pIndex - Index of sample.\r\n     */\r\n    public removeChannel(pIndex: number): void {\r\n        // Exit if index is out of bound.\r\n        if (pIndex >= (this.mChannelList.length - 1)) {\r\n            return;\r\n        }\r\n\r\n        // Remove last element if index is last element.\r\n        if (pIndex === (this.mChannelList.length - 1)) {\r\n            this.mChannelList.pop();\r\n        } else {\r\n            // Replace with empty channel if any gap would be produced.\r\n            this.mChannelList[pIndex] = new DivisionChannel();\r\n        }\r\n    }\r\n}", "import { Exception } from '@kartoffelgames/core';\r\nimport { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { Division } from './division.ts';\r\n\r\n@StatefullSerializeable('e9a8b42d-c2e2-4466-8a5d-5c24290310f2')\r\nexport class Pattern {\r\n    private readonly mDivisionList: Array<Division>;\r\n\r\n    /**\r\n     * Get division count.\r\n     */\r\n    public get divisionCount(): number {\r\n        return this.mDivisionList.length;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mDivisionList = new Array<Division>();\r\n    }\r\n\r\n    /**\r\n     * Add new division. Appends if no index is specified.\r\n     * @param pIndex - Index of new division.\r\n     */\r\n    public addDivision(pIndex?: number): Division {\r\n        const lNewDivision: Division = new Division();\r\n\r\n        // Add new when no index is specified.\r\n        if (typeof pIndex === 'undefined' || pIndex === this.mDivisionList.length) {\r\n            this.mDivisionList.push(lNewDivision);\r\n        } else {\r\n            // Check if index would produce gaps.\r\n            if (pIndex > this.mDivisionList.length) {\r\n                throw new Exception(`Division index would produce gaps with missing dicisions.`, this);\r\n            }\r\n\r\n            // Set pattern to index.\r\n            this.mDivisionList[pIndex] = lNewDivision;\r\n        }\r\n\r\n        return lNewDivision;\r\n    }\r\n\r\n    /**\r\n     * Get pattern row information.\r\n     * @param pDivisionIndex - Division index.\r\n     */\r\n    public getDivision(pDivisionIndex: number): Division {\r\n        // Return real row.\r\n        return this.mDivisionList[pDivisionIndex] ?? new Division();\r\n    }\r\n\r\n    /**\r\n     * Remove sample by index.\r\n     * @param pIndex - Index of sample.\r\n     */\r\n    public removeDivision(pIndex: number): void {\r\n        // Exit if index is out of bound.\r\n        if (pIndex >= (this.mDivisionList.length - 1)) {\r\n            return;\r\n        }\r\n\r\n        // Remove last element if index is last element.\r\n        if (pIndex === (this.mDivisionList.length - 1)) {\r\n            this.mDivisionList.pop();\r\n        } else {\r\n            // Replace with empty division if any gap would be produced.\r\n            this.mDivisionList[pIndex] = new Division();\r\n        }\r\n    }\r\n}", "import { Exception } from '@kartoffelgames/core';\r\nimport { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { Pattern } from './pattern.ts';\r\n\r\n/**\r\n * Complete pattern data.\r\n */\r\n@StatefullSerializeable('79cfd5d5-1575-45f4-a056-8248811d3deb')\r\nexport class PatternList {\r\n    private readonly mPatternList: Array<Pattern>;\r\n    private mSongPositionList: Array<number>;\r\n\r\n    /**\r\n     * Get pattern count.\r\n     */\r\n    public get patternCount(): number {\r\n        return this.mPatternList.length;\r\n    }\r\n\r\n    /**\r\n     * Get song positions.\r\n     */\r\n    public get songPositions(): Array<number> {\r\n        return this.mSongPositionList;\r\n    }\r\n\r\n    /**\r\n     * Set song positions.\r\n     */\r\n    public set songPositions(pPatternOrder: Array<number>) {\r\n        this.mSongPositionList = pPatternOrder;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * Initialize lists.\r\n     */\r\n    public constructor() {\r\n        this.mPatternList = new Array<Pattern>();\r\n        this.mSongPositionList = new Array<number>();\r\n    }\r\n\r\n    /**\r\n     * Add pattern.\r\n     * @param pPattern - Data of one pattern.\r\n     * @param pIndex - Index of pattern. If not specified, the pattern get append after last known pattern index.\r\n     */\r\n    public addPattern(pIndex?: number): Pattern {\r\n        const lNewPattern: Pattern = new Pattern();\r\n\r\n        // Add new when no index is specified.\r\n        if (typeof pIndex === 'undefined' || pIndex === this.mPatternList.length) {\r\n            this.mPatternList.push(lNewPattern);\r\n        } else {\r\n            // Check if index would produce gaps.\r\n            if (pIndex > this.mPatternList.length) {\r\n                throw new Exception(`Pattern index would produce gaps with missing pattern.`, this);\r\n            }\r\n\r\n            // Set pattern to index.\r\n            this.mPatternList[pIndex] = lNewPattern;\r\n        }\r\n\r\n        return lNewPattern;\r\n    }\r\n\r\n    /**\r\n     * Get pattern data by index.\r\n     * @param pIndex - Index of pattern.\r\n     */\r\n    public getPattern(pIndex: number): Pattern {\r\n        return this.mPatternList[pIndex] ?? new Pattern();\r\n    }\r\n\r\n    /**\r\n     * Clear Pattern or remove pattern when pattern is on last index.\r\n     * @param pIndex - .\r\n     */\r\n    public removePattern(pIndex: number): void {\r\n        // Exit when index is out of bound.\r\n        if (pIndex >= this.mPatternList.length) {\r\n            return;\r\n        }\r\n\r\n        // Remove last element or clear pattern.\r\n        if (pIndex === (this.mPatternList.length - 1)) {\r\n            this.mPatternList.pop();\r\n        } else {\r\n            // Replace pattern with empty one.\r\n            this.mPatternList[pIndex] = new Pattern();\r\n        }\r\n    }\r\n}", "import { Exception } from '@kartoffelgames/core';\r\nimport { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\n\r\n/**\r\n * Sample information.\r\n */\r\n@StatefullSerializeable('217a4b0a-1a1a-4c93-9228-ad04e032f5f9')\r\nexport class Sample {\r\n    private mData: Float32Array;\r\n    private mFineTune: number;\r\n    private mName: string;\r\n    private mRepeatLength: number;\r\n    private mRepeatStartOffset: number;\r\n    private mVolume: number;\r\n\r\n    /**\r\n     * Get sample byte data.\r\n     */\r\n    public get data(): Float32Array {\r\n        return this.mData;\r\n    }\r\n\r\n    /**\r\n     * Set sample byte data.\r\n     */\r\n    public set data(pData: Float32Array) {\r\n        this.mData = pData;\r\n    }\r\n\r\n    /**\r\n     * Get samples fine tune.\r\n     */\r\n    public get fineTune(): number {\r\n        return this.mFineTune;\r\n    }\r\n\r\n    /**\r\n     * Set samples fine tune.\r\n     */\r\n    public set fineTune(pFineTune: number) {\r\n        this.mFineTune = pFineTune;\r\n    }\r\n\r\n    /**\r\n     * Get sample name.\r\n     */\r\n    public get name(): string {\r\n        return this.mName;\r\n    }\r\n\r\n    /**\r\n     * Set sample name.\r\n     */\r\n    public set name(pName: string) {\r\n        this.mName = pName;\r\n    }\r\n\r\n    /**\r\n     * Get sample repeat length.\r\n     */\r\n    public get repeatLength(): number {\r\n        return this.mRepeatLength;\r\n    }\r\n\r\n    /**\r\n     * Get sample repeat offset.\r\n     */\r\n    public get repeatOffset(): number {\r\n        return this.mRepeatStartOffset;\r\n    }\r\n\r\n    /**\r\n     * Get samples volume. 0..1\r\n     */\r\n    public get volume(): number {\r\n        return this.mVolume;\r\n    }\r\n\r\n    /**\r\n     * Set samples volume. 0..1\r\n     */\r\n    public set volume(pVolume: number) {\r\n        if (pVolume > 1 || pVolume < 0) {\r\n            throw new Exception('Volume out of range [0..1]', this);\r\n        }\r\n\r\n        this.mVolume = pVolume;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * Set defaults.\r\n     */\r\n    public constructor() {\r\n        // Empty values.\r\n        this.mName = '';\r\n        this.mData = new Float32Array(1);\r\n        this.mVolume = 0;\r\n        this.mFineTune = 0;\r\n        this.mRepeatLength = 1;\r\n        this.mRepeatStartOffset = 0;\r\n    }\r\n\r\n    /**\r\n     * Set repeat information.\r\n     * @param pRepeatOffset - Repeat offset, where the repeat should start.\r\n     * @param pRepeatLength - Repeat byte length.\r\n     */\r\n    public setRepeatInformation(pRepeatOffset: number, pRepeatLength: number): void {\r\n        this.mRepeatStartOffset = pRepeatOffset;\r\n        this.mRepeatLength = pRepeatLength;\r\n    }\r\n}", "import { Exception } from '@kartoffelgames/core';\r\nimport { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { Sample } from './sample.ts';\r\n\r\n@StatefullSerializeable('930859f4-3833-4989-88d4-9b7a8f2d0bf7')\r\nexport class SampleList {\r\n    private readonly mSampleList: Array<Sample>;\r\n\r\n    /**\r\n     * Get sample count.\r\n     */\r\n    public get sampleCount(): number {\r\n        return this.mSampleList.length;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mSampleList = new Array<Sample>();\r\n    }\r\n\r\n    /**\r\n     * Add sample to list.\r\n     * @param pIndex - Index of sample.\r\n     * @param pSample - New sample.\r\n     */\r\n    public addSample(pIndex?: number): Sample {\r\n        const lNewSample: Sample = new Sample();\r\n\r\n        // Add new when no index is specified.\r\n        if (typeof pIndex === 'undefined' || pIndex === this.mSampleList.length) {\r\n            this.mSampleList.push(lNewSample);\r\n        } else {\r\n            // Check if index would produce gaps.\r\n            if (pIndex > this.mSampleList.length) {\r\n                throw new Exception(`Sample index would produce gaps with missing samples.`, this);\r\n            }\r\n\r\n            // Set sample to index.\r\n            this.mSampleList[pIndex] = lNewSample;\r\n        }\r\n\r\n        return lNewSample;\r\n    }\r\n\r\n    /**\r\n     * Get sample by index.\r\n     * @param pIndex - Index of sample.\r\n     */\r\n    public getSample(pIndex: number): Sample {\r\n        // Read sample.\r\n        return this.mSampleList[pIndex] ?? new Sample();\r\n    }\r\n\r\n    /**\r\n     * Remove sample by index.\r\n     * @param pIndex - Index of sample.\r\n     */\r\n    public removeSample(pIndex: number): void {\r\n        // Exit if index is out of bound.\r\n        if (pIndex >= (this.mSampleList.length - 1)) {\r\n            return;\r\n        }\r\n\r\n        // Remove last element if index is last element.\r\n        if (pIndex === (this.mSampleList.length - 1)) {\r\n            this.mSampleList.pop();\r\n        } else {\r\n            // Replace with empty sample if any gap would be produced.\r\n            this.mSampleList[pIndex] = new Sample();\r\n        }\r\n    }\r\n}", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { PatternList } from './pattern/pattern-list.ts';\r\nimport { SampleList } from './sample/sample-list.ts';\r\n\r\n@StatefullSerializeable('5fab5714-ec6e-4057-82df-1749054035c6')\r\nexport class GenericModule {\r\n    private readonly mPattern: PatternList;\r\n    private readonly mSamples: SampleList;\r\n    private mSongName: string;\r\n\r\n    /**\r\n     * Get module pattern list.\r\n     */\r\n    public get pattern(): PatternList {\r\n        return this.mPattern;\r\n    }\r\n\r\n    /**\r\n     * Get samples.\r\n     */\r\n    public get samples(): SampleList {\r\n        return this.mSamples;\r\n    }\r\n\r\n    /**\r\n     * Get module song name.\r\n     */\r\n    public get songName(): string {\r\n        return this.mSongName;\r\n    }\r\n\r\n    /**\r\n     * set module song name.\r\n     */\r\n    public set songName(pName: string) {\r\n        this.mSongName = pName;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * Initialize\r\n     */\r\n    public constructor() {\r\n        this.mSongName = '';\r\n        this.mPattern = new PatternList();\r\n        this.mSamples = new SampleList();\r\n    }\r\n}", "import { Dictionary } from '@kartoffelgames/core';\r\nimport { IGenericEffect } from '../effect/effect_definition/i-generic-effect.ts';\r\n\r\nexport class EffectParseHistory {\r\n    private readonly mLastEffectType: Dictionary<EffectConstructor<any>, IGenericEffect>;\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mLastEffectType = new Dictionary<EffectConstructor<any>, IGenericEffect>();\r\n    }\r\n\r\n    /**\r\n     * Add effect to history.\r\n     * @param pEffect - Effect.\r\n     */\r\n    public add(pEffect: IGenericEffect): void {\r\n        // Get effect constructor and override last effect of this type.\r\n        const lConstructor: EffectConstructor<any> = <any>pEffect.constructor;\r\n        this.mLastEffectType.set(lConstructor, pEffect);\r\n    }\r\n\r\n    /**\r\n     * Get last parsed effect of set type.\r\n     * @param pEffectConstructor - Effect type.\r\n     */\r\n    public last<K extends IGenericEffect>(pEffectConstructor: EffectConstructor<K>): K | undefined {\r\n        return <K | undefined>this.mLastEffectType.get(pEffectConstructor);\r\n    }\r\n}\r\n\r\ntype EffectConstructor<T extends IGenericEffect> = new () => T;\r\n", "import { IGenericEffect } from '../effect/effect_definition/i-generic-effect.ts';\r\nimport { GenericModule } from '../generic_module/generic-module.ts';\r\nimport { Division } from '../generic_module/pattern/division.ts';\r\nimport { DivisionChannel } from '../generic_module/pattern/division-channel.ts';\r\nimport { Pattern } from '../generic_module/pattern/pattern.ts';\r\nimport { Sample } from '../generic_module/sample/sample.ts';\r\nimport { EffectParser, ChannelValue } from './effect-parser.ts';\r\nimport { ByteUtil, Dictionary } from '@kartoffelgames/core';\r\nimport { EffectParseHistory } from './effect-parse-history.ts';\r\n\r\nexport abstract class BaseModuleParser {\r\n    private readonly mData: Uint8Array;\r\n    private readonly mEffectParser: EffectParser;\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pData - Byte data of module.\r\n     */\r\n    public constructor(pData: Uint8Array, pEffectParser: EffectParser) {\r\n        this.mData = pData;\r\n        this.mEffectParser = pEffectParser;\r\n    }\r\n\r\n    /**\r\n     * Parse data to a generic module.\r\n     */\r\n    public parse(): GenericModule {\r\n        const lModule: GenericModule = new GenericModule();\r\n        const lParseOptions: ModuleParseOptions = this.calculateModuleParseOptions(this.mData);\r\n\r\n        // Parse module name.\r\n        const lNameBuffer = ByteUtil.readBytes(this.mData, lParseOptions.name.byteOffset, lParseOptions.name.bytes);\r\n        lModule.songName = ByteUtil.byteToString(lNameBuffer, lParseOptions.name.emptyValue);\r\n\r\n        // Read and convert song position.\r\n        const lPatternOrderList: Array<number> = new Array<number>();\r\n        let lSongOrderPosition: number = lParseOptions.songPositions.byteOffset;\r\n        for (let lPatternOrderIndex: number = 0; lPatternOrderIndex < lParseOptions.songPositions.count; lPatternOrderIndex++) {\r\n            const lPatternIndexBuffer: Uint8Array = ByteUtil.readBytes(this.mData, lSongOrderPosition, lParseOptions.songPositions.valueByteSize);\r\n\r\n            // Convert pattern index buffer to number.\r\n            lPatternOrderList.push(Number(ByteUtil.concatBytes(lPatternIndexBuffer)));\r\n\r\n            lSongOrderPosition += lParseOptions.songPositions.valueByteSize;\r\n        }\r\n        lModule.pattern.songPositions = lPatternOrderList;\r\n\r\n        // Get pattern count from highest song position pattern index.\r\n        const lPatternCount: number = Math.max(...lPatternOrderList) + 1;\r\n\r\n        // Pattern starting position.\r\n        let lPatternPosition: number = lParseOptions.pattern.byteOffset;\r\n\r\n        // Create effect parse history to channel index mapping.\r\n        const lEffectParseHistorys: Dictionary<number, EffectParseHistory> = new Dictionary<number, EffectParseHistory>();\r\n\r\n        // Parse pattern.\r\n        for (let lPatternIndex: number = 0; lPatternIndex < lPatternCount; lPatternIndex++) {\r\n            const lPattern: Pattern = lModule.pattern.addPattern(lPatternIndex);\r\n            // Parse division.\r\n            for (let lDivisionIndex: number = 0; lDivisionIndex < lParseOptions.pattern.division.count; lDivisionIndex++) {\r\n                const lDivision: Division = lPattern.addDivision(lDivisionIndex);\r\n                // Parse division channel.\r\n                for (let lChannelIndex: number = 0; lChannelIndex < lParseOptions.pattern.channel.count; lChannelIndex++) {\r\n                    const lDivisionChannel: DivisionChannel = lDivision.addChannel(lChannelIndex);\r\n\r\n                    // For MOD files:\r\n                    // Get 32bit and concat all bits into one number: wwww xxxxxxxxxxxx yyyy zzzzzzzzzzzz = Length 32bit. \r\n                    const lDevisionBuffer: Uint8Array = ByteUtil.readBytes(this.mData, lPatternPosition, lParseOptions.pattern.channel.bytes);\r\n                    const lChannelValueList: Array<ChannelValue> = this.parseChannel(lDevisionBuffer);\r\n\r\n                    // Setup effect parse history for this channel.\r\n                    let lEffectParseHistory: EffectParseHistory | undefined = lEffectParseHistorys.get(lChannelIndex);\r\n                    if (!lEffectParseHistory) {\r\n                        lEffectParseHistory = new EffectParseHistory();\r\n                        lEffectParseHistorys.set(lChannelIndex, lEffectParseHistory);\r\n                    }\r\n\r\n                    // Convert received channel data to effects.\r\n                    for (const lChannelValue of lChannelValueList) {\r\n                        const lEffectList: Array<IGenericEffect> = this.mEffectParser.parseChannel(lChannelIndex, lChannelValue, lEffectParseHistory);\r\n\r\n                        // Add all effects to new division channel and history.\r\n                        for (const lEffect of lEffectList) {\r\n                            lDivisionChannel.setEffect(lEffect);\r\n                            lEffectParseHistory.add(lEffect);\r\n                        }\r\n                    }\r\n\r\n                    lPatternPosition += lParseOptions.pattern.channel.bytes;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Sample head starting position.\r\n        let lSampleHeadPosition: number = lParseOptions.sample.head.offset;\r\n        let lSampleBodyPosition: number = lParseOptions.sample.body.byteOffset;\r\n\r\n        const lSampleDataByteSize: number = lParseOptions.sample.body.valueByteSize;\r\n\r\n        // Parse sample header.\r\n        for (let lSampleIndex: number = 0; lSampleIndex < lParseOptions.sample.count; lSampleIndex++) {\r\n            const lSample: Sample = lModule.samples.addSample(lSampleIndex);\r\n\r\n            // Get sample data and parse.\r\n            const lSampleHeadBuffer: Uint8Array = ByteUtil.readBytes(this.mData, lSampleHeadPosition, lParseOptions.sample.head.bytes);\r\n            const lSampleHead: SampleHead = this.parseSampleHead(lSampleHeadBuffer);\r\n\r\n            // Fill sample data.\r\n            lSample.name = lSampleHead.name;\r\n            lSample.fineTune = lSampleHead.fineTune;\r\n            lSample.volume = lSampleHead.volume;\r\n            lSample.setRepeatInformation(lSampleHead.repeatOffset * lSampleDataByteSize, lSampleHead.repeatLength * lSampleDataByteSize);\r\n\r\n            // Calculate data length and offset.\r\n            const lDataLength: number = lSampleHead.bodyLength * lSampleDataByteSize - lParseOptions.sample.body.dataStartByteOffset;\r\n            const lDataOffset: number = lSampleBodyPosition + lParseOptions.sample.body.dataStartByteOffset;\r\n\r\n            // Retrieve and parse sample body.\r\n            const lSampleBodyBuffer: Uint8Array = ByteUtil.readBytes(this.mData, lDataOffset, lDataLength);\r\n            lSample.data = this.parseSampleBody(lSampleBodyBuffer);\r\n\r\n            // Move position cursor.\r\n            lSampleHeadPosition += lParseOptions.sample.head.bytes;\r\n            lSampleBodyPosition += lSampleHead.bodyLength * lSampleDataByteSize;\r\n        }\r\n\r\n        return lModule;\r\n    }\r\n\r\n    /**\r\n     * Caluculate parse options based on raw module data.\r\n     * @param pData - Module byte data.\r\n     */\r\n    protected abstract calculateModuleParseOptions(pData: Uint8Array): ModuleParseOptions;\r\n\r\n    /**\r\n     * Parse channel as effect list only.\r\n     * Result effect are looked up as byte pattern of effect parser.\r\n     * \r\n     * Example: 1001 0000 0101 => \r\n     * Effect | Param1 | Param2\r\n     * 1001   | 0000   | 0101\r\n     * So the effect pattern would be.\r\n     * \"1001xxxxyyyy\"\r\n     * \r\n     * @param pChannelData - Bytes only of channel.\r\n     */\r\n    protected abstract parseChannel(pChannelData: Uint8Array): Array<ChannelValue>;\r\n\r\n    /**\r\n     * Parse sample head data.\r\n     * Sample name doesn't get trimmed.\r\n     * @param pSampleHeadData - Bytes only of sample head.\r\n     */\r\n    protected abstract parseSampleHead(pSampleHeadData: Uint8Array): SampleHead;\r\n\r\n    /**\r\n     * Parse sample body data.\r\n     * Data should range between 0 and 1.\r\n     * @param pSampleBodyData - Bytes only of sample body.\r\n     */\r\n    protected abstract parseSampleBody(pSampleBodyData: Uint8Array): Float32Array;\r\n}\r\n\r\nexport type ModuleParseOptions = {\r\n    name: ModuleNameParseOptions;\r\n    pattern: ModulePatternParseOptions;\r\n    sample: ModuleSampleParseOptions;\r\n    songPositions: ModuleSongOrderParseOption;\r\n};\r\n\r\nexport type ModuleNameParseOptions = {\r\n    byteOffset: number;\r\n    bytes: number;\r\n    emptyValue: number;\r\n};\r\n\r\nexport type ModulePatternParseOptions = {\r\n    byteOffset: number;\r\n    division: {\r\n        count: number;\r\n    };\r\n    channel: {\r\n        count: number;\r\n        bytes: number;\r\n    };\r\n};\r\n\r\nexport type ModuleSongOrderParseOption = {\r\n    byteOffset: number;\r\n    count: number,\r\n    valueByteSize: number;\r\n};\r\n\r\nexport type ModuleSampleParseOptions = {\r\n    count: number;\r\n    head: {\r\n        offset: number;\r\n        bytes: number;\r\n    };\r\n    body: {\r\n        byteOffset: number;\r\n        valueByteSize: number;\r\n        dataStartByteOffset: number;\r\n    };\r\n};\r\n\r\nexport type SampleHead = {\r\n    name: string;\r\n    volume: number;\r\n    fineTune: number;\r\n    repeatOffset: number;\r\n    repeatLength: number;\r\n    bodyLength: number;\r\n};\r\n", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { IGenericEffect } from '../i-generic-effect.ts';\r\n\r\n/**\r\n * Sample finetune effect.\r\n */\r\n@StatefullSerializeable('a0572a01-adc4-479b-b874-7969d26ef0c8')\r\nexport class SetFinetuneEffect implements IGenericEffect {\r\n    private mFinetune: number;\r\n\r\n    /**\r\n     * Get finetune.\r\n     */\r\n    public get finetune(): number {\r\n        return this.mFinetune;\r\n    }\r\n\r\n    /**\r\n     * Set finetune.\r\n     */\r\n    public set finetune(pFinetune: number) {\r\n        this.mFinetune = pFinetune;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mFinetune = 0;\r\n    }\r\n}", "export enum Pitch {\r\n    Empty = 0,\r\n\r\n    // Octave 0\r\n    Octave0C = 1712,\r\n    Octave0Csharp = 1616,\r\n    Octave0D = 1525,\r\n    Octave0Dsharp = 1440,\r\n    Octave0E = 1357,\r\n    Octave0F = 1281,\r\n    Octave0Fsharp = 1209,\r\n    Octave0G = 1141,\r\n    Octave0Gsharp = 1077,\r\n    Octave0A = 1017,\r\n    Octave0Asharp = 961,\r\n    Octave0B = 907,\r\n\r\n    // Octave 1\r\n    Octave1C = 856,\r\n    Octave1Csharp = 808,\r\n    Octave1D = 762,\r\n    Octave1Dsharp = 720,\r\n    Octave1E = 678,\r\n    Octave1F = 640,\r\n    Octave1Fsharp = 604,\r\n    Octave1G = 570,\r\n    Octave1Gsharp = 538,\r\n    Octave1A = 508,\r\n    Octave1Asharp = 480,\r\n    Octave1B = 453,\r\n\r\n    // Octave 2\r\n    Octave2C = 428,\r\n    Octave2Csharp = 404,\r\n    Octave2D = 381,\r\n    Octave2Dsharp = 360,\r\n    Octave2E = 339,\r\n    Octave2F = 320,\r\n    Octave2Fsharp = 302,\r\n    Octave2G = 285,\r\n    Octave2Gsharp = 269,\r\n    Octave2A = 254,\r\n    Octave2Asharp = 240,\r\n    Octave2B = 226,\r\n\r\n    // Octave 3\r\n    Octave3C = 214,\r\n    Octave3Csharp = 202,\r\n    Octave3D = 190,\r\n    Octave3Dsharp = 180,\r\n    Octave3E = 170,\r\n    Octave3F = 160,\r\n    Octave3Fsharp = 151,\r\n    Octave3G = 143,\r\n    Octave3Gsharp = 135,\r\n    Octave3A = 127,\r\n    Octave3Asharp = 120,\r\n    Octave3B = 113,\r\n\r\n    // Octave 4\r\n    Octave4C = 107,\r\n    Octave4Csharp = 101,\r\n    Octave4D = 95,\r\n    Octave4Dsharp = 90,\r\n    Octave4E = 85,\r\n    Octave4F = 80,\r\n    Octave4Fsharp = 76,\r\n    Octave4G = 71,\r\n    Octave4Gsharp = 67,\r\n    Octave4A = 64,\r\n    Octave4Asharp = 60,\r\n    Octave4B = 57\r\n}", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { Pitch } from '../../../enum/pitch.enum.ts';\r\nimport { IGenericEffect } from '../i-generic-effect.ts';\r\n\r\n/**\r\n * Sample finetune effect.\r\n */\r\n@StatefullSerializeable('ad509656-422c-464e-9fd0-b26e417d7219')\r\nexport class SetPitchEffect implements IGenericEffect {\r\n    private mPitch: Pitch;\r\n\r\n    /**\r\n     * Get pitch.\r\n     */\r\n    public get pitch(): Pitch {\r\n        return this.mPitch;\r\n    }\r\n\r\n    /**\r\n     * Set pitch.\r\n     */\r\n    public set pitch(pFinetune: Pitch) {\r\n        this.mPitch = pFinetune;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mPitch = Pitch.Octave2C;\r\n    }\r\n}", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { IGenericEffect } from '../i-generic-effect.ts';\r\n\r\n/**\r\n * Sample cut effect.\r\n */\r\n@StatefullSerializeable('413db579-c8e3-405c-981c-3a791ac45259')\r\nexport class CutSampleEffect implements IGenericEffect {\r\n    private mTicks: number;\r\n\r\n    /**\r\n     * Get ticks after the sample is cut.\r\n     */\r\n    public get ticks(): number {\r\n        return this.mTicks;\r\n    }\r\n\r\n    /**\r\n     * Set ticks after the sample is cut.\r\n     */\r\n    public set ticks(pOffset: number) {\r\n        this.mTicks = pOffset;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mTicks = 0;\r\n    }\r\n}", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { IGenericEffect } from '../i-generic-effect.ts';\r\n\r\n/**\r\n * Sample delay effect.\r\n */\r\n@StatefullSerializeable('bff7a452-d645-4264-a132-d996bb37f5c1')\r\nexport class DelaySampleEffect implements IGenericEffect {\r\n    private mTicks: number;\r\n\r\n    /**\r\n     * Get ticks after the sample is played.\r\n     */\r\n    public get ticks(): number {\r\n        return this.mTicks;\r\n    }\r\n\r\n    /**\r\n     * Set ticks after the sample is played.\r\n     */\r\n    public set ticks(pOffset: number) {\r\n        this.mTicks = pOffset;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mTicks = 0;\r\n    }\r\n}", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { IGenericEffect } from '../i-generic-effect.ts';\r\n\r\n/**\r\n * Sample loop invert effect.\r\n */\r\n@StatefullSerializeable('111c5fcf-ae55-4f1d-8d5a-77f385129ce5')\r\nexport class InvertSampleLoopEffect implements IGenericEffect {\r\n    private mInvert: boolean;\r\n\r\n    /**\r\n     * Get if loop should be inverted.\r\n     */\r\n    public get invert(): boolean {\r\n        return this.mInvert;\r\n    }\r\n\r\n    /**\r\n     * Set if loop should be inverted.\r\n     */\r\n    public set invert(pOffset: boolean) {\r\n        this.mInvert = pOffset;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mInvert = false;\r\n    }\r\n}", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { IGenericEffect } from '../i-generic-effect.ts';\r\n\r\n/**\r\n * Sample retrigger effect.\r\n */\r\n@StatefullSerializeable('4b8bbb2f-d1ed-490c-ac37-0aae07a66b99')\r\nexport class RetriggerSampleEffect implements IGenericEffect {\r\n    private mRetriggerTickInterval: number;\r\n\r\n    /**\r\n     * Get tick interval.\r\n     */\r\n    public get tickInterval(): number {\r\n        return this.mRetriggerTickInterval;\r\n    }\r\n\r\n    /**\r\n     * Set tick interval.\r\n     */\r\n    public set tickInterval(pInterval: number) {\r\n        this.mRetriggerTickInterval = pInterval;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mRetriggerTickInterval = 0;\r\n    }\r\n}", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { IGenericEffect } from '../i-generic-effect.ts';\r\n\r\n/**\r\n * Sample offset effect.\r\n */\r\n@StatefullSerializeable('5f87532e-eb80-4e0b-8563-b5530f4d8f0c')\r\nexport class SampleOffsetEffect implements IGenericEffect {\r\n    private mOffset: number;\r\n\r\n    /**\r\n     * Get sample offset.\r\n     */\r\n    public get offset(): number {\r\n        return this.mOffset;\r\n    }\r\n\r\n    /**\r\n     * Set sample offset.\r\n     */\r\n    public set offset(pOffset: number) {\r\n        this.mOffset = pOffset;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mOffset = 0;\r\n    }\r\n}", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { IGenericEffect } from '../i-generic-effect.ts';\r\n\r\n/**\r\n * Set panning effect.\r\n */\r\n@StatefullSerializeable('a82c0549-79ef-4059-b0bc-f969fda0d012')\r\nexport class SetPanningEffect implements IGenericEffect {\r\n    private mPanning: number;\r\n\r\n    /**\r\n     * Get sample offset.\r\n     */\r\n    public get panning(): number {\r\n        return this.mPanning;\r\n    }\r\n\r\n    /**\r\n     * Set sample offset.\r\n     */\r\n    public set panning(pOffset: number) {\r\n        this.mPanning = pOffset;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mPanning = 0;\r\n    }\r\n}", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { IGenericEffect } from '../i-generic-effect.ts';\r\n\r\n/**\r\n * Sample set effect.\r\n */\r\n@StatefullSerializeable('4d89d145-7a92-4639-bebf-cfaa916e77ff')\r\nexport class SetSampleEffect implements IGenericEffect {\r\n    private mSampleIndex: number;\r\n\r\n    /**\r\n     * Get sample index.\r\n     */\r\n    public get sampleIndex(): number {\r\n        return this.mSampleIndex;\r\n    }\r\n\r\n    /**\r\n     * Set sample index.\r\n     */\r\n    public set sampleIndex(pOffset: number) {\r\n        this.mSampleIndex = pOffset;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mSampleIndex = 0;\r\n    }\r\n}", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { IGenericEffect } from '../i-generic-effect.ts';\r\n\r\n/**\r\n * Set beats per minute effect.\r\n */\r\n@StatefullSerializeable('371d3e18-350a-4737-8fb2-f6dee52e031c')\r\nexport class SetBeatsPerMinuteEffect implements IGenericEffect {\r\n    private mBeatsPerMinute: number;\r\n\r\n    /**\r\n     * Get beats per minute.\r\n     */\r\n    public get beatsPerMinute(): number {\r\n        return this.mBeatsPerMinute;\r\n    }\r\n\r\n    /**\r\n     * Set beats per minute.\r\n     */\r\n    public set beatsPerMinute(pVolume: number) {\r\n        this.mBeatsPerMinute = pVolume;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mBeatsPerMinute = 0;\r\n    }\r\n}", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { IGenericEffect } from '../i-generic-effect.ts';\r\n\r\n/**\r\n * Set speed effect.\r\n */\r\n@StatefullSerializeable('1641d552-51fc-4f24-8e01-52a29de9271c')\r\nexport class SetSpeedEffect implements IGenericEffect {\r\n    private mSpeed: number;\r\n\r\n    /**\r\n     * Get speed.\r\n     */\r\n    public get speed(): number {\r\n        return this.mSpeed;\r\n    }\r\n\r\n    /**\r\n     * Set speed.\r\n     */\r\n    public set speed(pVolume: number) {\r\n        this.mSpeed = pVolume;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mSpeed = 0;\r\n    }\r\n}", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { IGenericEffect } from '../i-generic-effect.ts';\r\n\r\n/**\r\n * Sample volume slide effect.\r\n */\r\n@StatefullSerializeable('cc8156b4-f9ff-4eba-94fb-2640f525bac2')\r\nexport class SetVolumeEffect implements IGenericEffect {\r\n    private mVolume: number;\r\n\r\n    /**\r\n     * Get volume.\r\n     */\r\n    public get volume(): number {\r\n        return this.mVolume;\r\n    }\r\n\r\n    /**\r\n     * Set volume.\r\n     */\r\n    public set volume(pVolume: number) {\r\n        this.mVolume = pVolume;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mVolume = 1;\r\n    }\r\n}", "export enum Direction {\r\n    Up = 1,\r\n    Down = 2\r\n}", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { Direction } from '../../../enum/direction.enum.ts';\r\nimport { IGenericEffect } from '../i-generic-effect.ts';\r\n\r\n/**\r\n * Sample volume slide effect.\r\n */\r\n@StatefullSerializeable('9c97f93e-a223-4f7b-a036-a2cd01c4ff0a')\r\nexport class VolumeSlideEffect implements IGenericEffect {\r\n    private mDirection: Direction;\r\n    private mVolumeChangePerTick: number;\r\n\r\n    /**\r\n     * Get volume change direction.\r\n     */\r\n    public get direction(): Direction {\r\n        return this.mDirection;\r\n    }\r\n\r\n    /**\r\n     * Set volume change direction.\r\n     */\r\n    public set direction(pDirection: Direction) {\r\n        this.mDirection = pDirection;\r\n    }\r\n\r\n    /**\r\n     * Get volume change per tick.\r\n     */\r\n    public get volumeChangePerTick(): number {\r\n        return this.mVolumeChangePerTick;\r\n    }\r\n\r\n    /**\r\n     * Set volume change per tick.\r\n     */\r\n    public set volumeChangePerTick(pVolumeChangePerTick: number) {\r\n        this.mVolumeChangePerTick = pVolumeChangePerTick;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mVolumeChangePerTick = 0;\r\n        this.mDirection = Direction.Down;\r\n    }\r\n}", "import { EffectParseHistory } from './effect-parse-history.ts';\r\n\r\nexport class EffectParseEvent {\r\n    private mIgnorePitch: boolean;\r\n    private mIgnoreSample: boolean;\r\n    private readonly mHistory: EffectParseHistory;\r\n    private readonly mData: EffectProcessEventData;\r\n\r\n    /**\r\n     * Get parse history of current channel. \r\n     */\r\n    public get history(): EffectParseHistory {\r\n        return this.mHistory;\r\n    }\r\n\r\n    /**\r\n     * Ignore pitch processing.\r\n     */\r\n    public get ignorePitch(): boolean {\r\n        return this.mIgnorePitch;\r\n    }\r\n\r\n    /**\r\n     * Ignore sample processing.\r\n     */\r\n    public get ignoreSample(): boolean {\r\n        return this.mIgnoreSample;\r\n    }\r\n\r\n    /**\r\n     * Get effect processing data.\r\n     */\r\n    public get data(): EffectProcessEventData {\r\n        return this.mData;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pChannelIndex - Channel index.\r\n     * @param pHistory - Effect parse history for current channel.\r\n     * @param pParameterX - Effect parameter one.\r\n     * @param pParameterY - Effect parameter two.\r\n     * @param pPitch - Channels pitch.\r\n     * @param pSample - Channels sample.\r\n     */\r\n    public constructor(pChannelIndex: number, pHistory: EffectParseHistory, pParameterX: number, pParameterY: number, pPitch: number, pSample: number) {\r\n        // Default.\r\n        this.mIgnorePitch = false;\r\n        this.mIgnoreSample = false;\r\n        this.mHistory = pHistory;\r\n\r\n        // Create data object.\r\n        this.mData = {\r\n            channelIndex: pChannelIndex,\r\n            parameter: {\r\n                first: pParameterX,\r\n                second: pParameterY\r\n            },\r\n            pitch: pPitch,\r\n            sample: pSample\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Prevent pitch processing.\r\n     */\r\n    public preventPitch(): void {\r\n        this.mIgnorePitch = true;\r\n    }\r\n\r\n    /**\r\n     * Prevent sample processing.\r\n     */\r\n    public preventSample(): void {\r\n        this.mIgnoreSample = true;\r\n    }\r\n}\r\n\r\ntype EffectProcessEventData = {\r\n    channelIndex: number;\r\n    parameter: {\r\n        first: number;\r\n        second: number;\r\n    };\r\n    pitch: number;\r\n    sample: number;\r\n};", "import { Exception, List } from '@kartoffelgames/core';\r\nimport { IGenericEffect } from '../effect/effect_definition/i-generic-effect.ts';\r\nimport { EffectParseEvent } from './effect-parse-event.ts';\r\nimport { EffectParseHistory } from './effect-parse-history.ts';\r\n\r\nexport class EffectParser {\r\n    private readonly mEffectHandler: List<EffectHandlerSetting>;\r\n    private mPitchHandler: EffectHandler | null;\r\n    private mSampleHandler: EffectHandler | null;\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mEffectHandler = new List<EffectHandlerSetting>();\r\n        this.mPitchHandler = null;\r\n        this.mSampleHandler = null;\r\n    }\r\n\r\n    /**\r\n     * Add effect handler for effect bit pattern.\r\n     * \r\n     * Example: 1001 0000 0101 => \r\n     * Effect | Param1 | Param2\r\n     * 1001   | 0000   | 0101\r\n     * So the effect pattern would be.\r\n     * \"1001xxxxyyyy\"\r\n     * \r\n     * Other character as 0, 1, x and y can be used as seperators.\r\n     * \r\n     * @param pBitPattern - Bit pattern of effect.\r\n     * @param pHandler - Effect handler.\r\n     */\r\n    public addEffectHandler(pBitPattern: string, pHandler: EffectHandler) {\r\n        const lBitList: Array<string> = [...pBitPattern];\r\n\r\n        // Generate bitmask.\r\n        const lBitmaskString: string = lBitList.reduce<string>((pCurrent: string, pNext: string) => {\r\n            // Ignore other characters than 1, 0, x or y\r\n            if (pNext !== '1' && pNext !== '0' && pNext !== 'x' && pNext !== 'y') {\r\n                return pCurrent;\r\n            }\r\n\r\n            if (isNaN(<any>pNext)) {\r\n                return pCurrent + '0';\r\n            } else {\r\n                return pCurrent + '1';\r\n            }\r\n        }, '');\r\n\r\n        // Get fixed bits of pattern other bits are zero by default.\r\n        const lFixedBitString: string = lBitList.reduce<string>((pCurrent: string, pNext: string) => {\r\n            // Ignore other characters than 1, 0, x or y\r\n            if (pNext !== '1' && pNext !== '0' && pNext !== 'x' && pNext !== 'y') {\r\n                return pCurrent;\r\n            }\r\n\r\n            if (isNaN(<any>pNext)) {\r\n                return pCurrent + '0';\r\n            } else {\r\n                return pCurrent + pNext;\r\n            }\r\n        }, '');\r\n\r\n        // Create cleared pattern.\r\n        const lClearedPattern: string = lBitList.filter(pCharacter => pCharacter === '1' || pCharacter === '0' || pCharacter === 'x' || pCharacter === 'y').join('');\r\n\r\n        // Register effect handler.\r\n        this.mEffectHandler.push({\r\n            allocation: {\r\n                bitmask: parseInt(lBitmaskString, 2),\r\n                pattern: lClearedPattern,\r\n                fixedBits: parseInt(lFixedBitString, 2)\r\n            },\r\n            handler: pHandler\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add pitch handler.\r\n     * Is ignored when the {@link EffectParseEvent.ignorePitch} is set.\r\n     * @param pHandler - Handler.\r\n     */\r\n    public addPitchHandler(pHandler: EffectHandler) {\r\n        this.mPitchHandler = pHandler;\r\n    }\r\n\r\n    /**\r\n     * Add sample handler.\r\n     * Is ignored when the {@link EffectParseEvent.ignoreSample} is set.\r\n     * @param pHandler - Handler.\r\n     */\r\n    public addSampleHandler(pHandler: EffectHandler) {\r\n        this.mSampleHandler = pHandler;\r\n    }\r\n\r\n    /**\r\n     * Parse channel data with handler found with bit pattern.\r\n     * @param pChannelIndex - Index of channel.\r\n     * @param pChannel - Channel data.\r\n     * @param pHistory - Effect parse history for current channel.\r\n     */\r\n    public parseChannel(pChannelIndex: number, pChannel: ChannelValue, pHistory: EffectParseHistory): Array<IGenericEffect> {\r\n        // Try to find effect handler.\r\n        const lEffectHandler: EffectHandlerSetting | undefined = this.mEffectHandler.find(pHandler => {\r\n            // Extract effects fixed bits with patterns bitmask and compare with handlers fixed bits.\r\n            const lFixedBits: number = pChannel.effect & pHandler.allocation.bitmask;\r\n            return lFixedBits === pHandler.allocation.fixedBits;\r\n        });\r\n\r\n        // Create empty effect list and define effect process event.\r\n        let lEvent: EffectParseEvent;\r\n        const lParsedEffectList: Array<IGenericEffect> = new Array<IGenericEffect>();\r\n\r\n        // Handle no found handler.\r\n        if (!lEffectHandler) {\r\n            lEvent = new EffectParseEvent(pChannelIndex, pHistory, 0, 0, pChannel.pitch, pChannel.sample);\r\n        } else {\r\n            // Reverse data, lower bits must be first.\r\n            const lReversedEffectBitList: Array<string> = [...pChannel.effect.toString(2)].reverse();\r\n            const lReversedEffectPattern: Array<string> = [...lEffectHandler.allocation.pattern].reverse();\r\n\r\n            // Extract parameter X bits.\r\n            let lParameterXBits: string = '';\r\n            let lParameterYBits: string = '';\r\n            for (let lBitIndex: number = 0; lBitIndex < lReversedEffectPattern.length; lBitIndex++) {\r\n                const lPatternCharacter: string = lReversedEffectPattern[lBitIndex];\r\n\r\n                // Add bit in, again revered order, to correct parameter bits.\r\n                if (lPatternCharacter === 'x') {\r\n                    lParameterXBits = (lReversedEffectBitList[lBitIndex] ?? 0) + lParameterXBits;\r\n                } else if (lPatternCharacter === 'y') {\r\n                    lParameterYBits = (lReversedEffectBitList[lBitIndex] ?? 0) + lParameterYBits;\r\n                }\r\n            }\r\n\r\n            // Convert paraeter bits to number. \r\n            const lParameterX: number = parseInt(lParameterXBits, 2);\r\n            const lParameterY: number = parseInt(lParameterYBits, 2);\r\n\r\n            // Create process event.\r\n            lEvent = new EffectParseEvent(pChannelIndex, pHistory, lParameterX, lParameterY, pChannel.pitch, pChannel.sample);\r\n\r\n            // Call handler for effect, pitch and sample processing.\r\n            lParsedEffectList.push(...lEffectHandler.handler(lEvent));\r\n        }\r\n\r\n        // Call pitch handler if it is not ignored and set.\r\n        if (!lEvent.ignorePitch) {\r\n            if (!this.mPitchHandler) {\r\n                throw new Exception('No pitch handler is registered.', this);\r\n            }\r\n\r\n            lParsedEffectList.push(...this.mPitchHandler(lEvent));\r\n        }\r\n\r\n        // Call sample handler if it is not ignored and set.\r\n        if (!lEvent.ignoreSample) {\r\n            if (!this.mSampleHandler) {\r\n                throw new Exception('No sample handler is registered.', this);\r\n            }\r\n\r\n            lParsedEffectList.push(...this.mSampleHandler(lEvent));\r\n        }\r\n\r\n        return lParsedEffectList;\r\n    }\r\n}\r\n\r\nexport type ChannelValue = {\r\n    effect: number;\r\n    pitch: number;\r\n    sample: number;\r\n};\r\n\r\nexport type EffectHandler = (pEvent: EffectParseEvent) => Array<IGenericEffect>;\r\n\r\ntype EffectHandlerSetting = {\r\n    allocation: {\r\n        pattern: string;\r\n        fixedBits: number;\r\n        bitmask: number;\r\n    };\r\n    handler: EffectHandler;\r\n};\r\n", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { Pitch } from '../../../enum/pitch.enum.ts';\r\nimport { IGenericEffect } from '../i-generic-effect.ts';\r\n\r\n/**\r\n * Devision arpeggio effect.\r\n */\r\n@StatefullSerializeable('af9665cc-4859-4d3e-ad0f-6f249dcfc60a')\r\nexport class ArpeggioEffect implements IGenericEffect {\r\n    private readonly mNoteList: Array<Pitch>;\r\n\r\n    /**\r\n     * Get semitone down changes in division.\r\n     */\r\n    public get notes(): Array<Pitch> {\r\n        return this.mNoteList;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mNoteList = new Array<Pitch>();\r\n    }\r\n\r\n    /**\r\n     * Add note to arpeggio pattern.\r\n     * @param pNote - Note.\r\n     */\r\n    public addNote(pNote: Pitch): void {\r\n        this.mNoteList.push(pNote);\r\n    }\r\n}", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { Direction } from '../../../enum/direction.enum.ts';\r\nimport { Pitch } from '../../../enum/pitch.enum.ts';\r\nimport { IGenericEffect } from '../i-generic-effect.ts';\r\n\r\n/**\r\n * Devision period slide effect.\r\n */\r\n@StatefullSerializeable('c73b8272-d6db-432d-a2af-2a364cff187e')\r\nexport class PeriodSlideEffect implements IGenericEffect {\r\n    private mDirection: Direction;\r\n    private mGlissandoSensitive: boolean;\r\n    private mNoteBoundary: Pitch;\r\n    private mPeriodSlidePerTick: number;\r\n\r\n    /**\r\n     * Get volume change direction.\r\n     */\r\n    public get direction(): Direction {\r\n        return this.mDirection;\r\n    }\r\n\r\n    /**\r\n     * Set volume change direction.\r\n     */\r\n    public set direction(pDirection: Direction) {\r\n        this.mDirection = pDirection;\r\n    }\r\n\r\n    /**\r\n     * Get if slide is glissando sensitive.\r\n     */\r\n    public get glissandoSensitive(): boolean {\r\n        return this.mGlissandoSensitive;\r\n    }\r\n\r\n    /**\r\n     * Set if slide is glissando sensitive.\r\n     */\r\n    public set glissandoSensitive(pSensitive: boolean) {\r\n        this.mGlissandoSensitive = pSensitive;\r\n    }\r\n\r\n    /**\r\n     * Get Set note bound for the slide.\r\n     */\r\n    public get noteBoundary(): Pitch {\r\n        return this.mNoteBoundary;\r\n    }\r\n\r\n    /**\r\n     * Set note bound for the slide.\r\n     */\r\n    public set noteBoundary(pDirection: Pitch) {\r\n        this.mNoteBoundary = pDirection;\r\n    }\r\n\r\n    /**\r\n     * Get period slide.\r\n     */\r\n    public get periodSlidePerTick(): number {\r\n        return this.mPeriodSlidePerTick;\r\n    }\r\n\r\n    /**\r\n     * Set period slide.\r\n     */\r\n    public set periodSlidePerTick(pChangeperTick: number) {\r\n        this.mPeriodSlidePerTick = pChangeperTick;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mPeriodSlidePerTick = 0;\r\n        this.mDirection = Direction.Down;\r\n        this.mNoteBoundary = Pitch.Empty;\r\n        this.mGlissandoSensitive = false;\r\n    }\r\n}", "export enum WaveformTarget {\r\n    Vibrato = 1,\r\n    Tremolo = 2\r\n}", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { WaveformTarget } from '../../../enum/waveform-target.enum.ts';\r\nimport { IGenericEffect } from '../i-generic-effect.ts';\r\n\r\n/**\r\n * Devision waveform effect.\r\n */\r\n@StatefullSerializeable('4b6b14f0-1f2f-4a5f-8eca-17ca284e6cf2')\r\nexport class WaveformEffect implements IGenericEffect {\r\n    private mAmplitude: number;\r\n    private mCirclesPerTick: number;\r\n    private mEffectTarget: WaveformTarget;\r\n\r\n    /**\r\n     * Get amplitude.\r\n     */\r\n    public get amplitude(): number {\r\n        return this.mAmplitude;\r\n    }\r\n\r\n    /**\r\n     * Set amplitude.\r\n     */\r\n    public set amplitude(pAmplitude: number) {\r\n        this.mAmplitude = pAmplitude;\r\n    }\r\n\r\n    /**\r\n     * Get circles per tick.\r\n     */\r\n    public get circlePerTick(): number {\r\n        return this.mCirclesPerTick;\r\n    }\r\n\r\n    /**\r\n     * Set circles per tick.\r\n     */\r\n    public set circlePerTick(pCirclePerTick: number) {\r\n        this.mCirclesPerTick = pCirclePerTick;\r\n    }\r\n\r\n    /**\r\n     * Get effect target.\r\n     */\r\n    public get target(): WaveformTarget {\r\n        return this.mEffectTarget;\r\n    }\r\n\r\n    /**\r\n     * Set effect target.\r\n     */\r\n    public set target(pTarget: WaveformTarget) {\r\n        this.mEffectTarget = pTarget;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mAmplitude = 0;\r\n        this.mCirclesPerTick = 0;\r\n        this.mEffectTarget = WaveformTarget.Vibrato;\r\n    }\r\n}", "import { StatefullSerializeable } from '@kartoffelgames/core-serializer';\r\nimport { IGenericEffect } from '../i-generic-effect.ts';\r\n\r\n/**\r\n * Jump effect.\r\n */\r\n@StatefullSerializeable('7ba5c774-d66e-4f58-a23d-49a2973aa4a3')\r\nexport class PositionJumpEffect implements IGenericEffect {\r\n    private mDivisionIndex: number;\r\n    private mSongPositionIndex: number;\r\n    private mSongPositionShiftMode: boolean;\r\n\r\n    /**\r\n     * Division index.\r\n     */\r\n    public get divisionIndex(): number {\r\n        return this.mDivisionIndex;\r\n    } set divisionIndex(pIndex: number) {\r\n        this.mDivisionIndex = pIndex;\r\n    }\r\n\r\n    /**\r\n     * Song position index or shift value based on shift mode.\r\n     */\r\n    public get songPosition(): number {\r\n        return this.mSongPositionIndex;\r\n    } set songPosition(pIndex: number) {\r\n        this.mSongPositionIndex = pIndex;\r\n    }\r\n\r\n    /**\r\n     * Song position shift mode.\r\n     */\r\n    public get songPositionShiftMode(): boolean {\r\n        return this.mSongPositionShiftMode;\r\n    } set songPositionShiftMode(pIndex: boolean) {\r\n        this.mSongPositionShiftMode = pIndex;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        this.mDivisionIndex = 0;\r\n        this.mSongPositionIndex = 0;\r\n        this.mSongPositionShiftMode = false;\r\n    }\r\n}", "import { IGenericEffect } from '../../effect/effect_definition/i-generic-effect.ts';\r\nimport { SetFinetuneEffect } from '../../effect/effect_definition/pitch/set-finetune-effect.ts';\r\nimport { SetPitchEffect } from '../../effect/effect_definition/pitch/set-pitch-effect.ts';\r\nimport { CutSampleEffect } from '../../effect/effect_definition/sample/cut-sample-effect.ts';\r\nimport { DelaySampleEffect } from '../../effect/effect_definition/sample/delay-sample-effect.ts';\r\nimport { InvertSampleLoopEffect } from '../../effect/effect_definition/sample/invert-sample-loop-effect.ts';\r\nimport { RetriggerSampleEffect } from '../../effect/effect_definition/sample/retrigger-sample-effect.ts';\r\nimport { SampleOffsetEffect } from '../../effect/effect_definition/sample/sample-offset-effect.ts';\r\nimport { SetPanningEffect } from '../../effect/effect_definition/sample/set-panning-effect.ts';\r\nimport { SetSampleEffect } from '../../effect/effect_definition/sample/set-sample-effect.ts';\r\nimport { SetBeatsPerMinuteEffect } from '../../effect/effect_definition/speed/set-bpm-effect.ts';\r\nimport { SetSpeedEffect } from '../../effect/effect_definition/speed/set-speed-effect.ts';\r\nimport { SetVolumeEffect } from '../../effect/effect_definition/volume/set-volume-effect.ts';\r\nimport { VolumeSlideEffect } from '../../effect/effect_definition/volume/volume-slide-effect.ts';\r\nimport { Direction } from '../../enum/direction.enum.ts';\r\nimport { Pitch } from '../../enum/pitch.enum.ts';\r\nimport { EffectParser } from '../effect-parser.ts';\r\nimport { EffectParseEvent } from '../effect-parse-event.ts';\r\nimport { ArpeggioEffect } from '../../effect/effect_definition/pitch/arpeggio-effect.ts';\r\nimport { PeriodSlideEffect } from '../../effect/effect_definition/pitch/period-slide-effect.ts';\r\nimport { WaveformEffect } from '../../effect/effect_definition/waveform/waveform-effect.ts';\r\nimport { WaveformTarget } from '../../enum/waveform-target.enum.ts';\r\nimport { PositionJumpEffect } from '../../effect/effect_definition/jump/position-jump-effect.ts';\r\n\r\nexport class ModEffectParser extends EffectParser {\r\n    private static readonly PITCH_TABLE: { [SourcePitch: number]: number; } = {\r\n        0: Pitch.Empty,\r\n\r\n        // Octave 0\r\n        1712: Pitch.Octave0C,\r\n        1616: Pitch.Octave0Csharp,\r\n        1525: Pitch.Octave0D,\r\n        1440: Pitch.Octave0Dsharp,\r\n        1357: Pitch.Octave0E,\r\n        1281: Pitch.Octave0F,\r\n        1209: Pitch.Octave0Fsharp,\r\n        1141: Pitch.Octave0G,\r\n        1077: Pitch.Octave0Gsharp,\r\n        1017: Pitch.Octave0A,\r\n        961: Pitch.Octave0Asharp,\r\n        907: Pitch.Octave0B,\r\n\r\n        // Octave 1\r\n        856: Pitch.Octave1C,\r\n        808: Pitch.Octave1Csharp,\r\n        762: Pitch.Octave1D,\r\n        720: Pitch.Octave1Dsharp,\r\n        678: Pitch.Octave1E,\r\n        640: Pitch.Octave1F,\r\n        604: Pitch.Octave1Fsharp,\r\n        570: Pitch.Octave1G,\r\n        538: Pitch.Octave1Gsharp,\r\n        508: Pitch.Octave1A,\r\n        480: Pitch.Octave1Asharp,\r\n        453: Pitch.Octave1B,\r\n\r\n        // Octave 2\r\n        428: Pitch.Octave2C,\r\n        404: Pitch.Octave2Csharp,\r\n        381: Pitch.Octave2D,\r\n        360: Pitch.Octave2Dsharp,\r\n        339: Pitch.Octave2E,\r\n        320: Pitch.Octave2F,\r\n        302: Pitch.Octave2Fsharp,\r\n        285: Pitch.Octave2G,\r\n        269: Pitch.Octave2Gsharp,\r\n        254: Pitch.Octave2A,\r\n        240: Pitch.Octave2Asharp,\r\n        226: Pitch.Octave2B,\r\n\r\n        // Octave 3\r\n        214: Pitch.Octave3C,\r\n        202: Pitch.Octave3Csharp,\r\n        190: Pitch.Octave3D,\r\n        180: Pitch.Octave3Dsharp,\r\n        170: Pitch.Octave3E,\r\n        160: Pitch.Octave3F,\r\n        151: Pitch.Octave3Fsharp,\r\n        143: Pitch.Octave3G,\r\n        135: Pitch.Octave3Gsharp,\r\n        127: Pitch.Octave3A,\r\n        120: Pitch.Octave3Asharp,\r\n        113: Pitch.Octave3B,\r\n\r\n        // Octave 4\r\n        107: Pitch.Octave4C,\r\n        101: Pitch.Octave4Csharp,\r\n        95: Pitch.Octave4D,\r\n        90: Pitch.Octave4Dsharp,\r\n        85: Pitch.Octave4E,\r\n        80: Pitch.Octave4F,\r\n        76: Pitch.Octave4Fsharp,\r\n        71: Pitch.Octave4G,\r\n        67: Pitch.Octave4Gsharp,\r\n        64: Pitch.Octave4A,\r\n        60: Pitch.Octave4Asharp,\r\n        57: Pitch.Octave4B\r\n    };\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public constructor() {\r\n        super();\r\n\r\n        // Pitch handler.\r\n        this.addPitchHandler((pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n            const lEffectList: Array<IGenericEffect> = new Array<IGenericEffect>();\r\n            const lPitch: Pitch = ModEffectParser.PITCH_TABLE[pEvent.data.pitch];\r\n\r\n            // Only add pitch when pitch is set.\r\n            if (pEvent.data.pitch !== Pitch.Empty) {\r\n                const lPitchEffect: SetPitchEffect = new SetPitchEffect();\r\n                lPitchEffect.pitch = lPitch;\r\n                lEffectList.push(lPitchEffect);\r\n            }\r\n\r\n            return lEffectList;\r\n        });\r\n\r\n        // Sample handler.\r\n        this.addSampleHandler((pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n            const lEffectList: Array<IGenericEffect> = new Array<IGenericEffect>();\r\n\r\n            // Only add sample when sample is set.\r\n            if (pEvent.data.sample > 0) {\r\n                const lSampleEffect: SetSampleEffect = new SetSampleEffect();\r\n                lSampleEffect.sampleIndex = pEvent.data.sample - 1; // Number to index.\r\n                lEffectList.push(lSampleEffect);\r\n\r\n                // Calculate channel panning based on channel index.\r\n                // L] [R R L L] [R R... => Period length is 4. Index 0 interpreted as last index of period (3).\r\n                const lIsLeftChannel: boolean = ((pEvent.data.channelIndex + 3) % 4) > 1; // Range from 0...3\r\n\r\n                // Add panning effect base on channel index.\r\n                const lPanningEffect: SetPanningEffect = new SetPanningEffect();\r\n                lPanningEffect.panning = lIsLeftChannel ? -1 : 1;\r\n                lEffectList.push(lPanningEffect);\r\n            }\r\n\r\n            return lEffectList;\r\n        });\r\n\r\n        // 0x0 => Arpeggio Effect.\r\n        this.addEffectHandler('0000.xxxx.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n            // Exit on empty effect. Prevents unnecessary effect creation on empty effects.\r\n            if (pEvent.data.parameter.first === 0 && pEvent.data.parameter.second === 0) {\r\n                return [];\r\n            }\r\n\r\n            const lArpeggioEffect: ArpeggioEffect = new ArpeggioEffect();\r\n\r\n            // Add notes for arpeggio\r\n            lArpeggioEffect.addNote(pEvent.data.pitch);\r\n            lArpeggioEffect.addNote(pEvent.data.pitch * Math.pow(Math.pow(2, 1 / 12), pEvent.data.parameter.first));\r\n            lArpeggioEffect.addNote(pEvent.data.pitch * Math.pow(Math.pow(2, 1 / 12), pEvent.data.parameter.second));\r\n            lArpeggioEffect.addNote(pEvent.data.pitch);\r\n\r\n            return [lArpeggioEffect];\r\n        });\r\n\r\n        // 0x1 => Period Slide Up\r\n        this.addEffectHandler('0001.xxxx.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n            const lPeriodSlideEffect: PeriodSlideEffect = new PeriodSlideEffect();\r\n            lPeriodSlideEffect.direction = Direction.Up;\r\n            lPeriodSlideEffect.noteBoundary = Pitch.Octave3B;\r\n            lPeriodSlideEffect.periodSlidePerTick = pEvent.data.parameter.first * 16 + pEvent.data.parameter.second;\r\n\r\n            return [lPeriodSlideEffect];\r\n        });\r\n\r\n        // 0x2 => Period Slide Down\r\n        this.addEffectHandler('0010.xxxx.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n            const lPeriodSlideEffect: PeriodSlideEffect = new PeriodSlideEffect();\r\n            lPeriodSlideEffect.direction = Direction.Down;\r\n            lPeriodSlideEffect.noteBoundary = Pitch.Octave1C;\r\n            lPeriodSlideEffect.periodSlidePerTick = pEvent.data.parameter.first * 16 + pEvent.data.parameter.second;\r\n\r\n            return [lPeriodSlideEffect];\r\n        });\r\n\r\n        // 0x3 => Slide to note\r\n        this.addEffectHandler('0011.xxxx.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n            const lPeriodSlideEffect: PeriodSlideEffect = new PeriodSlideEffect();\r\n\r\n            // Load last slide when not parameter is applied.\r\n            if (pEvent.data.parameter.first !== 0 || pEvent.data.parameter.second !== 0) {\r\n                // Load last pitch. Use C2 when not last pitch was set.\r\n                const lLastPitch: Pitch = pEvent.history.last(SetPitchEffect)?.pitch ?? Pitch.Octave2C;\r\n\r\n                // Set pitch depending on last pitch.\r\n                lPeriodSlideEffect.direction = (lLastPitch < pEvent.data.pitch) ? Direction.Down : Direction.Up;\r\n                lPeriodSlideEffect.noteBoundary = pEvent.data.pitch;\r\n                lPeriodSlideEffect.periodSlidePerTick = pEvent.data.parameter.first * 16 + pEvent.data.parameter.second;\r\n            } else {\r\n                // Load last used period slide effect.\r\n                const lLastPeriodSlide: PeriodSlideEffect | undefined = pEvent.history.last(PeriodSlideEffect);\r\n                const lLastEffectPitchBoundary: Pitch = lLastPeriodSlide?.noteBoundary ?? Pitch.Octave2C;\r\n                const lLastEffectSlide: number = lLastPeriodSlide?.periodSlidePerTick ?? 0;\r\n\r\n                // Load last pitch. Use C2 when not last pitch was set.\r\n                const lLastPitch: Pitch = pEvent.history.last(SetPitchEffect)?.pitch ?? Pitch.Octave2C;\r\n\r\n                // Set pitch depending on last pitch.\r\n                lPeriodSlideEffect.direction = (lLastPitch < lLastEffectPitchBoundary) ? Direction.Down : Direction.Up;\r\n                lPeriodSlideEffect.noteBoundary = lLastEffectPitchBoundary;\r\n                lPeriodSlideEffect.periodSlidePerTick = lLastEffectSlide;\r\n            }\r\n\r\n            // Ignore period.\r\n            pEvent.preventPitch();\r\n\r\n            return [lPeriodSlideEffect];\r\n        });\r\n\r\n        // 0x4 => Vibrato\r\n        this.addEffectHandler('0100.xxxx.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n            // Load current pitch. Use C2 when not last pitch was set.\r\n            const lLastPitch: Pitch = pEvent.data.pitch || (pEvent.history.last(SetPitchEffect)?.pitch ?? Pitch.Octave2C);\r\n\r\n            const lVibratoEffect: WaveformEffect = new WaveformEffect();\r\n\r\n            // Load old vibrato effect when one of the parameter is zero. \r\n            if (pEvent.data.parameter.first !== 0 && pEvent.data.parameter.second !== 0) {\r\n                lVibratoEffect.target = WaveformTarget.Vibrato;\r\n                lVibratoEffect.circlePerTick = pEvent.data.parameter.first / 64;\r\n\r\n                // Amplitude y/16 Semitones.\r\n                lVibratoEffect.amplitude = lLastPitch * Math.pow(Math.pow(2, 1 / 12), pEvent.data.parameter.second / 16);\r\n            } else {\r\n                // Load last vibrato effect.\r\n                const lLastVibratoEffect: WaveformEffect | undefined = pEvent.history.last(WaveformEffect);\r\n\r\n                // Apply last effect values.\r\n                lVibratoEffect.amplitude = lLastVibratoEffect?.amplitude ?? 0;\r\n                lVibratoEffect.circlePerTick = lLastVibratoEffect?.amplitude ?? 1;\r\n                lVibratoEffect.target = WaveformTarget.Vibrato;\r\n            }\r\n\r\n            return [lVibratoEffect];\r\n        });\r\n\r\n        // 0x5 => Continue 'Slide to note', but also do Volume slide\r\n        this.addEffectHandler('0101.xxxx.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n            const lVolumeSlideEffect: VolumeSlideEffect = new VolumeSlideEffect();\r\n\r\n            // Set direction based on set parameter.\r\n            if (pEvent.data.parameter.first !== 0) {\r\n                lVolumeSlideEffect.direction == Direction.Up;\r\n                lVolumeSlideEffect.volumeChangePerTick = pEvent.data.parameter.first;\r\n            } else {\r\n                lVolumeSlideEffect.direction == Direction.Up;\r\n                lVolumeSlideEffect.volumeChangePerTick = pEvent.data.parameter.second;\r\n            }\r\n\r\n            const lPeriodSlideEffect: PeriodSlideEffect = new PeriodSlideEffect();\r\n\r\n            // Load last used period slide effect.\r\n            const lLastPeriodSlide: PeriodSlideEffect | undefined = pEvent.history.last(PeriodSlideEffect);\r\n            const lLastEffectPitchBoundary: Pitch = lLastPeriodSlide?.noteBoundary ?? Pitch.Octave2C;\r\n            const lLastEffectSlide: number = lLastPeriodSlide?.periodSlidePerTick ?? 0;\r\n\r\n            // Load last pitch. Use C2 when not last pitch was set.\r\n            const lLastPitch: Pitch = pEvent.history.last(SetPitchEffect)?.pitch ?? Pitch.Octave2C;\r\n\r\n            // Set pitch depending on last pitch.\r\n            lPeriodSlideEffect.direction = (lLastPitch < lLastEffectPitchBoundary) ? Direction.Down : Direction.Up;\r\n            lPeriodSlideEffect.noteBoundary = lLastEffectPitchBoundary;\r\n            lPeriodSlideEffect.periodSlidePerTick = lLastEffectSlide;\r\n\r\n            return [lVolumeSlideEffect, lPeriodSlideEffect];\r\n        });\r\n\r\n        // 0x6 => Continue 'Vibrato', but also do Volume slide\r\n        this.addEffectHandler('0110.xxxx.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n            const lVolumeSlideEffect: VolumeSlideEffect = new VolumeSlideEffect();\r\n\r\n            // Set direction based on set parameter.\r\n            if (pEvent.data.parameter.first !== 0) {\r\n                lVolumeSlideEffect.direction == Direction.Up;\r\n                lVolumeSlideEffect.volumeChangePerTick = pEvent.data.parameter.first;\r\n            } else {\r\n                lVolumeSlideEffect.direction == Direction.Up;\r\n                lVolumeSlideEffect.volumeChangePerTick = pEvent.data.parameter.second;\r\n            }\r\n\r\n            const lVibratoEffect: WaveformEffect = new WaveformEffect();\r\n\r\n            // Load last vibrato effect.\r\n            const lLastVibratoEffect: WaveformEffect | undefined = pEvent.history.last(WaveformEffect);\r\n\r\n            // Apply last effect values.\r\n            lVibratoEffect.amplitude = lLastVibratoEffect?.amplitude ?? 0;\r\n            lVibratoEffect.circlePerTick = lLastVibratoEffect?.amplitude ?? 1;\r\n            lVibratoEffect.target = WaveformTarget.Vibrato;\r\n\r\n            return [lVolumeSlideEffect, lVibratoEffect];\r\n        });\r\n\r\n        // 0x7 => Tremolo\r\n        this.addEffectHandler('0111.xxxx.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n            const lTremoloEffect: WaveformEffect = new WaveformEffect();\r\n\r\n            // Load old vibrato effect when one of the parameter is zero. \r\n            if (pEvent.data.parameter.first !== 0 && pEvent.data.parameter.second !== 0) {\r\n                lTremoloEffect.target = WaveformTarget.Tremolo;\r\n                lTremoloEffect.circlePerTick = pEvent.data.parameter.first / 64;\r\n\r\n                // Amplitude y/16 Semitones.\r\n                lTremoloEffect.amplitude = pEvent.data.parameter.second;\r\n            } else {\r\n                // Load last vibrato effect.\r\n                const lLastTremoloEffect: WaveformEffect | undefined = pEvent.history.last(WaveformEffect);\r\n\r\n                // Apply last effect values.\r\n                lTremoloEffect.amplitude = lLastTremoloEffect?.amplitude ?? 0;\r\n                lTremoloEffect.circlePerTick = lLastTremoloEffect?.amplitude ?? 1;\r\n                lTremoloEffect.target = WaveformTarget.Tremolo;\r\n            }\r\n\r\n            return [lTremoloEffect];\r\n        });\r\n\r\n        // 0x8 => Set panning position\r\n        this.addEffectHandler('1000.xxxx.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n            const lSetPanningEffect: SetPanningEffect = new SetPanningEffect();\r\n            // Panning ranges from 0 to 128. Convert to -1...1 range.\r\n            lSetPanningEffect.panning = ((pEvent.data.parameter.first * 16 + pEvent.data.parameter.second) - 64) / 64;\r\n\r\n            return [lSetPanningEffect];\r\n        });\r\n\r\n        // 0x9 => Set sample offset\r\n        this.addEffectHandler('1001.xxxx.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n            const lSampleOffsetEffect: SampleOffsetEffect = new SampleOffsetEffect();\r\n            lSampleOffsetEffect.offset = pEvent.data.parameter.first * 4096 + pEvent.data.parameter.second * 256;\r\n            return [lSampleOffsetEffect];\r\n        });\r\n\r\n        // 0xA => Volume slide\r\n        this.addEffectHandler('1010.xxxx.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n            // Ignore YParameter when XParameter is set. Convert 0..64 to 0..1 range. \r\n            const lVolumeSlideEffect: VolumeSlideEffect = new VolumeSlideEffect();\r\n            lVolumeSlideEffect.direction = (pEvent.data.parameter.first > 0) ? Direction.Up : Direction.Down;\r\n            lVolumeSlideEffect.volumeChangePerTick = ((pEvent.data.parameter.first > 0) ? pEvent.data.parameter.first : pEvent.data.parameter.second) / 64;\r\n            return [lVolumeSlideEffect];\r\n        });\r\n\r\n        // 0xB => Position Jump\r\n        this.addEffectHandler('1011.xxxx.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n            const lJumpEffect: PositionJumpEffect = new PositionJumpEffect();\r\n            lJumpEffect.divisionIndex = 0;\r\n            lJumpEffect.songPosition = pEvent.data.parameter.first * 16 + pEvent.data.parameter.second;\r\n\r\n            return [lJumpEffect];\r\n        });\r\n\r\n        // 0xC => Set volume\r\n        this.addEffectHandler('1100.xxxx.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n            // Ignore YParameter when XParameter is set. Convert 0..64 to 0..1 range. \r\n            const lVolumeSetEffect: SetVolumeEffect = new SetVolumeEffect();\r\n            lVolumeSetEffect.volume = (pEvent.data.parameter.first * 16 + pEvent.data.parameter.second) / 64;\r\n            return [lVolumeSetEffect];\r\n        });\r\n\r\n        // 0xD => Pattern Break\r\n        this.addEffectHandler('1101.xxxx.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n            const lJumpEffect: PositionJumpEffect = new PositionJumpEffect();\r\n            lJumpEffect.divisionIndex = pEvent.data.parameter.first * 10 + pEvent.data.parameter.second;\r\n            lJumpEffect.songPosition = 1;\r\n            lJumpEffect.songPositionShiftMode = true;\r\n\r\n            return [lJumpEffect];\r\n        });\r\n\r\n        // 0xE\r\n        {\r\n            // 0x0 => Set filter on/off. UNUSED.\r\n            //this.addEffectHandler('1110.0000.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => { /* UNUSED */ });\r\n\r\n            // 0x1\r\n            //this.addEffectHandler('1110.0001.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => { return []; /* TODO: */ });\r\n\r\n            // 0x2\r\n            //this.addEffectHandler('1110.0010.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => { return []; /* TODO: */ });\r\n\r\n            // 0x3\r\n            //this.addEffectHandler('1110.0011.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => { return []; /* TODO: */ });\r\n\r\n            // 0x4\r\n            //this.addEffectHandler('1110.0100.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => { return []; /* TODO: */ });\r\n\r\n            // 0x5\r\n            this.addEffectHandler('1110.0101.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n                const lSetFinetuneEffect: SetFinetuneEffect = new SetFinetuneEffect();\r\n                lSetFinetuneEffect.finetune = pEvent.data.parameter.second;\r\n                return [lSetFinetuneEffect];\r\n            });\r\n\r\n            // 0x6\r\n            //this.addEffectHandler('1110.0110.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => { return []; /* TODO: */ });\r\n\r\n            // 0x7\r\n            //this.addEffectHandler('1110.0111.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => { return []; /* TODO: */ });\r\n\r\n            // 0x8\r\n            //this.addEffectHandler('1110.1000.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => { return []; /* TODO: */ });\r\n\r\n            // 0x9\r\n            this.addEffectHandler('1110.1001.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n                const lEffectList: Array<IGenericEffect> = new Array<IGenericEffect>();\r\n\r\n                // Set effect only when the interval parameter is set.\r\n                if (pEvent.data.parameter.second > 0) {\r\n                    const lRetriggerSampleEffect: RetriggerSampleEffect = new RetriggerSampleEffect();\r\n                    lRetriggerSampleEffect.tickInterval = pEvent.data.parameter.second;\r\n                    lEffectList.push(lRetriggerSampleEffect);\r\n                }\r\n\r\n                return lEffectList;\r\n            });\r\n\r\n            // 0xA\r\n            //this.addEffectHandler('1110.1010.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => { return []; /* TODO: */ });\r\n\r\n            // 0xB\r\n            //this.addEffectHandler('1110.1011.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => { return []; /* TODO: */ });\r\n\r\n            // 0xC\r\n            this.addEffectHandler('1110.1100.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n                const lCutSampleEffect: CutSampleEffect = new CutSampleEffect();\r\n                lCutSampleEffect.ticks = pEvent.data.parameter.second;\r\n                return [lCutSampleEffect];\r\n            });\r\n\r\n            // 0xD\r\n            this.addEffectHandler('1110.1101.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n                const lDelaySampleEffect: DelaySampleEffect = new DelaySampleEffect();\r\n                lDelaySampleEffect.ticks = pEvent.data.parameter.second;\r\n                return [lDelaySampleEffect];\r\n            });\r\n\r\n            // 0xE\r\n            //this.addEffectHandler('1110.1110.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => { return []; /* TODO: */ });\r\n\r\n            // 0xF\r\n            this.addEffectHandler('1110.1111.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n                const lInvertLoopEffect: InvertSampleLoopEffect = new InvertSampleLoopEffect();\r\n                lInvertLoopEffect.invert = pEvent.data.parameter.second > 0;\r\n                return [lInvertLoopEffect];\r\n            });\r\n        }\r\n\r\n        // 0xF\r\n        this.addEffectHandler('1111.xxxx.yyyy', (pEvent: EffectParseEvent): Array<IGenericEffect> => {\r\n            const lEffectList: Array<IGenericEffect> = new Array<IGenericEffect>();\r\n\r\n            // Calculate speed change. Speed can not be lower than 1.\r\n            let lSpeed: number = pEvent.data.parameter.first * 16 + pEvent.data.parameter.second;\r\n            lSpeed = Math.max(lSpeed, 1);\r\n\r\n            // Different effect for different speed value.\r\n            if (lSpeed <= 32) {\r\n                const lSetSpeedEffect: SetSpeedEffect = new SetSpeedEffect();\r\n                lSetSpeedEffect.speed = lSpeed;\r\n                lEffectList.push(lSetSpeedEffect);\r\n            } else {\r\n                const lSetBeatsPerMinuteEffect: SetBeatsPerMinuteEffect = new SetBeatsPerMinuteEffect();\r\n                lSetBeatsPerMinuteEffect.beatsPerMinute = lSpeed;\r\n                lEffectList.push(lSetBeatsPerMinuteEffect);\r\n            }\r\n\r\n            return lEffectList;\r\n        });\r\n    }\r\n}", "import { ByteUtil } from '@kartoffelgames/core';\r\nimport { BaseModuleParser, ModuleParseOptions, SampleHead } from '../base-module-parser.ts';\r\nimport { ChannelValue } from '../effect-parser.ts';\r\nimport { ModEffectParser } from './mod-effect-parser.ts';\r\n\r\nexport class ModParser extends BaseModuleParser {\r\n    private static readonly NAME_BYTE_LENGTH: number = 20;\r\n    private static readonly SAMPLE_HEADER_BYTE_LENGTH: number = 30;\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param pData - File data.\r\n     */\r\n    public constructor(pData: Uint8Array) {\r\n        super(pData, new ModEffectParser());\r\n    }\r\n\r\n    /**\r\n     * Calculate parse options from raw file data.\r\n     * @param pData - Complete file data.\r\n     */\r\n    protected calculateModuleParseOptions(pData: Uint8Array): ModuleParseOptions {\r\n        const lModuleExtension: ModuleExtension = this.getExtensionName(pData);\r\n        const lChannelCount: number = this.getChannelCount(lModuleExtension);\r\n        const lSampleCount: number = lModuleExtension !== '' ? 31 : 15;\r\n        const lPatternCount: number = this.getPatternCount(pData, lSampleCount);\r\n\r\n        // Get offset to song Positions. Name + sample header + order length + \"RestartPosition\"\r\n        const lSongPositionOffset = ModParser.NAME_BYTE_LENGTH + (lSampleCount * ModParser.SAMPLE_HEADER_BYTE_LENGTH) + 1 + 1;\r\n        // Calculate song position count.\r\n        const lSongPositionCount: number = this.getSongPositionLength(pData, lSampleCount);\r\n\r\n        // Calculate starting offset of first pattern division.\r\n        let lPatternOffset: number = ModParser.NAME_BYTE_LENGTH + (ModParser.SAMPLE_HEADER_BYTE_LENGTH * lSampleCount);\r\n        lPatternOffset += 130 + ((lSampleCount === 31) ? 4 : 0);  // Pattern count, pattern order and optional module extension.\r\n\r\n        // Calculate sample body offset.\r\n        let lSampleBodyOffset: number = ModParser.NAME_BYTE_LENGTH;\r\n        lSampleBodyOffset += ModParser.SAMPLE_HEADER_BYTE_LENGTH * lSampleCount;\r\n        lSampleBodyOffset += 130 + ((lSampleCount === 31) ? 4 : 0); // Pattern count, pattern order and module extension.\r\n        lSampleBodyOffset += 64 * 4 * lChannelCount * lPatternCount; // Pattern data.   \r\n\r\n        return {\r\n            name: {\r\n                byteOffset: 0,\r\n                bytes: ModParser.NAME_BYTE_LENGTH,\r\n                emptyValue: 0\r\n            },\r\n            songPositions: {\r\n                count: lSongPositionCount,\r\n                valueByteSize: 1,\r\n                byteOffset: lSongPositionOffset\r\n            },\r\n            pattern: {\r\n                byteOffset: lPatternOffset,\r\n                division: {\r\n                    count: 64,\r\n                },\r\n                channel: {\r\n                    count: lChannelCount,\r\n                    bytes: 4\r\n                }\r\n            },\r\n            sample: {\r\n                count: lSampleCount,\r\n                head: {\r\n                    bytes: ModParser.SAMPLE_HEADER_BYTE_LENGTH,\r\n                    offset: ModParser.NAME_BYTE_LENGTH\r\n                },\r\n                body: {\r\n                    byteOffset: lSampleBodyOffset,\r\n                    valueByteSize: 2,\r\n                    dataStartByteOffset: 2\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Parse channel from raw data.\r\n     * @param pChannelData - Single channel data.\r\n     */\r\n    protected parseChannel(pChannelData: Uint8Array): Array<ChannelValue> {\r\n        // Get 32bit and concat all bits into one number: wwww xxxxxxxxxxxx yyyy zzzzzzzzzzzz = Length 32bit. \r\n        const lBufferNumber: bigint = ByteUtil.concatBytes(pChannelData);\r\n\r\n        // wwww yyyy (8 bits ) - sample number, not index.\r\n        const lSampleNumber: number = Number(ByteUtil.pickBits(lBufferNumber, 32, [0, 1, 2, 3, 16, 17, 18, 19]));\r\n\r\n        // xxxx xxxx xxxx (12 bits) - sample period\r\n        const lSamplePeriod: number = Number(ByteUtil.pickBits(lBufferNumber, 32, [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]));\r\n\r\n        // zzzz zzzz zzzz (12 bits) - sample effect\r\n        const lSampleEffect: number = Number(ByteUtil.pickBits(lBufferNumber, 32, [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]));\r\n\r\n        // Save single channel value into array. \r\n        const lChannelValueList: Array<ChannelValue> = new Array<ChannelValue>();\r\n        lChannelValueList.push({\r\n            effect: lSampleEffect,\r\n            pitch: lSamplePeriod,\r\n            sample: lSampleNumber\r\n        });\r\n\r\n        return lChannelValueList;\r\n    }\r\n\r\n    /**\r\n     * Parse sample head from raw byte data. \r\n     * @param pSampleHeadData - Sample head data.\r\n     */\r\n    protected parseSampleHead(pSampleHeadData: Uint8Array): SampleHead {\r\n        // Sample header offsets.\r\n        const lSampleNameOffset: number = 0; // String\r\n        const lSampleLengthOffset: number = 22; // Word\r\n        const lSampleFinetuneOffset: number = 24; // Signed-Lower-Nibble -8..7\r\n        const lSampleVolumeOffset: number = 25; // Byte: 0..64\r\n        const lSampleRepeatOffsetOffset: number = 26; // Word\r\n        const lSampleRepeatLengthOffset: number = 28; // Word\r\n\r\n        // Read sample name.\r\n        const lSampleNameBuffer: Uint8Array = ByteUtil.readBytes(pSampleHeadData, lSampleNameOffset, 22);\r\n        const lSampleName: string = ByteUtil.byteToString(lSampleNameBuffer);\r\n\r\n        // Read sample length and save for later use.\r\n        const lSampleLengthBuffer: Uint8Array = ByteUtil.readBytes(pSampleHeadData, lSampleLengthOffset, 2);\r\n        const lSampleLength = ByteUtil.byteToWorld(lSampleLengthBuffer[0], lSampleLengthBuffer[1]); // WorldLength\r\n\r\n        // Read sample fine tune. Lowest four bits represent a signed nibble.\r\n        const lSampleFinetuneBuffer: Uint8Array = ByteUtil.readBytes(pSampleHeadData, lSampleFinetuneOffset, 1);\r\n        const lSampleFineTune: number = ByteUtil.byteToNibble(lSampleFinetuneBuffer[0], true)[1];\r\n\r\n        // Read sample volume.\r\n        const lSampleVolumeBuffer: Uint8Array = ByteUtil.readBytes(pSampleHeadData, lSampleVolumeOffset, 1);\r\n        const lSampleVolume: number = ByteUtil.byteToByte(lSampleVolumeBuffer[0]) / 64;\r\n\r\n        // Read sample repeat offset.\r\n        const lSampleRepeatOffsetBuffer: Uint8Array = ByteUtil.readBytes(pSampleHeadData, lSampleRepeatOffsetOffset, 2);\r\n        let lSampleRepeatOffset: number = ByteUtil.byteToWorld(lSampleRepeatOffsetBuffer[0], lSampleRepeatOffsetBuffer[1]); // WorldLength\r\n        lSampleRepeatOffset -= 2; // Remove repeat information in first word. \r\n\r\n        // Read sample repeat length.\r\n        const lSampleRepeatLengthBuffer: Uint8Array = ByteUtil.readBytes(pSampleHeadData, lSampleRepeatLengthOffset, 2);\r\n        let lSampleRepeatLength: number = ByteUtil.byteToWorld(lSampleRepeatLengthBuffer[0], lSampleRepeatLengthBuffer[1]); // WorldLength\r\n        lSampleRepeatLength -= 2; // Remove repeat information in first word. \r\n\r\n        // Get sample body length with removed repeat information in first word.\r\n        const lSampleLengthWithoutRepeat: number = lSampleLength;\r\n\r\n        return {\r\n            name: lSampleName,\r\n            volume: lSampleVolume,\r\n            fineTune: lSampleFineTune,\r\n            repeatOffset: lSampleRepeatOffset,\r\n            repeatLength: lSampleRepeatLength,\r\n            bodyLength: lSampleLengthWithoutRepeat\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Parse raw sample body to [1 .. -1] Float32 range.\r\n     * @param pSampleBodyData - Sample body data.\r\n     */\r\n    protected parseSampleBody(pSampleBodyData: Uint8Array): Float32Array {\r\n        const lFloat32Buffer: Float32Array = new Float32Array(pSampleBodyData.length);\r\n        for (let lIndex: number = 0; lIndex < pSampleBodyData.length; lIndex++) {\r\n            lFloat32Buffer[lIndex] = ByteUtil.byteToByte(pSampleBodyData[lIndex], true) / 128; // Range [-1 .. 1]\r\n        }\r\n\r\n        return lFloat32Buffer;\r\n    }\r\n\r\n    /**\r\n     * Parse extension name of module.\r\n     */\r\n    private getExtensionName(pData: Uint8Array): ModuleExtension {\r\n        const lPatternInformationLength = 130;\r\n\r\n        // Get 4 character extension name. \r\n        //When the module has a extension than it has allways 31 samples.\r\n        const lOffset = ModParser.NAME_BYTE_LENGTH + (31 * ModParser.SAMPLE_HEADER_BYTE_LENGTH) + lPatternInformationLength;\r\n        const lModuleExtensionBuffer = ByteUtil.readBytes(pData, lOffset, 4);\r\n        const lModuleExtensionName: string = ByteUtil.byteToString(lModuleExtensionBuffer);\r\n\r\n        // Check for all possible extension names. Return empty if no one matches any of those.\r\n        return <ModuleExtension>((['M.K.', 'FLT4', 'FLT8', 'M!K!', '6CHN', '8CHN'].includes(lModuleExtensionName)) ? lModuleExtensionName : '');\r\n    }\r\n\r\n    /**\r\n     * Parse module name.\r\n     * @param pModuleExtension - Module extension name.\r\n     */\r\n    private getChannelCount(pModuleExtension: ModuleExtension): number {\r\n        switch (pModuleExtension) {\r\n            case 'FLT8':\r\n            case '8CHN':\r\n                return 8;\r\n            case '6CHN':\r\n                return 6;\r\n            default:\r\n                return 4;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parse module pattern count.\r\n     * @param pData - Complete data.\r\n     * @param pSampleCount - Sample count.\r\n     */\r\n    private getPatternCount(pData: Uint8Array, pSampleCount: number): number {\r\n        // Get offset to pattern oder. Name + sample header + order length + \"RestartPosition\"\r\n        const lOffset = ModParser.NAME_BYTE_LENGTH + (pSampleCount * ModParser.SAMPLE_HEADER_BYTE_LENGTH) + 1 + 1;\r\n\r\n        // Get sample play order and find max value.\r\n        const lModuleSongPositionBuffer = ByteUtil.readBytes(pData, lOffset, 128);\r\n        const lHighestPatternIndex: number = Math.max(...lModuleSongPositionBuffer);\r\n\r\n        // Index to count.\r\n        return lHighestPatternIndex + 1;\r\n    }\r\n\r\n    /**\r\n     * Parse length of song list.\r\n     * @param pData - Complete data.\r\n     * @param pSampleCount - Sample count.\r\n     */\r\n    private getSongPositionLength(pData: Uint8Array, pSampleCount: number): number {\r\n        // Get pattern order length.\r\n        const lSampleOrderLengthOffset = ModParser.NAME_BYTE_LENGTH + (pSampleCount * ModParser.SAMPLE_HEADER_BYTE_LENGTH);\r\n        const lSampleOrderLengthBuffer = ByteUtil.readBytes(pData, lSampleOrderLengthOffset, 1);\r\n        return lSampleOrderLengthBuffer[0];\r\n    }\r\n}\r\n\r\ntype ModuleExtension = 'M.K.' | 'FLT4' | 'FLT8' | 'M!K!' | '6CHN' | '8CHN' | '';", "import { StatefullSerializer } from \"../../../kartoffelgames.core.serializer/source/index.ts\";\r\nimport { GenericModule } from \"../../source/generic_module/generic-module.ts\";\r\nimport { ModParser } from \"../../source/module_parser/mod_parser/mod-parser.ts\";\r\n\r\n(async () => {\r\n    // Load file as binary.\r\n    const lBinaryModFile: Uint8Array = await (async () => {\r\n        const lResponse = await fetch('/sample.mod');\r\n        const lBinaryBuffer = await lResponse.arrayBuffer();\r\n        return new Uint8Array(lBinaryBuffer);\r\n    })();\r\n\r\n    // Parse mod file.\r\n    const lModFile: GenericModule = new ModParser(lBinaryModFile).parse();\r\n\r\n    // Create a audio context and load the audio processors.\r\n    const lAudioContext = new AudioContext();\r\n    await lAudioContext.audioWorklet.addModule('/bundle/Kartoffelgames.Worker.Track_Player.jsworker');\r\n\r\n    // Create oscilatorNode for controlling play and pause.\r\n    const lOscilatorNode = lAudioContext.createOscillator();\r\n\r\n    // Create a track player audio node and load the mod file into it.\r\n    const lTrackplayerAudioNode = new AudioWorkletNode(lAudioContext, 'Trackplayer');\r\n    lTrackplayerAudioNode.port.postMessage({\r\n        type: 'load',\r\n        data: new StatefullSerializer().serialize(lModFile)\r\n    });\r\n\r\n    lOscilatorNode.connect(lTrackplayerAudioNode).connect(lAudioContext.destination);\r\n\r\n    document.addEventListener('click', () => {\r\n        // Play the mod file when the user clicks on the page.\r\n        lOscilatorNode.start();\r\n    });\r\n})();", "(() => {\n    const socket = new WebSocket('ws://127.0.0.1:8088');\n    socket.addEventListener('open', () => {\n        console.log('Refresh connection established');\n    });\n    socket.addEventListener('message', (event) => {\n        console.log('Bundle finished. Start refresh');\n        if (event.data === 'REFRESH') {\n            window.location.reload();\n        }\n    });\n})();\nimport('./index.ts');\n"],
  "mappings": "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",
  "names": ["List", "init_list", "__esmMin", "_List", "pItemList", "lNewList", "pArray", "lIndex", "pValue", "lFoundIndex", "pOldValue", "pNewValue", "lOldValue", "Exception", "init_exception", "__esmMin", "pMessage", "pTarget", "pErrorOptions", "Dictionary", "init_dictionary", "__esmMin", "init_list", "init_exception", "_Dictionary", "pKey", "pValue", "Exception", "pItem", "pDefault", "lValue", "pFunction", "lResultList", "List", "lKeyValuePair", "lMappingResult", "init_stack", "__esmMin", "init_linked_list", "__esmMin", "init_enum_util", "__esmMin", "init_type_util", "__esmMin", "ByteUtil", "init_byte_util", "__esmMin", "pByte", "pSigned", "lByte", "lHighNibble", "lLowNibble", "pByteArray", "pEmptyValue", "lNullFilteredArray", "pHightByte", "pLowByte", "lWord", "lConcatNumber", "pBits", "pBitCount", "pBitList", "lPicketNumber", "lBitIndex", "lBitMask", "lPickedBit", "pData", "pOffset", "pLength", "init_myers_diff", "__esmMin", "init_source", "__esmMin", "init_dictionary", "init_list", "init_stack", "init_exception", "init_linked_list", "init_enum_util", "init_type_util", "init_byte_util", "init_myers_diff", "StatefullSerializeableClasses", "init_statefull_serializeable_classes", "__esmMin", "init_source", "_StatefullSerializeableClasses", "Dictionary", "pObject", "lDefaultTypedArrayRetriever", "pArray", "pId", "lGuid", "Exception", "pConstructor", "lConstructor", "lObjectClassId", "pGuid", "pParameterRetrieve", "StatefullSerializeable", "pGuid", "pConstructor", "lObjectToConstructorParameter", "lParameterProxyConstructor", "pParameter", "StatefullSerializeableClasses", "pObject", "init_statefull_serializeable_decorator", "__esmMin", "init_statefull_serializeable_classes", "init_statefull_deserializer", "__esmMin", "init_source", "init_statefull_serializeable_classes", "StatefullSerializer", "init_statefull_serializer", "__esmMin", "init_source", "init_statefull_serializeable_classes", "pObject", "lObjectIds", "Dictionary", "pObjectIds", "lObjectId", "lClassConstructor", "lStatefullSerializeableClasses", "StatefullSerializeableClasses", "lClassId", "lInitializationObject", "lInitializationParameter", "pValue", "lInitializationRequiredValueList", "lValueObject", "lDescriptorList", "lDescriptorKey", "lPropertyDescriptor", "pUnknown", "lObject", "init_source", "__esmMin", "init_statefull_serializeable_decorator", "init_statefull_deserializer", "init_statefull_serializeable_classes", "init_statefull_serializer", "_DivisionChannel_decorators", "_init", "DivisionChannel", "init_division_channel", "__esmMin", "init_source", "StatefullSerializeable", "pEffect", "lSameEffectType", "pAppliedEffect", "lEffectIndex", "__decoratorStart", "__decorateElement", "__runInitializers", "_Division_decorators", "_init", "Division", "init_division", "__esmMin", "init_source", "init_division_channel", "StatefullSerializeable", "pIndex", "lNewChannel", "DivisionChannel", "Exception", "pChannelIndex", "__decoratorStart", "__decorateElement", "__runInitializers", "_Pattern_decorators", "_init", "Pattern", "init_pattern", "__esmMin", "init_source", "init_division", "StatefullSerializeable", "pIndex", "lNewDivision", "Division", "Exception", "pDivisionIndex", "__decoratorStart", "__decorateElement", "__runInitializers", "_PatternList_decorators", "_init", "PatternList", "init_pattern_list", "__esmMin", "init_source", "init_pattern", "StatefullSerializeable", "pPatternOrder", "pIndex", "lNewPattern", "Pattern", "Exception", "__decoratorStart", "__decorateElement", "__runInitializers", "_Sample_decorators", "_init", "Sample", "init_sample", "__esmMin", "init_source", "StatefullSerializeable", "pData", "pFineTune", "pName", "pVolume", "Exception", "pRepeatOffset", "pRepeatLength", "__decoratorStart", "__decorateElement", "__runInitializers", "_SampleList_decorators", "_init", "SampleList", "init_sample_list", "__esmMin", "init_source", "init_sample", "StatefullSerializeable", "pIndex", "lNewSample", "Sample", "Exception", "__decoratorStart", "__decorateElement", "__runInitializers", "_GenericModule_decorators", "_init", "GenericModule", "init_generic_module", "__esmMin", "init_source", "init_pattern_list", "init_sample_list", "StatefullSerializeable", "pName", "PatternList", "SampleList", "__decoratorStart", "__decorateElement", "__runInitializers", "EffectParseHistory", "init_effect_parse_history", "__esmMin", "init_source", "Dictionary", "pEffect", "lConstructor", "pEffectConstructor", "BaseModuleParser", "init_base_module_parser", "__esmMin", "init_generic_module", "init_source", "init_effect_parse_history", "pData", "pEffectParser", "lModule", "GenericModule", "lParseOptions", "lNameBuffer", "ByteUtil", "lPatternOrderList", "lSongOrderPosition", "lPatternOrderIndex", "lPatternIndexBuffer", "lPatternCount", "lPatternPosition", "lEffectParseHistorys", "Dictionary", "lPatternIndex", "lPattern", "lDivisionIndex", "lDivision", "lChannelIndex", "lDivisionChannel", "lDevisionBuffer", "lChannelValueList", "lEffectParseHistory", "EffectParseHistory", "lChannelValue", "lEffectList", "lEffect", "lSampleHeadPosition", "lSampleBodyPosition", "lSampleDataByteSize", "lSampleIndex", "lSample", "lSampleHeadBuffer", "lSampleHead", "lDataLength", "lDataOffset", "lSampleBodyBuffer", "_SetFinetuneEffect_decorators", "_init", "SetFinetuneEffect", "init_set_finetune_effect", "__esmMin", "init_source", "StatefullSerializeable", "pFinetune", "__decoratorStart", "__decorateElement", "__runInitializers", "init_pitch_enum", "__esmMin", "_SetPitchEffect_decorators", "_init", "SetPitchEffect", "init_set_pitch_effect", "__esmMin", "init_source", "init_pitch_enum", "StatefullSerializeable", "pFinetune", "__decoratorStart", "__decorateElement", "__runInitializers", "_CutSampleEffect_decorators", "_init", "CutSampleEffect", "init_cut_sample_effect", "__esmMin", "init_source", "StatefullSerializeable", "pOffset", "__decoratorStart", "__decorateElement", "__runInitializers", "_DelaySampleEffect_decorators", "_init", "DelaySampleEffect", "init_delay_sample_effect", "__esmMin", "init_source", "StatefullSerializeable", "pOffset", "__decoratorStart", "__decorateElement", "__runInitializers", "_InvertSampleLoopEffect_decorators", "_init", "InvertSampleLoopEffect", "init_invert_sample_loop_effect", "__esmMin", "init_source", "StatefullSerializeable", "pOffset", "__decoratorStart", "__decorateElement", "__runInitializers", "_RetriggerSampleEffect_decorators", "_init", "RetriggerSampleEffect", "init_retrigger_sample_effect", "__esmMin", "init_source", "StatefullSerializeable", "pInterval", "__decoratorStart", "__decorateElement", "__runInitializers", "_SampleOffsetEffect_decorators", "_init", "SampleOffsetEffect", "init_sample_offset_effect", "__esmMin", "init_source", "StatefullSerializeable", "pOffset", "__decoratorStart", "__decorateElement", "__runInitializers", "_SetPanningEffect_decorators", "_init", "SetPanningEffect", "init_set_panning_effect", "__esmMin", "init_source", "StatefullSerializeable", "pOffset", "__decoratorStart", "__decorateElement", "__runInitializers", "_SetSampleEffect_decorators", "_init", "SetSampleEffect", "init_set_sample_effect", "__esmMin", "init_source", "StatefullSerializeable", "pOffset", "__decoratorStart", "__decorateElement", "__runInitializers", "_SetBeatsPerMinuteEffect_decorators", "_init", "SetBeatsPerMinuteEffect", "init_set_bpm_effect", "__esmMin", "init_source", "StatefullSerializeable", "pVolume", "__decoratorStart", "__decorateElement", "__runInitializers", "_SetSpeedEffect_decorators", "_init", "SetSpeedEffect", "init_set_speed_effect", "__esmMin", "init_source", "StatefullSerializeable", "pVolume", "__decoratorStart", "__decorateElement", "__runInitializers", "_SetVolumeEffect_decorators", "_init", "SetVolumeEffect", "init_set_volume_effect", "__esmMin", "init_source", "StatefullSerializeable", "pVolume", "__decoratorStart", "__decorateElement", "__runInitializers", "init_direction_enum", "__esmMin", "_VolumeSlideEffect_decorators", "_init", "VolumeSlideEffect", "init_volume_slide_effect", "__esmMin", "init_source", "init_direction_enum", "StatefullSerializeable", "pDirection", "pVolumeChangePerTick", "__decoratorStart", "__decorateElement", "__runInitializers", "EffectParseEvent", "init_effect_parse_event", "__esmMin", "pChannelIndex", "pHistory", "pParameterX", "pParameterY", "pPitch", "pSample", "EffectParser", "init_effect_parser", "__esmMin", "init_source", "init_effect_parse_event", "List", "pBitPattern", "pHandler", "lBitList", "lBitmaskString", "pCurrent", "pNext", "lFixedBitString", "lClearedPattern", "pCharacter", "pChannelIndex", "pChannel", "pHistory", "lEffectHandler", "lEvent", "lParsedEffectList", "EffectParseEvent", "lReversedEffectBitList", "lReversedEffectPattern", "lParameterXBits", "lParameterYBits", "lBitIndex", "lPatternCharacter", "lParameterX", "lParameterY", "Exception", "_ArpeggioEffect_decorators", "_init", "ArpeggioEffect", "init_arpeggio_effect", "__esmMin", "init_source", "StatefullSerializeable", "pNote", "__decoratorStart", "__decorateElement", "__runInitializers", "_PeriodSlideEffect_decorators", "_init", "PeriodSlideEffect", "init_period_slide_effect", "__esmMin", "init_source", "init_direction_enum", "init_pitch_enum", "StatefullSerializeable", "pDirection", "pSensitive", "pChangeperTick", "__decoratorStart", "__decorateElement", "__runInitializers", "init_waveform_target_enum", "__esmMin", "_WaveformEffect_decorators", "_init", "WaveformEffect", "init_waveform_effect", "__esmMin", "init_source", "init_waveform_target_enum", "StatefullSerializeable", "pAmplitude", "pCirclePerTick", "pTarget", "__decoratorStart", "__decorateElement", "__runInitializers", "_PositionJumpEffect_decorators", "_init", "PositionJumpEffect", "init_position_jump_effect", "__esmMin", "init_source", "StatefullSerializeable", "pIndex", "__decoratorStart", "__decorateElement", "__runInitializers", "ModEffectParser", "init_mod_effect_parser", "__esmMin", "init_set_finetune_effect", "init_set_pitch_effect", "init_cut_sample_effect", "init_delay_sample_effect", "init_invert_sample_loop_effect", "init_retrigger_sample_effect", "init_sample_offset_effect", "init_set_panning_effect", "init_set_sample_effect", "init_set_bpm_effect", "init_set_speed_effect", "init_set_volume_effect", "init_volume_slide_effect", "init_direction_enum", "init_pitch_enum", "init_effect_parser", "init_arpeggio_effect", "init_period_slide_effect", "init_waveform_effect", "init_waveform_target_enum", "init_position_jump_effect", "_ModEffectParser", "EffectParser", "pEvent", "lEffectList", "lPitch", "lPitchEffect", "SetPitchEffect", "lSampleEffect", "SetSampleEffect", "lIsLeftChannel", "lPanningEffect", "SetPanningEffect", "lArpeggioEffect", "ArpeggioEffect", "lPeriodSlideEffect", "PeriodSlideEffect", "lLastPitch", "lLastPeriodSlide", "lLastEffectPitchBoundary", "lLastEffectSlide", "lVibratoEffect", "WaveformEffect", "lLastVibratoEffect", "lVolumeSlideEffect", "VolumeSlideEffect", "lTremoloEffect", "lLastTremoloEffect", "lSetPanningEffect", "lSampleOffsetEffect", "SampleOffsetEffect", "lJumpEffect", "PositionJumpEffect", "lVolumeSetEffect", "SetVolumeEffect", "lSetFinetuneEffect", "SetFinetuneEffect", "lRetriggerSampleEffect", "RetriggerSampleEffect", "lCutSampleEffect", "CutSampleEffect", "lDelaySampleEffect", "DelaySampleEffect", "lInvertLoopEffect", "InvertSampleLoopEffect", "lSpeed", "lSetSpeedEffect", "SetSpeedEffect", "lSetBeatsPerMinuteEffect", "SetBeatsPerMinuteEffect", "ModParser", "init_mod_parser", "__esmMin", "init_source", "init_base_module_parser", "init_mod_effect_parser", "_ModParser", "BaseModuleParser", "pData", "ModEffectParser", "lModuleExtension", "lChannelCount", "lSampleCount", "lPatternCount", "lSongPositionOffset", "lSongPositionCount", "lPatternOffset", "lSampleBodyOffset", "pChannelData", "lBufferNumber", "ByteUtil", "lSampleNumber", "lSamplePeriod", "lSampleEffect", "lChannelValueList", "pSampleHeadData", "lSampleNameBuffer", "lSampleName", "lSampleLengthBuffer", "lSampleLength", "lSampleFinetuneBuffer", "lSampleFineTune", "lSampleVolumeBuffer", "lSampleVolume", "lSampleRepeatOffsetBuffer", "lSampleRepeatOffset", "lSampleRepeatLengthBuffer", "lSampleRepeatLength", "pSampleBodyData", "lFloat32Buffer", "lIndex", "lOffset", "lModuleExtensionBuffer", "lModuleExtensionName", "pModuleExtension", "pSampleCount", "lModuleSongPositionBuffer", "lSampleOrderLengthOffset", "source_exports", "init_source", "__esmMin", "init_mod_parser", "lBinaryModFile", "lBinaryBuffer", "lModFile", "ModParser", "lAudioContext", "lOscilatorNode", "lTrackplayerAudioNode", "StatefullSerializer", "socket", "event"]
}
